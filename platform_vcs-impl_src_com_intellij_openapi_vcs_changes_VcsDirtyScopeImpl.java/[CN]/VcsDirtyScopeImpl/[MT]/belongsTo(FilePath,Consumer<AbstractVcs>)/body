{
  return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
    public Boolean compute(){
      if (myProject.isDisposed())       return Boolean.FALSE;
      final VcsRoot rootObject=myVcsManager.getVcsRootObjectFor(path);
      if (vcsConsumer != null && rootObject != null) {
        vcsConsumer.consume(rootObject.vcs);
      }
      if (rootObject == null || rootObject.vcs != myVcs) {
        return Boolean.FALSE;
      }
      final VirtualFile vcsRoot=rootObject.path;
      if (vcsRoot != null) {
        for (        VirtualFile contentRoot : myAffectedContentRoots) {
          if (VfsUtil.isAncestor(contentRoot,vcsRoot,false)) {
            THashSet<FilePath> dirsByRoot=myDirtyDirectoriesRecursively.get(contentRoot);
            if (dirsByRoot != null) {
              for (              FilePath filePath : dirsByRoot) {
                if (path.isUnder(filePath,false))                 return Boolean.TRUE;
              }
            }
          }
        }
      }
      if (myDirtyFiles.size() > 0) {
        FilePath parent;
        VirtualFile vParent=path.getVirtualFileParent();
        if (vParent != null && vParent.isValid()) {
          parent=new FilePathImpl(vParent);
        }
 else {
          parent=FilePathImpl.create(path.getIOFile().getParentFile());
        }
        if (myDirtyFiles.contains(parent) || myDirtyFiles.contains(path))         return Boolean.TRUE;
      }
      return Boolean.FALSE;
    }
  }
).booleanValue();
}
