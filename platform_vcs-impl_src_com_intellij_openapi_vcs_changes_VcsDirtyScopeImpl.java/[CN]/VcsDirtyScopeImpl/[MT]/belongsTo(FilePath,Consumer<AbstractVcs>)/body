{
  return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
    @Override public Boolean compute(){
      if (myProject.isDisposed())       return Boolean.FALSE;
      final VcsRoot rootObject=myVcsManager.getVcsRootObjectFor(path);
      if (vcsConsumer != null && rootObject != null) {
        vcsConsumer.consume(rootObject.getVcs());
      }
      if (rootObject == null || rootObject.getVcs() != myVcs) {
        return Boolean.FALSE;
      }
      final VirtualFile vcsRoot=rootObject.getPath();
      if (vcsRoot != null) {
        for (        VirtualFile contentRoot : myAffectedContentRoots) {
          if (VfsUtilCore.isAncestor(contentRoot,vcsRoot,false)) {
            THashSet<FilePath> dirsByRoot=myDirtyDirectoriesRecursively.get(contentRoot);
            if (dirsByRoot != null) {
              for (              FilePath filePath : dirsByRoot) {
                if (path.isUnder(filePath,false))                 return Boolean.TRUE;
              }
            }
          }
        }
      }
      if (!myDirtyFiles.isEmpty()) {
        FilePath parent;
        VirtualFile vParent=path.getVirtualFileParent();
        if (vParent != null && vParent.isValid()) {
          parent=new FilePathImpl(vParent);
        }
 else {
          parent=FilePathImpl.create(path.getIOFile().getParentFile());
        }
        return isInDirtyFiles(path) || isInDirtyFiles(parent);
      }
      return Boolean.FALSE;
    }
  }
).booleanValue();
}
