{
  Document document=myEditor.getDocument();
  int startOffset=document.getLineStartOffset(line);
  int endOffset=document.getLineEndOffset(line);
  myStorage.removeInRange(startOffset,endOffset + 1);
  if (indentType == IndentType.NONE) {
    TIntArrayList offsets=calculateSoftWrapOffsets(text,startOffset,endOffset,fontType,0);
    registerSoftWraps(offsets,0,temporary);
    return;
  }
  int prevLineIndentInColumns=0;
  int firstNonSpaceSymbolIndex=startOffset;
  for (; firstNonSpaceSymbolIndex < endOffset; firstNonSpaceSymbolIndex++) {
    char c=text.charAt(firstNonSpaceSymbolIndex);
    if (c != ' ' && c != '\t') {
      break;
    }
  }
  if (firstNonSpaceSymbolIndex > startOffset) {
    prevLineIndentInColumns=myTextRepresentationHelper.toVisualColumnSymbolsNumber(text,startOffset,firstNonSpaceSymbolIndex,0);
  }
  int spaceWidth=EditorUtil.getSpaceWidth(fontType,myEditor);
  int indentInColumns=getIndentSize();
  int indentInColumnsToUse=0;
  TIntArrayList softWrapOffsetsToUse=null;
  for (; indentInColumns >= 0; indentInColumns--) {
    TIntArrayList offsets=calculateSoftWrapOffsets(text,startOffset,endOffset,fontType,(prevLineIndentInColumns + indentInColumns) * spaceWidth);
    if (softWrapOffsetsToUse == null) {
      softWrapOffsetsToUse=offsets;
      indentInColumnsToUse=indentInColumns;
      continue;
    }
    if (softWrapOffsetsToUse.size() > offsets.size()) {
      softWrapOffsetsToUse=offsets;
      indentInColumnsToUse=indentInColumns;
    }
  }
  if (indentInColumnsToUse <= 0) {
    processLogicalLine(text,line,fontType,IndentType.NONE,temporary);
  }
 else {
    registerSoftWraps(softWrapOffsetsToUse,indentInColumnsToUse + prevLineIndentInColumns,temporary);
  }
}
