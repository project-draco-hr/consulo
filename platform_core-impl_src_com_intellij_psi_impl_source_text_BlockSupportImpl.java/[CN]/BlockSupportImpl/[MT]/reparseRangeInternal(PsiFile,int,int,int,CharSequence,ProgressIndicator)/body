{
  final PsiFileImpl fileImpl=(PsiFileImpl)file;
  Project project=fileImpl.getProject();
  final FileElement treeFileElement=fileImpl.getTreeElement();
  final CharTable charTable=treeFileElement.getCharTable();
  final int textLength=treeFileElement.getTextLength() + lengthShift;
  if (treeFileElement.getElementType() instanceof ITemplateDataElementType || isTooDeep(file)) {
    return makeFullParse(treeFileElement,newFileText,textLength,fileImpl,indicator);
  }
  final ASTNode leafAtStart=treeFileElement.findLeafElementAt(startOffset);
  final ASTNode leafAtEnd=treeFileElement.findLeafElementAt(endOffset);
  ASTNode node=leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart,leafAtEnd) : treeFileElement;
  Language baseLanguage=file.getViewProvider().getBaseLanguage();
  while (node != null && !(node instanceof FileElement)) {
    IElementType elementType=node.getElementType();
    if (elementType instanceof IReparseableElementType) {
      final TextRange textRange=node.getTextRange();
      final IReparseableElementType reparseable=(IReparseableElementType)elementType;
      if (baseLanguage.isKindOf(reparseable.getLanguage())) {
        final int start=textRange.getStartOffset();
        final int end=start + textRange.getLength() + lengthShift;
        assertFileLength(file,newFileText,node,elementType,start,end);
        CharSequence newTextStr=newFileText.subSequence(start,end);
        if (reparseable.isParsable(newTextStr,baseLanguage,project)) {
          ASTNode chameleon=reparseable.createNode(newTextStr);
          if (chameleon != null) {
            DummyHolder holder=DummyHolderFactory.createHolder(fileImpl.getManager(),null,node.getPsi(),charTable);
            holder.getTreeElement().rawAddChildren((TreeElement)chameleon);
            if (holder.getTextLength() != newTextStr.length()) {
              String details=ApplicationManager.getApplication().isInternal() ? "text=" + newTextStr + "; treeText="+ holder.getText()+ ";" : "";
              LOG.error("Inconsistent reparse: " + details + " type="+ elementType);
            }
            return mergeTrees(fileImpl,node,chameleon,indicator);
          }
        }
      }
    }
    node=node.getTreeParent();
  }
  return makeFullParse(node,newFileText,textLength,fileImpl,indicator);
}
