{
  int depth=0;
  try {
    int hc=value.hashCode();
    int vector=FIRST_VECTOR_OFFSET;
    int pos;
    int lastVector;
    do {
      lastVector=vector;
      pos=vector + (hc & LEVEL_MASK) * 4;
      hc>>>=BITS_PER_LEVEL;
      vector=myStorage.getInt(pos);
      depth++;
    }
 while (vector > 0);
    if (vector == 0) {
      final int newId=writeNewString(value);
      myStorage.putInt(pos,-newId);
      return newId;
    }
 else {
      int collision=Math.abs(vector);
      boolean splitVector=false;
      String candidate;
      do {
        candidate=valueOf(collision);
        if (candidate.hashCode() != value.hashCode()) {
          splitVector=true;
          break;
        }
        if (value.equals(candidate)) {
          return collision;
        }
        collision=nextCanditate(collision);
      }
 while (collision != 0);
      final int newId=writeNewString(value);
      if (splitVector) {
        depth--;
        do {
          final int valueHC=hcByte(value,depth);
          final int oldHC=hcByte(candidate,depth);
          if (valueHC == oldHC) {
            int newVector=allocVector();
            myStorage.putInt(lastVector + oldHC * 4,newVector);
            lastVector=newVector;
          }
 else {
            myStorage.putInt(lastVector + valueHC * 4,-newId);
            myStorage.putInt(lastVector + oldHC * 4,vector);
            break;
          }
          depth++;
        }
 while (true);
      }
 else {
        myStorage.putInt(newId,vector);
        myStorage.putInt(pos,-newId);
      }
      return newId;
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    if (depth > maxDepth)     maxDepth=depth;
  }
}
