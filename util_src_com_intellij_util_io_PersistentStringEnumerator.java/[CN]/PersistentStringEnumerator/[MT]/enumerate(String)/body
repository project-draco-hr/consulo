{
  int depth=0;
  final int valueHC=value.hashCode();
  int hc=valueHC;
  int vector=FIRST_VECTOR_OFFSET;
  int pos;
  int lastVector;
  do {
    lastVector=vector;
    pos=vector + (hc & LEVEL_MASK) * 4;
    hc>>>=BITS_PER_LEVEL;
    myStorage.seek(pos);
    vector=myStorage.readInt();
    depth++;
  }
 while (vector > 0);
  if (vector == 0) {
    final int newId=writeNewString(value,valueHC);
    myStorage.seek(pos);
    myStorage.writeInt(-newId);
    return newId;
  }
 else {
    int collision=-vector;
    boolean splitVector=false;
    int candidateHC;
    do {
      candidateHC=hashCodeOf(collision);
      if (candidateHC != valueHC) {
        splitVector=true;
        break;
      }
      String candidate=valueOf(collision);
      if (value.equals(candidate)) {
        return collision;
      }
      collision=nextCanditate(collision);
    }
 while (collision != 0);
    final int newId=writeNewString(value,valueHC);
    if (splitVector) {
      depth--;
      do {
        final int valueHCByte=hcByte(valueHC,depth);
        final int oldHCByte=hcByte(candidateHC,depth);
        if (valueHCByte == oldHCByte) {
          int newVector=allocVector();
          myStorage.seek(lastVector + oldHCByte * 4);
          myStorage.writeInt(newVector);
          lastVector=newVector;
        }
 else {
          myStorage.seek(lastVector + oldHCByte * 4);
          myStorage.writeInt(vector);
          myStorage.seek(lastVector + valueHCByte * 4);
          myStorage.writeInt(-newId);
          break;
        }
        depth++;
      }
 while (true);
    }
 else {
      myStorage.seek(newId);
      myStorage.writeInt(vector);
      myStorage.seek(pos);
      myStorage.writeInt(-newId);
    }
    return newId;
  }
}
