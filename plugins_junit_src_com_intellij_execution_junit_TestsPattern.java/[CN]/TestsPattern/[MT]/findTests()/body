{
  final JUnitConfiguration.Data data=myConfiguration.getPersistentData();
  final Project project=myConfiguration.getProject();
  final Set<String> classNames=new HashSet<String>();
  for (  String className : data.getPatterns()) {
    final PsiClass psiClass=JavaExecutionUtil.findMainClass(project,className.contains(",") ? className.substring(0,className.indexOf(',')) : className,GlobalSearchScope.allScope(project));
    if (psiClass != null && JUnitUtil.isTestClass(psiClass)) {
      classNames.add(className);
    }
  }
  if (classNames.size() == data.getPatterns().size()) {
    final SearchForTestsTask task=new SearchForTestsTask(project,"Searching for tests...",true){
      @Override public void run(      @NotNull ProgressIndicator indicator){
        try {
          mySocket=myServerSocket.accept();
          addClassesListToJavaParameters(classNames,StringUtil.isEmpty(data.METHOD_NAME) ? FunctionUtil.<String>id() : new Function<String,String>(){
            @Override public String fun(            String className){
              return className;
            }
          }
,"",false,true);
        }
 catch (        IOException e) {
          LOG.info(e);
        }
catch (        Throwable e) {
          LOG.error(e);
        }
      }
      @Override public void onSuccess(){
        finish();
      }
    }
;
    mySearchForTestsIndicator=new BackgroundableProcessIndicator(task);
    ProgressManagerImpl.runProcessWithProgressAsynchronously(task,mySearchForTestsIndicator);
    return task;
  }
  return super.findTests();
}
