{
  myRootPane=new JPanel(new BorderLayout());
  mySplitter=new JBSplitter();
  myTree=new CheckboxTreeNoPolicy(new ExtensionTreeCellRenderer(),new ExtensionCheckedTreeNode(null,myState,this)){
    @Override protected void adjustParentsAndChildren(    CheckedTreeNode node,    boolean checked){
      if (!checked) {
        changeNodeState(node,false);
        checkOrUncheckChildren(node,false);
      }
 else {
        List<CheckedTreeNode> parents=new ArrayList<CheckedTreeNode>();
        TreeNode parent=node.getParent();
        while (parent != null) {
          if (parent instanceof CheckedTreeNode) {
            parents.add((CheckedTreeNode)parent);
          }
          parent=parent.getParent();
        }
        Collections.reverse(parents);
        for (        CheckedTreeNode checkedTreeNode : parents) {
          checkNode(checkedTreeNode,true);
        }
        changeNodeState(node,true);
      }
      repaint();
    }
  }
;
  myTree.setRootVisible(false);
  myTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  myTree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final List<MutableModuleExtension> selected=TreeUtil.collectSelectedObjectsOfType(myTree,MutableModuleExtension.class);
      mySplitter.setSecondComponent(null);
      if (!selected.isEmpty()) {
        final MutableModuleExtension extension=selected.get(0);
        if (!extension.isEnabled()) {
          return;
        }
        mySplitter.setSecondComponent(createConfigurationPanel(extension));
      }
    }
  }
);
  TreeUtil.expandAll(myTree);
  mySplitter.setFirstComponent(myTree);
  myRootPane.add(new JBScrollPane(mySplitter),BorderLayout.CENTER);
  return myRootPane;
}
