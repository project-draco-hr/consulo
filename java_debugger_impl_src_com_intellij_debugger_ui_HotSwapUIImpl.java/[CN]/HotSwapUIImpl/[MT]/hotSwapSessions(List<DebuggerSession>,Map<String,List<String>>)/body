{
  final boolean shouldAskBeforeHotswap=myAskBeforeHotswap;
  myAskBeforeHotswap=true;
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  final DebuggerSettings settings=DebuggerSettings.getInstance();
  final String runHotswap=settings.RUN_HOTSWAP_AFTER_COMPILE;
  final boolean shouldDisplayHangWarning=shouldDisplayHangWarning(settings,sessions);
  if (shouldAskBeforeHotswap && DebuggerSettings.RUN_HOTSWAP_NEVER.equals(runHotswap)) {
    return;
  }
  final boolean isOutOfProcessMode=CompilerWorkspaceConfiguration.getInstance(myProject).useOutOfProcessBuild();
  final boolean shouldPerformScan=!isOutOfProcessMode || generatedPaths == null;
  final HotSwapProgressImpl findClassesProgress=shouldPerformScan ? new HotSwapProgressImpl(myProject) : null;
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    public void run(){
      final Map<DebuggerSession,Map<String,HotSwapFile>> newlyModifiedClasses=shouldPerformScan ? scanForModifiedClassesWithProgress(sessions,findClassesProgress,!isOutOfProcessMode) : HotSwapManager.findModifiedClasses(sessions,generatedPaths);
      for (      Map.Entry<DebuggerSession,Map<String,HotSwapFile>> entry : newlyModifiedClasses.entrySet()) {
        final DebuggerSession session=entry.getKey();
        if (shouldPerformScan) {
          session.clearHotswapFiles();
        }
        session.addHotswapFiles(entry.getValue());
      }
      boolean hasFilesToReload=false;
      for (      DebuggerSession session : sessions) {
        if (!session.getHotswapFiles().isEmpty()) {
          hasFilesToReload=true;
          break;
        }
      }
      if (!hasFilesToReload) {
        final String message=DebuggerBundle.message("status.hotswap.uptodate");
        HotSwapProgressImpl.NOTIFICATION_GROUP.createNotification(message,NotificationType.INFORMATION).notify(myProject);
        return;
      }
      final Set<DebuggerSession> sessionsToReload=new HashSet<DebuggerSession>(sessions);
      final Application application=ApplicationManager.getApplication();
      application.invokeLater(new Runnable(){
        public void run(){
          if (shouldAskBeforeHotswap && !DebuggerSettings.RUN_HOTSWAP_ALWAYS.equals(runHotswap)) {
            final RunHotswapDialog dialog=new RunHotswapDialog(myProject,sessions,shouldDisplayHangWarning);
            dialog.show();
            if (!dialog.isOK()) {
              return;
            }
            sessionsToReload.retainAll(dialog.getSessionsToReload());
          }
 else {
            if (shouldDisplayHangWarning) {
              final int answer=Messages.showCheckboxMessageDialog(DebuggerBundle.message("hotswap.dialog.hang.warning"),DebuggerBundle.message("hotswap.dialog.title"),new String[]{"Perform &Reload Classes","&Skip Reload Classes"},CommonBundle.message("dialog.options.do.not.show"),false,1,1,Messages.getWarningIcon(),new PairFunction<Integer,JCheckBox,Integer>(){
                @Override public Integer fun(                Integer exitCode,                JCheckBox cb){
                  settings.HOTSWAP_HANG_WARNING_ENABLED=!cb.isSelected();
                  return exitCode == DialogWrapper.OK_EXIT_CODE ? exitCode : DialogWrapper.CANCEL_EXIT_CODE;
                }
              }
);
              if (answer == DialogWrapper.CANCEL_EXIT_CODE) {
                return;
              }
            }
          }
          if (!sessionsToReload.isEmpty()) {
            final HotSwapProgressImpl progress=new HotSwapProgressImpl(myProject);
            application.executeOnPooledThread(new Runnable(){
              public void run(){
                reloadModifiedClasses(sessionsToReload,progress);
              }
            }
);
          }
        }
      }
,ModalityState.NON_MODAL);
    }
  }
);
}
