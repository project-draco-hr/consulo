{
  final boolean shouldAskBeforeHotswap=myAskBeforeHotswap;
  myAskBeforeHotswap=true;
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  final DebuggerSettings settings=DebuggerSettings.getInstance();
  final String runHotswap=settings.RUN_HOTSWAP_AFTER_COMPILE;
  final boolean shouldDisplayHangWarning=shouldDisplayHangWarning(settings,sessions);
  if (shouldAskBeforeHotswap && DebuggerSettings.RUN_HOTSWAP_NEVER.equals(runHotswap)) {
    return;
  }
  final boolean isOutOfProcessMode=CompilerWorkspaceConfiguration.getInstance(myProject).useOutOfProcessBuild();
  final boolean shouldPerformScan=!isOutOfProcessMode || generatedPaths == null;
  final HotSwapProgressImpl findClassesProgress;
  if (shouldPerformScan) {
    findClassesProgress=new HotSwapProgressImpl(myProject);
  }
 else {
    boolean createProgress=false;
    for (    DebuggerSession session : sessions) {
      if (session.isModifiedClassesScanRequired()) {
        createProgress=true;
        break;
      }
    }
    findClassesProgress=createProgress ? new HotSwapProgressImpl(myProject) : null;
  }
  ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
    public void run(){
      final Map<DebuggerSession,Map<String,HotSwapFile>> modifiedClasses;
      if (shouldPerformScan) {
        modifiedClasses=scanForModifiedClassesWithProgress(sessions,findClassesProgress,!isOutOfProcessMode);
      }
 else {
        final List<DebuggerSession> toScan=new ArrayList<DebuggerSession>();
        final List<DebuggerSession> toUseGenerated=new ArrayList<DebuggerSession>();
        for (        DebuggerSession session : sessions) {
          (session.isModifiedClassesScanRequired() ? toScan : toUseGenerated).add(session);
          session.setModifiedClassesScanRequired(false);
        }
        modifiedClasses=new HashMap<DebuggerSession,Map<String,HotSwapFile>>();
        if (!toUseGenerated.isEmpty()) {
          modifiedClasses.putAll(HotSwapManager.findModifiedClasses(toUseGenerated,generatedPaths));
        }
        if (!toScan.isEmpty()) {
          modifiedClasses.putAll(scanForModifiedClassesWithProgress(toScan,findClassesProgress,!isOutOfProcessMode));
        }
      }
      final Application application=ApplicationManager.getApplication();
      if (modifiedClasses.isEmpty()) {
        final String message=DebuggerBundle.message("status.hotswap.uptodate");
        HotSwapProgressImpl.NOTIFICATION_GROUP.createNotification(message,NotificationType.INFORMATION).notify(myProject);
        return;
      }
      application.invokeLater(new Runnable(){
        public void run(){
          if (shouldAskBeforeHotswap && !DebuggerSettings.RUN_HOTSWAP_ALWAYS.equals(runHotswap)) {
            final RunHotswapDialog dialog=new RunHotswapDialog(myProject,sessions,shouldDisplayHangWarning);
            dialog.show();
            if (!dialog.isOK()) {
              for (              DebuggerSession session : modifiedClasses.keySet()) {
                session.setModifiedClassesScanRequired(true);
              }
              return;
            }
            final Set<DebuggerSession> toReload=new HashSet<DebuggerSession>(dialog.getSessionsToReload());
            for (            DebuggerSession session : modifiedClasses.keySet()) {
              if (!toReload.contains(session)) {
                session.setModifiedClassesScanRequired(true);
              }
            }
            modifiedClasses.keySet().retainAll(toReload);
          }
 else {
            if (shouldDisplayHangWarning) {
              final int answer=Messages.showCheckboxMessageDialog(DebuggerBundle.message("hotswap.dialog.hang.warning"),DebuggerBundle.message("hotswap.dialog.title"),new String[]{"Perform &Reload Classes","&Skip Reload Classes"},CommonBundle.message("dialog.options.do.not.show"),false,1,1,Messages.getWarningIcon(),new PairFunction<Integer,JCheckBox,Integer>(){
                @Override public Integer fun(                Integer exitCode,                JCheckBox cb){
                  settings.HOTSWAP_HANG_WARNING_ENABLED=!cb.isSelected();
                  return exitCode == DialogWrapper.OK_EXIT_CODE ? exitCode : DialogWrapper.CANCEL_EXIT_CODE;
                }
              }
);
              if (answer == DialogWrapper.CANCEL_EXIT_CODE) {
                for (                DebuggerSession session : modifiedClasses.keySet()) {
                  session.setModifiedClassesScanRequired(true);
                }
                return;
              }
            }
          }
          if (!modifiedClasses.isEmpty()) {
            final HotSwapProgressImpl progress=new HotSwapProgressImpl(myProject);
            application.executeOnPooledThread(new Runnable(){
              public void run(){
                reloadModifiedClasses(modifiedClasses,progress);
              }
            }
);
          }
        }
      }
,ModalityState.NON_MODAL);
    }
  }
);
}
