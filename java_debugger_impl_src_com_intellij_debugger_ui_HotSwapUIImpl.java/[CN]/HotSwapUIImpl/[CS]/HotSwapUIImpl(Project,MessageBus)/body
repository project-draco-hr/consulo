{
  myProject=project;
  bus.connect().subscribe(CompilerTopics.COMPILATION_STATUS,new CompilationStatusListener(){
    private final AtomicReference<Map<String,List<String>>> myGeneratedPaths=new AtomicReference<Map<String,List<String>>>(new HashMap<String,List<String>>());
    public void fileGenerated(    String outputRoot,    String relativePath){
      final Map<String,List<String>> map=myGeneratedPaths.get();
      List<String> paths=map.get(outputRoot);
      if (paths == null) {
        paths=new ArrayList<String>();
        map.put(outputRoot,paths);
      }
      paths.add(relativePath);
    }
    public void compilationFinished(    boolean aborted,    int errors,    int warnings,    CompileContext compileContext){
      final Map<String,List<String>> generated=myGeneratedPaths.getAndSet(new HashMap<String,List<String>>());
      if (myProject.isDisposed()) {
        return;
      }
      if (errors == 0 && !aborted && myPerformHotswapAfterThisCompilation) {
        for (        HotSwapVetoableListener listener : myListeners) {
          if (!listener.shouldHotSwap(compileContext)) {
            return;
          }
        }
        final List<DebuggerSession> sessions=new ArrayList<DebuggerSession>();
        Collection<DebuggerSession> debuggerSessions=DebuggerManagerEx.getInstanceEx(myProject).getSessions();
        for (        final DebuggerSession debuggerSession : debuggerSessions) {
          if (debuggerSession.isAttached() && debuggerSession.getProcess().canRedefineClasses()) {
            sessions.add(debuggerSession);
          }
        }
        if (!sessions.isEmpty()) {
          hotSwapSessions(sessions,generated);
        }
      }
      myPerformHotswapAfterThisCompilation=true;
    }
  }
);
}
