{
  if (candidate == myPattern[0])   return null;
  PsiElement sibling=candidate;
  ArrayList<PsiElement> candidates=new ArrayList<PsiElement>();
  for (int i=0; i < myPattern.length; i++) {
    final PsiElement element=myPattern[i];
    if (sibling == null)     return null;
    if (!canBeEquivalent(element,sibling))     return null;
    candidates.add(sibling);
    sibling=sibling.getNextSibling();
    while (sibling instanceof PsiWhiteSpace) {
      sibling=sibling.getNextSibling();
    }
  }
  LOG.assertTrue(myPattern.length == candidates.size());
  if (myPattern.length == 1 && myPattern[0] instanceof PsiExpression) {
    if (candidates.get(0) instanceof PsiExpression) {
      final PsiType patternType=((PsiExpression)myPattern[0]).getType();
      final PsiType candidateType=((PsiExpression)candidates.get(0)).getType();
      if (patternType != null && candidateType != null && !candidateType.isAssignableFrom(patternType)) {
        return null;
      }
    }
 else {
      return null;
    }
  }
  final Match match=new Match(candidates.get(0),candidates.get(candidates.size() - 1));
  for (int i=0; i < myPattern.length; i++) {
    if (!matchPattern(myPattern[i],candidates.get(i),candidates,match))     return null;
  }
  return match;
}
