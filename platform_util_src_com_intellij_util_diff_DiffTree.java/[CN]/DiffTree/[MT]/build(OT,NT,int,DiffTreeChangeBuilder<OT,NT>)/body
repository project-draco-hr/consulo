{
  OT oldNode=myOldTree.prepareForGetChildren(oldN);
  NT newNode=myNewTree.prepareForGetChildren(newN);
  if (level == myNewChildrenLists.size()) {
    myNewChildrenLists.add(new Ref<NT[]>());
    myOldChildrenLists.add(new Ref<OT[]>());
  }
  final Ref<OT[]> oldChildrenR=myOldChildrenLists.get(level);
  int oldChildrenSize=myOldTree.getChildren(oldNode,oldChildrenR);
  final OT[] oldChildren=oldChildrenR.get();
  final Ref<NT[]> newChildrenR=myNewChildrenLists.get(level);
  int newChildrenSize=myNewTree.getChildren(newNode,newChildrenR);
  final NT[] newChildren=newChildrenR.get();
  CompareResult result;
  if (Math.abs(oldChildrenSize - newChildrenSize) > CHANGE_PARENT_VERSUS_CHILDREN_THRESHOLD) {
    consumer.nodeReplaced(oldNode,newNode);
    result=CompareResult.NOT_EQUAL;
  }
 else   if (oldChildrenSize == 0 && newChildrenSize == 0) {
    if (!myComparator.hashCodesEqual(oldNode,newNode) || !myComparator.typesEqual(oldNode,newNode)) {
      consumer.nodeReplaced(oldNode,newNode);
      result=CompareResult.NOT_EQUAL;
    }
 else {
      result=CompareResult.EQUAL;
    }
  }
 else {
    final ShallowNodeComparator<OT,NT> comparator=myComparator;
    int minSize=Math.min(oldChildrenSize,newChildrenSize);
    int suffixLength=match(oldChildren,oldChildrenSize - 1,newChildren,newChildrenSize - 1,level,-1,minSize);
    int maxPrefixLength=minSize - suffixLength - (oldChildrenSize == newChildrenSize && suffixLength < minSize ? 1 : 0);
    int prefixLength=match(oldChildren,0,newChildren,0,level,1,maxPrefixLength);
    if (oldChildrenSize == newChildrenSize && suffixLength + prefixLength == oldChildrenSize) {
      result=CompareResult.EQUAL;
    }
 else     if (consumer == emptyConsumer()) {
      result=CompareResult.NOT_EQUAL;
    }
 else {
      int oldIndex=prefixLength;
      int newIndex=prefixLength;
      while (oldIndex < oldChildrenSize - suffixLength || newIndex < newChildrenSize - suffixLength) {
        OT oldChild1=oldIndex < oldChildrenSize - suffixLength ? oldChildren[oldIndex] : null;
        OT oldChild2=oldIndex < oldChildrenSize - suffixLength - 1 ? oldChildren[oldIndex + 1] : null;
        OT oldChild3=oldIndex < oldChildrenSize - suffixLength - 2 ? oldChildren[oldIndex + 2] : null;
        NT newChild1=newIndex < newChildrenSize - suffixLength ? newChildren[newIndex] : null;
        NT newChild2=newIndex < newChildrenSize - suffixLength - 1 ? newChildren[newIndex + 1] : null;
        NT newChild3=newIndex < newChildrenSize - suffixLength - 2 ? newChildren[newIndex + 2] : null;
        CompareResult c11=looksEqual(comparator,oldChild1,newChild1);
        if (c11 == CompareResult.EQUAL || c11 == CompareResult.DRILL_DOWN_NEEDED) {
          if (c11 == CompareResult.DRILL_DOWN_NEEDED) {
            build(oldChild1,newChild1,level + 1,consumer);
          }
          oldIndex++;
          newIndex++;
          continue;
        }
        if (c11 == CompareResult.TYPE_ONLY) {
          CompareResult c21=looksEqual(comparator,oldChild2,newChild1);
          if (c21 == CompareResult.EQUAL || c21 == CompareResult.DRILL_DOWN_NEEDED) {
            consumer.nodeDeleted(oldNode,oldChild1);
            oldIndex++;
            continue;
          }
          CompareResult c12=looksEqual(comparator,oldChild1,newChild2);
          if (c12 == CompareResult.EQUAL || c12 == CompareResult.DRILL_DOWN_NEEDED) {
            consumer.nodeInserted(oldNode,newChild1,newIndex);
            newIndex++;
            continue;
          }
          consumer.nodeReplaced(oldChild1,newChild1);
          oldIndex++;
          newIndex++;
          continue;
        }
        CompareResult c12=looksEqual(comparator,oldChild1,newChild2);
        if (c12 == CompareResult.EQUAL || c12 == CompareResult.DRILL_DOWN_NEEDED) {
          consumer.nodeInserted(oldNode,newChild1,newIndex);
          newIndex++;
          continue;
        }
        CompareResult c21=looksEqual(comparator,oldChild2,newChild1);
        if (c21 == CompareResult.EQUAL || c21 == CompareResult.DRILL_DOWN_NEEDED || c21 == CompareResult.TYPE_ONLY) {
          consumer.nodeDeleted(oldNode,oldChild1);
          oldIndex++;
          continue;
        }
        if (c12 == CompareResult.TYPE_ONLY) {
          consumer.nodeInserted(oldNode,newChild1,newIndex);
          newIndex++;
          continue;
        }
        if (oldChild1 == null) {
          consumer.nodeInserted(oldNode,newChild1,newIndex);
          newIndex++;
          continue;
        }
        if (newChild1 == null) {
          consumer.nodeDeleted(oldNode,oldChild1);
          oldIndex++;
          continue;
        }
        if (oldChild3 != null || newChild3 != null) {
          CompareResult c13=looksEqual(comparator,oldChild1,newChild3);
          if (c13 == CompareResult.EQUAL || c13 == CompareResult.DRILL_DOWN_NEEDED || c13 == CompareResult.TYPE_ONLY) {
            consumer.nodeInserted(oldNode,newChild1,newIndex);
            newIndex++;
            consumer.nodeInserted(oldNode,newChild2,newIndex);
            newIndex++;
            continue;
          }
          CompareResult c31=looksEqual(comparator,oldChild3,newChild1);
          if (c31 == CompareResult.EQUAL || c31 == CompareResult.DRILL_DOWN_NEEDED || c31 == CompareResult.TYPE_ONLY) {
            consumer.nodeDeleted(oldNode,oldChild1);
            consumer.nodeDeleted(oldNode,oldChild2);
            oldIndex++;
            oldIndex++;
            continue;
          }
        }
        OT oldLastChild=oldIndex < oldChildrenSize - suffixLength ? oldChildren[oldChildrenSize - suffixLength - 1] : null;
        NT newLastChild=newIndex < newChildrenSize - suffixLength ? newChildren[newChildrenSize - suffixLength - 1] : null;
        CompareResult c=oldLastChild == null || newLastChild == null ? CompareResult.NOT_EQUAL : looksEqual(comparator,oldLastChild,newLastChild);
        if (c == CompareResult.EQUAL || c == CompareResult.TYPE_ONLY || c == CompareResult.DRILL_DOWN_NEEDED) {
          if (c == CompareResult.DRILL_DOWN_NEEDED) {
            build(oldLastChild,newLastChild,level + 1,consumer);
          }
 else {
            consumer.nodeReplaced(oldLastChild,newLastChild);
          }
          suffixLength++;
          continue;
        }
        consumer.nodeReplaced(oldChild1,newChild1);
        oldIndex++;
        newIndex++;
      }
      result=CompareResult.NOT_EQUAL;
    }
  }
  myOldTree.disposeChildren(oldChildren,oldChildrenSize);
  myNewTree.disposeChildren(newChildren,newChildrenSize);
  return result;
}
