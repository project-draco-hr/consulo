{
  PsiClass containingClass=methodWithOverrides.getContainingClass();
  if (containingClass == null)   return;
  final PsiManager manager=containingClass.getManager();
  boolean canBePulledUp=true;
  String name="Pull method \'" + methodWithOverrides.getName() + "\' up";
  if (containingClass instanceof PsiAnonymousClass) {
    final PsiClassType baseClassType=((PsiAnonymousClass)containingClass).getBaseClassType();
    final PsiClass baseClass=baseClassType.resolve();
    if (baseClass == null)     return;
    if (!manager.isInProject(baseClass))     return;
    if (!baseClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
      name="Pull method \'" + methodWithOverrides.getName() + "\' up and make it abstract";
    }
  }
 else {
    final LinkedHashSet<PsiClass> classesToPullUp=new LinkedHashSet<PsiClass>();
    collectClassesToPullUp(manager,classesToPullUp,containingClass.getExtendsListTypes());
    collectClassesToPullUp(manager,classesToPullUp,containingClass.getImplementsListTypes());
    if (classesToPullUp.size() == 0) {
      name="Extract method \'" + methodWithOverrides.getName() + "\' to new interface";
      canBePulledUp=false;
    }
 else     if (classesToPullUp.size() == 1) {
      final PsiClass baseClass=classesToPullUp.iterator().next();
      name="Pull method \'" + methodWithOverrides.getName() + "\' to \'"+ baseClass.getName()+ "\'";
      if (!baseClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
        name+=" and make it abstract";
      }
    }
    registrar.register(new RunRefactoringAction(new ExtractInterfaceHandler(),"Extract interface"));
    registrar.register(new RunRefactoringAction(new ExtractSuperclassHandler(),"Extract superclass"));
  }
  if (canBePulledUp) {
    registrar.register(new RunRefactoringAction(new JavaPullUpHandler(),"Pull members up"));
  }
  registrar.register(new PullAsAbstractUpFix(methodWithOverrides,name));
}
