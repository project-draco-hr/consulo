{
  assertBounds(startOffset,endOffset);
  assertWriteAccess();
  assertValidSeparators(s);
  if (!isWritable()) {
    throw new ReadOnlyModificationException(this);
  }
  int initialStartOffset=startOffset;
  int initialOldLength=endOffset - startOffset;
  final int newStringLength=s.length();
  final CharSequence chars=myText;
  int newStartInString=0;
  int newEndInString=newStringLength;
  while (newStartInString < newStringLength && startOffset < endOffset && s.charAt(newStartInString) == chars.charAt(startOffset)) {
    startOffset++;
    newStartInString++;
  }
  while (endOffset > startOffset && newEndInString > newStartInString && s.charAt(newEndInString - 1) == chars.charAt(endOffset - 1)) {
    newEndInString--;
    endOffset--;
  }
  if (startOffset == 0 && endOffset == getTextLength()) {
    wholeTextReplaced=true;
  }
  CharSequence changedPart=s.subSequence(newStartInString,newEndInString);
  CharSequence sToDelete=myText.subtext(startOffset,endOffset);
  RangeMarker guard=getRangeGuard(startOffset,endOffset);
  if (guard != null) {
    throwGuardedFragment(guard,startOffset,sToDelete.toString(),changedPart.toString());
  }
  ImmutableText newText;
  if (wholeTextReplaced && s instanceof ImmutableText) {
    newText=(ImmutableText)s;
  }
 else {
    myText=myText.ensureChunked();
    newText=myText.delete(startOffset,endOffset).insert(startOffset,changedPart);
    changedPart=newText.subtext(startOffset,startOffset + changedPart.length());
  }
  updateText(newText,startOffset,sToDelete,changedPart,wholeTextReplaced,newModificationStamp,initialStartOffset,initialOldLength);
  trimToSize();
}
