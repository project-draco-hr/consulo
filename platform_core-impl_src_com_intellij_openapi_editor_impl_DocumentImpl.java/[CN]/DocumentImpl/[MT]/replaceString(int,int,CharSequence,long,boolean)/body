{
  assertBounds(startOffset,endOffset);
  assertWriteAccess();
  assertValidSeparators(s);
  if (!isWritable()) {
    throw new ReadOnlyModificationException(this);
  }
  assertNotNestedModification();
  final int newStringLength=s.length();
  final CharSequence chars=getCharsSequence();
  int newStartInString=0;
  int newEndInString=newStringLength;
  while (newStartInString < newStringLength && startOffset < endOffset && s.charAt(newStartInString) == chars.charAt(startOffset)) {
    startOffset++;
    newStartInString++;
  }
  while (endOffset > startOffset && newEndInString > newStartInString && s.charAt(newEndInString - 1) == chars.charAt(endOffset - 1)) {
    newEndInString--;
    endOffset--;
  }
  CharSequence changedPart=s.subSequence(newStartInString,newEndInString);
  CharSequence sToDelete=myText.subSequence(startOffset,endOffset);
  RangeMarker guard=getRangeGuard(startOffset,endOffset);
  if (guard != null) {
    throwGuardedFragment(guard,startOffset,sToDelete.toString(),changedPart.toString());
  }
  final DocumentEvent event=beforeChangedUpdate(startOffset,sToDelete,changedPart,wholeTextReplaced);
  myTextString=null;
  if (wholeTextReplaced && s instanceof ImmutableText) {
    myText=(ImmutableText)s;
  }
 else {
    myText=myText.delete(startOffset,endOffset).insert(startOffset,changedPart);
  }
  changedUpdate(event,newModificationStamp);
  trimToSize();
}
