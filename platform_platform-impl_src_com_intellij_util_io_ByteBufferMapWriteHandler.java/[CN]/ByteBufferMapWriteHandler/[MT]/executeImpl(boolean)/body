{
  if (write)   myOut.writeInt(myMod);
  int offset=4;
  int[] overflowList=new int[myKeyHashes.length];
  int[] firstOverflowElem=new int[myMod];
  int[] occurs=new int[myMod];
  Arrays.fill(firstOverflowElem,-1);
  for (int i=myKeyHashes.length - 1; i >= 0; i--) {
    int hashhash=hash(myKeyHashes[i]);
    overflowList[i]=firstOverflowElem[hashhash];
    firstOverflowElem[hashhash]=i;
    occurs[hashhash]++;
  }
  offset+=4 * myMod;
  for (int i=0; i < myMod; i++) {
    if (write)     myOut.writeInt(occurs[i] != 0 ? offset : -1);
    if (occurs[i] != 0)     offset+=4;
    int occurs_i=0;
    for (int j=firstOverflowElem[i]; j != -1; j=overflowList[j]) {
      offset+=myMap.getKeyLength(j) + 4;
      occurs_i++;
    }
    LOG.assertTrue(occurs_i == occurs[i]);
  }
  for (int i=0; i < myMod; i++) {
    if (occurs[i] == 0)     continue;
    if (write)     myOut.writeInt(occurs[i]);
    for (int j=firstOverflowElem[i]; j != -1; j=overflowList[j]) {
      if (write) {
        myMap.writeKey(myOut,j);
        myOut.writeInt(offset);
      }
      V value=myMap.getValue(j);
      offset+=myValueProvider.length(value);
    }
  }
  for (int i=0; i < myMod; i++) {
    for (int j=firstOverflowElem[i]; j != -1; j=overflowList[j]) {
      V value=myMap.getValue(j);
      if (write)       myValueProvider.write(myOut,value);
    }
  }
  return offset;
}
