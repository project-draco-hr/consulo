{
  Rectangle rect=state.getLabelBounds().getRectangle();
  Graphics2D g=canvas.getGraphics();
  if (labelGlyphs == null) {
    updateLabelBounds(text,style);
  }
  if (labelGlyphs != null && (g.getClipBounds() == null || g.getClipBounds().intersects(rect))) {
    float opacity=mxUtils.getFloat(style,mxConstants.STYLE_OPACITY,100);
    Graphics2D previousGraphics=g;
    g=canvas.createTemporaryGraphics(style,opacity,state);
    Font font=mxUtils.getFont(style,canvas.getScale());
    g.setFont(font);
    Color fontColor=mxUtils.getColor(style,mxConstants.STYLE_FONTCOLOR,Color.black);
    g.setColor(fontColor);
    g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS,FONT_FRACTIONALMETRICS);
    for (int j=0; j < labelGlyphs.length; j++) {
      mxLine parallel=labelGlyphs[j].glyphGeometry;
      if (labelGlyphs[j].visible && parallel != null && parallel != mxCurve.INVALID_POSITION) {
        mxPoint parallelEnd=parallel.getEndPoint();
        double x=parallelEnd.getX();
        double rotation=(Math.atan(parallelEnd.getY() / x));
        if (x < 0) {
          rotation+=Math.PI;
        }
        final AffineTransform old=g.getTransform();
        g.translate(parallel.getX(),parallel.getY());
        g.rotate(rotation);
        Shape letter=labelGlyphs[j].glyphShape;
        g.fill(letter);
        g.setTransform(old);
      }
    }
    g.dispose();
    g=previousGraphics;
  }
}
