{
  final ReferencedElementsCollector collector=new ReferencedElementsCollector();
  myMethod.accept(collector);
  final HashMap<PsiMember,HashSet<PsiMember>> containersToReferenced;
  String fromForReference=null;
  if (usages[0] != null) {
    containersToReferenced=getInaccessible(collector.myReferencedMembers,usages[0]);
  }
 else {
    containersToReferenced=getInaccessible(collector.myReferencedMembers,new UsageInfo[]{new UsageInfo(myReference)});
    fromForReference=ConflictsUtil.getDescription(ConflictsUtil.getContainer(myReference),true);
  }
  ArrayList<String> conflicts=new ArrayList<String>();
  final Set<PsiMember> containers=containersToReferenced.keySet();
  for (Iterator<PsiMember> iterator=containers.iterator(); iterator.hasNext(); ) {
    PsiMember container=iterator.next();
    HashSet<PsiMember> referencedInaccessible=containersToReferenced.get(container);
    for (Iterator<PsiMember> iterator1=referencedInaccessible.iterator(); iterator1.hasNext(); ) {
      PsiElement referenced=iterator1.next();
      String message=ConflictsUtil.getDescription(referenced,true) + " that is used in inlined method, " + " is not accessible from "+ (fromForReference == null ? "call site(s) in " + ConflictsUtil.getDescription(container,true) : fromForReference);
      conflicts.add(ConflictsUtil.capitalize(message));
    }
  }
  if (myDialog != null && conflicts.size() > 0) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK())     return false;
  }
  ToolWindowManager.getInstance(myProject).invokeLater(new Runnable(){
    public void run(){
      myDialog.close(DialogWrapper.CANCEL_EXIT_CODE);
    }
  }
);
  return true;
}
