{
  UsageInfo[] usagesIn=refUsages.get();
  ArrayList<String> conflicts=new ArrayList<String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.add(message);
    }
  }
  final ReferencedElementsCollector collector=new ReferencedElementsCollector();
  myMethod.accept(collector);
  final Map<PsiMember,Set<PsiMember>> containersToReferenced;
  containersToReferenced=getInaccessible(collector.myReferencedMembers,usagesIn);
  final Set<PsiMember> containers=containersToReferenced.keySet();
  for (  PsiMember container : containers) {
    Set<PsiMember> referencedInaccessible=containersToReferenced.get(container);
    for (    PsiMember referenced : referencedInaccessible) {
      String message=RefactoringBundle.message("0.that.is.used.in.inlined.method.is.not.accessible.from.call.site.s.in.1",ConflictsUtil.getDescription(referenced,true),ConflictsUtil.getDescription(container,true));
      conflicts.add(ConflictsUtil.capitalize(message));
    }
  }
  if (conflicts.size() > 0) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK()) {
      return false;
    }
  }
  prepareSuccessful();
  return true;
}
