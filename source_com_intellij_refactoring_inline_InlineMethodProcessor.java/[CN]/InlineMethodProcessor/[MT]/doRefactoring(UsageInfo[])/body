{
  try {
    if (myInlineThisOnly) {
      if (myMethod.isConstructor()) {
        PsiCall constructorCall=RefactoringUtil.getEnclosingConstructorCall(myReference);
        if (constructorCall != null) {
          inlineConstructorCall(constructorCall);
        }
      }
 else {
        myReference=addBracesWhenNeeded(new PsiReferenceExpression[]{(PsiReferenceExpression)myReference})[0];
        inlineMethodCall((PsiReferenceExpression)myReference);
      }
    }
 else {
      if (myMethod.isConstructor()) {
        for (int i=0; i < usages.length; i++) {
          PsiElement element=usages[i].getElement();
          if (element instanceof PsiJavaCodeReferenceElement) {
            PsiCall constructorCall=RefactoringUtil.getEnclosingConstructorCall((PsiJavaCodeReferenceElement)element);
            if (constructorCall != null) {
              inlineConstructorCall(constructorCall);
            }
          }
        }
        if (myMethod.isWritable())         myMethod.delete();
      }
 else {
        Set<PsiReferenceExpression> tempRefs=new TreeSet<PsiReferenceExpression>(new Comparator<PsiReferenceExpression>(){
          public int compare(          final PsiReferenceExpression e1,          final PsiReferenceExpression e2){
            if (PsiTreeUtil.isAncestor(e2,e1,false))             return 1;
            return -1;
          }
        }
);
        for (int i=0; i < usages.length; i++) {
          final UsageInfo usage=usages[i];
          if (usage.getElement() instanceof PsiReferenceExpression) {
            tempRefs.add((PsiReferenceExpression)usage.getElement());
          }
        }
        PsiReferenceExpression[] refs=tempRefs.toArray(new PsiReferenceExpression[tempRefs.size()]);
        refs=addBracesWhenNeeded(refs);
        for (int i=0; i < refs.length; i++) {
          inlineMethodCall(refs[i]);
        }
        if (myMethod.isWritable())         myMethod.delete();
      }
    }
    removeAddedBracesWhenPossible();
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
