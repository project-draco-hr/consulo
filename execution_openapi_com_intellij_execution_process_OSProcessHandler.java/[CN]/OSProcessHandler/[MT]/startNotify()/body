{
  final ReadProcessThread stdoutThread=new ReadProcessThread(createProcessOutReader()){
    protected void textAvailable(    String s){
      notifyTextAvailable(s,ProcessOutputTypes.STDOUT);
    }
  }
;
  final ReadProcessThread stderrThread=new ReadProcessThread(createProcessErrReader()){
    protected void textAvailable(    String s){
      notifyTextAvailable(s,ProcessOutputTypes.STDERR);
    }
  }
;
  notifyTextAvailable(myCommandLine + '\n',ProcessOutputTypes.SYSTEM);
  addProcessListener(new ProcessAdapter(){
    public void startNotified(    final ProcessEvent event){
      try {
        final Application application=ApplicationManager.getApplication();
        final Future<?> stdOutReadingFuture;
        final Future<?> stdErrReadingFuture;
        if (application != null) {
          stdOutReadingFuture=application.executeOnPooledThread(stdoutThread);
          stdErrReadingFuture=application.executeOnPooledThread(stderrThread);
        }
 else {
          stdOutReadingFuture=getOurThreadExecutorsService().submit(stdoutThread);
          stdErrReadingFuture=getOurThreadExecutorsService().submit(stderrThread);
        }
        final Runnable action=new Runnable(){
          public void run(){
            int exitCode=0;
            try {
              exitCode=myWaitFor.waitFor();
              stderrThread.setProcessTerminated(true);
              stdoutThread.setProcessTerminated(true);
              stdErrReadingFuture.get();
              stdOutReadingFuture.get();
            }
 catch (            InterruptedException e) {
            }
catch (            ExecutionException e) {
            }
            onOSProcessTerminated(exitCode);
          }
        }
;
        if (application != null) {
          application.executeOnPooledThread(action);
        }
 else {
          getOurThreadExecutorsService().submit(action);
        }
      }
  finally {
        removeProcessListener(this);
      }
    }
  }
);
  super.startNotify();
}
