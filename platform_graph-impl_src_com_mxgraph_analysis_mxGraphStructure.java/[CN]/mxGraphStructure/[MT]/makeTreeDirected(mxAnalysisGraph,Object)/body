{
  if (isTree(aGraph)) {
    mxGraphProperties.setDirected(aGraph.getProperties(),false);
    final ArrayList<Object> bFSList=new ArrayList<Object>();
    mxGraph graph=aGraph.getGraph();
    final mxIGraphModel model=graph.getModel();
    Object parent=graph.getDefaultParent();
    mxTraversal.bfs(aGraph,startVertex,new mxICellVisitor(){
      public boolean visit(      Object vertex,      Object edge){
        bFSList.add(vertex);
        return false;
      }
    }
);
    for (int i=0; i < bFSList.size(); i++) {
      Object parentVertex=bFSList.get(i);
      Object currEdges[]=aGraph.getEdges(parentVertex,parent,true,true,false,true);
      Object[] neighbors=aGraph.getOpposites(currEdges,parentVertex,true,true);
      for (int j=0; j < neighbors.length; j++) {
        Object currVertex=neighbors[j];
        int childIndex=bFSList.indexOf(currVertex);
        if (childIndex > i) {
          Object currEdge=getConnectingEdge(aGraph,parentVertex,currVertex);
          model.setTerminal(currEdge,parentVertex,true);
          model.setTerminal(currEdge,currVertex,false);
        }
      }
    }
    mxGraphProperties.setDirected(aGraph.getProperties(),true);
    mxGraphStructure.setDefaultGraphStyle(aGraph,false);
  }
 else {
    throw new StructuralException("The graph is not a tree");
  }
}
