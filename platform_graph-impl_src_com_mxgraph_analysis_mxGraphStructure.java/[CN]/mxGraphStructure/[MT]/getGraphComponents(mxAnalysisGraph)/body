{
  Object parent=aGraph.getGraph().getDefaultParent();
  Object[] vertices=aGraph.getChildVertices(parent);
  int vertexCount=vertices.length;
  if (vertexCount == 0) {
    return null;
  }
  ArrayList<ArrayList<Object>> componentList=new ArrayList<ArrayList<Object>>();
  ArrayList<Object> unvisitedVertexList=new ArrayList<Object>(Arrays.asList(vertices));
  boolean oldDirectedness=mxGraphProperties.isDirected(aGraph.getProperties(),mxGraphProperties.DEFAULT_DIRECTED);
  mxGraphProperties.setDirected(aGraph.getProperties(),false);
  while (unvisitedVertexList.size() > 0) {
    Object currVertex=unvisitedVertexList.remove(0);
    int componentCount=componentList.size();
    boolean isInComponent=false;
    for (int i=0; i < componentCount; i++) {
      if (componentList.get(i).contains(currVertex)) {
        isInComponent=true;
      }
    }
    if (!isInComponent) {
      final ArrayList<Object> currVertexList=new ArrayList<Object>();
      mxTraversal.bfs(aGraph,currVertex,new mxICellVisitor(){
        public boolean visit(        Object vertex,        Object edge){
          currVertexList.add(vertex);
          return false;
        }
      }
);
      for (int i=0; i < currVertexList.size(); i++) {
        unvisitedVertexList.remove(currVertexList.get(i));
      }
      componentList.add(currVertexList);
    }
  }
  mxGraphProperties.setDirected(aGraph.getProperties(),oldDirectedness);
  Object[][] result=new Object[componentList.size()][];
  for (int i=0; i < componentList.size(); i++) {
    result[i]=componentList.get(i).toArray();
  }
  return (Object[][])result;
}
