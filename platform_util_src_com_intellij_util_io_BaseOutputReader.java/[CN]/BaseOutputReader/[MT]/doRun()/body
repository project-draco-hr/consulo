{
  try {
    final int sleepTimeWhenRead=1;
    final int initialSleepTimeWhenIdle=5;
    final int maxSleepTimeWhenIdle=200;
    final int maxIterationsWithCurrentSleepTime=50;
    int iterationsWithCurrentTime=0;
    int currentSleepTime=initialSleepTimeWhenIdle;
    while (true) {
      boolean read=readAvailable();
      if (isStopped) {
        break;
      }
      if (read)       currentSleepTime=sleepTimeWhenRead;
 else       if (currentSleepTime == sleepTimeWhenRead) {
        currentSleepTime=initialSleepTimeWhenIdle;
        iterationsWithCurrentTime=0;
      }
 else {
        ++iterationsWithCurrentTime;
        if (iterationsWithCurrentTime == maxIterationsWithCurrentSleepTime) {
          iterationsWithCurrentTime=0;
          currentSleepTime=Math.min(2 * currentSleepTime,maxSleepTimeWhenIdle);
        }
      }
      TimeoutUtil.sleep(currentSleepTime);
    }
  }
 catch (  IOException e) {
    LOG.info(e);
  }
catch (  Exception e) {
    LOG.error(e);
  }
 finally {
    try {
      myReader.close();
    }
 catch (    IOException e) {
      LOG.error("Can't close stream",e);
    }
  }
}
