{
  if (elements.length == 0) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.block.should.represent.a.set.of.statements.or.an.expression"));
    CommonRefactoringUtil.showErrorHint(project,editor,message,ExtractMethodObjectProcessor.REFACTORING_NAME,HelpID.EXTRACT_METHOD_OBJECT);
    return;
  }
  final ExtractMethodObjectProcessor processor=new ExtractMethodObjectProcessor(project,editor,elements,"");
  final ExtractMethodObjectProcessor.MyExtractMethodProcessor extractProcessor=processor.getExtractProcessor();
  try {
    if (!extractProcessor.prepare())     return;
  }
 catch (  PrepareFailedException e) {
    CommonRefactoringUtil.showErrorHint(project,editor,e.getMessage(),ExtractMethodObjectProcessor.REFACTORING_NAME,HelpID.EXTRACT_METHOD_OBJECT);
    ExtractMethodHandler.highlightPrepareError(e,file,editor,project);
    return;
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,extractProcessor.getTargetClass().getContainingFile()))   return;
  if (extractProcessor.showDialog()) {
    new WriteCommandAction(project,ExtractMethodObjectProcessor.REFACTORING_NAME,ExtractMethodObjectProcessor.REFACTORING_NAME){
      protected void run(      final Result result) throws Throwable {
        extractProcessor.doRefactoring();
        processor.run();
        if (processor.isCreateInnerClass()) {
          processor.moveUsedMethodsToInner();
          DuplicatesImpl.processDuplicates(extractProcessor,project,editor);
          processor.changeInstanceAccess(project);
        }
        final PsiElement method=processor.getMethod();
        LOG.assertTrue(method != null);
        method.delete();
      }
    }
.execute();
  }
}
