{
  boolean findGet=myDescriptor.isToEncapsulateGet();
  boolean findSet=myDescriptor.isToEncapsulateSet();
  PsiModifierList newModifierList=null;
  final JavaPsiFacade facade=JavaPsiFacade.getInstance(myProject);
  if (!myDescriptor.isToUseAccessorsWhenAccessible()) {
    PsiElementFactory factory=facade.getElementFactory();
    try {
      PsiField field=factory.createField("a",PsiType.INT);
      setNewFieldVisibility(field);
      newModifierList=field.getModifierList();
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
  }
  PsiMethod[] getterPrototypes=myDescriptor.getGetterPrototypes();
  PsiMethod[] setterPrototypes=myDescriptor.getSetterPrototypes();
  ArrayList<UsageInfo> array=new ArrayList<UsageInfo>();
  PsiField[] fields=myFields;
  for (int i=0; i < fields.length; i++) {
    PsiField field=fields[i];
    for (    final PsiReference reference : ReferencesSearch.search(field)) {
      if (!(reference instanceof PsiReferenceExpression))       continue;
      PsiReferenceExpression ref=(PsiReferenceExpression)reference;
      if (findGet && isUsedInExistingAccessor(getterPrototypes[i],ref))       continue;
      if (findSet && isUsedInExistingAccessor(setterPrototypes[i],ref))       continue;
      if (!findGet) {
        if (!PsiUtil.isAccessedForWriting(ref))         continue;
      }
      if (!findSet || field.hasModifierProperty(PsiModifier.FINAL)) {
        if (!PsiUtil.isAccessedForReading(ref))         continue;
      }
      if (!myDescriptor.isToUseAccessorsWhenAccessible()) {
        PsiClass accessObjectClass=null;
        PsiExpression qualifier=ref.getQualifierExpression();
        if (qualifier != null) {
          accessObjectClass=(PsiClass)PsiUtil.getAccessObjectClass(qualifier).getElement();
        }
        if (facade.getResolveHelper().isAccessible(field,newModifierList,ref,accessObjectClass,null)) {
          continue;
        }
      }
      UsageInfo usageInfo=new MyUsageInfo(ref,i);
      array.add(usageInfo);
    }
  }
  MyUsageInfo[] usageInfos=array.toArray(new MyUsageInfo[array.size()]);
  return UsageViewUtil.removeDuplicatedUsages(usageInfos);
}
