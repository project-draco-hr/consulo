{
  if (isGetter) {
    if (!myDescriptor.isToEncapsulateGet())     return;
  }
 else {
    if (!myDescriptor.isToEncapsulateSet())     return;
  }
  for (  FieldDescriptor descriptor : myFieldDescriptors) {
    PsiMethod prototype=isGetter ? descriptor.getGetterPrototype() : descriptor.getSetterPrototype();
    final PsiType prototypeReturnType=prototype.getReturnType();
    PsiMethod existing=myClass.findMethodBySignature(prototype,true);
    if (existing != null) {
      final PsiType returnType=existing.getReturnType();
      if (!RefactoringUtil.equivalentTypes(prototypeReturnType,returnType,myClass.getManager())) {
        final String descr=PsiFormatUtil.formatMethod(existing,PsiSubstitutor.EMPTY,PsiFormatUtilBase.SHOW_NAME | PsiFormatUtilBase.SHOW_PARAMETERS | PsiFormatUtilBase.SHOW_TYPE,PsiFormatUtilBase.SHOW_TYPE);
        String message=isGetter ? RefactoringBundle.message("encapsulate.fields.getter.exists",CommonRefactoringUtil.htmlEmphasize(descr),CommonRefactoringUtil.htmlEmphasize(prototype.getName())) : RefactoringBundle.message("encapsulate.fields.setter.exists",CommonRefactoringUtil.htmlEmphasize(descr),CommonRefactoringUtil.htmlEmphasize(prototype.getName()));
        conflicts.putValue(existing,message);
      }
    }
 else {
      PsiClass containingClass=myClass.getContainingClass();
      while (containingClass != null && existing == null) {
        existing=containingClass.findMethodBySignature(prototype,true);
        if (existing != null) {
          for (          PsiReference reference : ReferencesSearch.search(existing)) {
            final PsiElement place=reference.getElement();
            LOG.assertTrue(place instanceof PsiReferenceExpression);
            final PsiExpression qualifierExpression=((PsiReferenceExpression)place).getQualifierExpression();
            final PsiClass inheritor;
            if (qualifierExpression == null) {
              inheritor=PsiTreeUtil.getParentOfType(place,PsiClass.class,false);
            }
 else {
              inheritor=PsiUtil.resolveClassInType(qualifierExpression.getType());
            }
            if (InheritanceUtil.isInheritorOrSelf(inheritor,myClass,true)) {
              conflicts.putValue(existing,"There is already a " + RefactoringUIUtil.getDescription(existing,true) + " which would be hidden by generated "+ (isGetter ? "getter" : "setter"));
              break;
            }
          }
        }
        containingClass=containingClass.getContainingClass();
      }
    }
  }
}
