{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  checkExistingMethods(conflicts,true);
  checkExistingMethods(conflicts,false);
  final Collection<PsiClass> classes=ClassInheritorsSearch.search(myClass).findAll();
  for (  FieldDescriptor fieldDescriptor : myFieldDescriptors) {
    final Set<PsiMethod> setters=new HashSet<PsiMethod>();
    final Set<PsiMethod> getters=new HashSet<PsiMethod>();
    for (    PsiClass aClass : classes) {
      final PsiMethod getterOverrider=myDescriptor.isToEncapsulateGet() ? aClass.findMethodBySignature(fieldDescriptor.getGetterPrototype(),false) : null;
      if (getterOverrider != null) {
        getters.add(getterOverrider);
      }
      final PsiMethod setterOverrider=myDescriptor.isToEncapsulateSet() ? aClass.findMethodBySignature(fieldDescriptor.getSetterPrototype(),false) : null;
      if (setterOverrider != null) {
        setters.add(setterOverrider);
      }
    }
    if (!getters.isEmpty() || !setters.isEmpty()) {
      final PsiField field=fieldDescriptor.getField();
      for (      PsiReference reference : ReferencesSearch.search(field)) {
        final PsiElement place=reference.getElement();
        LOG.assertTrue(place instanceof PsiReferenceExpression);
        final PsiExpression qualifierExpression=((PsiReferenceExpression)place).getQualifierExpression();
        final PsiClass ancestor;
        if (qualifierExpression == null) {
          ancestor=PsiTreeUtil.getParentOfType(place,PsiClass.class,false);
        }
 else {
          ancestor=PsiUtil.resolveClassInType(qualifierExpression.getType());
        }
        final boolean isGetter=!PsiUtil.isAccessedForWriting((PsiExpression)place);
        for (        PsiMethod overridden : isGetter ? getters : setters) {
          if (InheritanceUtil.isInheritorOrSelf(myClass,ancestor,true)) {
            conflicts.putValue(overridden,"There is already a " + RefactoringUIUtil.getDescription(overridden,true) + " which would hide generated "+ (isGetter ? "getter" : "setter")+ " for "+ place.getText());
            break;
          }
        }
      }
    }
  }
  return showConflicts(conflicts,refUsages.get());
}
