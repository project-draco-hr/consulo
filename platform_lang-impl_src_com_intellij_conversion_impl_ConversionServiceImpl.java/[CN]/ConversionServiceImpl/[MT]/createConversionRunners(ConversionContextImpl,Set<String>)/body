{
  List<ConversionRunner> runners=new ArrayList<ConversionRunner>();
  final ConverterProvider[] providers=ConverterProvider.EP_NAME.getExtensions();
  for (  ConverterProvider provider : providers) {
    if (!performedConversionIds.contains(provider.getId())) {
      runners.add(new ConversionRunner(provider,context));
    }
  }
  final CachingSemiGraph<ConverterProvider> graph=CachingSemiGraph.create(new ConverterProvidersGraph(providers));
  final DFSTBuilder<ConverterProvider> builder=new DFSTBuilder<ConverterProvider>(GraphGenerator.create(graph));
  if (!builder.isAcyclic()) {
    final Pair<ConverterProvider,ConverterProvider> pair=builder.getCircularDependency();
    LOG.error("cyclic dependencies between converters: " + pair.getFirst().getId() + " and "+ pair.getSecond().getId());
  }
  final Comparator<ConverterProvider> comparator=builder.comparator();
  Collections.sort(runners,new Comparator<ConversionRunner>(){
    @Override public int compare(    ConversionRunner o1,    ConversionRunner o2){
      return comparator.compare(o1.getProvider(),o2.getProvider());
    }
  }
);
  return runners;
}
