{
  if (argument instanceof PsiReferenceExpression) {
    PsiElement element=((PsiReferenceExpression)argument).resolve();
    if (element instanceof PsiParameter) {
      PsiParameter parameter=(PsiParameter)element;
      if (myLocalsForParameters.containsKey(parameter)) {
        return argument.replace(getParameterReference(parameter));
      }
      int index=myConstructorParameters.getParameterIndex(parameter);
      return argument.replace(myConstructorArguments.getExpressions()[index]);
    }
  }
  final List<Pair<PsiReferenceExpression,PsiParameter>> parameterReferences=new ArrayList<Pair<PsiReferenceExpression,PsiParameter>>();
  final Map<PsiElement,PsiElement> elementsToReplace=new HashMap<PsiElement,PsiElement>();
  argument.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitReferenceExpression(    final PsiReferenceExpression expression){
      super.visitReferenceExpression(expression);
      final PsiElement psiElement=expression.resolve();
      if (psiElement instanceof PsiParameter) {
        parameterReferences.add(new Pair<PsiReferenceExpression,PsiParameter>(expression,(PsiParameter)psiElement));
      }
 else       if ((psiElement instanceof PsiField || psiElement instanceof PsiMethod) && ((PsiMember)psiElement).getContainingClass() == myClass.getSuperClass()) {
        PsiMember member=(PsiMember)psiElement;
        if (member.hasModifierProperty(PsiModifier.STATIC) && expression.getQualifierExpression() == null) {
          final String qualifiedText=myClass.getSuperClass().getQualifiedName() + "." + member.getName();
          try {
            final PsiExpression replacement=myElementFactory.createExpressionFromText(qualifiedText,myClass);
            elementsToReplace.put(expression,replacement);
          }
 catch (          IncorrectOperationException e) {
            LOG.error(e);
          }
        }
      }
 else       if (psiElement instanceof PsiVariable) {
        if (localVarRefs != null) {
          localVarRefs.add(expression);
        }
        if (replaceFieldsWithInitializers && psiElement instanceof PsiField && ((PsiField)psiElement).getContainingClass() == myClass) {
          final PsiExpression initializer=((PsiField)psiElement).getInitializer();
          if (isConstant(initializer)) {
            elementsToReplace.put(expression,initializer);
          }
        }
      }
    }
  }
);
  for (  Pair<PsiReferenceExpression,PsiParameter> pair : parameterReferences) {
    PsiReferenceExpression ref=pair.first;
    PsiParameter param=pair.second;
    if (myLocalsForParameters.containsKey(param)) {
      ref.replace(getParameterReference(param));
    }
 else {
      int index=myConstructorParameters.getParameterIndex(param);
      if (ref == argument) {
        argument=argument.replace(myConstructorArguments.getExpressions()[index]);
      }
 else {
        ref.replace(myConstructorArguments.getExpressions()[index]);
      }
    }
  }
  return RefactoringUtil.replaceElementsWithMap(argument,elementsToReplace);
}
