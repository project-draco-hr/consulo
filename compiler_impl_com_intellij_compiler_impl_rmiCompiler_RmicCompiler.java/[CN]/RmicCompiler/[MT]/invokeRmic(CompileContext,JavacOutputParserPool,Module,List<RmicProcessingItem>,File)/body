{
  final ProjectJdk jdk=ModuleRootManager.getInstance(module).getJdk();
  final Map<String,RmicProcessingItem> pathToItemMap=new HashMap<String,RmicProcessingItem>();
  final String[] cmdLine=ApplicationManager.getApplication().runReadAction(new Computable<String[]>(){
    public String[] compute(){
      for (      final RmicProcessingItem item : dirItems) {
        pathToItemMap.put(item.myStub.getPath().replace(File.separatorChar,'/'),item);
        pathToItemMap.put(item.mySkel.getPath().replace(File.separatorChar,'/'),item);
        pathToItemMap.put(item.myTie.getPath().replace(File.separatorChar,'/'),item);
      }
      return createStartupCommand(module,outputDir.getPath(),dirItems.toArray(new RmicProcessingItem[dirItems.size()]));
    }
  }
);
  if (LOG.isDebugEnabled()) {
    StringBuffer buf=new StringBuffer();
    for (int idx=0; idx < cmdLine.length; idx++) {
      if (idx > 0) {
        buf.append(" ");
      }
      buf.append(cmdLine[idx]);
    }
    LOG.debug(buf.toString());
  }
  final OutputParser outputParser=parserPool.getJavacOutputParser(jdk);
  final Process process=Runtime.getRuntime().exec(cmdLine);
  final Set<RmicProcessingItem> successfullyCompiledItems=new HashSet<RmicProcessingItem>();
  final CompilerParsingThread parsingThread=new CompilerParsingThreadImpl(process,context,outputParser,false,true){
    protected void processCompiledClass(    String classFileToProcess){
      final RmicProcessingItem item=pathToItemMap.get(classFileToProcess.replace(File.separatorChar,'/'));
      if (item != null) {
        successfullyCompiledItems.add(item);
      }
    }
  }
;
  final Future<?> parsingThreadFuture=ApplicationManager.getApplication().executeOnPooledThread(parsingThread);
  try {
    parsingThreadFuture.get();
  }
 catch (  InterruptedException e) {
  }
catch (  ExecutionException e) {
  }
  return successfullyCompiledItems.toArray(new RmicProcessingItem[successfullyCompiledItems.size()]);
}
