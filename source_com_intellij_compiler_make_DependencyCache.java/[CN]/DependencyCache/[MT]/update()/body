{
  if (myToUpdate.size() == 0) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  for (int idx=0; idx < namesToUpdate.length; idx++) {
    final int qName=namesToUpdate[idx];
    final int oldClassId=cache.getClassId(qName);
    if (oldClassId != Cache.UNKNOWN) {
      final int[] referencedClasses=cache.getReferencedClasses(oldClassId);
      for (int i=0; i < referencedClasses.length; i++) {
        final int referencedClassDeclarationId=cache.getClassDeclarationId(referencedClasses[i]);
        if (referencedClassDeclarationId == Cache.UNKNOWN) {
          continue;
        }
        cache.removeClassReferencer(referencedClassDeclarationId,qName);
        final int[] fieldIds=cache.getFieldIds(referencedClassDeclarationId);
        for (int j=0; j < fieldIds.length; j++) {
          cache.removeFieldReferencer(fieldIds[j],qName);
        }
        final int[] methodIds=cache.getMethodIds(referencedClassDeclarationId);
        for (int j=0; j < methodIds.length; j++) {
          cache.removeMethodReferencer(methodIds[j],qName);
        }
      }
      navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
        public boolean process(        int classQName) throws CacheCorruptedException {
          final int classId=cache.getClassId(classQName);
          cache.removeSubclass(classId,qName);
          return true;
        }
      }
);
    }
  }
  for (int idx=0; idx < namesToUpdate.length; idx++) {
    final int qName=namesToUpdate[idx];
    final int newInfoId=getNewClassesCache().getClassId(qName);
    if (newInfoId == Cache.UNKNOWN) {
      continue;
    }
    cache.importClassInfo(getNewClassesCache(),qName);
  }
  for (int idx=0; idx < namesToUpdate.length; idx++) {
    final int qName=namesToUpdate[idx];
    final int newClassId=getNewClassesCache().getClassId(qName);
    if (newClassId == Cache.UNKNOWN) {
      continue;
    }
    buildForwardDependencies(qName,getNewClassesCache().getReferences(newClassId));
    boolean isRemote=false;
    final int classId=cache.getClassId(qName);
    final int[] superInterfaces=cache.getSuperInterfaces(classId);
    if (superInterfaces.length > 0) {
      final int remoteInterfaceName=mySymbolTable.getId(REMOTE_INTERFACE_NAME);
      for (int i=0; i < superInterfaces.length; i++) {
        if (isRemoteInterface(cache,superInterfaces[i],remoteInterfaceName)) {
          isRemote=true;
          break;
        }
      }
    }
    final boolean wasRemote=cache.isRemote(classId);
    if (wasRemote && !isRemote) {
      myPreviouslyRemoteClasses.add(qName);
    }
    cache.setRemote(classId,isRemote);
  }
  for (int idx=0; idx < namesToUpdate.length; idx++) {
    final int qName=namesToUpdate[idx];
    buildSubclassDependencies(qName,qName);
  }
  final int[] classesToRemove=myClassesWithSourceRemoved.toArray();
  for (int idx=0; idx < classesToRemove.length; idx++) {
    final int qName=classesToRemove[idx];
    cache.removeClass(qName);
  }
  myToUpdate=new TIntHashSet();
}
