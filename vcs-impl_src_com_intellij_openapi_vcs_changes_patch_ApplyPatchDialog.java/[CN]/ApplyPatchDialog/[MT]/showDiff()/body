{
  List<Change> changes=new ArrayList<Change>();
  ApplyPatchContext context=getApplyPatchContext().getPrepareContext();
  Object[] selection=myPatchContentsList.getSelectedValues();
  if (selection.length == 0) {
    if (myPatches == null)     return;
    selection=myPatches.toArray(new Object[myPatches.size()]);
  }
  for (  Object o : selection) {
    final TextFilePatch patch=(TextFilePatch)o;
    try {
      if (patch.isNewFile()) {
        final FilePath newFilePath=FilePathImpl.createNonLocal(patch.getAfterName(),false);
        final String content=patch.getNewFileText();
        ContentRevision revision=new SimpleContentRevision(content,newFilePath,patch.getAfterVersionId());
        changes.add(new Change(null,revision));
      }
 else {
        final VirtualFile fileToPatch=patch.findFileToPatch(context);
        if (fileToPatch != null) {
          final FilePathImpl filePath=new FilePathImpl(fileToPatch);
          final CurrentContentRevision currentRevision=new CurrentContentRevision(filePath);
          if (patch.isDeletedFile()) {
            changes.add(new Change(currentRevision,null));
          }
 else {
            final Document doc=FileDocumentManager.getInstance().getDocument(fileToPatch);
            String baseContent=doc.getText();
            StringBuilder newText=new StringBuilder();
            patch.applyModifications(baseContent,newText);
            ContentRevision revision=new SimpleContentRevision(newText.toString(),filePath,patch.getAfterVersionId());
            changes.add(new Change(currentRevision,revision));
          }
        }
      }
    }
 catch (    Exception e) {
      Messages.showErrorDialog(myProject,"Error loading changes for " + patch.getAfterFileName() + ": "+ e.getMessage(),VcsBundle.message("patch.apply.dialog.title"));
      return;
    }
  }
  if (changes.size() > 0) {
    ShowDiffAction.showDiffForChange(changes.toArray(new Change[changes.size()]),0,myProject,ShowDiffAction.DiffExtendUIFactory.NONE,false);
  }
}
