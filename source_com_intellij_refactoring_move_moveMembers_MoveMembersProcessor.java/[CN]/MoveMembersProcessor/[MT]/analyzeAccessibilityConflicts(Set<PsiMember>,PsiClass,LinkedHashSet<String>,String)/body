{
  for (  PsiMember member : membersToMove) {
    checkUsedElements(member,member,membersToMove,targetClass,conflicts);
    PsiModifierList modifierList=(PsiModifierList)member.getModifierList().copy();
    if (newVisibility != null) {
      try {
        RefactoringUtil.setVisibility(modifierList,newVisibility);
      }
 catch (      IncorrectOperationException ex) {
      }
    }
    final boolean isMemberPublic=modifierList.hasModifierProperty(PsiModifier.PUBLIC) || targetClass.isInterface() || (newVisibility != null && PsiModifier.PUBLIC.equals(newVisibility));
    if (!isMemberPublic) {
      PsiManager manager=member.getManager();
      PsiSearchHelper helper=manager.getSearchHelper();
      GlobalSearchScope projectScope=GlobalSearchScope.projectScope(manager.getProject());
      PsiReference[] references=helper.findReferences(member,projectScope,false);
      for (      PsiReference psiReference : references) {
        PsiElement ref=psiReference.getElement();
        if (!RefactoringHierarchyUtil.willBeInTargetClass(ref,membersToMove,targetClass,false)) {
          if (!manager.getResolveHelper().isAccessible(member,modifierList,ref,null)) {
            String message=ConflictsUtil.getDescription(member,true) + " is " + VisibilityUtil.getVisiblityStringToDisplay(member)+ " and will not be accessible from "+ ConflictsUtil.getDescription(ConflictsUtil.getContainer(ref),true)+ " when moved to the target class.";
            message=ConflictsUtil.capitalize(message);
            conflicts.add(message);
          }
        }
      }
    }
  }
  return conflicts.toArray(new String[conflicts.size()]);
}
