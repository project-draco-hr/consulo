{
  try {
    final Ref<Long> beforeTick=new Ref<Long>(Long.MAX_VALUE);
    final Ref<Long> afterTick=new Ref<Long>(-1L);
    lowLevelAccess.loadCommits(Collections.<String>emptyList(),before,after,Collections.<ChangesFilter.Filter>emptyList(),new Consumer<GitCommit>(){
      public void consume(      GitCommit gitCommit){
        atomicSectionsAware.checkShouldExit();
        final long time=gitCommit.getDate().getTime();
        beforeTick.set(Math.min(beforeTick.get(),time));
        afterTick.set(Math.max(afterTick.get(),time));
        if (!StringUtil.isEmptyOrSpaces(gitCommit.getAuthor())) {
          newData.add(gitCommit.getAuthor());
        }
        if (!StringUtil.isEmptyOrSpaces(gitCommit.getCommitter())) {
          newData.add(gitCommit.getCommitter());
        }
        if (gitCommit.getParentsHashes().isEmpty()) {
          myStartReached=true;
        }
      }
    }
,ourPackSize,Collections.<String>emptyList());
    if (myCloserDate.getT() < afterTick.get()) {
      myCloserDate.updateT(afterTick.get());
    }
    if (myEarlierDate.getT() > beforeTick.get()) {
      myEarlierDate.updateT(beforeTick.get());
    }
  }
 catch (  VcsException e) {
    LOG.info(e);
  }
}
