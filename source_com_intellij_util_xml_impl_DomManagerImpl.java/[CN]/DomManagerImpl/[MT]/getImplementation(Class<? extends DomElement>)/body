{
  if (myCachedImplementationClasses.containsKey(concreteInterface)) {
    return myCachedImplementationClasses.get(concreteInterface);
  }
  final TreeSet<Class<? extends DomElement>> set=new TreeSet<Class<? extends DomElement>>(new Comparator<Class<? extends DomElement>>(){
    public int compare(    final Class<? extends DomElement> o1,    final Class<? extends DomElement> o2){
      if (o1.isAssignableFrom(o2))       return 1;
      if (o2.isAssignableFrom(o1))       return -1;
      if (o1.equals(o2))       return 0;
      throw new AssertionError("Incompatible implementation classes: " + o1 + " & "+ o2);
    }
  }
);
  findImplementationClassDFS(concreteInterface,set);
  if (!set.isEmpty()) {
    final Class<? extends DomElement> aClass=set.first();
    myCachedImplementationClasses.put(concreteInterface,aClass);
    return aClass;
  }
  final Implementation implementation=DomUtil.findAnnotationDFS(concreteInterface,Implementation.class);
  final Class<? extends DomElement> aClass1=implementation == null ? null : implementation.value();
  myCachedImplementationClasses.put(concreteInterface,aClass1);
  return aClass1;
}
