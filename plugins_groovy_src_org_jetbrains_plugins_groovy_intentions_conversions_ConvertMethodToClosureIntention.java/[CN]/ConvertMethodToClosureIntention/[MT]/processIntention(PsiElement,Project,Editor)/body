{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final GrMethod method;
  if (element.getParent() instanceof GrMethod) {
    method=(GrMethod)element.getParent();
  }
 else {
    final PsiReference ref=element.getReference();
    LOG.assertTrue(ref != null);
    final PsiElement resolved=ref.resolve();
    LOG.assertTrue(resolved instanceof GrMethod);
    method=(GrMethod)resolved;
  }
  final PsiClass containingClass=method.getContainingClass();
  final String methodName=method.getName();
  final PsiField field=containingClass.findFieldByName(methodName,true);
  if (field != null) {
    conflicts.putValue(field,GroovyIntentionsBundle.message("field.already.exists",methodName));
  }
  final Collection<PsiReference> references=MethodReferencesSearch.search(method).findAll();
  final Collection<GrReferenceExpression> usagesToConvert=new HashSet<GrReferenceExpression>(references.size());
  for (  PsiReference ref : references) {
    final PsiElement psiElement=ref.getElement();
    if (!GroovyFileType.GROOVY_LANGUAGE.equals(psiElement.getLanguage())) {
      conflicts.putValue(psiElement,GroovyIntentionsBundle.message("method.is.used.outside.of.groovy"));
    }
 else     if (!PsiUtil.isMethodUsage(psiElement)) {
      if (psiElement instanceof GrReferenceExpression) {
        if (((GrReferenceExpression)psiElement).hasMemberPointer()) {
          usagesToConvert.add((GrReferenceExpression)psiElement);
        }
      }
    }
  }
  if (conflicts.size() > 0) {
    ConflictsDialog conflictsDialog=new ConflictsDialog(project,conflicts,new Runnable(){
      @Override public void run(){
        execute(method,usagesToConvert);
      }
    }
);
    conflictsDialog.show();
    if (conflictsDialog.getExitCode() != DialogWrapper.OK_EXIT_CODE)     return;
  }
  execute(method,usagesToConvert);
}
