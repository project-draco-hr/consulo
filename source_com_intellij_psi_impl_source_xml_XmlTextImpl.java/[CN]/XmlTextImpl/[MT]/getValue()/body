{
  if (myDisplayText != null)   return myDisplayText;
  StringBuffer buffer=new StringBuffer();
  ASTNode child=getFirstChildNode();
  final List<Integer> gaps=new ArrayList<Integer>();
  while (child != null) {
    final int start=buffer.length();
    IElementType elementType=child.getElementType();
    if (elementType == XmlElementType.XML_CDATA) {
      final ASTNode cdata=child;
      child=cdata.getFirstChildNode();
    }
 else     if (elementType == XmlTokenType.XML_CHAR_ENTITY_REF) {
      buffer.append(getChar(child.getText()));
    }
 else     if (elementType == XmlTokenType.XML_WHITE_SPACE || elementType == XmlTokenType.XML_DATA_CHARACTERS || elementType == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {
      buffer.append(child.getText());
    }
    int end=buffer.length();
    int originalLength=child.getTextLength();
    if (end - start != originalLength) {
      gaps.add(new Integer(start));
      gaps.add(new Integer(originalLength - (end - start)));
    }
    final ASTNode next=child.getTreeNext();
    if (next == null && child.getTreeParent().getElementType() == XmlElementType.XML_CDATA) {
      child=child.getTreeParent().getTreeNext();
    }
 else {
      child=next;
    }
  }
  myGaps=new int[gaps.size()];
  int index=0;
  final Iterator<Integer> iterator=gaps.iterator();
  while (iterator.hasNext()) {
    final Integer integer=iterator.next();
    myGaps[index++]=integer.intValue();
  }
  return myDisplayText=buffer.toString();
}
