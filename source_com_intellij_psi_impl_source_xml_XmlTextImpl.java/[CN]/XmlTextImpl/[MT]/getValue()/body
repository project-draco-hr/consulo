{
  if (myDisplayText != null)   return myDisplayText;
  StringBuffer buffer=new StringBuffer();
  ASTNode child=getFirstChildNode();
  final List<Integer> gapsStarts=new ArrayList<Integer>();
  final List<Integer> gapsShifts=new ArrayList<Integer>();
  while (child != null) {
    final int start=buffer.length();
    IElementType elementType=child.getElementType();
    if (elementType == XmlElementType.XML_CDATA) {
      final ASTNode cdata=child;
      child=cdata.getFirstChildNode();
    }
 else     if (elementType == XmlTokenType.XML_CHAR_ENTITY_REF) {
      buffer.append(getChar(child.getText()));
    }
 else     if (elementType == XmlTokenType.XML_WHITE_SPACE || elementType == XmlTokenType.XML_DATA_CHARACTERS || elementType == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {
      buffer.append(child.getText());
    }
 else     if (elementType == ElementType.ERROR_ELEMENT) {
      buffer.append(child.getText());
    }
    int end=buffer.length();
    int originalLength=child.getTextLength();
    if (end - start != originalLength) {
      gapsStarts.add(new Integer(start));
      gapsShifts.add(new Integer(originalLength - (end - start)));
    }
    final ASTNode next=child.getTreeNext();
    if (next == null && child.getTreeParent().getElementType() == XmlElementType.XML_CDATA) {
      child=child.getTreeParent().getTreeNext();
    }
 else {
      child=next;
    }
  }
  myGapDisplayStarts=new int[gapsShifts.size()];
  myGapPhysicalStarts=new int[gapsShifts.size()];
  int index=0;
  final Iterator<Integer> startsIterator=gapsStarts.iterator();
  final Iterator<Integer> shiftsIterator=gapsShifts.iterator();
  int currentGapsSum=0;
  while (startsIterator.hasNext()) {
    final Integer integer=shiftsIterator.next();
    currentGapsSum+=integer.intValue();
    myGapDisplayStarts[index]=startsIterator.next().intValue();
    myGapPhysicalStarts[index]=myGapDisplayStarts[index] + currentGapsSum;
    index++;
  }
  return myDisplayText=buffer.toString();
}
