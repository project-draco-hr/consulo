{
  String displayText=myDisplayText;
  if (displayText != null)   return displayText;
  StringBuilder buffer=new StringBuilder();
  ASTNode child=getFirstChildNode();
  final TIntArrayList gapsStarts=new TIntArrayList();
  final TIntArrayList gapsShifts=new TIntArrayList();
  while (child != null) {
    final int start=buffer.length();
    IElementType elementType=child.getElementType();
    if (elementType == XmlElementType.XML_CDATA) {
      final ASTNode cdata=child;
      child=cdata.getFirstChildNode();
    }
 else     if (elementType == XmlTokenType.XML_CHAR_ENTITY_REF) {
      buffer.append(XmlUtil.getCharFromEntityRef(child.getText()));
    }
 else     if (elementType == XmlTokenType.XML_WHITE_SPACE || elementType == XmlTokenType.XML_DATA_CHARACTERS || elementType == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {
      buffer.append(child.getText());
    }
 else     if (elementType == JavaElementType.ERROR_ELEMENT) {
      buffer.append(child.getText());
    }
    int end=buffer.length();
    int originalLength=child.getTextLength();
    if (end - start != originalLength) {
      gapsStarts.add(end);
      gapsShifts.add(originalLength - (end - start));
    }
    final ASTNode next=child.getTreeNext();
    if (next == null && child.getTreeParent().getElementType() == XmlElementType.XML_CDATA) {
      child=child.getTreeParent().getTreeNext();
    }
 else {
      child=next;
    }
  }
  myGapDisplayStarts=new int[gapsShifts.size()];
  myGapPhysicalStarts=new int[gapsShifts.size()];
  int currentGapsSum=0;
  for (int i=0; i < myGapDisplayStarts.length; i++) {
    currentGapsSum+=gapsShifts.get(i);
    myGapDisplayStarts[i]=gapsStarts.get(i);
    myGapPhysicalStarts[i]=myGapDisplayStarts[i] + currentGapsSum;
  }
  return myDisplayText=buffer.toString();
}
