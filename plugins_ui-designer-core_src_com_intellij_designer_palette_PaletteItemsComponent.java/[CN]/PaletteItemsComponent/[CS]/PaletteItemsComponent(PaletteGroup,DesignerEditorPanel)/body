{
  myGroup=group;
  myDesigner=designer;
  setModel(new AbstractListModel(){
    @Override public int getSize(){
      return myGroup.getItems().size();
    }
    @Override public Object getElementAt(    int index){
      return myGroup.getItems().get(index);
    }
  }
);
  ColoredListCellRenderer renderer=new ColoredListCellRenderer(){
    @Override protected void customizeCellRenderer(    JList list,    Object value,    int index,    boolean selected,    boolean hasFocus){
      clear();
      PaletteItem item=(PaletteItem)value;
      boolean enabled=item.isEnabled();
      setEnabled(enabled);
      if (enabled) {
        setIcon(item.getIcon());
      }
 else {
        setIcon(IconLoader.getDisabledIcon(item.getIcon()));
      }
      String title=item.getTitle();
      String tooltip=item.getTooltip();
      String version=myDesigner.getVersionLabel(item.getVersion());
      String deprecatedIn=item.getDeprecatedIn();
      boolean deprecated=myDesigner.isDeprecated(deprecatedIn);
      append(title,deprecated ? DEPRECATED_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);
      if (!version.isEmpty()) {
        version="<sup><i>" + version + "</i></sup>";
      }
      if (tooltip != null) {
        String deprecatedMessage="";
        if (deprecated) {
          deprecatedMessage=String.format("<b>This item is deprecated in version \"%1$s\".<br>",myDesigner.getVersionLabel(deprecatedIn));
          String hint=item.getDeprecatedHint();
          if (!StringUtil.isEmpty(hint)) {
            deprecatedMessage+=hint;
          }
          deprecatedMessage+="</b><br><br>";
        }
        tooltip="<html><body><center><b>" + StringUtil.escapeXml(title) + "</b>"+ version+ "</center><p style='width: 300px'>"+ deprecatedMessage+ tooltip+ "</p></body></html>";
      }
      setToolTipText(tooltip);
    }
  }
;
  renderer.getIpad().left=2 * UIUtil.getTreeLeftChildIndent();
  renderer.getIpad().right=UIUtil.getTreeRightChildIndent();
  setCellRenderer(renderer);
  setVisibleRowCount(0);
  setLayoutOrientation(HORIZONTAL_WRAP);
  setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      myNeedClearSelection=SwingUtilities.isLeftMouseButton(e) && myBeforeClickSelectedRow >= 0 && locationToIndex(e.getPoint()) == myBeforeClickSelectedRow && !UIUtil.isControlKeyDown(e) && !e.isShiftDown();
    }
    @Override public void mouseReleased(    MouseEvent e){
      if (SwingUtilities.isLeftMouseButton(e) && myBeforeClickSelectedRow >= 0 && locationToIndex(e.getPoint()) == myBeforeClickSelectedRow && !UIUtil.isControlKeyDown(e) && !e.isShiftDown() && myNeedClearSelection) {
        clearSelection();
      }
    }
  }
);
  setDragEnabled(true);
  setTransferHandler(new TreeTransfer(PaletteItem.class));
  DnDManager.getInstance().registerSource(new DnDSource(){
    @Override public boolean canStartDragging(    DnDAction action,    Point dragOrigin){
      int index=locationToIndex(dragOrigin);
      if (index != -1 && myDesigner != null) {
        PaletteItem paletteItem=myGroup.getItems().get(index);
        myDesigner.activatePaletteItem(paletteItem);
      }
      return false;
    }
    @Override public DnDDragStartBean startDragging(    DnDAction action,    Point dragOrigin){
      return null;
    }
    @Nullable @Override public Pair<Image,Point> createDraggedImage(    DnDAction action,    Point dragOrigin){
      return null;
    }
    @Override public void dragDropEnd(){
    }
    @Override public void dropActionChanged(    int gestureModifiers){
    }
  }
,this);
  initActions();
}
