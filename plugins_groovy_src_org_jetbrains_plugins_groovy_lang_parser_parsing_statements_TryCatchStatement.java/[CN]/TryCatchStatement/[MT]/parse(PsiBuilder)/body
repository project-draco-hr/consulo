{
  PsiBuilder.Marker marker=builder.mark();
  ParserUtils.getToken(builder,kTRY);
  PsiBuilder.Marker warn=builder.mark();
  ParserUtils.getToken(builder,mNLS);
  GroovyElementType result=WRONGWAY;
  if (mLCURLY.equals(builder.getTokenType())) {
    result=OpenOrClosableBlock.parseOpenBlock(builder);
  }
  if (result.equals(WRONGWAY)) {
    warn.rollbackTo();
    builder.error(GroovyBundle.message("expression.expected"));
    marker.done(TRY_BLOCK_STATEMENT);
    return TRY_BLOCK_STATEMENT;
  }
  warn.drop();
  ParserUtils.getToken(builder,mNLS);
  if (!(builder.getTokenType() == kCATCH) && !(builder.getTokenType() == kFINALLY)) {
    builder.error(GroovyBundle.message("catch.or.finally.expected"));
    marker.done(TRY_BLOCK_STATEMENT);
    return TRY_BLOCK_STATEMENT;
  }
  if (kCATCH.equals(builder.getTokenType())) {
    parseHandlers(builder);
  }
  if (kFINALLY.equals(builder.getTokenType()) | ParserUtils.lookAhead(builder,mNLS,kFINALLY)) {
    ParserUtils.getToken(builder,mNLS);
    PsiBuilder.Marker finallyMarker=builder.mark();
    warn=builder.mark();
    ParserUtils.getToken(builder,kFINALLY);
    ParserUtils.getToken(builder,mNLS);
    result=WRONGWAY;
    if (mLCURLY.equals(builder.getTokenType())) {
      result=OpenOrClosableBlock.parseOpenBlock(builder);
    }
    if (result.equals(WRONGWAY)) {
      finallyMarker.drop();
      warn.rollbackTo();
      builder.error(GroovyBundle.message("expression.expected"));
    }
 else {
      warn.drop();
      finallyMarker.done(FINALLY_CLAUSE);
    }
  }
  marker.done(TRY_BLOCK_STATEMENT);
  return TRY_BLOCK_STATEMENT;
}
