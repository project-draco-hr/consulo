{
  PsiBuilder.Marker marker=builder.mark();
  ParserUtils.getToken(builder,kTRY);
  PsiBuilder.Marker warn=builder.mark();
  ParserUtils.getToken(builder,mNLS);
  if (!OpenOrClosableBlock.parseOpenBlock(builder,parser)) {
    warn.rollbackTo();
    builder.error(GroovyBundle.message("lcurly.expected"));
    marker.drop();
    return true;
  }
  warn.drop();
  ParserUtils.getToken(builder,mNLS);
  if (!(builder.getTokenType() == kCATCH) && !(builder.getTokenType() == kFINALLY)) {
    builder.error(GroovyBundle.message("catch.or.finally.expected"));
    marker.done(TRY_BLOCK_STATEMENT);
    return true;
  }
  if (kCATCH.equals(builder.getTokenType())) {
    parseHandlers(builder,parser);
  }
  if (kFINALLY.equals(builder.getTokenType()) || ParserUtils.lookAhead(builder,mNLS,kFINALLY)) {
    ParserUtils.getToken(builder,mNLS);
    PsiBuilder.Marker finallyMarker=builder.mark();
    warn=builder.mark();
    ParserUtils.getToken(builder,kFINALLY);
    ParserUtils.getToken(builder,mNLS);
    if (mLCURLY.equals(builder.getTokenType()) && OpenOrClosableBlock.parseOpenBlock(builder,parser)) {
      warn.drop();
      finallyMarker.done(FINALLY_CLAUSE);
    }
 else {
      finallyMarker.drop();
      warn.rollbackTo();
      builder.error(GroovyBundle.message("expression.expected"));
    }
  }
  marker.done(TRY_BLOCK_STATEMENT);
  return true;
}
