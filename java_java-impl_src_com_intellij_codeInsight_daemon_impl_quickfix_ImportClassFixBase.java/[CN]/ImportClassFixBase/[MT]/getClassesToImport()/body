{
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(myRef.getProject());
  String name=getReferenceName(myRef);
  GlobalSearchScope scope=myRef.getResolveScope();
  if (name == null) {
    return Collections.emptyList();
  }
  boolean referenceHasTypeParameters=hasTypeParameters(myRef);
  PsiClass[] classes=cache.getClassesByName(name,scope);
  if (classes.length == 0)   return Collections.emptyList();
  ArrayList<PsiClass> classList=new ArrayList<PsiClass>(classes.length);
  boolean isAnnotationReference=myRef.getParent() instanceof PsiAnnotation;
  for (  PsiClass aClass : classes) {
    if (isAnnotationReference && !aClass.isAnnotationType())     continue;
    if (JavaCompletionUtil.isInExcludedPackage(aClass,false))     continue;
    if (referenceHasTypeParameters && !aClass.hasTypeParameters())     continue;
    String qName=aClass.getQualifiedName();
    if (qName != null) {
      if (qName.indexOf('.') == -1)       continue;
      if (qName.endsWith(name)) {
        if (isAccessible(aClass,myRef)) {
          classList.add(aClass);
        }
      }
    }
  }
  final String memberName=getRequiredMemberName(myRef);
  if (memberName != null) {
    List<PsiClass> filtered=ContainerUtil.findAll(classList,new Condition<PsiClass>(){
      @Override public boolean value(      PsiClass psiClass){
        PsiField field=psiClass.findFieldByName(memberName,true);
        if (field != null && field.hasModifierProperty(PsiModifier.STATIC) && isAccessible(field,myRef))         return true;
        PsiClass inner=psiClass.findInnerClassByName(memberName,true);
        if (inner != null && isAccessible(inner,myRef))         return true;
        for (        PsiMethod method : psiClass.findMethodsByName(memberName,true)) {
          if (method.hasModifierProperty(PsiModifier.STATIC) && isAccessible(method,myRef))           return true;
        }
        return false;
      }
    }
);
    if (!filtered.isEmpty()) {
      return filtered;
    }
  }
  return classList;
}
