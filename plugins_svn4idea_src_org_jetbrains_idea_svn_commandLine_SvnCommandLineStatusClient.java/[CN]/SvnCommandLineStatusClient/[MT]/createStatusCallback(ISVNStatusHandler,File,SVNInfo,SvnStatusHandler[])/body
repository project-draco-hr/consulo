{
  final Map<File,SVNInfo> externalsMap=new HashMap<File,SVNInfo>();
  final String[] changelistName=new String[1];
  return new SvnStatusHandler.ExternalDataCallback(){
    @Override public void switchPath(){
      final PortableStatus pending=svnHandl[0].getPending();
      pending.setChangelistName(changelistName[0]);
      try {
        SVNInfo baseInfo=infoBase;
        File baseFile=base;
        final File pendingFile=new File(pending.getPath());
        if (!externalsMap.isEmpty()) {
          for (          File file : externalsMap.keySet()) {
            if (FileUtil.isAncestor(file,pendingFile,false)) {
              baseInfo=externalsMap.get(file);
              baseFile=file;
              break;
            }
          }
        }
        if (baseInfo != null) {
          final String append;
          final String systemIndependentPath=FileUtil.toSystemIndependentName(pending.getPath());
          if (pendingFile.isAbsolute()) {
            final String relativePath=FileUtil.getRelativePath(FileUtil.toSystemIndependentName(baseFile.getPath()),systemIndependentPath,'/');
            append=SVNPathUtil.append(baseInfo.getURL().toString(),FileUtil.toSystemIndependentName(relativePath));
          }
 else {
            append=SVNPathUtil.append(baseInfo.getURL().toString(),systemIndependentPath);
          }
          pending.setURL(SVNURL.parseURIEncoded(append));
        }
        if (SVNStatusType.STATUS_EXTERNAL.equals(pending.getNodeStatus())) {
          externalsMap.put(pending.getFile(),pending.getInfo());
        }
        handler.handleStatus(pending);
      }
 catch (      SVNException e) {
        throw new SvnExceptionWrapper(e);
      }
    }
    @Override public void switchChangeList(    String newList){
      changelistName[0]=newList;
    }
  }
;
}
