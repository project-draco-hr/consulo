{
  final ExpectedTypeInfo[] expectedTypes=myExpectedTypesProvider.getExpectedTypes(myMainOccurence,false,myOccurrenceClassProvider);
  final ArrayList<PsiType> allowedTypes=new ArrayList<PsiType>();
  RefactoringHierarchyUtil.processSuperTypes(myDefaultType,new RefactoringHierarchyUtil.SuperTypeVisitor(){
    public void visitType(    PsiType aType){
      checkIfAllowed(aType);
    }
    public void visitClass(    PsiClass aClass){
      checkIfAllowed(myFactory.createType(aClass));
    }
    private void checkIfAllowed(    PsiType type){
      if (expectedTypes.length > 0) {
        final ExpectedTypeInfo typeInfo=myExpectedTypesProvider.createInfo(type,ExpectedTypeInfo.TYPE_STRICTLY,type,TailType.NONE);
        for (        ExpectedTypeInfo expectedType : expectedTypes) {
          if (expectedType.intersect(typeInfo).length != 0) {
            allowedTypes.add(type);
            break;
          }
        }
      }
 else {
        allowedTypes.add(type);
      }
    }
  }
);
  ArrayList<PsiType> result=normalizeTypeList(allowedTypes);
  return result.toArray(new PsiType[result.size()]);
}
