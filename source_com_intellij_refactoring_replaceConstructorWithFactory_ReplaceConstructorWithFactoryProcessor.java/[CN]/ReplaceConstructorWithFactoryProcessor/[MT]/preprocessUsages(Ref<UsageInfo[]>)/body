{
  UsageInfo[] usages=refUsages.get();
  ArrayList<String> conflicts=new ArrayList<String>();
  if (!myManager.getResolveHelper().isAccessible(getConstructorContainingClass(),myTargetClass,null)) {
    String message="Class " + ConflictsUtil.getDescription(getConstructorContainingClass(),true) + " is not accessible from target "+ ConflictsUtil.getDescription(myTargetClass,true)+ ".";
    conflicts.add(message);
  }
  HashSet<PsiElement> reportedContainers=new HashSet<PsiElement>();
  final String targetClassDescription=ConflictsUtil.getDescription(myTargetClass,true);
  for (  UsageInfo usage : usages) {
    final PsiElement container=ConflictsUtil.getContainer(usage.getElement());
    if (!reportedContainers.contains(container)) {
      reportedContainers.add(container);
      if (!myManager.getResolveHelper().isAccessible(myTargetClass,usage.getElement(),null)) {
        String message="Target " + targetClassDescription + " is not accessible from "+ ConflictsUtil.getDescription(container,true)+ ".";
        conflicts.add(message);
      }
    }
  }
  if (myIsInner) {
    for (    UsageInfo usage : usages) {
      final PsiField field=PsiTreeUtil.getParentOfType(usage.getElement(),PsiField.class);
      if (field != null) {
        final PsiClass containingClass=field.getContainingClass();
        if (PsiTreeUtil.isAncestor(containingClass,myTargetClass,true)) {
          String message="Constructor being refactored is used in initializer of " + ConflictsUtil.getDescription(field,true) + ". Non-static factory of inner class"+ ConflictsUtil.getDescription(getConstructorContainingClass(),false)+ " cannot be used in this context. Resulting code will not compile.";
          conflicts.add(message);
        }
      }
    }
  }
  if (myPrepareSuccessfulSwingThreadCallback != null && conflicts.size() > 0) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK())     return false;
  }
  prepareSuccessful();
  return true;
}
