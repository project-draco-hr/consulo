{
  UsageInfo[] usages=refUsages.get();
  ArrayList<String> conflicts=new ArrayList<String>();
  if (!myManager.getResolveHelper().isAccessible(getConstructorContainingClass(),myTargetClass,null)) {
    String message=RefactoringBundle.message("class.0.is.not.accessible.from.target.1",ConflictsUtil.getDescription(getConstructorContainingClass(),true),ConflictsUtil.getDescription(myTargetClass,true));
    conflicts.add(message);
  }
  HashSet<PsiElement> reportedContainers=new HashSet<PsiElement>();
  final String targetClassDescription=ConflictsUtil.getDescription(myTargetClass,true);
  for (  UsageInfo usage : usages) {
    final PsiElement container=ConflictsUtil.getContainer(usage.getElement());
    if (!reportedContainers.contains(container)) {
      reportedContainers.add(container);
      if (!myManager.getResolveHelper().isAccessible(myTargetClass,usage.getElement(),null)) {
        String message=RefactoringBundle.message("target.0.is.not.accessible.from.1",targetClassDescription,ConflictsUtil.getDescription(container,true));
        conflicts.add(message);
      }
    }
  }
  if (myIsInner) {
    for (    UsageInfo usage : usages) {
      final PsiField field=PsiTreeUtil.getParentOfType(usage.getElement(),PsiField.class);
      if (field != null) {
        final PsiClass containingClass=field.getContainingClass();
        if (PsiTreeUtil.isAncestor(containingClass,myTargetClass,true)) {
          String message=RefactoringBundle.message("constructor.being.refactored.is.used.in.initializer.of.0",ConflictsUtil.getDescription(field,true),ConflictsUtil.getDescription(getConstructorContainingClass(),false));
          conflicts.add(message);
        }
      }
    }
  }
  if (myPrepareSuccessfulSwingThreadCallback != null && conflicts.size() > 0) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK())     return false;
  }
  prepareSuccessful();
  return true;
}
