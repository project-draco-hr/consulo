{
switch (number) {
case PARSE_ASSIGNMENT:
    return parseAssignmentExpression(lexer);
case PARSE_CONDITIONAL:
  return parseConditionalExpression(lexer);
case PARSE_COND_OR:
return parseBinaryExpression(lexer,PARSE_COND_AND,COND_OR_SIGN_BIT_SET);
case PARSE_COND_AND:
return parseBinaryExpression(lexer,PARSE_OR,COND_AND_SIGN_BIT_SET);
case PARSE_OR:
return parseBinaryExpression(lexer,PARSE_XOR,OR_SIGN_BIT_SET);
case PARSE_XOR:
return parseBinaryExpression(lexer,PARSE_AND,XOR_SIGN_BIT_SET);
case PARSE_AND:
return parseBinaryExpression(lexer,PARSE_EQUALITY,AND_SIGN_BIT_SET);
case PARSE_EQUALITY:
return parseBinaryExpression(lexer,PARSE_RELATIONAL,EQUALITY_SIGN_BIT_SET);
case PARSE_RELATIONAL:
return parseRelationalExpression(lexer);
case PARSE_SHIFT:
return parseBinaryExpression(lexer,PARSE_ADDITIVE,SHIFT_SIGN_BIT_SET);
case PARSE_ADDITIVE:
return parseBinaryExpression(lexer,PARSE_MULTIPLICATIVE,ADDITIVE_SIGN_BIT_SET);
case PARSE_MULTIPLICATIVE:
return parseBinaryExpression(lexer,PARSE_UNARY,MULTIPLICATIVE_SIGN_BIT_SET);
case PARSE_UNARY:
return parseUnaryExpression(lexer);
case PARSE_POSTFIX:
return parsePostfixExpression(lexer);
case PARSE_PRIMARY:
return parsePrimaryExpression(lexer);
case PARSE_CLASS_OBJECT_ACCESS:
return parseClassObjectAccessExpression(lexer);
case PARSE_ARGUMENT_LIST:
return parseArgumentList(lexer);
case PARSE_ARRAY_INITIALIZER:
return parseArrayInitializerExpression(lexer);
case PARSE_TYPE:
return parseType(lexer);
default :
LOG.assertTrue(false);
return null;
}
}
