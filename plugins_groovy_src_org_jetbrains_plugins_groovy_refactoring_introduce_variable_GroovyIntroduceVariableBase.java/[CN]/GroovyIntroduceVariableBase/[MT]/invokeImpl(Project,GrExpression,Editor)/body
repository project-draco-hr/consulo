{
  if (selectedExpr == null || (selectedExpr instanceof GrClosableBlock && selectedExpr.getParent() instanceof GrStringInjection)) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("selected.block.should.represent.an.expression"));
    showErrorMessage(project,editor,message);
    return false;
  }
  if (selectedExpr instanceof GrReferenceExpression && selectedExpr.getParent() instanceof GrMethodCall && (((GrMethodCall)selectedExpr.getParent()).isCommandExpression() || selectedExpr.getParent() instanceof GrApplicationStatement) || selectedExpr instanceof GrApplicationStatement) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("selected.expression.in.command.expression"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiFile file=selectedExpr.getContainingFile();
  LOG.assertTrue(file != null,"expr.getContainingFile() == null");
  final GroovyPsiElementFactory factory=GroovyPsiElementFactory.getInstance(project);
  PsiType type=selectedExpr.getType();
  if (type != null)   type=TypeConversionUtil.erasure(type);
  if (PsiType.VOID.equals(type)) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("selected.expression.has.void.type"));
    showErrorMessage(project,editor,message);
    return false;
  }
  PsiElement parent=selectedExpr.getParent();
  while (parent != null && !(parent instanceof GroovyFileBase) && !(parent instanceof GrParameter)) {
    parent=parent.getParent();
  }
  if (checkInFieldInitializer(selectedExpr)) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("refactoring.is.not.supported.in.the.current.context"));
    showErrorMessage(project,editor,message);
    return false;
  }
  if (parent instanceof GrParameter) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("refactoring.is.not.supported.in.method.parameters"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiElement enclosingContainer=GroovyRefactoringUtil.getEnclosingContainer(selectedExpr);
  if (enclosingContainer == null || !(enclosingContainer instanceof GroovyPsiElement)) {
    return tempContainerNotFound(project);
  }
  final GroovyPsiElement tempContainer=((GroovyPsiElement)enclosingContainer);
  if (!GroovyRefactoringUtil.isAppropriateContainerForIntroduceVariable(tempContainer)) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("refactoring.is.not.supported.in.the.current.context",REFACTORING_NAME));
    showErrorMessage(project,editor,message);
    return false;
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,file))   return false;
  final PsiElement[] occurrences=GroovyRefactoringUtil.getExpressionOccurrences(PsiUtil.skipParentheses(selectedExpr,false),tempContainer);
  if (occurrences == null || occurrences.length == 0) {
    String message=RefactoringBundle.getCannotRefactorMessage(GroovyRefactoringBundle.message("no.occurences.found"));
    showErrorMessage(project,editor,message);
    return false;
  }
  Validator validator=new GroovyVariableValidator(this,project,selectedExpr,occurrences,tempContainer);
  GroovyIntroduceVariableDialog dialog=getDialog(project,editor,selectedExpr,type,occurrences,false,validator);
  if (!dialog.isOK()) {
    return false;
  }
  GroovyIntroduceVariableSettings settings=dialog.getSettings();
  final String varName=settings.getEnteredName();
  PsiType varType=settings.getSelectedType();
  final boolean isFinal=settings.isDeclareFinal();
  final boolean replaceAllOccurrences=settings.isReplaceAllOccurrences();
  final GrVariableDeclaration varDecl=factory.createVariableDeclaration(isFinal ? new String[]{PsiModifier.FINAL} : null,(GrExpression)PsiUtil.skipParentheses(selectedExpr,false),varType,varName);
  runRefactoring(selectedExpr,editor,tempContainer,occurrences,varName,varType,replaceAllOccurrences,varDecl);
  return true;
}
