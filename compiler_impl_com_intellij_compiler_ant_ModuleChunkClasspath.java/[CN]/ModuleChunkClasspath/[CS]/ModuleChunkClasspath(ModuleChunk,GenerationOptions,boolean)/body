{
  super(generateRuntimeClasspath ? BuildProperties.getRuntimeClasspathProperty(chunk.getName()) : BuildProperties.getClasspathProperty(chunk.getName()));
  final OrderedSet<ClasspathItem> pathItems=new OrderedSet<ClasspathItem>((TObjectHashingStrategy<ClasspathItem>)TObjectHashingStrategy.CANONICAL);
  final String moduleChunkBasedirProperty=BuildProperties.getModuleChunkBasedirProperty(chunk);
  final Module[] modules=chunk.getModules();
  final Set<ModuleChunk> processedChunks=new HashSet<ModuleChunk>();
  final Set<Module> processedModules=new HashSet<Module>();
  for (  final Module module : modules) {
    new Object(){
      /** 
 * Process the module. The logic is different for compile-time case and runtime case.
 * In the case of runtime, only directly referenced objects are included in classpath.
 * Indirectly referenced are
 * @param module a module to process.
 * @param dependencyLevel is increased with every of recursion.
 * @param isModuleExported if true the module is exported from the previous level
 */
      public void processModule(      final Module module,      final int dependencyLevel,      final boolean isModuleExported){
        if (processedModules.contains(module)) {
          return;
        }
        if (dependencyLevel > 1 && !isModuleExported && !(genOptions.inlineRuntimeClasspath && generateRuntimeClasspath)) {
          return;
        }
        processedModules.add(module);
        final ProjectEx project=(ProjectEx)chunk.getProject();
        final File baseDir=BuildProperties.getProjectBaseDir(project);
        for (        final OrderEntry orderEntry : ModuleRootManager.getInstance(module).getOrderEntries()) {
          if (!orderEntry.isValid()) {
            continue;
          }
          if (!generateRuntimeClasspath) {
            if ((orderEntry instanceof ModuleSourceOrderEntry)) {
              if (dependencyLevel == 0 || chunk.contains(module)) {
                continue;
              }
            }
 else {
              final boolean isExported=(orderEntry instanceof ExportableOrderEntry) && ((ExportableOrderEntry)orderEntry).isExported();
              if (dependencyLevel > 0 && !isExported) {
                if (!(orderEntry instanceof ModuleOrderEntry)) {
                  continue;
                }
              }
            }
          }
          if (orderEntry instanceof JdkOrderEntry) {
            if (genOptions.forceTargetJdk && !generateRuntimeClasspath) {
              pathItems.add(new PathRefItem(BuildProperties.propertyRef(BuildProperties.getModuleChunkJdkClasspathProperty(chunk.getName()))));
            }
          }
 else           if (orderEntry instanceof ModuleOrderEntry) {
            final ModuleOrderEntry moduleOrderEntry=(ModuleOrderEntry)orderEntry;
            final Module dependentModule=moduleOrderEntry.getModule();
            if (!chunk.contains(dependentModule)) {
              if (generateRuntimeClasspath && !genOptions.inlineRuntimeClasspath) {
                final ModuleChunk depChunk=genOptions.getChunkByModule(dependentModule);
                if (!processedChunks.contains(depChunk)) {
                  processedChunks.add(depChunk);
                  pathItems.add(new PathRefItem(BuildProperties.getRuntimeClasspathProperty(depChunk.getName())));
                }
              }
 else {
                processModule(dependentModule,dependencyLevel + 1,moduleOrderEntry.isExported());
              }
            }
          }
 else           if (orderEntry instanceof LibraryOrderEntry) {
            final LibraryOrderEntry libraryOrderEntry=(LibraryOrderEntry)orderEntry;
            final String libraryName=libraryOrderEntry.getLibraryName();
            if (((LibraryOrderEntry)orderEntry).isModuleLevel()) {
              CompositeGenerator gen=new CompositeGenerator();
              gen.setHasLeadingNewline(false);
              LibraryDefinitionsGeneratorFactory.genLibraryContent(project,genOptions,libraryOrderEntry.getLibrary(),baseDir,gen);
              pathItems.add(new GeneratorItem(libraryName,gen));
            }
 else {
              pathItems.add(new PathRefItem(BuildProperties.getLibraryPathId(libraryName)));
            }
          }
 else {
            for (            String url : getCompilationClasses(orderEntry,((GenerationOptionsImpl)genOptions),generateRuntimeClasspath)) {
              if (url.endsWith(JarFileSystem.JAR_SEPARATOR)) {
                url=url.substring(0,url.length() - JarFileSystem.JAR_SEPARATOR.length());
              }
              final String propertyRef=genOptions.getPropertyRefForUrl(url);
              if (propertyRef != null) {
                pathItems.add(new PathElementItem(propertyRef));
              }
 else {
                final String path=VirtualFileManager.extractPath(url);
                pathItems.add(new PathElementItem(GenerationUtils.toRelativePath(path,chunk.getBaseDir(),moduleChunkBasedirProperty,genOptions,!chunk.isSavePathsRelative())));
              }
            }
          }
        }
      }
    }
.processModule(module,0,false);
  }
  for (  final ClasspathItem pathItem : pathItems) {
    add(pathItem.toGenerator());
  }
}
