{
  final int existingIndex=searchForCacheEntry(key);
  if (existingIndex != 0) {
    final CacheEntry<K,V> cacheEntry=myCache[existingIndex];
    final V deletedVal=cacheEntry.value;
    cacheEntry.value=x;
    if (existingIndex != myTop) {
      add2Top(existingIndex);
    }
    fireListenersAboutDeletion(key,deletedVal);
    return;
  }
  K deletedKey=null;
  V deletedValue=null;
  int index=myFirstFree;
  if (myCount < myCache.length - 1) {
    if (index == 0) {
      index=myCount;
      ++index;
    }
 else {
      myFirstFree=myCache[index].hash_next;
    }
    if (myCount == 0) {
      myBack=index;
    }
  }
 else {
    index=myBack;
    removeEntryFromHashTable(index);
    final CacheEntry<K,V> cacheEntry=myCache[index];
    deletedKey=cacheEntry.key;
    deletedValue=cacheEntry.value;
    myCache[myBack=myCache[index].prev].next=0;
  }
  myCache[index].key=key;
  myCache[index].value=x;
  addEntry2HashTable(index);
  add2Top(index);
  if (deletedKey != null) {
    fireListenersAboutDeletion(deletedKey,deletedValue);
  }
}
