{
  final IElementType type=builder.getTokenType();
  final PsiBuilder.Marker marker=builder.mark();
  if (RegExpTT.GROUPS.contains(type)) {
    builder.advanceLexer();
    if (!parsePattern(builder)) {
      patternExpected(builder);
    }
 else {
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
    }
    marker.done(RegExpElementTypes.GROUP);
  }
 else   if (type == RegExpTT.SET_OPTIONS) {
    builder.advanceLexer();
    final PsiBuilder.Marker o=builder.mark();
    if (builder.getTokenType() == RegExpTT.OPTIONS_ON) {
      builder.advanceLexer();
    }
    if (builder.getTokenType() == RegExpTT.OPTIONS_OFF) {
      builder.advanceLexer();
    }
    o.done(RegExpElementTypes.OPTIONS);
    if (builder.getTokenType() == RegExpTT.COLON) {
      builder.advanceLexer();
      if (!parsePattern(builder)) {
        patternExpected(builder);
      }
 else {
        checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
      }
      marker.done(RegExpElementTypes.GROUP);
    }
 else {
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed options group");
      marker.done(RegExpElementTypes.SET_OPTIONS);
    }
  }
 else   if (type == StringEscapesTokenTypes.INVALID_CHARACTER_ESCAPE_TOKEN) {
    builder.error("Illegal/unsupported escape sequence");
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else   if (RegExpTT.CHARACTERS.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else   if (RegExpTT.BOUNDARIES.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.BOUNDARY);
  }
 else   if (type == RegExpTT.BACKREF) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.BACKREF);
  }
 else   if (type == RegExpTT.PYTHON_NAMED_GROUP || type == RegExpTT.RUBY_NAMED_GROUP || type == RegExpTT.RUBY_QUOTED_NAMED_GROUP) {
    builder.advanceLexer();
    checkMatches(builder,RegExpTT.NAME,"Group name expected");
    checkMatches(builder,type == RegExpTT.RUBY_QUOTED_NAMED_GROUP ? RegExpTT.QUOTE : RegExpTT.GT,"Unclosed group name");
    if (!parsePattern(builder)) {
      patternExpected(builder);
    }
 else {
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
    }
    marker.done(RegExpElementTypes.GROUP);
  }
 else   if (type == RegExpTT.PYTHON_NAMED_GROUP_REF) {
    builder.advanceLexer();
    checkMatches(builder,RegExpTT.NAME,"Group name expected");
    checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group reference");
    marker.done(RegExpElementTypes.PY_NAMED_GROUP_REF);
  }
 else   if (type == RegExpTT.PYTHON_COND_REF) {
    builder.advanceLexer();
    if (builder.getTokenType() == RegExpTT.NAME || builder.getTokenType() == RegExpTT.NUMBER) {
      builder.advanceLexer();
    }
 else {
      builder.error("Group name or number expected");
    }
    checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group reference");
    if (!parseBranch(builder)) {
      patternExpected(builder);
    }
 else {
      if (builder.getTokenType() == RegExpTT.UNION) {
        builder.advanceLexer();
        if (!parseBranch(builder)) {
          patternExpected(builder);
        }
      }
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
    }
    marker.done(RegExpElementTypes.PY_COND_REF);
  }
 else   if (type == RegExpTT.PROPERTY) {
    parseProperty(builder);
    marker.done(RegExpElementTypes.PROPERTY);
  }
 else   if (RegExpTT.SIMPLE_CLASSES.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.SIMPLE_CLASS);
  }
 else   if (type == RegExpTT.CLASS_BEGIN) {
    marker.drop();
    return parseClass(builder);
  }
 else   if (type == RegExpTT.LBRACE && myCapabilities.contains(RegExpCapability.DANGLING_METACHARACTERS)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else {
    marker.drop();
    return null;
  }
  return marker;
}
