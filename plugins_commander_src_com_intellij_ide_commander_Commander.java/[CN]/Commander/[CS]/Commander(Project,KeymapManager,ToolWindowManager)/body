{
  super(new BorderLayout());
  myProject=project;
  myToolWindowManager=toolWindowManager;
  final AbstractAction backAction=new AbstractAction(){
    @Override public void actionPerformed(    final ActionEvent e){
      myHistory.back();
    }
  }
;
  final AbstractAction fwdAction=new AbstractAction(){
    @Override public void actionPerformed(    final ActionEvent e){
      myHistory.forward();
    }
  }
;
  final ActionMap actionMap=getActionMap();
  actionMap.put(ACTION_BACKCOMMAND,backAction);
  actionMap.put(ACTION_FORWARDCOMMAND,fwdAction);
  final KeyStroke[] backStrokes=getKeyStrokes(IdeActions.ACTION_GOTO_BACK,keymapManager);
  for (  KeyStroke stroke : backStrokes) {
    registerKeyboardAction(backAction,ACTION_BACKCOMMAND,stroke,JComponent.WHEN_IN_FOCUSED_WINDOW);
    registerKeyboardAction(backAction,ACTION_BACKCOMMAND,stroke,JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }
  final KeyStroke[] fwdStrokes=getKeyStrokes(IdeActions.ACTION_GOTO_FORWARD,keymapManager);
  for (  KeyStroke stroke : fwdStrokes) {
    registerKeyboardAction(fwdAction,ACTION_FORWARDCOMMAND,stroke,JComponent.WHEN_IN_FOCUSED_WINDOW);
    registerKeyboardAction(fwdAction,ACTION_FORWARDCOMMAND,stroke,JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
  }
  myHistory=new CommanderHistory(this);
  mySelectionListener=new ListSelectionListener(){
    @Override public void valueChanged(    final ListSelectionEvent e){
      updateToolWindowTitle();
    }
  }
;
  myListDataListener=new ListDataListener(){
    @Override public void intervalAdded(    final ListDataEvent e){
      updateToolWindowTitle();
    }
    @Override public void intervalRemoved(    final ListDataEvent e){
      updateToolWindowTitle();
    }
    @Override public void contentsChanged(    final ListDataEvent e){
      updateToolWindowTitle();
    }
  }
;
  myFocusWatcher=new FocusWatcher();
  myLeftPanel=createPanel();
  myLeftPanel.addHistoryListener(new CommanderHistoryListener(){
    @Override public void historyChanged(    final PsiElement selectedElement,    final boolean elementExpanded){
      getCommandHistory().saveState(selectedElement,elementExpanded,true);
    }
  }
);
  myRightPanel=createPanel();
  myRightPanel.addHistoryListener(new CommanderHistoryListener(){
    @Override public void historyChanged(    final PsiElement selectedElement,    final boolean elementExpanded){
      getCommandHistory().saveState(selectedElement,elementExpanded,false);
    }
  }
);
  mySplitter=new Splitter();
  mySplitter.setFirstComponent(myLeftPanel);
  mySplitter.setSecondComponent(myRightPanel);
  add(mySplitter,BorderLayout.CENTER);
  final AutoScrollToSourceHandler handler=new AutoScrollToSourceHandler(){
    @Override protected boolean isAutoScrollMode(){
      return myAutoScrollMode;
    }
    @Override protected void setAutoScrollMode(    boolean state){
      myAutoScrollMode=state;
    }
  }
;
  handler.install(myLeftPanel.getList());
  handler.install(myRightPanel.getList());
  final boolean shouldAddToolbar=!ApplicationManager.getApplication().isUnitTestMode();
  if (shouldAddToolbar) {
    final DefaultActionGroup toolbarActions=createToolbarActions();
    toolbarActions.add(handler.createToggleAction());
    final ActionToolbar toolbar=ActionManager.getInstance().createActionToolbar(ActionPlaces.COMMANDER_TOOLBAR,toolbarActions,true);
    add(toolbar.getComponent(),BorderLayout.NORTH);
  }
  myFocusWatcher.install(this);
}
