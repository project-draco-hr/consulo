{
  boolean suspendable=false;
switch (handler.myCommand.lockingPolicy()) {
case META:
    break;
case READ:
  handler.myVcs.getCommandLock().readLock().lock();
break;
case WRITE_SUSPENDABLE:
suspendable=true;
case WRITE:
handler.myVcs.getCommandLock().writeLock().lock();
break;
}
try {
if (suspendable) {
final Object EXIT=new Object();
final Object SUSPEND=new Object();
final Object RESUME=new Object();
final LinkedBlockingQueue<Object> queue=new LinkedBlockingQueue<Object>();
Runnable suspend=new Runnable(){
public void run(){
queue.add(SUSPEND);
}
}
;
Runnable resume=new Runnable(){
public void run(){
queue.add(RESUME);
}
}
;
handler.setSuspendResume(suspend,resume);
handler.start();
if (handler.isStarted()) {
if (postStartAction != null) {
postStartAction.run();
}
ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
public void run(){
handler.waitFor();
queue.add(EXIT);
}
}
);
boolean suspended=false;
while (true) {
Object action;
while (true) {
try {
  action=queue.take();
  break;
}
 catch (InterruptedException e) {
  if (LOG.isDebugEnabled()) {
    LOG.debug("queue.take() is interrupted",e);
  }
}
}
if (action == EXIT) {
if (suspended) {
  LOG.error("Exiting while RW lock is suspended (reacquiring W-lock command)");
  handler.myVcs.getCommandLock().writeLock().lock();
}
break;
}
 else if (action == SUSPEND) {
if (suspended) {
  LOG.error("Suspending suspended W-lock (ignoring command)");
}
 else {
  handler.myVcs.getCommandLock().writeLock().unlock();
  suspended=true;
}
}
 else if (action == RESUME) {
if (!suspended) {
  LOG.error("Resuming not suspended W-lock (ignoring command)");
}
 else {
  handler.myVcs.getCommandLock().writeLock().lock();
  suspended=false;
}
}
}
}
}
 else {
handler.start();
if (handler.isStarted()) {
if (postStartAction != null) {
postStartAction.run();
}
handler.waitFor();
}
}
}
  finally {
switch (handler.myCommand.lockingPolicy()) {
case META:
break;
case READ:
handler.myVcs.getCommandLock().readLock().unlock();
break;
case WRITE_SUSPENDABLE:
case WRITE:
handler.myVcs.getCommandLock().writeLock().unlock();
break;
}
}
}
