{
  final Result result=new Result(component);
  result.constraints.gridx=constraints.getColumn();
  result.constraints.gridy=constraints.getRow();
  result.constraints.gridwidth=constraints.getColSpan();
  result.constraints.gridheight=constraints.getRowSpan();
  result.constraints.weightx=getWeight(constraints,true);
  result.constraints.weighty=getWeight(constraints,false);
  result.constraints.insets=myInsets;
switch (constraints.getFill()) {
case GridConstraints.FILL_HORIZONTAL:
    result.constraints.fill=GridBagConstraints.HORIZONTAL;
  break;
case GridConstraints.FILL_VERTICAL:
result.constraints.fill=GridBagConstraints.VERTICAL;
break;
case GridConstraints.FILL_BOTH:
result.constraints.fill=GridBagConstraints.BOTH;
break;
}
Dimension minSize=constraints.myMinimumSize;
if (component != null && minSize.width <= 0 && minSize.height <= 0) {
minSize=component.getMinimumSize();
}
if ((constraints.getHSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {
minSize.width=constraints.myPreferredSize.width > 0 || component == null ? constraints.myPreferredSize.width : component.getPreferredSize().width;
}
if ((constraints.getVSizePolicy() & GridConstraints.SIZEPOLICY_CAN_SHRINK) == 0) {
minSize.height=constraints.myPreferredSize.height > 0 || component == null ? constraints.myPreferredSize.height : component.getPreferredSize().height;
}
if (minSize.width != -1 || minSize.height != -1) {
result.minimumSize=minSize;
}
if (constraints.myPreferredSize.width > 0 && constraints.myPreferredSize.height > 0) {
result.preferredSize=constraints.myPreferredSize;
}
if (constraints.myMaximumSize.width > 0 && constraints.myMaximumSize.height > 0) {
result.maximumSize=constraints.myMaximumSize;
}
return result;
}
