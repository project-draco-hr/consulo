def _dispatch(ui, args):
    _parseconfig(ui, _earlygetopt(['--config'], args))
    cwd = _earlygetopt(['--cwd'], args)
    if cwd:
        os.chdir(cwd[(-1)])
    path = (cmdutil.findrepo(os.getcwd()) or '')
    if (not path):
        lui = ui
    else:
        try:
            lui = ui.copy()
            lui.readconfig(os.path.join(path, '.hg', 'hgrc'))
        except IOError:
            pass
    rpath = _earlygetopt(['-R', '--repository', '--repo'], args)
    if rpath:
        path = lui.expandpath(rpath[(-1)])
        lui = ui.copy()
        lui.readconfig(os.path.join(path, '.hg', 'hgrc'))
    extensions.loadall(lui)
    exts = [ext for ext in extensions.extensions() if (ext[0] not in _loaded)]
    for (name, module) in exts:
        cmdtable = getattr(module, 'cmdtable', {})
        overrides = [cmd for cmd in cmdtable if (cmd in commands.table)]
        if overrides:
            ui.warn((_("extension '%s' overrides commands: %s\n") % (name, ' '.join(overrides))))
        commands.table.update(cmdtable)
        _loaded.add(name)
    addaliases(lui, commands.table)
    fallback = lui.config('ui', 'fallbackencoding')
    if fallback:
        encoding.fallbackencoding = fallback
    fullargs = args
    (cmd, func, args, options, cmdoptions) = _parse(lui, args)
    if options['config']:
        raise util.Abort(_('Option --config may not be abbreviated!'))
    if options['cwd']:
        raise util.Abort(_('Option --cwd may not be abbreviated!'))
    if options['repository']:
        raise util.Abort(_('Option -R has to be separated from other options (e.g. not -qR) and --repository may only be abbreviated as --repo!'))
    if options['encoding']:
        encoding.encoding = options['encoding']
    if options['encodingmode']:
        encoding.encodingmode = options['encodingmode']
    if options['time']:

        def get_times():
            t = os.times()
            if (t[4] == 0.0):
                t = (t[0], t[1], t[2], t[3], time.clock())
            return t
        s = get_times()

        def print_time():
            t = get_times()
            ui.warn((_('Time: real %.3f secs (user %.3f+%.3f sys %.3f+%.3f)\n') % ((t[4] - s[4]), (t[0] - s[0]), (t[2] - s[2]), (t[1] - s[1]), (t[3] - s[3]))))
        atexit.register(print_time)
    if (options['verbose'] or options['debug'] or options['quiet']):
        ui.setconfig('ui', 'verbose', str(bool(options['verbose'])))
        ui.setconfig('ui', 'debug', str(bool(options['debug'])))
        ui.setconfig('ui', 'quiet', str(bool(options['quiet'])))
    if options['traceback']:
        ui.setconfig('ui', 'traceback', 'on')
    if options['noninteractive']:
        ui.setconfig('ui', 'interactive', 'off')
    if options['help']:
        return commands.help_(ui, cmd, options['version'])
    elif options['version']:
        return commands.version_(ui)
    elif (not cmd):
        return commands.help_(ui, 'shortlist')
    repo = None
    if (cmd not in commands.norepo.split()):
        try:
            repo = hg.repository(ui, path=path)
            ui = repo.ui
            if (not repo.local()):
                raise util.Abort((_("repository '%s' is not local") % path))
            ui.setconfig('bundle', 'mainreporoot', repo.root)
        except error.RepoError:
            if (cmd not in commands.optionalrepo.split()):
                if (args and (not path)):
                    repos = map(cmdutil.findrepo, args)
                    guess = repos[0]
                    if (guess and (repos.count(guess) == len(repos))):
                        return _dispatch(ui, (['--repository', guess] + fullargs))
                if (not path):
                    raise error.RepoError(_('There is no Mercurial repository here (.hg not found)'))
                raise
        args.insert(0, repo)
    elif rpath:
        ui.warn('warning: --repository ignored\n')
    d = (lambda : util.checksignature(func)(ui, *args, **cmdoptions))
    return runcommand(lui, repo, cmd, fullargs, ui, options, d)
