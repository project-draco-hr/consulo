{
  final TextRange textRange=list.getTextRange();
  offset=textRange.contains(offset) ? offset : textRange.getStartOffset() + 1;
  if (previousOffset == offset)   return new Pair<Point,Short>(previousBestPoint,previousBestPosition);
  String listText=list.getText();
  final boolean isMultiline=listText.indexOf('\n') >= 0 || listText.indexOf('\r') >= 0;
  final LogicalPosition pos=myEditor.offsetToLogicalPosition(offset);
  Pair<Point,Short> position;
  if (!isMultiline) {
    position=chooseBestHintPosition(myEditor.getProject(),myEditor,pos.line,pos.column,hint,awtTooltip,preferredPosition);
  }
 else {
    Point p=HintManagerImpl.getHintPosition(hint,myEditor,pos,HintManagerImpl.ABOVE);
    Dimension hintSize=hint.getComponent().getPreferredSize();
    JComponent editorComponent=myEditor.getComponent();
    JLayeredPane layeredPane=editorComponent.getRootPane().getLayeredPane();
    p.x=Math.min(p.x,layeredPane.getWidth() - hintSize.width);
    p.x=Math.max(p.x,0);
    position=new Pair<Point,Short>(p,HintManagerImpl.ABOVE);
  }
  previousBestPoint=position.getFirst();
  previousBestPosition=position.getSecond();
  previousOffset=offset;
  return position;
}
