{
  if (!ApplicationManager.getApplication().isUnitTestMode()) {
    ApplicationManager.getApplication().assertIsDispatchThread();
  }
  checkValid();
  final Pair<List<LookupElement>,Iterable<List<LookupElement>>> snapshot=myModel.getModelSnapshot();
  final List<LookupElement> items=matchingItems(snapshot);
  List<LookupElement> oldItems=getItems();
  if (oldItems.size() == items.size() && new THashSet<LookupElement>(items,TObjectHashingStrategy.IDENTITY).containsAll(oldItems)) {
    return;
  }
  checkMinPrefixLengthChanges(items);
  boolean hasPreselected=!mySelectionTouched && items.contains(myPreselectedItem);
  LookupElement oldSelected=mySelectionTouched ? (LookupElement)myList.getSelectedValue() : null;
  String oldInvariant=mySelectionInvariant;
  LinkedHashSet<LookupElement> model=new LinkedHashSet<LookupElement>();
  model.addAll(getPrefixItems(items));
  model.addAll(myFrozenItems);
  addMostRelevantItems(model,snapshot.second);
  if (hasPreselected) {
    model.add(myPreselectedItem);
  }
  myPreferredItemsCount=model.size();
  myFrozenItems.clear();
  myFrozenItems.addAll(model);
  model.addAll(addRemainingItemsLexicographically(model,items));
  DefaultListModel listModel=(DefaultListModel)myList.getModel();
synchronized (myList) {
    listModel.clear();
    if (!model.isEmpty()) {
      for (      LookupElement element : model) {
        listModel.addElement(element);
      }
    }
 else {
      addEmptyItem(listModel);
    }
  }
  updateListHeight(listModel);
  if (!model.isEmpty()) {
    myList.setFixedCellWidth(Math.max(myLookupTextWidth + myCellRenderer.getIconIndent(),myAdComponent.getAdComponent().getPreferredSize().width));
    if (isFocused() && (!isExactPrefixItem(model.iterator().next()) || mySelectionTouched)) {
      restoreSelection(oldSelected,hasPreselected,oldInvariant);
    }
 else {
      myList.setSelectedIndex(0);
    }
  }
}
