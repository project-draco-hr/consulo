{
  if (!ApplicationManager.getApplication().isUnitTestMode()) {
    ApplicationManager.getApplication().assertIsDispatchThread();
  }
  checkValid();
  final Trinity<List<LookupElement>,Iterable<List<LookupElement>>,Boolean> snapshot=myPresentableModel.getModelSnapshot();
  final LinkedHashSet<LookupElement> items=matchingItems(snapshot.first);
  checkMinPrefixLengthChanges(items);
  boolean hasPreselected=!mySelectionTouched && items.contains(myPresentableModel.preselectedItem);
  LookupElement oldSelected=mySelectionTouched ? (LookupElement)myList.getSelectedValue() : null;
  String oldInvariant=mySelectionInvariant;
  LinkedHashSet<LookupElement> model=new LinkedHashSet<LookupElement>();
  model.addAll(getPrefixItems(items,true));
  model.addAll(getPrefixItems(items,false));
  myFrozenItems.retainAll(items);
  model.addAll(myFrozenItems);
  if (!isAlphaSorted()) {
    addMostRelevantItems(model,snapshot.second);
    if (hasPreselected) {
      model.add(myPresentableModel.preselectedItem);
    }
  }
  myFrozenItems.clear();
  if (myShown) {
    myFrozenItems.addAll(model);
  }
  if (isAlphaSorted()) {
    final ArrayList<LookupElement> elements=new ArrayList<LookupElement>(items);
    Collections.sort(elements,new Comparator<LookupElement>(){
      @Override public int compare(      LookupElement o1,      LookupElement o2){
        return o1.getLookupString().compareToIgnoreCase(o2.getLookupString());
      }
    }
);
    model.addAll(elements);
  }
 else {
    for (    List<LookupElement> group : snapshot.second) {
      for (      LookupElement element : group) {
        if (prefixMatches(element)) {
          model.add(element);
        }
      }
    }
  }
  DefaultListModel listModel=(DefaultListModel)myList.getModel();
synchronized (myList) {
    listModel.clear();
    if (!model.isEmpty()) {
      for (      LookupElement element : model) {
        listModel.addElement(element);
      }
    }
 else {
      addEmptyItem(listModel);
    }
  }
  updateListHeight(listModel);
  if (!model.isEmpty()) {
    LookupElement first=model.iterator().next();
    if (isFocused() && (!isExactPrefixItem(first,true) || mySelectionTouched || shouldSkip(first))) {
      restoreSelection(oldSelected,hasPreselected,oldInvariant,snapshot.second);
    }
 else {
      myList.setSelectedIndex(0);
    }
  }
  return snapshot.third;
}
