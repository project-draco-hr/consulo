{
  final List<LookupElement> items=getSortedItems();
  SortedMap<Comparable,List<LookupElement>> itemsMap=new TreeMap<Comparable,List<LookupElement>>();
  int minPrefixLength=items.isEmpty() ? 0 : Integer.MAX_VALUE;
  for (  final LookupElement item : items) {
    minPrefixLength=Math.min(item.getPrefixMatcher().getPrefix().length(),minPrefixLength);
    final Comparable relevance=myArranger.getRelevance(item);
    List<LookupElement> list=itemsMap.get(relevance);
    if (list == null) {
      itemsMap.put(relevance,list=new ArrayList<LookupElement>());
    }
    list.add(item);
  }
  if (myMinPrefixLength != minPrefixLength) {
    myLookupStartMarker=null;
    myOldLookupStartOffset=-1;
  }
  myMinPrefixLength=minPrefixLength;
  Object oldSelected=!myDirty ? null : myList.getSelectedValue();
  boolean hasExactPrefixes;
  final boolean hasPreselectedItem;
synchronized (myList) {
    DefaultListModel model=(DefaultListModel)myList.getModel();
    model.clear();
    Set<LookupElement> firstItems=new THashSet<LookupElement>();
    hasExactPrefixes=addExactPrefixItems(model,firstItems,items);
    addMostRelevantItems(model,firstItems,itemsMap.values());
    hasPreselectedItem=addPreselectedItem(model,firstItems);
    myPreferredItemsCount=firstItems.size();
    addRemainingItemsLexicographically(model,firstItems,items);
  }
  updateListBounds();
  myAdComponent.setText(myAdText);
  if (myList.getModel().getSize() > 0) {
    if (oldSelected != null) {
      if (hasExactPrefixes || !ListScrollingUtil.selectItem(myList,oldSelected)) {
        selectMostPreferableItem();
      }
    }
 else {
      if (myPreselectedItem == EMPTY_LOOKUP_ITEM) {
        selectMostPreferableItem();
        myPreselectedItem=getCurrentItem();
      }
 else       if (hasPreselectedItem && !hasExactPrefixes) {
        ListScrollingUtil.selectItem(myList,myPreselectedItem);
      }
 else {
        selectMostPreferableItem();
      }
    }
  }
}
