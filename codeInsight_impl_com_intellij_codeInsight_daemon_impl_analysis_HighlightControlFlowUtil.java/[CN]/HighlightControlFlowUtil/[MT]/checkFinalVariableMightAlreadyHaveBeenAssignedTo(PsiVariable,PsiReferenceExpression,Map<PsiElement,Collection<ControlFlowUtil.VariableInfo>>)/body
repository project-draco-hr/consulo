{
  if (!PsiUtil.isAccessedForWriting(expression))   return null;
  final PsiElement scope=variable instanceof PsiField ? variable.getParent() : variable.getParent() == null ? null : variable.getParent().getParent();
  PsiElement codeBlock=PsiUtil.getTopLevelEnclosingCodeBlock(expression,scope);
  if (codeBlock == null)   return null;
  Collection<ControlFlowUtil.VariableInfo> codeBlockProblems=getFinalVariableProblemsInBlock(finalVarProblems,codeBlock);
  boolean alreadyAssigned=false;
  for (  ControlFlowUtil.VariableInfo variableInfo : codeBlockProblems) {
    if (variableInfo.expression == expression) {
      alreadyAssigned=true;
      break;
    }
  }
  if (!alreadyAssigned) {
    if (!(variable instanceof PsiField))     return null;
    final PsiField field=(PsiField)variable;
    final PsiClass aClass=field.getContainingClass();
    if (aClass == null)     return null;
    final PsiField[] fields=aClass.getFields();
    boolean isFieldStatic=field.hasModifierProperty(PsiModifier.STATIC);
    for (    PsiField psiField : fields) {
      PsiExpression initializer=psiField.getInitializer();
      if (psiField != field && psiField.hasModifierProperty(PsiModifier.STATIC) == isFieldStatic && initializer != null && initializer != codeBlock && !variableDefinitelyNotAssignedIn(field,initializer)) {
        alreadyAssigned=true;
        break;
      }
    }
    if (!alreadyAssigned) {
      final PsiMember enclosingConstructorOrInitializer=PsiUtil.findEnclosingConstructorOrInitializer(expression);
      if (enclosingConstructorOrInitializer == null || !aClass.getManager().areElementsEquivalent(enclosingConstructorOrInitializer.getContainingClass(),aClass)) {
        return null;
      }
      final PsiClassInitializer[] initializers=aClass.getInitializers();
      for (      PsiClassInitializer initializer : initializers) {
        if (initializer.hasModifierProperty(PsiModifier.STATIC) == field.hasModifierProperty(PsiModifier.STATIC)) {
          final PsiCodeBlock body=initializer.getBody();
          if (body == codeBlock)           return null;
          try {
            final ControlFlow controlFlow=ControlFlowFactory.getInstance(body.getProject()).getControlFlow(body,LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());
            if (!ControlFlowUtil.isVariableDefinitelyNotAssigned(field,controlFlow)) {
              alreadyAssigned=true;
              break;
            }
          }
 catch (          AnalysisCanceledException e) {
            return null;
          }
        }
      }
    }
    if (!alreadyAssigned && !field.hasModifierProperty(PsiModifier.STATIC)) {
      final PsiMethod ctr=codeBlock.getParent() instanceof PsiMethod ? (PsiMethod)codeBlock.getParent() : null;
      final List<PsiMethod> redirectedConstructors=ctr != null && ctr.isConstructor() ? getChainedConstructors(ctr) : null;
      for (int j=0; redirectedConstructors != null && j < redirectedConstructors.size(); j++) {
        PsiMethod redirectedConstructor=redirectedConstructors.get(j);
        if (redirectedConstructor.getBody() != null && variableDefinitelyAssignedIn(variable,redirectedConstructor.getBody())) {
          alreadyAssigned=true;
          break;
        }
      }
    }
  }
  if (alreadyAssigned) {
    String description=JavaErrorMessages.message("variable.already.assigned",variable.getName());
    final HighlightInfo highlightInfo=HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,description);
    IntentionAction fix=QUICK_FIX_FACTORY.createModifierListFix(variable.getModifierList(),PsiModifier.FINAL,false,false);
    QuickFixAction.registerQuickFixAction(highlightInfo,fix);
    QuickFixAction.registerQuickFixAction(highlightInfo,new DeferFinalAssignmentFix(variable,expression));
    return highlightInfo;
  }
  return null;
}
