{
  markRows(from,rootVisible);
  if (from == to) {
    ArrangementTreeNode parent=from.getParent();
    int index=parent.getIndex(from);
    treeModel.removeNodeFromParent(from);
    insert(parent,index,replacement,treeModel);
    return collectRowChangesAndUnmark(parent,rootVisible);
  }
  final ArrangementTreeNode root=from.getParent();
  ArrangementTreeNode cutHierarchy=null;
  for (ArrangementTreeNode current=to; current != root; current=current.getParent()) {
    ArrangementTreeNode parent=current.getParent();
    int i=parent.getIndex(current);
    int childCount=parent.getChildCount();
    if (i >= childCount - 1) {
      continue;
    }
    ArrangementTreeNode parentCopy=parent.copy();
    if (parent.getChildCount() > 0) {
      parentCopy.resetRow();
    }
    if (cutHierarchy != null) {
      parentCopy.add(cutHierarchy);
    }
    for (int j=i + 1; j < childCount; j++) {
      ArrangementTreeNode child=parent.getChildAt(j);
      treeModel.removeNodeFromParent(child);
      parentCopy.add(child);
    }
    cutHierarchy=parentCopy;
  }
  int childCountBefore=root.getChildCount();
  for (ArrangementTreeNode current=to; current != root; ) {
    ArrangementTreeNode parent=current.getParent();
    treeModel.removeNodeFromParent(current);
    current=parent;
    if (parent.getChildCount() > 0) {
      break;
    }
  }
  int insertionIndex=root.getChildCount() < childCountBefore ? childCountBefore - 1 : childCountBefore;
  boolean merged=insert(root,insertionIndex,replacement,treeModel);
  if (cutHierarchy != null) {
    List<ArrangementTreeNode> toInsert=new ArrayList<ArrangementTreeNode>();
    if (hasEqualSetting(root,cutHierarchy)) {
      for (int i=0; i < cutHierarchy.getChildCount(); i++) {
        toInsert.add(cutHierarchy.getChildAt(i));
      }
    }
 else {
      toInsert.add(cutHierarchy);
    }
    for (    ArrangementTreeNode node : toInsert) {
      insert(root,root.getChildCount(),node,treeModel);
    }
  }
  return collectRowChangesAndUnmark(root,rootVisible);
}
