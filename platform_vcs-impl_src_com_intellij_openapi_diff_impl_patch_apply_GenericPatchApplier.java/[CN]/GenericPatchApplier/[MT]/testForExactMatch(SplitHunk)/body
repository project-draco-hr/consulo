{
  final int offset=splitHunk.getContextBefore().size();
  final List<BeforeAfter<List<String>>> steps=splitHunk.getPatchSteps();
  if (splitHunk.isInsertion()) {
    final boolean emptyFile=myLines.isEmpty() || myLines.size() == 1 && myLines.get(0).trim().length() == 0;
    if (emptyFile) {
      myNotBound.add(splitHunk);
    }
    return emptyFile;
  }
  int idx=splitHunk.getStartLineBefore() + offset;
  int cnt=0;
  boolean hadAlreadyApplied=false;
  for (  BeforeAfter<List<String>> step : steps) {
    if (myLines.size() <= idx)     return false;
    if (step.getBefore().isEmpty())     continue;
    final Pair<Integer,Boolean> distance=new FragmentMatcher(idx + cnt,step).find(false);
    if (distance.getFirst() > 0) {
      return false;
    }
    int length;
    if (distance.getSecond()) {
      length=step.getBefore().size();
    }
 else {
      length=step.getAfter().size();
      hadAlreadyApplied=true;
    }
    cnt+=length;
  }
  putCutIntoTransformations(new TextRange(idx,idx + cnt - 1),new MyAppliedData(splitHunk.getAfterAll(),hadAlreadyApplied,true,true,ChangeType.REPLACE));
  return true;
}
