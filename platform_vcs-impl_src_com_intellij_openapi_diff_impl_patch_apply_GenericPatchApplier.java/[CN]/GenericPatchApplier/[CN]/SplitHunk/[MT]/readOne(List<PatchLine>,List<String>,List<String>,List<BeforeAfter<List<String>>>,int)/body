{
  int i=startI;
  for (; i < lines.size(); i++) {
    final PatchLine patchLine=lines.get(i);
    if (!PatchLine.Type.CONTEXT.equals(patchLine.getType()))     break;
    contextBefore.add(patchLine.getText());
  }
  final boolean addFirst=i < lines.size() && PatchLine.Type.ADD.equals(lines.get(i).getType());
  List<String> before=new ArrayList<String>();
  List<String> after=new ArrayList<String>();
  for (; i < lines.size(); i++) {
    final PatchLine patchLine=lines.get(i);
    final PatchLine.Type type=patchLine.getType();
    if (PatchLine.Type.CONTEXT.equals(type)) {
      break;
    }
    if (PatchLine.Type.ADD.equals(type)) {
      if (addFirst && !before.isEmpty()) {
        steps.add(new BeforeAfter<List<String>>(before,after));
        before=new ArrayList<String>();
        after=new ArrayList<String>();
      }
      after.add(patchLine.getText());
    }
 else     if (PatchLine.Type.REMOVE.equals(type)) {
      if (!addFirst && !after.isEmpty()) {
        steps.add(new BeforeAfter<List<String>>(before,after));
        before=new ArrayList<String>();
        after=new ArrayList<String>();
      }
      before.add(patchLine.getText());
    }
  }
  if (!before.isEmpty() || !after.isEmpty()) {
    steps.add(new BeforeAfter<List<String>>(before,after));
  }
  for (; i < lines.size(); i++) {
    final PatchLine patchLine=lines.get(i);
    if (!PatchLine.Type.CONTEXT.equals(patchLine.getType())) {
      return i;
    }
    contextAfter.add(patchLine.getText());
  }
  return lines.size();
}
