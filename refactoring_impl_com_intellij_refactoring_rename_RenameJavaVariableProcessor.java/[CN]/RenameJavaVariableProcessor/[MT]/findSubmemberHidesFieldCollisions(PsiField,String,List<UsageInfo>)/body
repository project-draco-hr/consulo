{
  if (field.getContainingClass() == null)   return;
  if (field.hasModifierProperty(PsiModifier.PRIVATE))   return;
  final PsiClass containingClass=field.getContainingClass();
  Collection<PsiClass> inheritors=ClassInheritorsSearch.search(containingClass,containingClass.getUseScope(),true).findAll();
  for (  PsiClass inheritor : inheritors) {
    PsiField conflictingField=inheritor.findFieldByName(newName,false);
    if (conflictingField != null) {
      result.add(new SubmemberHidesMemberUsageInfo(conflictingField,field));
    }
  }
}
