{
  Out.print(numStates + " states before minimization, ");
  if (numStates == 0) {
    Out.error(ErrorMessages.ZERO_STATES);
    throw new GeneratorException();
  }
  if (Options.no_minimize) {
    Out.println("minimization skipped.");
    return;
  }
  final int n=numStates + 1;
  int[] block=new int[2 * n];
  int[] b_forward=new int[2 * n];
  int[] b_backward=new int[2 * n];
  int lastBlock=n;
  final int b0=n;
  int[] l_forward=new int[n * numInput + 1];
  int[] l_backward=new int[n * numInput + 1];
  int anchorL=n * numInput;
  int[][] inv_delta=new int[n][numInput];
  int[] inv_delta_set=new int[2 * n * numInput];
  int[] twin=new int[2 * n];
  int numSplit;
  int[] SD=new int[2 * n];
  int[] D=new int[n];
  int numD;
  int lastDelta=0;
  int[] inv_lists=new int[n];
  int[] inv_list_last=new int[n];
  for (int c=0; c < numInput; c++) {
    for (int s=0; s < n; s++) {
      inv_list_last[s]=-1;
      inv_delta[s][c]=-1;
    }
    inv_delta[0][c]=0;
    inv_list_last[0]=0;
    for (int s=1; s < n; s++) {
      int t=table[s - 1][c] + 1;
      if (inv_list_last[t] == -1) {
        inv_delta[t][c]=s;
        inv_list_last[t]=s;
      }
 else {
        inv_lists[inv_list_last[t]]=s;
        inv_list_last[t]=s;
      }
    }
    for (int s=0; s < n; s++) {
      int i=inv_delta[s][c];
      inv_delta[s][c]=lastDelta;
      int j=inv_list_last[s];
      boolean go_on=(i != -1);
      while (go_on) {
        go_on=(i != j);
        inv_delta_set[lastDelta++]=i;
        i=inv_lists[i];
      }
      inv_delta_set[lastDelta++]=-1;
    }
  }
  b_forward[b0]=0;
  b_backward[b0]=0;
  b_forward[0]=b0;
  b_backward[0]=b0;
  block[0]=b0;
  block[b0]=1;
  for (int s=1; s < n; s++) {
    int b=b0 + 1;
    boolean found=false;
    while (!found && b <= lastBlock) {
      int t=b_forward[b];
      found=(isPushback[s - 1] == isPushback[t - 1]) && (isLookEnd[s - 1] == isLookEnd[t - 1]);
      if (found) {
        if (isFinal[s - 1]) {
          found=isFinal[t - 1] && action[s - 1].isEquiv(action[t - 1]);
        }
 else {
          found=!isFinal[t - 1];
        }
        if (found) {
          block[s]=b;
          block[b]++;
          int last=b_backward[b];
          b_forward[last]=s;
          b_forward[s]=b;
          b_backward[b]=s;
          b_backward[s]=last;
        }
      }
      b++;
    }
    if (!found) {
      block[s]=b;
      block[b]++;
      b_forward[b]=s;
      b_forward[s]=b;
      b_backward[b]=s;
      b_backward[s]=b;
      lastBlock++;
    }
  }
  int B_max=b0;
  int B_i;
  for (B_i=b0 + 1; B_i <= lastBlock; B_i++)   if (block[B_max] < block[B_i])   B_max=B_i;
  l_forward[anchorL]=anchorL;
  l_backward[anchorL]=anchorL;
  if (B_max == b0)   B_i=b0 + 1;
 else   B_i=b0;
  int index=(B_i - b0) * numInput;
  while (index < (B_i + 1 - b0) * numInput) {
    int last=l_backward[anchorL];
    l_forward[last]=index;
    l_forward[index]=anchorL;
    l_backward[index]=last;
    l_backward[anchorL]=index;
    index++;
  }
  while (B_i <= lastBlock) {
    if (B_i != B_max) {
      index=(B_i - b0) * numInput;
      while (index < (B_i + 1 - b0) * numInput) {
        int last=l_backward[anchorL];
        l_forward[last]=index;
        l_forward[index]=anchorL;
        l_backward[index]=last;
        l_backward[anchorL]=index;
        index++;
      }
    }
    B_i++;
  }
  while (l_forward[anchorL] != anchorL) {
    int B_j_a=l_forward[anchorL];
    l_forward[anchorL]=l_forward[B_j_a];
    l_backward[l_forward[anchorL]]=anchorL;
    l_forward[B_j_a]=0;
    int B_j=b0 + B_j_a / numInput;
    int a=B_j_a % numInput;
    numD=0;
    int s=b_forward[B_j];
    while (s != B_j) {
      int t=inv_delta[s][a];
      while (inv_delta_set[t] != -1) {
        D[numD++]=inv_delta_set[t++];
      }
      s=b_forward[s];
    }
    numSplit=0;
    for (int indexD=0; indexD < numD; indexD++) {
      s=D[indexD];
      B_i=block[s];
      SD[B_i]=-1;
      twin[B_i]=0;
    }
    for (int indexD=0; indexD < numD; indexD++) {
      s=D[indexD];
      B_i=block[s];
      if (SD[B_i] < 0) {
        SD[B_i]=0;
        int t=b_forward[B_i];
        while (t != B_i && (t != 0 || block[0] == B_j) && (t == 0 || block[table[t - 1][a] + 1] == B_j)) {
          SD[B_i]++;
          t=b_forward[t];
        }
      }
    }
    for (int indexD=0; indexD < numD; indexD++) {
      s=D[indexD];
      B_i=block[s];
      if (SD[B_i] != block[B_i]) {
        int B_k=twin[B_i];
        if (B_k == 0) {
          B_k=++lastBlock;
          b_forward[B_k]=B_k;
          b_backward[B_k]=B_k;
          twin[B_i]=B_k;
          twin[numSplit++]=B_i;
        }
        b_forward[b_backward[s]]=b_forward[s];
        b_backward[b_forward[s]]=b_backward[s];
        int last=b_backward[B_k];
        b_forward[last]=s;
        b_forward[s]=B_k;
        b_backward[s]=last;
        b_backward[B_k]=s;
        block[s]=B_k;
        block[B_k]++;
        block[B_i]--;
        SD[B_i]--;
      }
    }
    for (int indexTwin=0; indexTwin < numSplit; indexTwin++) {
      B_i=twin[indexTwin];
      int B_k=twin[B_i];
      for (int c=0; c < numInput; c++) {
        int B_i_c=(B_i - b0) * numInput + c;
        int B_k_c=(B_k - b0) * numInput + c;
        if (l_forward[B_i_c] > 0) {
          int last=l_backward[anchorL];
          l_backward[anchorL]=B_k_c;
          l_forward[last]=B_k_c;
          l_backward[B_k_c]=last;
          l_forward[B_k_c]=anchorL;
        }
 else {
          if (block[B_i] <= block[B_k]) {
            int last=l_backward[anchorL];
            l_backward[anchorL]=B_i_c;
            l_forward[last]=B_i_c;
            l_backward[B_i_c]=last;
            l_forward[B_i_c]=anchorL;
          }
 else {
            int last=l_backward[anchorL];
            l_backward[anchorL]=B_k_c;
            l_forward[last]=B_k_c;
            l_backward[B_k_c]=last;
            l_forward[B_k_c]=anchorL;
          }
        }
      }
    }
  }
  int trans[]=new int[numStates];
  boolean kill[]=new boolean[numStates];
  int move[]=new int[numStates];
  for (int b=b0 + 1; b <= lastBlock; b++) {
    int s=b_forward[b];
    int min_s=s;
    for (; s != b; s=b_forward[s])     if (min_s > s)     min_s=s;
    min_s--;
    for (s=b_forward[b] - 1; s != b - 1; s=b_forward[s + 1] - 1) {
      trans[s]=min_s;
      kill[s]=s != min_s;
    }
  }
  int amount=0;
  for (int i=0; i < numStates; i++) {
    if (kill[i])     amount++;
 else     move[i]=amount;
  }
  int i, j;
  for (i=0, j=0; i < numStates; i++) {
    if (!kill[i]) {
      for (int c=0; c < numInput; c++) {
        if (table[i][c] >= 0) {
          table[j][c]=trans[table[i][c]];
          table[j][c]-=move[table[j][c]];
        }
 else {
          table[j][c]=table[i][c];
        }
      }
      isFinal[j]=isFinal[i];
      isPushback[j]=isPushback[i];
      isLookEnd[j]=isLookEnd[i];
      action[j]=action[i];
      j++;
    }
  }
  numStates=j;
  for (i=0; i < lexState.length; i++) {
    lexState[i]=trans[lexState[i]];
    lexState[i]-=move[lexState[i]];
  }
  Out.println(numStates + " states in minimized DFA");
}
