{
  int i, j;
  char c;
  Out.print(numStates + " states before minimization, ");
  if (numStates == 0) {
    Out.error(ErrorMessages.ZERO_STATES);
    throw new GeneratorException();
  }
  if (Options.no_minimize) {
    Out.println("minimization skipped.");
    return null;
  }
  boolean[][] equiv=new boolean[numStates][];
  StatePairList[][] list=new StatePairList[numStates][];
  for (i=1; i < numStates; i++) {
    list[i]=new StatePairList[i];
    equiv[i]=new boolean[i];
    for (j=0; j < i; j++) {
      if (isFinal[i] && isFinal[j] && (isPushback[i] == isPushback[j])&& (isLookEnd[i] == isLookEnd[j]))       equiv[i][j]=action[i].isEquiv(action[j]);
 else       equiv[i][j]=!isFinal[j] && !isFinal[i] && (isPushback[i] == isPushback[j])&& (isLookEnd[i] == isLookEnd[j]);
    }
  }
  for (i=1; i < numStates; i++) {
    Out.debug("Testing state " + i);
    for (j=0; j < i; j++) {
      if (equiv[i][j]) {
        for (c=0; c < numInput; c++) {
          if (equiv[i][j]) {
            int p=table[i][c];
            int q=table[j][c];
            if (p < q) {
              int t=p;
              p=q;
              q=t;
            }
            if (p >= 0 || q >= 0) {
              if (p != q && (p == -1 || q == -1 || !equiv[p][q])) {
                equiv[i][j]=false;
                if (list[i][j] != null)                 list[i][j].markAll(list,equiv);
              }
            }
          }
        }
        if (equiv[i][j]) {
          for (c=0; c < numInput; c++) {
            int p=table[i][c];
            int q=table[j][c];
            if (p < q) {
              int t=p;
              p=q;
              q=t;
            }
            if (p != q && p >= 0 && q >= 0) {
              if (list[p][q] == null) {
                list[p][q]=new StatePairList();
              }
              list[p][q].addPair(i,j);
            }
          }
        }
 else {
        }
      }
    }
  }
  return equiv;
}
