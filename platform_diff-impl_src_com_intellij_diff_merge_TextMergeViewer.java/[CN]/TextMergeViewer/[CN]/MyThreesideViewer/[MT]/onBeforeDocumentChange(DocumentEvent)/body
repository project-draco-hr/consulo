{
  super.onBeforeDocumentChange(e);
  enterBulkChangeUpdateBlock();
  if (myAllMergeChanges.isEmpty())   return;
  List<Document> documents=ContainerUtil.map(getEditors(),new Function<EditorEx,Document>(){
    @Override public Document fun(    EditorEx editorEx){
      return editorEx.getDocument();
    }
  }
);
  ThreeSide side=ThreeSide.fromValue(documents,e.getDocument());
  if (side == null) {
    LOG.warn("Unknown document changed");
    return;
  }
  if (side != ThreeSide.BASE) {
    LOG.error("Non-base side was changed");
    return;
  }
  if (myInitialRediffFinished)   myContentModified=true;
  int line1=e.getDocument().getLineNumber(e.getOffset());
  int line2=e.getDocument().getLineNumber(e.getOffset() + e.getOldLength()) + 1;
  int shift=DiffUtil.countLinesShift(e);
  final List<TextMergeChange.State> corruptedStates=ContainerUtil.newSmartList();
  for (int index=0; index < myAllMergeChanges.size(); index++) {
    TextMergeChange change=myAllMergeChanges.get(index);
    TextMergeChange.State oldState=change.processBaseChange(line1,line2,shift);
    if (oldState != null) {
      if (myCurrentMergeCommand == null) {
        corruptedStates.add(oldState);
      }
      reinstallHighlighter(change);
    }
  }
  if (!corruptedStates.isEmpty() && myUndoManager != null) {
    myUndoManager.undoableActionPerformed(new MyUndoableAction(TextMergeViewer.this,corruptedStates,true));
  }
}
