{
  final PsiParameter psiParameter=(PsiParameter)psiElement;
  final PsiParameterList parameterList=(PsiParameterList)psiParameter.getParent();
  if (!(parameterList.getParent() instanceof PsiMethod)) {
    return;
  }
  final int index=parameterList.getParameterIndex(psiParameter);
  final PsiMethod method=(PsiMethod)parameterList.getParent();
  String errorMessage=getCannotInlineMessage(psiParameter,method);
  if (errorMessage != null) {
    CommonRefactoringUtil.showErrorHint(project,editor,errorMessage,RefactoringBundle.message("inline.parameter.refactoring"),null);
    return;
  }
  final Ref<PsiExpression> refInitializer=new Ref<PsiExpression>();
  final Ref<PsiExpression> refConstantInitializer=new Ref<PsiExpression>();
  final Ref<PsiCallExpression> refMethodCall=new Ref<PsiCallExpression>();
  final List<PsiReference> occurrences=new ArrayList<PsiReference>();
  final Collection<PsiFile> containingFiles=new HashSet<PsiFile>();
  containingFiles.add(psiParameter.getContainingFile());
  boolean result=ReferencesSearch.search(method).forEach(new Processor<PsiReference>(){
    public boolean process(    final PsiReference psiReference){
      PsiElement element=psiReference.getElement();
      final PsiElement parent=element.getParent();
      if (parent instanceof PsiCallExpression) {
        final PsiCallExpression methodCall=(PsiCallExpression)parent;
        occurrences.add(psiReference);
        containingFiles.add(element.getContainingFile());
        PsiExpression argument=methodCall.getArgumentList().getExpressions()[index];
        if (!refInitializer.isNull()) {
          return argument != null && PsiEquivalenceUtil.areElementsEquivalent(refInitializer.get(),argument) && PsiEquivalenceUtil.areElementsEquivalent(refMethodCall.get(),methodCall);
        }
        if (InlineToAnonymousConstructorProcessor.isConstant(argument) || getReferencedFinalField(argument) != null) {
          if (refConstantInitializer.isNull()) {
            refConstantInitializer.set(argument);
          }
 else           if (!isSameConstant(argument,refConstantInitializer.get())) {
            return false;
          }
        }
 else {
          if (!refConstantInitializer.isNull())           return false;
          refInitializer.set(argument);
          refMethodCall.set(methodCall);
        }
      }
      return true;
    }
  }
);
  if (occurrences.isEmpty()) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Method has no usages",RefactoringBundle.message("inline.parameter.refactoring"),null);
    return;
  }
  if (!result) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Cannot find constant initializer for parameter",RefactoringBundle.message("inline.parameter.refactoring"),null);
    return;
  }
  if (!refInitializer.isNull()) {
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      final InlineParameterExpressionProcessor processor=new InlineParameterExpressionProcessor(refMethodCall.get(),method,psiParameter,refInitializer.get(),method.getProject().getUserData(InlineParameterExpressionProcessor.CREATE_LOCAL_FOR_TESTS));
      processor.run();
    }
 else {
      final boolean createLocal=ReferencesSearch.search(psiParameter).findAll().size() > 1;
      InlineParameterDialog dlg=new InlineParameterDialog(refMethodCall.get(),method,psiParameter,refInitializer.get(),createLocal);
      dlg.show();
    }
    return;
  }
  if (refConstantInitializer.isNull()) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Cannot find constant initializer for parameter",RefactoringBundle.message("inline.parameter.refactoring"),null);
    return;
  }
  final Ref<Boolean> isNotConstantAccessible=new Ref<Boolean>();
  final PsiExpression constantExpression=refConstantInitializer.get();
  constantExpression.accept(new JavaRecursiveElementVisitor(){
    @Override public void visitReferenceExpression(    PsiReferenceExpression expression){
      super.visitReferenceExpression(expression);
      final PsiElement resolved=expression.resolve();
      if (resolved instanceof PsiMember && !PsiUtil.isAccessible((PsiMember)resolved,method,null)) {
        isNotConstantAccessible.set(Boolean.TRUE);
      }
    }
  }
);
  if (!isNotConstantAccessible.isNull() && isNotConstantAccessible.get()) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Constant initializer is not accessible in method body",RefactoringBundle.message("inline.parameter.refactoring"),null);
    return;
  }
  if (!ApplicationManager.getApplication().isUnitTestMode()) {
    String occurencesString=RefactoringBundle.message("occurences.string",occurrences.size());
    String question=RefactoringBundle.message("inline.parameter.confirmation",psiParameter.getName(),constantExpression.getText()) + " " + occurencesString;
    RefactoringMessageDialog dialog=new RefactoringMessageDialog(REFACTORING_NAME,question,HelpID.INLINE_VARIABLE,"OptionPane.questionIcon",true,project);
    dialog.show();
    if (!dialog.isOK()) {
      return;
    }
  }
  new WriteCommandAction(project,RefactoringBundle.message("inline.parameter.command.name",psiParameter.getName()),containingFiles.toArray(new PsiFile[containingFiles.size()])){
    protected void run(    final Result result) throws Throwable {
      SameParameterValueInspection.InlineParameterValueFix.inlineSameParameterValue(method,psiParameter,constantExpression);
    }
    protected UndoConfirmationPolicy getUndoConfirmationPolicy(){
      return UndoConfirmationPolicy.DEFAULT;
    }
  }
.execute();
}
