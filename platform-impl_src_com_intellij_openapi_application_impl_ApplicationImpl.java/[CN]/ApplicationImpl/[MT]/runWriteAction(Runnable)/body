{
  assertCanRunWriteAction();
  fireBeforeWriteActionStart(action);
  LOG.assertTrue(myActionsLock.isWriteLockAcquired(Thread.currentThread()) || !Thread.holdsLock(PsiLock.LOCK),"Thread must not hold PsiLock while performing writeAction");
  myIsWaitingForWriteAction=true;
  try {
    myActionsLock.writeLock().acquire();
  }
 catch (  InterruptedException e) {
    throw new RuntimeInterruptedException(e);
  }
 finally {
    myIsWaitingForWriteAction=false;
  }
  fireWriteActionStarted(action);
  try {
synchronized (myWriteActionsStack) {
      myWriteActionsStack.push(action);
    }
    final Project project=CommandProcessor.getInstance().getCurrentCommandProject();
    if (project != null) {
      PostprocessReformattingAspect.getInstance(project).postponeFormattingInside(new Computable<Object>(){
        public Object compute(){
          action.run();
          return null;
        }
      }
);
    }
 else     action.run();
  }
  finally {
synchronized (myWriteActionsStack) {
      myWriteActionsStack.pop();
    }
    fireWriteActionFinished(action);
    myActionsLock.writeLock().release();
  }
}
