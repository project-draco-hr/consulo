{
synchronized (myCalculatedLock) {
    final long revision=calculateCopyRevision(branchPath);
    if (revision != -1 && revision >= list.getNumber()) {
      return MergeCheckResult.COMMON;
    }
    final MergeCheckResult calculated=myAlreadyCalculatedMap.get(list.getNumber());
    if (calculated != null) {
      return calculated;
    }
    final Ref<Boolean> mergedRef=new Ref<Boolean>();
    final Ref<Boolean> notExistsRef=new Ref<Boolean>();
    checkPaths(list.getNumber(),list.getAddedPaths(),mergedRef,notExistsRef,branchPath);
    checkPaths(list.getNumber(),list.getDeletedPaths(),mergedRef,notExistsRef,branchPath);
    checkPaths(list.getNumber(),list.getChangedPaths(),mergedRef,notExistsRef,branchPath);
    final MergeCheckResult result;
    boolean mergedDetected=Boolean.TRUE.equals(mergedRef.get());
    boolean notExistsDetected=Boolean.TRUE.equals(notExistsRef.get());
    if (notExistsDetected && (!mergedDetected)) {
      result=MergeCheckResult.NOT_EXISTS;
    }
 else     if (notExistsDetected) {
      result=MergeCheckResult.NOT_EXISTS_PARTLY_MERGED;
    }
 else {
      result=MergeCheckResult.getInstance(mergedDetected);
    }
    myAlreadyCalculatedMap.put(list.getNumber(),result);
    return result;
  }
}
