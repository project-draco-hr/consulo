{
  if ((myNonExistingPaths.contains(head)) || (head.length() == 0)) {
    return MergeCheckResult.NOT_EXISTS;
  }
  final Set<Long> mergeInfo=myPathMergedMap.get(head);
  if (mergeInfo != null) {
    if (mergeInfo.contains(number)) {
      return MergeCheckResult.getInstance(mergeInfo.contains(number));
    }
    return goDownLocally(number,head,tail);
  }
  LOG.debug("checking " + head + " tail: "+ tail);
  try {
    final SVNPropertyData mergeinfoProperty=myClient.doGetProperty(new File(head),SVNProperty.MERGE_INFO,SVNRevision.WORKING,SVNRevision.WORKING);
    boolean propertyFound=false;
    if (mergeinfoProperty != null) {
      final SVNPropertyValue value=mergeinfoProperty.getValue();
      if (value != null) {
        final Map<String,SVNMergeRangeList> map=SVNMergeInfoUtil.parseMergeInfo(new StringBuffer(value.getString()),null);
        for (        String key : map.keySet()) {
          if ((key != null) && (key.startsWith(myRelativeTrunk))) {
            propertyFound=true;
            final Set<Long> revisions=new HashSet<Long>();
            final SVNMergeRangeList rangesList=map.get(key);
            boolean result=false;
            for (            SVNMergeRange range : rangesList.getRanges()) {
              final long startRevision=range.getStartRevision() + 1;
              final long endRevision=range.getEndRevision();
              if ((number >= startRevision) && (number <= endRevision)) {
                result=true;
              }
              for (long i=startRevision; i <= endRevision; i++) {
                revisions.add(i);
              }
            }
            myPathMergedMap.put(head,revisions);
            if (result) {
              return MergeCheckResult.getInstance(result);
            }
          }
        }
      }
    }
    if (!propertyFound) {
      myPathMergedMap.put(head,Collections.<Long>emptySet());
    }
  }
 catch (  SVNException e) {
    LOG.info(e);
    if (SVNErrorCode.ENTRY_NOT_FOUND.equals(e.getErrorMessage().getErrorCode())) {
      myNonExistingPaths.add(head);
      return MergeCheckResult.NOT_EXISTS;
    }
    return MergeCheckResult.NOT_MERGED;
  }
  return goDownLocally(number,head,tail);
}
