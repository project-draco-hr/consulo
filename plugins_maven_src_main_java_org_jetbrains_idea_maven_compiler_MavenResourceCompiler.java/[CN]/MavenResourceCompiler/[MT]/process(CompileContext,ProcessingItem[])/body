{
  context.getProgressIndicator().setText("Processing Maven resources...");
  List<ProcessingItem> result=new ArrayList<ProcessingItem>(items.length);
  List<File> filesToRefresh=new ArrayList<File>(items.length);
  deleteOutdatedFile(context.getUserData(FILES_TO_DELETE_KEY),filesToRefresh);
  for (int i=0; i < items.length; i++) {
    if (!(items[i] instanceof MyProcessingItem))     continue;
    context.getProgressIndicator().setFraction(((double)i) / items.length);
    context.getProgressIndicator().checkCanceled();
    MyProcessingItem eachItem=(MyProcessingItem)items[i];
    VirtualFile sourceVirtualFile=eachItem.getFile();
    File sourceFile=new File(sourceVirtualFile.getPath());
    File outputFile=new File(eachItem.getOutputPath());
    try {
      outputFile.getParentFile().mkdirs();
      boolean shouldFilter=eachItem.isFiltered();
      if (shouldFilter && sourceFile.length() > 10 * 1024 * 1024) {
        context.addMessage(CompilerMessageCategory.WARNING,"Maven: File is too big to be filtered. Most likely it is a binary file and should be excluded from filtering.",sourceVirtualFile.getUrl(),-1,-1);
        shouldFilter=false;
      }
      if (shouldFilter) {
        String charset=sourceVirtualFile.getCharset().name();
        String text=new String(FileUtil.loadFileBytes(sourceFile),charset);
        PrintWriter printWriter=new PrintWriter(outputFile,charset);
        try {
          MavenPropertyResolver.doFilterText(eachItem.getModule(),text,eachItem.getProperties(),eachItem.getEscapeString(),printWriter);
        }
  finally {
          printWriter.close();
        }
      }
 else {
        FileUtil.copy(sourceFile,outputFile);
      }
      eachItem.getValidityState().setOutputFileTimestamp(outputFile.lastModified());
      result.add(eachItem);
      filesToRefresh.add(outputFile);
    }
 catch (    IOException e) {
      MavenLog.LOG.info(e);
      context.addMessage(CompilerMessageCategory.ERROR,"Maven: Cannot process resource file: " + e.getMessage(),sourceVirtualFile.getUrl(),-1,-1);
    }
  }
  CompilerUtil.refreshIOFiles(filesToRefresh);
  return result.toArray(new ProcessingItem[result.size()]);
}
