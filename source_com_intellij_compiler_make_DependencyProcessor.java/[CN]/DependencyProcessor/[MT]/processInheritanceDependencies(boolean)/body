{
  final Cache oldCache=myDependencyCache.getCache();
  final Cache newCache=myDependencyCache.getNewClassesCache();
  boolean becameFinal=!CacheUtils.isFinal(oldCache,myQName) && CacheUtils.isFinal(newCache,myQName);
  final SymbolTable symbolTable=myDependencyCache.getSymbolTable();
  final Set removedConcreteMethods=fetchNonAbstractMethods(myRemovedMembers);
  final int[] subclasses=oldCache.getSubclasses(oldCache.getClassId(myQName));
  for (int idx=0; idx < subclasses.length; idx++) {
    final int subclassQName=subclasses[idx];
    if (myDependencyCache.isClassInfoMarked(subclassQName)) {
      continue;
    }
    int subclassId=oldCache.getClassId(subclassQName);
    if (subclassId == Cache.UNKNOWN) {
      continue;
    }
    if (hasRemovedMethods && myIsRemoteInterface && !CacheUtils.isInterface(oldCache,subclassQName)) {
      if (myDependencyCache.markClass(subclassQName)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: methods were removed from remote interface: "+ myDependencyCache.resolve(myQName));
        }
      }
      continue;
    }
    if (mySuperClassAdded || mySuperInterfaceAdded) {
      if (myDependencyCache.markClass(subclassQName)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the superlist of "+ myDependencyCache.resolve(myQName)+ " is changed");
        }
      }
      continue;
    }
    if (becameFinal) {
      if (myQName == oldCache.getSuperQualifiedName(subclassId)) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class "+ myDependencyCache.resolve(myQName)+ " was made final");
          }
        }
        continue;
      }
    }
    for (Iterator it=myAddedMembers.iterator(); it.hasNext(); ) {
      final MemberInfo member=(MemberInfo)it.next();
      if (member instanceof MethodInfo) {
        final MethodInfo method=(MethodInfo)member;
        if (method.isAbstract()) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added abstract method to "+ myDependencyCache.resolve(myQName));
            }
          }
          break;
        }
        if (!method.isPrivate()) {
          int derivedMethod=CacheUtils.findMethodBySignature(oldCache,oldCache.getClassDeclarationId(subclassQName),method.getDescriptor(symbolTable),symbolTable);
          if (derivedMethod != Cache.UNKNOWN) {
            if (!method.getReturnTypeDescriptor(symbolTable).equals(CacheUtils.getMethodReturnTypeDescriptor(oldCache,derivedMethod,symbolTable))) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: return types of method "+ method+ " in base and derived classes are different");
                }
              }
              break;
            }
            if (MakeUtil.isMoreAccessible(method.getFlags(),oldCache.getMethodFlags(derivedMethod))) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the method "+ method+ " in derived class is less accessible than in base class");
                }
              }
              break;
            }
            if (!CacheUtils.areArraysContentsEqual(method.getThrownExceptions(),oldCache.getMethodThrownExceptions(derivedMethod))) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: exception lists of "+ method+ " in base and derived classes are different");
                }
              }
              break;
            }
          }
          if (hasGenericsNameClashes(method,oldCache,subclassQName)) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: found method with the same name, different generic signature, but the same erasure as "+ method);
              }
            }
            break;
          }
        }
      }
 else       if (member instanceof FieldInfo) {
        if (CacheUtils.findFieldByName(oldCache,oldCache.getClassDeclarationId(subclassQName),member.getName()) != Cache.UNKNOWN) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added field "+ member+ " to base class");
            }
          }
          break;
        }
      }
    }
    for (Iterator it=myChangedMembers.iterator(); it.hasNext(); ) {
      final MemberInfo changedMember=(MemberInfo)it.next();
      if (changedMember instanceof MethodInfo) {
        final MethodInfo oldMethod=(MethodInfo)changedMember;
        MethodChangeDescription changeDescription=(MethodChangeDescription)myChangeDescriptions.get(oldMethod);
        if (changeDescription.becameAbstract) {
          if (!ClsUtil.isAbstract(oldCache.getFlags(subclassId))) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
              }
            }
            break;
          }
        }
        int derivedMethod=CacheUtils.findMethodBySignature(oldCache,oldCache.getClassDeclarationId(subclassQName),oldMethod.getDescriptor(symbolTable),symbolTable);
        if (derivedMethod != Cache.UNKNOWN) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
            }
          }
          break;
        }
      }
    }
    if (!ClsUtil.isAbstract(oldCache.getFlags(subclassId))) {
      if (hasUnimplementedAbstractMethods(subclassQName,new HashSet(removedConcreteMethods))) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class should be declared abstract because abstract method implementation was removed from its superclass: "+ myDependencyCache.resolve(myQName));
          }
        }
      }
    }
  }
}
