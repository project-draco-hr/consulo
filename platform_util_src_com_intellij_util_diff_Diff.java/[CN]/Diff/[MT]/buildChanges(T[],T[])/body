{
  for (  T anObjects1 : objects1)   LOG.assertTrue(anObjects1 != null);
  for (  T anObjects2 : objects2)   LOG.assertTrue(anObjects2 != null);
  final int startShift=getStartShift(objects1,objects2);
  final int endCut=getEndCut(objects1,objects2,startShift);
  ChangeBuilder builder=new ChangeBuilder(startShift);
  int trimmedLength1=objects1.length - startShift - endCut;
  int trimmedLength2=objects2.length - startShift - endCut;
  if (trimmedLength1 == 0 || trimmedLength2 == 0) {
    if (trimmedLength1 != 0 || trimmedLength2 != 0) {
      builder.addChange(trimmedLength1,trimmedLength2);
    }
    return builder.getFirstChange();
  }
  Enumerator<T> enumerator=new Enumerator<T>(trimmedLength1 + trimmedLength2,ContainerUtil.<T>canonicalStrategy());
  int[] ints1=enumerator.enumerate(objects1,startShift,endCut);
  int[] ints2=enumerator.enumerate(objects2,startShift,endCut);
  Reindexer reindexer=new Reindexer();
  int[][] discarded=reindexer.discardUnique(ints1,ints2);
  if (discarded[0].length == 0 && discarded[1].length == 0) {
    builder.addChange(ints1.length,ints2.length);
    return builder.getFirstChange();
  }
  BitSet[] changes;
  if (Registry.is("diff.patience.alg")) {
    PatienceIntLCS patienceIntLCS=new PatienceIntLCS(discarded[0],discarded[1]);
    patienceIntLCS.execute();
    changes=patienceIntLCS.getChanges();
  }
 else {
    try {
      IntLCS intLCS=new IntLCS(discarded[0],discarded[1]);
      intLCS.execute();
      changes=intLCS.getChanges();
    }
 catch (    FilesTooBigForDiffException e) {
      PatienceIntLCS patienceIntLCS=new PatienceIntLCS(discarded[0],discarded[1]);
      patienceIntLCS.failOnSmallSizeReduction();
      patienceIntLCS.execute();
      changes=patienceIntLCS.getChanges();
      LOG.info("Successful fallback to patience diff");
    }
  }
  reindexer.reindex(changes,builder);
  return builder.getFirstChange();
}
