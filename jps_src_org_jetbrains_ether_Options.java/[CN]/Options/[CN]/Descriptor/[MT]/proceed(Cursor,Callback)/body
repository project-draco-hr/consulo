{
  if (cursor.endOf())   return false;
  final String arg=cursor.look();
  if (!arg.startsWith("-")) {
    callback.addFree(arg);
    cursor.shift();
    return true;
  }
  if (myShort != null && arg.equals("-" + myShort)) {
switch (myArgumentSpecifier) {
case NONE:
      callback.update(myKey,SWITCH);
    break;
default :
  if (cursor.nextIsArg()) {
    callback.update(myKey,new Value(cursor.lookahead()));
  }
 else {
switch (myArgumentSpecifier) {
case OPTIONAL:
      callback.update(myKey,SWITCH);
    break;
case MANDATORY:
  callback.report("option \"" + arg + "\" requires an argument, discarding.");
}
}
}
;
cursor.shift();
return true;
}
final Matcher m=myLongPattern.matcher(arg);
if (myLong != null && m.matches()) {
final String prm=m.group(2);
switch (myArgumentSpecifier) {
case MANDATORY:
if (prm == null) {
callback.report("option \"" + arg + "\" requires an argument, discarding.");
}
 else {
callback.update(myKey,new Value(prm));
}
break;
case NONE:
if (prm == null) {
callback.update(myKey,SWITCH);
}
 else {
callback.report("option \"" + arg + "\" does not take an argument, omitting.");
}
break;
case OPTIONAL:
callback.update(myKey,prm == null ? SWITCH : new Value(prm));
break;
}
cursor.shift();
return true;
}
return false;
}
