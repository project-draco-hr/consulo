{
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    final EmptyProgressIndicator indicator=new EmptyProgressIndicator();
    task.run(indicator);
    if (indicator.isCanceled()) {
      task.onCancel();
    }
 else {
      task.onSuccess();
    }
  }
 else   if (task.isConditionalModal() && !task.shouldStartInBackground()) {
    ProgressManager.getInstance().run(task);
  }
 else {
    final Object LOCK=new Object();
    String title=task.getTitle();
    if (StringUtil.isEmptyOrSpaces(title)) {
      title=myTitle;
    }
    final Task.Backgroundable container=new Task.Backgroundable(myProject,title,task.isCancellable()){
      @Override public void onSuccess(){
        task.onSuccess();
synchronized (LOCK) {
          LOCK.notifyAll();
        }
      }
      @Override public void onCancel(){
        task.onCancel();
synchronized (LOCK) {
          LOCK.notifyAll();
        }
      }
      @Override public boolean shouldStartInBackground(){
        return task.shouldStartInBackground();
      }
      @Override public void processSentToBackground(){
        task.processSentToBackground();
      }
      @Override public boolean isConditionalModal(){
        return task.isConditionalModal();
      }
      @Override public DumbModeAction getDumbModeAction(){
        return task.getDumbModeAction();
      }
      @Override public void run(      @NotNull ProgressIndicator indicator){
        task.run(indicator);
      }
    }
;
    UIUtil.invokeLaterIfNeeded(new Runnable(){
      public void run(){
        if (myProject == null || !myProject.isDisposed()) {
          ProgressManager.getInstance().run(container);
        }
      }
    }
);
    try {
synchronized (LOCK) {
        LOCK.wait();
      }
    }
 catch (    InterruptedException e) {
      LOG.error(e);
    }
  }
}
