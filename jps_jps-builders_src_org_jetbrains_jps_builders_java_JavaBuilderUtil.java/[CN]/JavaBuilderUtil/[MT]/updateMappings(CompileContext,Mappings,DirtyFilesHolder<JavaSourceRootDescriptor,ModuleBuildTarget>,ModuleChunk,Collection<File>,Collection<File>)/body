{
  try {
    boolean additionalPassRequired=false;
    final Set<String> removedPaths=getRemovedPaths(chunk,dirtyFilesHolder);
    final Mappings globalMappings=context.getProjectDescriptor().dataManager.getMappings();
    if (!context.isProjectRebuild()) {
      if (context.shouldDifferentiate(chunk)) {
        context.processMessage(new ProgressMessage("Checking dependencies... [" + chunk.getName() + "]"));
        final Set<File> allCompiledFiles=getAllCompiledFilesContainer(context);
        final Set<File> allAffectedFiles=getAllAffectedFilesContainer(context);
        allAffectedFiles.addAll(filesToCompile);
        allCompiledFiles.addAll(successfullyCompiled);
        allAffectedFiles.removeAll(successfullyCompiled);
        final Set<File> affectedBeforeDif=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
        affectedBeforeDif.addAll(allAffectedFiles);
        final ModulesBasedFileFilter moduleBasedFilter=new ModulesBasedFileFilter(context,chunk);
        final boolean incremental=globalMappings.differentiateOnIncrementalMake(delta,removedPaths,filesToCompile,allCompiledFiles,allAffectedFiles,moduleBasedFilter,CONSTANT_SEARCH_SERVICE.get(context));
        if (LOG.isDebugEnabled()) {
          LOG.debug("Differentiate Results:");
          LOG.debug("   Compiled Files:");
          for (          final File c : allCompiledFiles) {
            LOG.debug("      " + c.getAbsolutePath());
          }
          LOG.debug("   Affected Files:");
          for (          final File c : allAffectedFiles) {
            LOG.debug("      " + c.getAbsolutePath());
          }
          LOG.debug("End Of Differentiate Results.");
        }
        if (incremental) {
          final Set<File> newlyAffectedFiles=new HashSet<File>(allAffectedFiles);
          newlyAffectedFiles.removeAll(affectedBeforeDif);
          newlyAffectedFiles.removeAll(allCompiledFiles);
          final String infoMessage="Dependency analysis found " + newlyAffectedFiles.size() + " affected files";
          LOG.info(infoMessage);
          context.processMessage(new ProgressMessage(infoMessage));
          if (!newlyAffectedFiles.isEmpty()) {
            if (LOG.isDebugEnabled()) {
              for (              File file : newlyAffectedFiles) {
                LOG.debug("affected file: " + file.getPath());
              }
              final List<Pair<File,JpsModule>> wrongFiles=checkAffectedFilesInCorrectModules(context,newlyAffectedFiles,moduleBasedFilter);
              if (!wrongFiles.isEmpty()) {
                LOG.debug("Wrong affected files for module chunk " + chunk.getName() + ": ");
                for (                Pair<File,JpsModule> pair : wrongFiles) {
                  final String name=pair.second != null ? pair.second.getName() : "null";
                  LOG.debug("\t[" + name + "] "+ pair.first.getPath());
                }
              }
            }
            for (            File file : newlyAffectedFiles) {
              FSOperations.markDirtyIfNotDeleted(context,file);
            }
            additionalPassRequired=context.isMake() && chunkContainsAffectedFiles(context,chunk,newlyAffectedFiles);
          }
        }
 else {
          final String messageText="Marking " + chunk.getName() + " and direct dependants for recompilation";
          LOG.info("Non-incremental mode: " + messageText);
          context.processMessage(new ProgressMessage(messageText));
          additionalPassRequired=context.isMake();
          FSOperations.markDirtyRecursively(context,chunk);
        }
      }
 else {
        globalMappings.differentiateOnNonIncrementalMake(delta,removedPaths,filesToCompile);
      }
    }
 else {
      globalMappings.differentiateOnRebuild(delta);
    }
    if (Utils.errorsDetected(context)) {
      return false;
    }
    context.processMessage(new ProgressMessage("Updating dependency information... [" + chunk.getName() + "]"));
    globalMappings.integrate(delta);
    return additionalPassRequired;
  }
 catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException) {
      throw ((IOException)cause);
    }
    throw e;
  }
 finally {
    context.processMessage(new ProgressMessage(""));
  }
}
