{
  if (e instanceof RunCanceledByUserException)   return;
  LOG.debug(e);
  String description=e.getMessage();
  HyperlinkListener listener=null;
  if ((description.contains("87") || description.contains("111") || description.contains("206")) && e instanceof ProcessNotCreatedException && !PropertiesComponent.getInstance(project).isTrueValue("dynamic.classpath")) {
    final String commandLineString=((ProcessNotCreatedException)e).getCommandLine().getCommandLineString();
    if (commandLineString.length() > 1024 * 32) {
      description="Command line is too long. In order to reduce its length classpath file can be used.<br>" + "Would you like to enable classpath file mode for all run configurations of your project?<br>" + "<a href=\"\">Enable</a>";
      listener=new HyperlinkListener(){
        @Override public void hyperlinkUpdate(        HyperlinkEvent event){
          PropertiesComponent.getInstance(project).setValue("dynamic.classpath","true");
        }
      }
;
    }
  }
  final String title=ExecutionBundle.message("error.running.configuration.message",taskName);
  final String fullMessage=title + ":<br>" + description;
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    LOG.error(fullMessage);
  }
  if (listener == null && e instanceof HyperlinkListener) {
    listener=(HyperlinkListener)e;
  }
  final HyperlinkListener finalListener=listener;
  final String finalDescription=description;
  UIUtil.invokeLaterIfNeeded(new Runnable(){
    @Override public void run(){
      ToolWindowManager.getInstance(project).notifyByBalloon(toolWindowId,MessageType.ERROR,fullMessage,null,finalListener);
      ourNotificationGroup.createNotification(title,finalDescription,NotificationType.ERROR,null).notify(project);
    }
  }
);
}
