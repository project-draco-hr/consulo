def pop(self, repo, patch=None, force=False, update=True, all=False):

    def getfile(f, rev, flags):
        t = repo.file(f).read(rev)
        repo.wwrite(f, t, flags)
    wlock = repo.wlock()
    try:
        if patch:
            info = self.isapplied(patch)
            if (not info):
                patch = self.lookup(patch)
            info = self.isapplied(patch)
            if (not info):
                raise util.Abort((_('patch %s is not applied') % patch))
        if (len(self.applied) == 0):
            self.ui.warn(_('no patches applied\n'))
            return (not all)
        if all:
            start = 0
        elif patch:
            start = (info[0] + 1)
        else:
            start = (len(self.applied) - 1)
        if (start >= len(self.applied)):
            self.ui.warn((_('qpop: %s is already at the top\n') % patch))
            return
        if (not update):
            parents = repo.dirstate.parents()
            rr = [bin(x.rev) for x in self.applied]
            for p in parents:
                if (p in rr):
                    self.ui.warn(_('qpop: forcing dirstate update\n'))
                    update = True
        else:
            parents = [p.hex() for p in repo[None].parents()]
            needupdate = False
            for entry in self.applied[start:]:
                if (entry.rev in parents):
                    needupdate = True
                    break
            update = needupdate
        if ((not force) and update):
            self.check_localchanges(repo)
        self.applied_dirty = 1
        end = len(self.applied)
        rev = bin(self.applied[start].rev)
        if update:
            top = self.check_toppatch(repo)[0]
        try:
            heads = repo.changelog.heads(rev)
        except error.LookupError:
            node = short(rev)
            raise util.Abort((_('trying to pop unknown node %s') % node))
        if (heads != [bin(self.applied[(-1)].rev)]):
            raise util.Abort(_('popping would remove a revision not managed by this patch queue'))
        if update:
            qp = self.qparents(repo, rev)
            changes = repo.changelog.read(qp)
            mmap = repo.manifest.read(changes[0])
            (m, a, r, d) = repo.status(qp, top)[:4]
            if d:
                raise util.Abort(_('deletions found between repo revs'))
            for f in a:
                try:
                    util.unlink(repo.wjoin(f))
                except OSError as e:
                    if (e.errno != errno.ENOENT):
                        raise
                repo.dirstate.forget(f)
            for f in m:
                getfile(f, mmap[f], mmap.flags(f))
            for f in r:
                getfile(f, mmap[f], mmap.flags(f))
            for f in (m + r):
                repo.dirstate.normal(f)
            repo.dirstate.setparents(qp, nullid)
        for patch in reversed(self.applied[start:end]):
            self.ui.status((_('popping %s\n') % patch.name))
        del self.applied[start:end]
        self.strip(repo, rev, update=False, backup='strip')
        if len(self.applied):
            self.ui.write((_('now at: %s\n') % self.applied[(-1)].name))
        else:
            self.ui.write(_('patch queue now empty\n'))
    finally:
        wlock.release()
