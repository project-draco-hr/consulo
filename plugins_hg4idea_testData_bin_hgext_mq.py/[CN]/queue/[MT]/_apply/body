def _apply(self, repo, series, list=False, update_status=True, strict=False, patchdir=None, merge=None, all_files={}):
    'returns (error, hash)\n        error = 1 for unable to read, 2 for patch failed, 3 for patch fuzz'
    if (not patchdir):
        patchdir = self.path
    err = 0
    n = None
    for patchname in series:
        (pushable, reason) = self.pushable(patchname)
        if (not pushable):
            self.explain_pushable(patchname, all_patches=True)
            continue
        self.ui.status((_('applying %s\n') % patchname))
        pf = os.path.join(patchdir, patchname)
        try:
            ph = patchheader(self.join(patchname), self.plainmode)
        except:
            self.ui.warn((_('unable to read %s\n') % patchname))
            err = 1
            break
        message = ph.message
        if (not message):
            message = ('imported patch %s\n' % patchname)
        else:
            if list:
                message.append(('\nimported patch %s' % patchname))
            message = '\n'.join(message)
        if ph.haspatch:
            (patcherr, files, fuzz) = self.patch(repo, pf)
            all_files.update(files)
            patcherr = (not patcherr)
        else:
            self.ui.warn((_('patch %s is empty\n') % patchname))
            (patcherr, files, fuzz) = (0, [], 0)
        if (merge and files):
            removed = []
            merged = []
            for f in files:
                if os.path.exists(repo.wjoin(f)):
                    merged.append(f)
                else:
                    removed.append(f)
            for f in removed:
                repo.dirstate.remove(f)
            for f in merged:
                repo.dirstate.merge(f)
            (p1, p2) = repo.dirstate.parents()
            repo.dirstate.setparents(p1, merge)
        files = patch.updatedir(self.ui, repo, files)
        match = cmdutil.matchfiles(repo, (files or []))
        n = repo.commit(message, ph.user, ph.date, match=match, force=True)
        if (n is None):
            raise util.Abort(_('repo commit failed'))
        if update_status:
            self.applied.append(statusentry(hex(n), patchname))
        if patcherr:
            self.ui.warn(_('patch failed, rejects left in working dir\n'))
            err = 2
            break
        if (fuzz and strict):
            self.ui.warn(_('fuzz found when applying patch, stopping\n'))
            err = 3
            break
    return (err, n)
