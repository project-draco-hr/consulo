def restore(self, repo, rev, delete=None, qupdate=None):
    c = repo.changelog.read(rev)
    desc = c[4].strip()
    lines = desc.splitlines()
    i = 0
    datastart = None
    series = []
    applied = []
    qpp = None
    for (i, line) in enumerate(lines):
        if (line == 'Patch Data:'):
            datastart = (i + 1)
        elif line.startswith('Dirstate:'):
            l = line.rstrip()
            l = l[10:].split(' ')
            qpp = [bin(x) for x in l]
        elif (datastart != None):
            l = line.rstrip()
            se = statusentry(l)
            file_ = se.name
            if se.rev:
                applied.append(se)
            else:
                series.append(file_)
    if (datastart is None):
        self.ui.warn(_('No saved patch data found\n'))
        return 1
    self.ui.warn((_('restoring status: %s\n') % lines[0]))
    self.full_series = series
    self.applied = applied
    self.parse_series()
    self.series_dirty = 1
    self.applied_dirty = 1
    heads = repo.changelog.heads()
    if delete:
        if (rev not in heads):
            self.ui.warn(_('save entry has children, leaving it alone\n'))
        else:
            self.ui.warn((_('removing save entry %s\n') % short(rev)))
            pp = repo.dirstate.parents()
            if (rev in pp):
                update = True
            else:
                update = False
            self.strip(repo, rev, update=update, backup='strip')
    if qpp:
        self.ui.warn((_('saved queue repository parents: %s %s\n') % (short(qpp[0]), short(qpp[1]))))
        if qupdate:
            self.ui.status(_('queue directory updating\n'))
            r = self.qrepo()
            if (not r):
                self.ui.warn(_('Unable to load queue repository\n'))
                return 1
            hg.clean(r, qpp[0])
