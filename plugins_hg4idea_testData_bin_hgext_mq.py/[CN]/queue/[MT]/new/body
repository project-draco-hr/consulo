def new(self, repo, patchfn, *pats, **opts):
    'options:\n           msg: a string or a no-argument function returning a string\n        '
    msg = opts.get('msg')
    user = opts.get('user')
    date = opts.get('date')
    if date:
        date = util.parsedate(date)
    diffopts = self.diffopts({'git': opts.get('git'), })
    self.check_reserved_name(patchfn)
    if os.path.exists(self.join(patchfn)):
        raise util.Abort((_('patch "%s" already exists') % patchfn))
    if (opts.get('include') or opts.get('exclude') or pats):
        match = cmdutil.match(repo, pats, opts)

        def badfn(f, msg):
            raise util.Abort(('%s: %s' % (f, msg)))
        match.bad = badfn
        (m, a, r, d) = repo.status(match=match)[:4]
    else:
        (m, a, r, d) = self.check_localchanges(repo, force=True)
        match = cmdutil.matchfiles(repo, ((m + a) + r))
    if (len(repo[None].parents()) > 1):
        raise util.Abort(_('cannot manage merge changesets'))
    commitfiles = ((m + a) + r)
    self.check_toppatch(repo)
    insert = self.full_series_end()
    wlock = repo.wlock()
    try:
        p = self.opener(patchfn, 'w')
        try:
            if self.plainmode:
                if user:
                    p.write((('From: ' + user) + '\n'))
                    if (not date):
                        p.write('\n')
                if date:
                    p.write(('Date: %d %d\n\n' % date))
            else:
                p.write('# HG changeset patch\n')
                p.write((('# Parent ' + hex(repo[None].parents()[0].node())) + '\n'))
                if user:
                    p.write((('# User ' + user) + '\n'))
                if date:
                    p.write(('# Date %s %s\n\n' % date))
            if hasattr(msg, '__call__'):
                msg = msg()
            commitmsg = ((msg and msg) or ('[mq]: %s' % patchfn))
            n = repo.commit(commitmsg, user, date, match=match, force=True)
            if (n is None):
                raise util.Abort(_('repo commit failed'))
            try:
                self.full_series[insert:insert] = [patchfn]
                self.applied.append(statusentry(hex(n), patchfn))
                self.parse_series()
                self.series_dirty = 1
                self.applied_dirty = 1
                if msg:
                    msg = (msg + '\n\n')
                    p.write(msg)
                if commitfiles:
                    parent = self.qparents(repo, n)
                    chunks = patch.diff(repo, node1=parent, node2=n, match=match, opts=diffopts)
                    for chunk in chunks:
                        p.write(chunk)
                p.close()
                wlock.release()
                wlock = None
                r = self.qrepo()
                if r:
                    r.add([patchfn])
            except:
                repo.rollback()
                raise
        except Exception:
            patchpath = self.join(patchfn)
            try:
                os.unlink(patchpath)
            except:
                self.ui.warn((_('error unlinking %s\n') % patchpath))
            raise
        self.removeundo(repo)
    finally:
        release(wlock)
