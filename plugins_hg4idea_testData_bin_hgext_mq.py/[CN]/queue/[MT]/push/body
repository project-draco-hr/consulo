def push(self, repo, patch=None, force=False, list=False, mergeq=None, all=False):
    diffopts = self.diffopts()
    wlock = repo.wlock()
    try:
        heads = []
        for (b, ls) in repo.branchmap().iteritems():
            heads += ls
        if (not heads):
            heads = [nullid]
        if (repo.dirstate.parents()[0] not in heads):
            self.ui.status(_('(working directory not at a head)\n'))
        if (not self.series):
            self.ui.warn(_('no patches in series\n'))
            return 0
        patch = self.lookup(patch)
        if patch:
            info = self.isapplied(patch)
            if info:
                if (info[0] < (len(self.applied) - 1)):
                    raise util.Abort((_('cannot push to a previous patch: %s') % patch))
                self.ui.warn((_('qpush: %s is already at the top\n') % patch))
                return
            (pushable, reason) = self.pushable(patch)
            if (not pushable):
                if reason:
                    reason = (_('guarded by %r') % reason)
                else:
                    reason = _('no matching guards')
                self.ui.warn((_("cannot push '%s' - %s\n") % (patch, reason)))
                return 1
        elif all:
            patch = self.series[(-1)]
            if self.isapplied(patch):
                self.ui.warn(_('all patches are currently applied\n'))
                return 0
        start = self.series_end()
        if (start == len(self.series)):
            self.ui.warn(_('patch series already fully applied\n'))
            return 1
        if (not force):
            self.check_localchanges(repo)
        self.applied_dirty = 1
        if (start > 0):
            self.check_toppatch(repo)
        if (not patch):
            patch = self.series[start]
            end = (start + 1)
        else:
            end = (self.series.index(patch, start) + 1)
        s = self.series[start:end]
        all_files = {}
        try:
            if mergeq:
                ret = self.mergepatch(repo, mergeq, s, diffopts)
            else:
                ret = self.apply(repo, s, list, all_files=all_files)
        except:
            self.ui.warn(_('cleaning up working directory...'))
            node = repo.dirstate.parents()[0]
            hg.revert(repo, node, None)
            unknown = repo.status(unknown=True)[4]
            for f in unknown:
                if (f in all_files):
                    util.unlink(repo.wjoin(f))
            self.ui.warn(_('done\n'))
            raise
        if (not self.applied):
            return ret[0]
        top = self.applied[(-1)].name
        if (ret[0] and (ret[0] > 1)):
            msg = _('errors during apply, please fix and refresh %s\n')
            self.ui.write((msg % top))
        else:
            self.ui.write((_('now at: %s\n') % top))
        return ret[0]
    finally:
        wlock.release()
