def mergepatch(self, repo, mergeq, series, diffopts):
    if (len(self.applied) == 0):
        pname = '.hg.patches.merge.marker'
        n = repo.commit('[mq]: merge marker', force=True)
        self.removeundo(repo)
        self.applied.append(statusentry(hex(n), pname))
        self.applied_dirty = 1
    head = self.qparents(repo)
    for patch in series:
        patch = mergeq.lookup(patch, strict=True)
        if (not patch):
            self.ui.warn((_('patch %s does not exist\n') % patch))
            return (1, None)
        (pushable, reason) = self.pushable(patch)
        if (not pushable):
            self.explain_pushable(patch, all_patches=True)
            continue
        info = mergeq.isapplied(patch)
        if (not info):
            self.ui.warn((_('patch %s is not applied\n') % patch))
            return (1, None)
        rev = bin(info[1])
        (err, head) = self.mergeone(repo, mergeq, head, patch, rev, diffopts)
        if head:
            self.applied.append(statusentry(hex(head), patch))
            self.applied_dirty = 1
        if err:
            return (err, head)
    self.save_dirty()
    return (0, head)
