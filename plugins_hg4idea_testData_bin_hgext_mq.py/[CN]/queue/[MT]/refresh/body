def refresh(self, repo, pats=None, **opts):
    if (len(self.applied) == 0):
        self.ui.write(_('no patches applied\n'))
        return 1
    msg = opts.get('msg', '').rstrip()
    newuser = opts.get('user')
    newdate = opts.get('date')
    if newdate:
        newdate = ('%d %d' % util.parsedate(newdate))
    wlock = repo.wlock()
    try:
        self.check_toppatch(repo)
        (top, patchfn) = (self.applied[(-1)].rev, self.applied[(-1)].name)
        top = bin(top)
        if (repo.changelog.heads(top) != [top]):
            raise util.Abort(_('cannot refresh a revision with children'))
        cparents = repo.changelog.parents(top)
        patchparent = self.qparents(repo, top)
        ph = patchheader(self.join(patchfn), self.plainmode)
        diffopts = self.diffopts({'git': opts.get('git'), }, patchfn)
        if msg:
            ph.setmessage(msg)
        if newuser:
            ph.setuser(newuser)
        if newdate:
            ph.setdate(newdate)
        ph.setparent(hex(patchparent))
        patchf = self.opener(patchfn, 'w', atomictemp=True)
        comments = str(ph)
        if comments:
            patchf.write(comments)
        (mm, aa, dd, aa2) = repo.status(patchparent, top)[:4]
        changes = repo.changelog.read(top)
        man = repo.manifest.read(changes[0])
        aaa = aa[:]
        matchfn = cmdutil.match(repo, pats, opts)
        if opts.get('short'):
            match = cmdutil.matchfiles(repo, (((mm + aa) + dd) + matchfn.files()))
            matchfn = cmdutil.match(repo, opts=opts)
        else:
            match = cmdutil.matchall(repo)
        (m, a, r, d) = repo.status(match=match)[:4]
        for x in m:
            if (x not in aa):
                mm.append(x)
        for x in a:
            if (x in dd):
                del dd[dd.index(x)]
                mm.append(x)
            else:
                aa.append(x)
        forget = []
        for x in (d + r):
            if (x in aa):
                del aa[aa.index(x)]
                forget.append(x)
                continue
            elif (x in mm):
                del mm[mm.index(x)]
            dd.append(x)
        m = list(set(mm))
        r = list(set(dd))
        a = list(set(aa))
        c = [filter(matchfn, l) for l in (m, a, r)]
        match = cmdutil.matchfiles(repo, set(((c[0] + c[1]) + c[2])))
        chunks = patch.diff(repo, patchparent, match=match, changes=c, opts=diffopts)
        for chunk in chunks:
            patchf.write(chunk)
        try:
            if (diffopts.git or diffopts.upgrade):
                copies = {}
                for dst in a:
                    src = repo.dirstate.copied(dst)
                    if ((src is not None) and (src in repo.dirstate)):
                        copies.setdefault(src, []).append(dst)
                    repo.dirstate.add(dst)
                for dst in aaa:
                    f = repo.file(dst)
                    src = f.renamed(man[dst])
                    if src:
                        copies.setdefault(src[0], []).extend(copies.get(dst, []))
                        if (dst in a):
                            copies[src[0]].append(dst)
                    if (dst in copies):
                        del copies[dst]
                for (src, dsts) in copies.iteritems():
                    for dst in dsts:
                        repo.dirstate.copy(src, dst)
            else:
                for dst in a:
                    repo.dirstate.add(dst)
                for f in list(repo.dirstate.copies()):
                    repo.dirstate.copy(None, f)
            for f in r:
                repo.dirstate.remove(f)
            mm = []
            for i in xrange((len(m) - 1), (-1), (-1)):
                if (not matchfn(m[i])):
                    mm.append(m[i])
                    del m[i]
            for f in m:
                repo.dirstate.normal(f)
            for f in mm:
                repo.dirstate.normallookup(f)
            for f in forget:
                repo.dirstate.forget(f)
            if (not msg):
                if (not ph.message):
                    message = ('[mq]: %s\n' % patchfn)
                else:
                    message = '\n'.join(ph.message)
            else:
                message = msg
            user = (ph.user or changes[1])
            repo.dirstate.setparents(*cparents)
            self.applied.pop()
            self.applied_dirty = 1
            self.strip(repo, top, update=False, backup='strip')
        except:
            repo.dirstate.invalidate()
            raise
        try:
            patchf.rename()
            n = repo.commit(message, user, ph.date, match=match, force=True)
            self.applied.append(statusentry(hex(n), patchfn))
        except:
            ctx = repo[cparents[0]]
            repo.dirstate.rebuild(ctx.node(), ctx.manifest())
            self.save_dirty()
            self.ui.warn(_('refresh interrupted while patch was popped! (revert --all, qpush to recover)\n'))
            raise
    finally:
        wlock.release()
        self.removeundo(repo)
