def lookup(self, patch, strict=False):
    patch = (patch and str(patch))

    def partial_name(s):
        if (s in self.series):
            return s
        matches = [x for x in self.series if (s in x)]
        if (len(matches) > 1):
            self.ui.warn((_('patch name "%s" is ambiguous:\n') % s))
            for m in matches:
                self.ui.warn(('  %s\n' % m))
            return None
        if matches:
            return matches[0]
        if ((len(self.series) > 0) and (len(self.applied) > 0)):
            if (s == 'qtip'):
                return self.series[(self.series_end(True) - 1)]
            if (s == 'qbase'):
                return self.series[0]
        return None
    if (patch is None):
        return None
    if (patch in self.series):
        return patch
    if (not os.path.isfile(self.join(patch))):
        try:
            sno = int(patch)
        except (ValueError, OverflowError):
            pass
        else:
            if ((- len(self.series)) <= sno < len(self.series)):
                return self.series[sno]
        if (not strict):
            res = partial_name(patch)
            if res:
                return res
            minus = patch.rfind('-')
            if (minus >= 0):
                res = partial_name(patch[:minus])
                if res:
                    i = self.series.index(res)
                    try:
                        off = int((patch[(minus + 1):] or 1))
                    except (ValueError, OverflowError):
                        pass
                    else:
                        if ((i - off) >= 0):
                            return self.series[(i - off)]
            plus = patch.rfind('+')
            if (plus >= 0):
                res = partial_name(patch[:plus])
                if res:
                    i = self.series.index(res)
                    try:
                        off = int((patch[(plus + 1):] or 1))
                    except (ValueError, OverflowError):
                        pass
                    else:
                        if ((i + off) < len(self.series)):
                            return self.series[(i + off)]
    raise util.Abort((_('patch %s not in series') % patch))
