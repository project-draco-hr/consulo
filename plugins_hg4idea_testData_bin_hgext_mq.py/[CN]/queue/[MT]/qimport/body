def qimport(self, repo, files, patchname=None, rev=None, existing=None, force=None, git=False):

    def checkseries(patchname):
        if (patchname in self.series):
            raise util.Abort((_('patch %s is already in the series file') % patchname))

    def checkfile(patchname):
        if ((not force) and os.path.exists(self.join(patchname))):
            raise util.Abort((_('patch "%s" already exists') % patchname))
    if rev:
        if files:
            raise util.Abort(_('option "-r" not valid when importing files'))
        rev = cmdutil.revrange(repo, rev)
        rev.sort(reverse=True)
    if (((len(files) > 1) or (len(rev) > 1)) and patchname):
        raise util.Abort(_('option "-n" not valid when importing multiple patches'))
    i = 0
    added = []
    if rev:
        heads = repo.changelog.heads(repo.changelog.node(rev[(-1)]))
        if (len(heads) > 1):
            raise util.Abort((_('revision %d is the root of more than one branch') % rev[(-1)]))
        if self.applied:
            base = hex(repo.changelog.node(rev[0]))
            if (base in [n.rev for n in self.applied]):
                raise util.Abort((_('revision %d is already managed') % rev[0]))
            if (heads != [bin(self.applied[(-1)].rev)]):
                raise util.Abort((_('revision %d is not the parent of the queue') % rev[0]))
            base = repo.changelog.rev(bin(self.applied[0].rev))
            lastparent = repo.changelog.parentrevs(base)[0]
        else:
            if (heads != [repo.changelog.node(rev[0])]):
                raise util.Abort((_('revision %d has unmanaged children') % rev[0]))
            lastparent = None
        diffopts = self.diffopts({'git': git, })
        for r in rev:
            (p1, p2) = repo.changelog.parentrevs(r)
            n = repo.changelog.node(r)
            if (p2 != nullrev):
                raise util.Abort((_('cannot import merge revision %d') % r))
            if (lastparent and (lastparent != r)):
                raise util.Abort((_('revision %d is not the parent of %d') % (r, lastparent)))
            lastparent = p1
            if (not patchname):
                patchname = normname(('%d.diff' % r))
            self.check_reserved_name(patchname)
            checkseries(patchname)
            checkfile(patchname)
            self.full_series.insert(0, patchname)
            patchf = self.opener(patchname, 'w')
            patch.export(repo, [n], fp=patchf, opts=diffopts)
            patchf.close()
            se = statusentry(hex(n), patchname)
            self.applied.insert(0, se)
            added.append(patchname)
            patchname = None
        self.parse_series()
        self.applied_dirty = 1
    for filename in files:
        if existing:
            if (filename == '-'):
                raise util.Abort(_('-e is incompatible with import from -'))
            if (not patchname):
                patchname = normname(filename)
            self.check_reserved_name(patchname)
            if (not os.path.isfile(self.join(patchname))):
                raise util.Abort((_('patch %s does not exist') % patchname))
        else:
            try:
                if (filename == '-'):
                    if (not patchname):
                        raise util.Abort(_('need --name to import a patch from -'))
                    text = sys.stdin.read()
                else:
                    text = url.open(self.ui, filename).read()
            except (OSError, IOError):
                raise util.Abort((_('unable to read %s') % filename))
            if (not patchname):
                patchname = normname(os.path.basename(filename))
            self.check_reserved_name(patchname)
            checkfile(patchname)
            patchf = self.opener(patchname, 'w')
            patchf.write(text)
        if (not force):
            checkseries(patchname)
        if (patchname not in self.series):
            index = (self.full_series_end() + i)
            self.full_series[index:index] = [patchname]
        self.parse_series()
        self.ui.warn((_('adding %s to series file\n') % patchname))
        i += 1
        added.append(patchname)
        patchname = None
    self.series_dirty = 1
    qrepo = self.qrepo()
    if qrepo:
        qrepo.add(added)
