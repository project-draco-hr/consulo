def select(ui, repo, *args, **opts):
    'set or print guarded patches to push\n\n    Use the qguard command to set or print guards on patch, then use\n    qselect to tell mq which guards to use. A patch will be pushed if\n    it has no guards or any positive guards match the currently\n    selected guard, but will not be pushed if any negative guards\n    match the current guard. For example::\n\n        qguard foo.patch -stable    (negative guard)\n        qguard bar.patch +stable    (positive guard)\n        qselect stable\n\n    This activates the "stable" guard. mq will skip foo.patch (because\n    it has a negative match) but push bar.patch (because it has a\n    positive match).\n\n    With no arguments, prints the currently active guards.\n    With one argument, sets the active guard.\n\n    Use -n/--none to deactivate guards (no other arguments needed).\n    When no guards are active, patches with positive guards are\n    skipped and patches with negative guards are pushed.\n\n    qselect can change the guards on applied patches. It does not pop\n    guarded patches by default. Use --pop to pop back to the last\n    applied patch that is not guarded. Use --reapply (which implies\n    --pop) to push back to the current patch afterwards, but skip\n    guarded patches.\n\n    Use -s/--series to print a list of all guards in the series file\n    (no other arguments needed). Use -v for more information.'
    q = repo.mq
    guards = q.active()
    if (args or opts['none']):
        old_unapplied = q.unapplied(repo)
        old_guarded = [i for i in xrange(len(q.applied)) if (not q.pushable(i)[0])]
        q.set_active(args)
        q.save_dirty()
        if (not args):
            ui.status(_('guards deactivated\n'))
        if ((not opts['pop']) and (not opts['reapply'])):
            unapplied = q.unapplied(repo)
            guarded = [i for i in xrange(len(q.applied)) if (not q.pushable(i)[0])]
            if (len(unapplied) != len(old_unapplied)):
                ui.status((_('number of unguarded, unapplied patches has changed from %d to %d\n') % (len(old_unapplied), len(unapplied))))
            if (len(guarded) != len(old_guarded)):
                ui.status((_('number of guarded, applied patches has changed from %d to %d\n') % (len(old_guarded), len(guarded))))
    elif opts['series']:
        guards = {}
        noguards = 0
        for gs in q.series_guards:
            if (not gs):
                noguards += 1
            for g in gs:
                guards.setdefault(g, 0)
                guards[g] += 1
        if ui.verbose:
            guards['NONE'] = noguards
        guards = guards.items()
        guards.sort(key=(lambda x: x[0][1:]))
        if guards:
            ui.note(_('guards in series file:\n'))
            for (guard, count) in guards:
                ui.note(('%2d  ' % count))
                ui.write(guard, '\n')
        else:
            ui.note(_('no guards in series file\n'))
    elif guards:
        ui.note(_('active guards:\n'))
        for g in guards:
            ui.write(g, '\n')
    else:
        ui.write(_('no active guards\n'))
    reapply = (opts['reapply'] and q.applied and q.appliedname((-1)))
    popped = False
    if (opts['pop'] or opts['reapply']):
        for i in xrange(len(q.applied)):
            (pushable, reason) = q.pushable(i)
            if (not pushable):
                ui.status(_('popping guarded patches\n'))
                popped = True
                if (i == 0):
                    q.pop(repo, all=True)
                else:
                    q.pop(repo, (i - 1))
                break
    if popped:
        try:
            if reapply:
                ui.status(_('reapplying unguarded patches\n'))
                q.push(repo, reapply)
        finally:
            q.save_dirty()
