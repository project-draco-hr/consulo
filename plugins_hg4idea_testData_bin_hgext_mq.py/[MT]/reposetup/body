def reposetup(ui, repo):


    class mqrepo(repo.__class__):

        @util.propertycache
        def mq(self):
            return queue(self.ui, self.join(''))

        def abort_if_wdir_patched(self, errmsg, force=False):
            if (self.mq.applied and (not force)):
                parent = hex(self.dirstate.parents()[0])
                if (parent in [s.rev for s in self.mq.applied]):
                    raise util.Abort(errmsg)

        def commit(self, text='', user=None, date=None, match=None, force=False, editor=False, extra={}):
            self.abort_if_wdir_patched(_('cannot commit over an applied mq patch'), force)
            return super(mqrepo, self).commit(text, user, date, match, force, editor, extra)

        def push(self, remote, force=False, revs=None):
            if (self.mq.applied and (not force) and (not revs)):
                raise util.Abort(_('source has mq patches applied'))
            return super(mqrepo, self).push(remote, force, revs)

        def _findtags(self):
            'augment tags from base class with patch tags'
            result = super(mqrepo, self)._findtags()
            q = self.mq
            if (not q.applied):
                return result
            mqtags = [(bin(patch.rev), patch.name) for patch in q.applied]
            if (mqtags[(-1)][0] not in self.changelog.nodemap):
                self.ui.warn((_('mq status file refers to unknown node %s\n') % short(mqtags[(-1)][0])))
                return result
            mqtags.append((mqtags[(-1)][0], 'qtip'))
            mqtags.append((mqtags[0][0], 'qbase'))
            mqtags.append((self.changelog.parents(mqtags[0][0])[0], 'qparent'))
            tags = result[0]
            for patch in mqtags:
                if (patch[1] in tags):
                    self.ui.warn((_('Tag %s overrides mq patch of the same name\n') % patch[1]))
                else:
                    tags[patch[1]] = patch[0]
            return result

        def _branchtags(self, partial, lrev):
            q = self.mq
            if (not q.applied):
                return super(mqrepo, self)._branchtags(partial, lrev)
            cl = self.changelog
            qbasenode = bin(q.applied[0].rev)
            if (qbasenode not in cl.nodemap):
                self.ui.warn((_('mq status file refers to unknown node %s\n') % short(qbasenode)))
                return super(mqrepo, self)._branchtags(partial, lrev)
            qbase = cl.rev(qbasenode)
            start = (lrev + 1)
            if (start < qbase):
                ctxgen = (self[r] for r in xrange((lrev + 1), qbase))
                self._updatebranchcache(partial, ctxgen)
                self._writebranchcache(partial, cl.node((qbase - 1)), (qbase - 1))
                start = qbase
            ctxgen = (self[r] for r in xrange(start, len(cl)))
            self._updatebranchcache(partial, ctxgen)
            return partial
    if repo.local():
        repo.__class__ = mqrepo
