def new(ui, repo, patch, *args, **opts):
    "create a new patch\n\n    qnew creates a new patch on top of the currently-applied patch (if\n    any). The patch will be initialized with any outstanding changes\n    in the working directory. You may also use -I/--include,\n    -X/--exclude, and/or a list of files after the patch name to add\n    only changes to matching files to the new patch, leaving the rest\n    as uncommitted modifications.\n\n    -u/--user and -d/--date can be used to set the (given) user and\n    date, respectively. -U/--currentuser and -D/--currentdate set user\n    to current user and date to current date.\n\n    -e/--edit, -m/--message or -l/--logfile set the patch header as\n    well as the commit message. If none is specified, the header is\n    empty and the commit message is '[mq]: PATCH'.\n\n    Use the -g/--git option to keep the patch in the git extended diff\n    format. Read the diffs help topic for more information on why this\n    is important for preserving permission changes and copy/rename\n    information.\n    "
    msg = cmdutil.logmessage(opts)

    def getmsg():
        return ui.edit(msg, ui.username())
    q = repo.mq
    opts['msg'] = msg
    if opts.get('edit'):
        opts['msg'] = getmsg
    else:
        opts['msg'] = msg
    setupheaderopts(ui, opts)
    q.new(repo, patch, *args, **opts)
    q.save_dirty()
    return 0
