def rename(ui, repo, patch, name=None, **opts):
    'rename a patch\n\n    With one argument, renames the current patch to PATCH1.\n    With two arguments, renames PATCH1 to PATCH2.'
    q = repo.mq
    if (not name):
        name = patch
        patch = None
    if patch:
        patch = q.lookup(patch)
    else:
        if (not q.applied):
            ui.write(_('no patches applied\n'))
            return
        patch = q.lookup('qtip')
    absdest = q.join(name)
    if os.path.isdir(absdest):
        name = normname(os.path.join(name, os.path.basename(patch)))
        absdest = q.join(name)
    if os.path.exists(absdest):
        raise util.Abort((_('%s already exists') % absdest))
    if (name in q.series):
        raise util.Abort((_('A patch named %s already exists in the series file') % name))
    ui.note((_('renaming %s to %s\n') % (patch, name)))
    i = q.find_series(patch)
    guards = q.guard_re.findall(q.full_series[i])
    q.full_series[i] = (name + ''.join([(' #' + g) for g in guards]))
    q.parse_series()
    q.series_dirty = 1
    info = q.isapplied(patch)
    if info:
        q.applied[info[0]] = statusentry(info[1], name)
    q.applied_dirty = 1
    util.rename(q.join(patch), absdest)
    r = q.qrepo()
    if r:
        wlock = r.wlock()
        try:
            if (r.dirstate[patch] == 'a'):
                r.dirstate.forget(patch)
                r.dirstate.add(name)
            else:
                if (r.dirstate[name] == 'r'):
                    r.undelete([name])
                r.copy(patch, name)
                r.remove([patch], False)
        finally:
            wlock.release()
    q.save_dirty()
