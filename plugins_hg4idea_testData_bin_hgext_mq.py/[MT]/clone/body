def clone(ui, source, dest=None, **opts):
    'clone main and patch repository at same time\n\n    If source is local, destination will have no patches applied. If\n    source is remote, this command can not check if patches are\n    applied in source, so cannot guarantee that patches are not\n    applied in destination. If you clone remote repository, be sure\n    before that it has no patches applied.\n\n    Source patch repository is looked for in <src>/.hg/patches by\n    default. Use -p <url> to change.\n\n    The patch directory must be a nested Mercurial repository, as\n    would be created by init --mq.\n    '

    def patchdir(repo):
        url = repo.url()
        if url.endswith('/'):
            url = url[:(-1)]
        return (url + '/.hg/patches')
    if (dest is None):
        dest = hg.defaultdest(source)
    sr = hg.repository(cmdutil.remoteui(ui, opts), ui.expandpath(source))
    if opts['patches']:
        patchespath = ui.expandpath(opts['patches'])
    else:
        patchespath = patchdir(sr)
    try:
        hg.repository(ui, patchespath)
    except error.RepoError:
        raise util.Abort(_('versioned patch repository not found (see init --mq)'))
    (qbase, destrev) = (None, None)
    if sr.local():
        if sr.mq.applied:
            qbase = bin(sr.mq.applied[0].rev)
            if (not hg.islocal(dest)):
                heads = set(sr.heads())
                destrev = list(heads.difference(sr.heads(qbase)))
                destrev.append(sr.changelog.parents(qbase)[0])
    elif sr.capable('lookup'):
        try:
            qbase = sr.lookup('qbase')
        except error.RepoError:
            pass
    ui.note(_('cloning main repository\n'))
    (sr, dr) = hg.clone(ui, sr.url(), dest, pull=opts['pull'], rev=destrev, update=False, stream=opts['uncompressed'])
    ui.note(_('cloning patch repository\n'))
    hg.clone(ui, (opts['patches'] or patchdir(sr)), patchdir(dr), pull=opts['pull'], update=(not opts['noupdate']), stream=opts['uncompressed'])
    if dr.local():
        if qbase:
            ui.note(_('stripping applied patches from destination repository\n'))
            dr.mq.strip(dr, qbase, update=False, backup=None)
        if (not opts['noupdate']):
            ui.note(_('updating destination repository\n'))
            hg.update(dr, dr.changelog.tip())
