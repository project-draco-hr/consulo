def guard(ui, repo, *args, **opts):
    'set or print guards for a patch\n\n    Guards control whether a patch can be pushed. A patch with no\n    guards is always pushed. A patch with a positive guard ("+foo") is\n    pushed only if the qselect command has activated it. A patch with\n    a negative guard ("-foo") is never pushed if the qselect command\n    has activated it.\n\n    With no arguments, print the currently active guards.\n    With arguments, set guards for the named patch.\n    NOTE: Specifying negative guards now requires \'--\'.\n\n    To set guards on another patch::\n\n      hg qguard other.patch -- +2.6.17 -stable\n    '

    def status(idx):
        guards = (q.series_guards[idx] or ['unguarded'])
        ui.write(('%s: %s\n' % (q.series[idx], ' '.join(guards))))
    q = repo.mq
    patch = None
    args = list(args)
    if opts['list']:
        if (args or opts['none']):
            raise util.Abort(_('cannot mix -l/--list with options or arguments'))
        for i in xrange(len(q.series)):
            status(i)
        return
    if ((not args) or (args[0][0:1] in '-+')):
        if (not q.applied):
            raise util.Abort(_('no patches applied'))
        patch = q.applied[(-1)].name
    if ((patch is None) and (args[0][0:1] not in '-+')):
        patch = args.pop(0)
    if (patch is None):
        raise util.Abort(_('no patch to work with'))
    if (args or opts['none']):
        idx = q.find_series(patch)
        if (idx is None):
            raise util.Abort((_('no patch named %s') % patch))
        q.set_guards(idx, args)
        q.save_dirty()
    else:
        status(q.series.index(q.lookup(patch)))
