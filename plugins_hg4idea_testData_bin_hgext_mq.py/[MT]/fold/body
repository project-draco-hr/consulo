def fold(ui, repo, *files, **opts):
    "fold the named patches into the current patch\n\n    Patches must not yet be applied. Each patch will be successively\n    applied to the current patch in the order given. If all the\n    patches apply successfully, the current patch will be refreshed\n    with the new cumulative patch, and the folded patches will be\n    deleted. With -k/--keep, the folded patch files will not be\n    removed afterwards.\n\n    The header for each folded patch will be concatenated with the\n    current patch header, separated by a line of '* * *'."
    q = repo.mq
    if (not files):
        raise util.Abort(_('qfold requires at least one patch name'))
    if (not q.check_toppatch(repo)[0]):
        raise util.Abort(_('No patches applied'))
    q.check_localchanges(repo)
    message = cmdutil.logmessage(opts)
    if opts['edit']:
        if message:
            raise util.Abort(_('option "-e" incompatible with "-m" or "-l"'))
    parent = q.lookup('qtip')
    patches = []
    messages = []
    for f in files:
        p = q.lookup(f)
        if ((p in patches) or (p == parent)):
            ui.warn((_('Skipping already folded patch %s') % p))
        if q.isapplied(p):
            raise util.Abort((_('qfold cannot fold already applied patch %s') % p))
        patches.append(p)
    for p in patches:
        if (not message):
            ph = patchheader(q.join(p), q.plainmode)
            if ph.message:
                messages.append(ph.message)
        pf = q.join(p)
        (patchsuccess, files, fuzz) = q.patch(repo, pf)
        if (not patchsuccess):
            raise util.Abort((_('Error folding patch %s') % p))
        patch.updatedir(ui, repo, files)
    if (not message):
        ph = patchheader(q.join(parent), q.plainmode)
        (message, user) = (ph.message, ph.user)
        for msg in messages:
            message.append('* * *')
            message.extend(msg)
        message = '\n'.join(message)
    if opts['edit']:
        message = ui.edit(message, (user or ui.username()))
    diffopts = q.patchopts(q.diffopts(), *patches)
    q.refresh(repo, msg=message, git=diffopts.git)
    q.delete(repo, patches, opts)
    q.save_dirty()
