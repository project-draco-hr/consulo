'manage a stack of patches\n\nThis extension lets you work with a stack of patches in a Mercurial\nrepository. It manages two stacks of patches - all known patches, and\napplied patches (subset of known patches).\n\nKnown patches are represented as patch files in the .hg/patches\ndirectory. Applied patches are both patch files and changesets.\n\nCommon tasks (use "hg help command" for more details)::\n\n  create new patch                          qnew\n  import existing patch                     qimport\n\n  print patch series                        qseries\n  print applied patches                     qapplied\n\n  add known patch to applied stack          qpush\n  remove patch from applied stack           qpop\n  refresh contents of top applied patch     qrefresh\n\nBy default, mq will automatically use git patches when required to\navoid losing file mode changes, copy records, binary files or empty\nfiles creations or deletions. This behaviour can be configured with::\n\n  [mq]\n  git = auto/keep/yes/no\n\nIf set to \'keep\', mq will obey the [diff] section configuration while\npreserving existing git patches upon qrefresh. If set to \'yes\' or\n\'no\', mq will override the [diff] section and always generate git or\nregular patches, possibly losing data in the second case.\n'
from mercurial.i18n import _
from mercurial.node import bin, hex, short, nullid, nullrev
from mercurial.lock import release
from mercurial import commands, cmdutil, hg, patch, util
from mercurial import repair, extensions, url, error
import os, sys, re, errno
commands.norepo += ' qclone'
normname = util.normpath
seriesopts = [('s', 'summary', None, _('print first line of patch header'))]
cmdtable = {'qapplied': (applied, ([('1', 'last', None, _('show only the last patch'))] + seriesopts), _('hg qapplied [-1] [-s] [PATCH]')), 'qclone': (clone, ([('', 'pull', None, _('use pull protocol to copy metadata')), ('U', 'noupdate', None, _('do not update the new working directories')), ('', 'uncompressed', None, _('use uncompressed transfer (fast over LAN)')), ('p', 'patches', '', _('location of source patch repository'))] + commands.remoteopts), _('hg qclone [OPTION]... SOURCE [DEST]')), 'qcommit|qci': (commit, commands.table['^commit|ci'][1], _('hg qcommit [OPTION]... [FILE]...')), '^qdiff': (diff, ((commands.diffopts + commands.diffopts2) + commands.walkopts), _('hg qdiff [OPTION]... [FILE]...')), 'qdelete|qremove|qrm': (delete, [('k', 'keep', None, _('keep patch file')), ('r', 'rev', [], _('stop managing a revision (DEPRECATED)'))], _('hg qdelete [-k] [-r REV]... [PATCH]...')), 'qfold': (fold, ([('e', 'edit', None, _('edit patch header')), ('k', 'keep', None, _('keep folded patch files'))] + commands.commitopts), _('hg qfold [-e] [-k] [-m TEXT] [-l FILE] PATCH...')), 'qgoto': (goto, [('f', 'force', None, _('overwrite any local changes'))], _('hg qgoto [OPTION]... PATCH')), 'qguard': (guard, [('l', 'list', None, _('list all patches and guards')), ('n', 'none', None, _('drop all guards'))], _('hg qguard [-l] [-n] [PATCH] [-- [+GUARD]... [-GUARD]...]')), 'qheader': (header, [], _('hg qheader [PATCH]')), '^qimport': (qimport, [('e', 'existing', None, _('import file in patch directory')), ('n', 'name', '', _('name of patch file')), ('f', 'force', None, _('overwrite existing files')), ('r', 'rev', [], _('place existing revisions under mq control')), ('g', 'git', None, _('use git extended diff format')), ('P', 'push', None, _('qpush after importing'))], _('hg qimport [-e] [-n NAME] [-f] [-g] [-P] [-r REV]... FILE...')), '^qinit': (init, [('c', 'create-repo', None, _('create queue repository'))], _('hg qinit [-c]')), 'qnew': (new, (([('e', 'edit', None, _('edit commit message')), ('f', 'force', None, _('import uncommitted changes (DEPRECATED)')), ('g', 'git', None, _('use git extended diff format')), ('U', 'currentuser', None, _('add "From: <current user>" to patch')), ('u', 'user', '', _('add "From: <given user>" to patch')), ('D', 'currentdate', None, _('add "Date: <current date>" to patch')), ('d', 'date', '', _('add "Date: <given date>" to patch'))] + commands.walkopts) + commands.commitopts), _('hg qnew [-e] [-m TEXT] [-l FILE] PATCH [FILE]...')), 'qnext': (next, ([] + seriesopts), _('hg qnext [-s]')), 'qprev': (prev, ([] + seriesopts), _('hg qprev [-s]')), '^qpop': (pop, [('a', 'all', None, _('pop all patches')), ('n', 'name', '', _('queue name to pop (DEPRECATED)')), ('f', 'force', None, _('forget any local changes to patched files'))], _('hg qpop [-a] [-n NAME] [-f] [PATCH | INDEX]')), '^qpush': (push, [('f', 'force', None, _('apply if the patch has rejects')), ('l', 'list', None, _('list patch name in commit text')), ('a', 'all', None, _('apply all patches')), ('m', 'merge', None, _('merge from another queue (DEPRECATED)')), ('n', 'name', '', _('merge queue name (DEPRECATED)'))], _('hg qpush [-f] [-l] [-a] [-m] [-n NAME] [PATCH | INDEX]')), '^qrefresh': (refresh, (([('e', 'edit', None, _('edit commit message')), ('g', 'git', None, _('use git extended diff format')), ('s', 'short', None, _('refresh only files already in the patch and specified files')), ('U', 'currentuser', None, _('add/update author field in patch with current user')), ('u', 'user', '', _('add/update author field in patch with given user')), ('D', 'currentdate', None, _('add/update date field in patch with current date')), ('d', 'date', '', _('add/update date field in patch with given date'))] + commands.walkopts) + commands.commitopts), _('hg qrefresh [-I] [-X] [-e] [-m TEXT] [-l FILE] [-s] [FILE]...')), 'qrename|qmv': (rename, [], _('hg qrename PATCH1 [PATCH2]')), 'qrestore': (restore, [('d', 'delete', None, _('delete save entry')), ('u', 'update', None, _('update queue working directory'))], _('hg qrestore [-d] [-u] REV')), 'qsave': (save, ([('c', 'copy', None, _('copy patch directory')), ('n', 'name', '', _('copy directory name')), ('e', 'empty', None, _('clear queue status file')), ('f', 'force', None, _('force copy'))] + commands.commitopts), _('hg qsave [-m TEXT] [-l FILE] [-c] [-n NAME] [-e] [-f]')), 'qselect': (select, [('n', 'none', None, _('disable all guards')), ('s', 'series', None, _('list all guards in series file')), ('', 'pop', None, _('pop to before first guarded applied patch')), ('', 'reapply', None, _('pop, then reapply patches'))], _('hg qselect [OPTION]... [GUARD]...')), 'qseries': (series, ([('m', 'missing', None, _('print patches not in series'))] + seriesopts), _('hg qseries [-ms]')), '^strip': (strip, [('f', 'force', None, _('force removal of changesets even if the working directory has uncommitted changes')), ('b', 'backup', None, _('bundle only changesets with local revision number greater than REV which are not descendants of REV (DEPRECATED)')), ('n', 'nobackup', None, _('no backups'))], _('hg strip [-f] [-b] [-n] REV')), 'qtop': (top, ([] + seriesopts), _('hg qtop [-s]')), 'qunapplied': (unapplied, ([('1', 'first', None, _('show only the first patch'))] + seriesopts), _('hg qunapplied [-1] [-s] [PATCH]')), 'qfinish': (finish, [('a', 'applied', None, _('finish all applied changesets'))], _('hg qfinish [-a] [REV]...')), }
