{
  final GitVcs vcs=GitVcs.getInstance(project);
  final AbstractVcsHelper vcsHelper=AbstractVcsHelper.getInstance(project);
  if (vcs == null) {
    return MergeResult.CANCEL_UPDATE;
  }
  final AtomicReference<MergeResult> mergeDecision=new AtomicReference<MergeResult>(MergeResult.ALL_MERGED);
  final AtomicReference<VcsException> ex=new AtomicReference<VcsException>();
  UIUtil.invokeAndWaitIfNeeded(new Runnable(){
    public void run(){
      try {
        List<VirtualFile> unmergedFiles=GitChangeUtils.unmergedFiles(project,root);
        while (unmergedFiles.size() != 0) {
          vcsHelper.showMergeDialog(unmergedFiles,reverse ? vcs.getReverseMergeProvider() : vcs.getMergeProvider());
          unmergedFiles=GitChangeUtils.unmergedFiles(project,root);
          if (unmergedFiles.size() != 0) {
            int decision=Messages.showDialog(project,"There are unresolved merges. Would you like to continue merging, merge later by hands or cancel the update","Unresolved merges",new String[]{"Cancel update","Merge later","Merge now"},2,Messages.getErrorIcon());
            if (decision == 0) {
              mergeDecision.set(MergeResult.CANCEL_UPDATE);
              return;
            }
 else             if (decision == 1) {
              mergeDecision.set(MergeResult.MERGE_LATER);
              return;
            }
          }
        }
      }
 catch (      VcsException t) {
        ex.set(t);
      }
    }
  }
);
  if (ex.get() != null) {
    throw ex.get();
  }
  return mergeDecision.get();
}
