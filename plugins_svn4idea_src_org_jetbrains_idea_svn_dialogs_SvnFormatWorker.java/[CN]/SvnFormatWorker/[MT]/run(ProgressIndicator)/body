{
  ProjectLevelVcsManager.getInstanceChecked(myProject).startBackgroundVcsOperation();
  indicator.setIndeterminate(true);
  final boolean supportsChangelists=myNewFormat.supportsChangelists();
  if (supportsChangelists) {
    myBeforeChangeLists=ChangeListManager.getInstance(myProject).getChangeListsCopy();
  }
  final SVNWCClient wcClient=myVcs.createWCClient();
  wcClient.setEventHandler(new ISVNEventHandler(){
    @Override public void handleEvent(    SVNEvent event,    double progress) throws SVNException {
      if (SVNEventAction.UPGRADED_PATH.equals(event.getAction()) && event.getFile() != null) {
        indicator.setText2("Upgraded path " + VcsUtil.getPathForProgressPresentation(event.getFile()));
      }
    }
    @Override public void checkCancelled() throws SVNCancelException {
      indicator.checkCanceled();
    }
  }
);
  try {
    for (    WCInfo wcInfo : myWcInfos) {
      File path=new File(wcInfo.getPath());
      if (!wcInfo.isIsWcRoot()) {
        path=SvnUtil.getWorkingCopyRoot(path);
      }
      try {
        if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(myNewFormat)) {
          indicator.setText(SvnBundle.message("action.Subversion.cleanup.progress.text",path.getAbsolutePath()));
          wcClient.doCleanup(path);
        }
        indicator.setText(SvnBundle.message("action.change.wcopy.format.task.progress.text",path.getAbsolutePath(),SvnUtil.formatRepresentation(wcInfo.getFormat()),SvnUtil.formatRepresentation(myNewFormat)));
        wcClient.doSetWCFormat(path,myNewFormat.getFormat());
      }
 catch (      Throwable e) {
        myExceptions.add(e);
      }
    }
  }
  finally {
    ProjectLevelVcsManager.getInstance(myProject).stopBackgroundVcsOperation();
    if (supportsChangelists) {
      SvnVcs.getInstance(myProject).processChangeLists(myBeforeChangeLists);
    }
    ApplicationManager.getApplication().getMessageBus().syncPublisher(SvnVcs.WC_CONVERTED).run();
  }
}
