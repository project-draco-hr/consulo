{
  super.visitMethodCallExpression(expression);
  final PsiMethod method=expression.resolveMethod();
  if (method == null) {
    return;
  }
  final PsiClass calledClass=method.getContainingClass();
  if (currentClass.equals(calledClass)) {
    return;
  }
  final Set overAccessedClasses=m_overAccessedClasses;
  if (overAccessedClasses.contains(calledClass)) {
    return;
  }
  if (LibraryUtil.classIsInLibrary(calledClass)) {
    return;
  }
  if (PsiTreeUtil.isAncestor(currentClass,calledClass,true)) {
    return;
  }
  if (PsiTreeUtil.isAncestor(calledClass,currentClass,true)) {
    return;
  }
  PsiClass lexicallyEnclosingClass=currentClass;
  while (lexicallyEnclosingClass != null) {
    if (lexicallyEnclosingClass.isInheritor(calledClass,true)) {
      return;
    }
    lexicallyEnclosingClass=(PsiClass)PsiTreeUtil.getParentOfType(lexicallyEnclosingClass,PsiClass.class);
  }
  final Map accessCounts=m_accessCounts;
  final Integer count=(Integer)accessCounts.get(calledClass);
  if (count == null) {
    accessCounts.put(calledClass,ONE);
  }
 else   if (count.equals(ONE)) {
    accessCounts.put(calledClass,TWO);
  }
 else {
    overAccessedClasses.add(calledClass);
  }
}
