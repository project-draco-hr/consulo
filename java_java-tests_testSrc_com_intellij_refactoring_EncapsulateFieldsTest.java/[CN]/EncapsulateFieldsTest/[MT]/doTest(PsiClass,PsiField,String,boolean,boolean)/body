{
  try {
    final Project project=aClass.getProject();
    EncapsulateFieldsProcessor processor=new EncapsulateFieldsProcessor(project,new EncapsulateFieldsDescriptor(){
      @Override public PsiField[] getSelectedFields(){
        return new PsiField[]{field};
      }
      @Override public String[] getGetterNames(){
        return new String[]{PropertyUtil.suggestGetterName(project,field)};
      }
      @Override public String[] getSetterNames(){
        return new String[]{PropertyUtil.suggestSetterName(project,field)};
      }
      @Override @Nullable public PsiMethod[] getGetterPrototypes(){
        return isToEncapsulateGet() ? new PsiMethod[]{PropertyUtil.generateGetterPrototype(field)} : null;
      }
      @Override @Nullable public PsiMethod[] getSetterPrototypes(){
        return isToEncapsulateSet() ? new PsiMethod[]{PropertyUtil.generateSetterPrototype(field)} : null;
      }
      @Override public boolean isToEncapsulateGet(){
        return generateGetters;
      }
      @Override public boolean isToEncapsulateSet(){
        return generateSetters;
      }
      @Override public boolean isToUseAccessorsWhenAccessible(){
        return true;
      }
      @Override public String getFieldsVisibility(){
        return null;
      }
      @Override public String getAccessorsVisibility(){
        return PsiModifier.PUBLIC;
      }
      @Override public int getJavadocPolicy(){
        return DocCommentPolicy.MOVE;
      }
    }
);
    processor.run();
    LocalFileSystem.getInstance().refresh(false);
    FileDocumentManager.getInstance().saveAllDocuments();
  }
 catch (  BaseRefactoringProcessor.ConflictsInTestsException e) {
    if (conflicts != null) {
      Assert.assertEquals(conflicts,e.getMessage());
      return;
    }
 else {
      e.printStackTrace();
      fail(e.getMessage());
    }
  }
  if (conflicts != null) {
    fail("Conflicts were not detected: " + conflicts);
  }
}
