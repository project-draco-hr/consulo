{
  final CachedRefs refs=new CachedRefs();
  GitRepository repository=myProject == null || myProject.isDefault() ? null : GitUtil.getRepositoryManager(myProject).getRepositoryForRoot(myRoot);
  if (repository == null) {
    final File child=new File(myRoot.getPath(),GitUtil.DOT_GIT);
    if (!child.exists()) {
      throw new VcsException("No git repository in " + myRoot.getPath());
    }
    repository=GitRepositoryImpl.getLightInstance(myRoot,myProject,ServiceManager.getService(myProject,GitPlatformFacade.class),myProject);
    repository.update();
    repository.getBranches();
  }
  GitBranchesCollection branches=repository.getBranches();
  refs.setCollection(branches);
  final GitBranch current=repository.getCurrentBranch();
  refs.setCurrentBranch(current);
  if (current != null) {
    final Collection<GitBranchTrackInfo> infos=repository.getBranchTrackInfos();
    for (    GitBranchTrackInfo info : infos) {
      if (info.getLocalBranch().equals(current)) {
        String fullName=info.getRemoteBranch().getFullName();
        fullName=fullName.startsWith(GitBranch.REFS_REMOTES_PREFIX) ? fullName.substring(GitBranch.REFS_REMOTES_PREFIX.length()) : fullName;
        refs.setTrackedRemoteName(fullName);
        break;
      }
    }
  }
  refs.setUsername(GitConfigUtil.getValue(myProject,myRoot,GitConfigUtil.USER_NAME));
  final String head=repository.getCurrentRevision();
  if (head != null) {
    refs.setHeadHash(AbstractHash.create(head));
  }
  return refs;
}
