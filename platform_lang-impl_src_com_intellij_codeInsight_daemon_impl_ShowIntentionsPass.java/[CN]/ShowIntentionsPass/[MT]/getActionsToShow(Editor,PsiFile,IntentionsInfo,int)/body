{
  final PsiElement psiElement=hostFile.findElementAt(hostEditor.getCaretModel().getOffset());
  LOG.assertTrue(psiElement == null || psiElement.isValid(),psiElement);
  int offset=hostEditor.getCaretModel().getOffset();
  final Project project=hostFile.getProject();
  List<HighlightInfo.IntentionActionDescriptor> fixes=getAvailableActions(hostEditor,hostFile,passIdToShowIntentionsFor);
  final DaemonCodeAnalyzer codeAnalyzer=DaemonCodeAnalyzer.getInstance(project);
  final Document hostDocument=hostEditor.getDocument();
  HighlightInfo infoAtCursor=((DaemonCodeAnalyzerImpl)codeAnalyzer).findHighlightByOffset(hostDocument,offset,true);
  if (infoAtCursor == null) {
    intentions.errorFixesToShow.addAll(fixes);
  }
 else {
    final boolean isError=infoAtCursor.getSeverity() == HighlightSeverity.ERROR;
    for (    HighlightInfo.IntentionActionDescriptor fix : fixes) {
      if (fix.isError() && isError) {
        intentions.errorFixesToShow.add(fix);
      }
 else {
        intentions.inspectionFixesToShow.add(fix);
      }
    }
  }
  for (  final IntentionAction action : IntentionManager.getInstance().getAvailableIntentionActions()) {
    Pair<PsiFile,Editor> place=ShowIntentionActionsHandler.chooseBetweenHostAndInjected(hostFile,hostEditor,new PairProcessor<PsiFile,Editor>(){
      @Override public boolean process(      PsiFile psiFile,      Editor editor){
        return ShowIntentionActionsHandler.availableFor(psiFile,editor,action);
      }
    }
);
    if (place != null) {
      List<IntentionAction> enableDisableIntentionAction=new ArrayList<IntentionAction>();
      enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));
      enableDisableIntentionAction.add(new IntentionHintComponent.EditIntentionSettingsAction(action));
      HighlightInfo.IntentionActionDescriptor descriptor=new HighlightInfo.IntentionActionDescriptor(action,enableDisableIntentionAction,null);
      if (!fixes.contains(descriptor)) {
        intentions.intentionsToShow.add(descriptor);
      }
    }
  }
  final int line=hostDocument.getLineNumber(offset);
  MarkupModelEx model=(MarkupModelEx)DocumentMarkupModel.forDocument(hostDocument,project,true);
  model.processRangeHighlightersOverlappingWith(hostDocument.getLineStartOffset(line),hostDocument.getLineEndOffset(line),new Processor<RangeHighlighterEx>(){
    @Override public boolean process(    RangeHighlighterEx highlighter){
      GutterIntentionAction.addActions(project,hostEditor,hostFile,highlighter,intentions.guttersToShow);
      return true;
    }
  }
);
  boolean cleanup=appendCleanupCode(intentions.inspectionFixesToShow,hostFile);
  if (!cleanup) {
    appendCleanupCode(intentions.errorFixesToShow,hostFile);
  }
}
