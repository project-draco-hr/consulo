{
  int start=range.getStartOffset();
  int end;
  VisualPosition visual=new VisualPosition(myEditor.offsetToVisualPosition(start).line,0);
  LogicalPosition logical=myEditor.visualToLogicalPosition(visual);
  start=myEditor.logicalPositionToOffset(logical);
  Document document=myEditor.getDocument();
  CharSequence text=document.getCharsSequence();
  IterationState iterationState=new IterationState(myEditor,start,false);
  TextAttributes attributes=iterationState.getMergedAttributes();
  int fontType=attributes.getFontType();
  ProcessingContext context=new ProcessingContext(logical,start,myEditor,myRepresentationHelper);
  Point point=myEditor.visualPositionToXY(visual);
  context.x=point.x;
  int newX;
  int spaceWidth=EditorUtil.getSpaceWidth(fontType,myEditor);
  LogicalLineData logicalLineData=new LogicalLineData();
  logicalLineData.update(logical.line,spaceWidth,myEditor);
  ProcessingContext startLineContext=context.clone();
  JComponent contentComponent=myEditor.getContentComponent();
  TIntIntHashMap offset2fontType=new TIntIntHashMap();
  TIntIntHashMap offset2widthInPixels=new TIntIntHashMap();
  TIntIntHashMap fontType2spaceWidth=new TIntIntHashMap();
  fontType2spaceWidth.put(fontType,spaceWidth);
  int softWrapStartOffset=startLineContext.offset;
  int reservedWidth=myPainter.getMinDrawingWidth(SoftWrapDrawingType.BEFORE_SOFT_WRAP_LINE_FEED);
  outer:   while (!iterationState.atEnd() && start <= range.getEndOffset()) {
    FoldRegion currentFold=iterationState.getCurrentFold();
    if (currentFold != null) {
      String placeholder=currentFold.getPlaceholderText();
      FontInfo fontInfo=EditorUtil.fontForChar(placeholder.charAt(0),fontType,myEditor);
      newX=context.x;
      for (int i=0; i < placeholder.length(); i++) {
        newX+=fontInfo.charWidth(placeholder.charAt(i),contentComponent);
      }
      if (newX + reservedWidth >= myVisibleAreaWidth) {
        logicalLineData.update(currentFold.getStartOffset(),spaceWidth);
        SoftWrap softWrap=registerSoftWrap(softWrapStartOffset,start,start,logicalLineData.indentInColumns,logicalLineData.indentInPixels,spaceWidth);
        softWrapStartOffset=softWrap.getStart();
        if (softWrap.getStart() < start) {
          revertListeners(softWrap.getStart(),context.visualLine);
          for (int j=currentFold.getStartOffset() - 1; j >= softWrap.getStart(); j--) {
            int pixelsDiff=offset2widthInPixels.get(j);
            int columnsDiff=calculateWidthInColumns(pixelsDiff,fontType2spaceWidth.get(offset2fontType.get(j)));
            context.offset--;
            context.logicalColumn-=columnsDiff;
            context.visualColumn-=columnsDiff;
          }
          notifyListenersOnBeforeSoftWrap(context);
        }
        context.visualColumn=0;
        context.softWrapColumnDiff=context.visualColumn - context.foldingColumnDiff - context.logicalColumn;
        context.softWrapLinesCurrent++;
        context.visualLine++;
        notifyListenersOnAfterSoftWrapLineFeed(context);
        context.x=softWrap.getIndentInPixels();
        context.visualColumn=softWrap.getIndentInColumns();
        context.softWrapColumnDiff+=softWrap.getIndentInColumns();
        startLineContext.from(context);
        for (int j=softWrap.getStart(); j < start; j++) {
          fontType=offset2fontType.get(j);
          newX=calculateNewX(context,fontType,contentComponent);
          processSymbol(context,startLineContext,logicalLineData,fontType,newX,fontType2spaceWidth,offset2widthInPixels,offset2fontType);
        }
        continue;
      }
 else {
        int visualLineBefore=context.visualLine;
        int logicalColumnBefore=context.logicalColumn;
        context.advance(currentFold);
        context.x=newX;
        int collapsedFoldingWidthInColumns=context.logicalColumn;
        if (context.visualLine <= visualLineBefore) {
          collapsedFoldingWidthInColumns=context.logicalColumn - logicalColumnBefore;
        }
        notifyListenersOnFoldRegion(currentFold,collapsedFoldingWidthInColumns,visualLineBefore);
        start=context.offset;
        softWrapStartOffset=currentFold.getEndOffset();
      }
    }
    end=iterationState.getEndOffset();
    for (int i=start; i < end; i++) {
      if (!offset2fontType.contains(i)) {
        offset2fontType.put(i,fontType);
      }
    }
    for (int i=start; i < end; i++) {
      if (i > range.getEndOffset()) {
        break outer;
      }
      char c=text.charAt(i);
      if (offset2fontType.contains(i)) {
        fontType=offset2fontType.get(i);
      }
      context.symbol=c;
      if (c == '\n') {
        processSymbol(context,startLineContext,logicalLineData,fontType,0,fontType2spaceWidth,offset2widthInPixels,offset2fontType);
        softWrapStartOffset=startLineContext.offset;
        continue;
      }
      if (offset2widthInPixels.contains(context.offset) && context.symbol != '\t') {
        newX=context.x + offset2widthInPixels.get(context.offset);
      }
 else {
        newX=calculateNewX(context,fontType,contentComponent);
      }
      if (newX + reservedWidth >= myVisibleAreaWidth) {
        logicalLineData.update(i,spaceWidth);
        SoftWrap softWrap=registerSoftWrap(softWrapStartOffset,Math.max(softWrapStartOffset,i - 1),calculateSoftWrapEndOffset(softWrapStartOffset,end),logicalLineData.indentInColumns,logicalLineData.indentInPixels,spaceWidth);
        int newI=softWrap.getStart();
        if (newI < i) {
          revertListeners(newI,context.visualLine);
          for (int j=i - 1; j >= newI; j--) {
            int pixelsDiff=offset2widthInPixels.get(j);
            int columnsDiff=calculateWidthInColumns(pixelsDiff,fontType2spaceWidth.get(offset2fontType.get(j)));
            context.offset--;
            context.logicalColumn-=columnsDiff;
            context.visualColumn-=columnsDiff;
          }
        }
 else         if (newI > i) {
          processSymbol(context,startLineContext,logicalLineData,fontType,newX,fontType2spaceWidth,offset2widthInPixels,offset2fontType);
          for (int j=i + 1; j < newI; j++) {
            context.symbol=text.charAt(j);
            newX=calculateNewX(context,fontType,contentComponent);
            processSymbol(context,startLineContext,logicalLineData,fontType,newX,fontType2spaceWidth,offset2widthInPixels,offset2fontType);
          }
        }
        notifyListenersOnBeforeSoftWrap(context);
        softWrapStartOffset=newI;
        context.visualColumn=0;
        context.softWrapColumnDiff=context.visualColumn - context.foldingColumnDiff - context.logicalColumn;
        context.softWrapLinesCurrent++;
        context.visualLine++;
        notifyListenersOnAfterSoftWrapLineFeed(context);
        context.x=softWrap.getIndentInPixels();
        context.visualColumn=softWrap.getIndentInColumns();
        context.softWrapColumnDiff+=softWrap.getIndentInColumns();
        i=newI - 1;
        startLineContext.from(context);
      }
 else {
        processSymbol(context,startLineContext,logicalLineData,fontType,newX,fontType2spaceWidth,offset2widthInPixels,offset2fontType);
      }
    }
    iterationState.advance();
    attributes=iterationState.getMergedAttributes();
    fontType=attributes.getFontType();
    start=iterationState.getStartOffset();
  }
}
