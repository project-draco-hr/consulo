{
  final SvnCommandLineInfoClient infoClient=new SvnCommandLineInfoClient(myProject);
  final SVNInfo info=infoClient.doInfo(paths[0],SVNRevision.UNDEFINED);
  if (info == null || info.getURL() == null) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.WC_NOT_WORKING_COPY,paths[0].getPath()));
  }
  final AtomicReference<long[]> updatedToRevision=new AtomicReference<long[]>();
  updatedToRevision.set(new long[0]);
  File base=myCommonAncestor == null ? paths[0] : new File(myCommonAncestor.getPath());
  base=base.isDirectory() ? base : base.getParentFile();
  final List<String> parameters=new ArrayList<String>();
  if (revision != null && !SVNRevision.UNDEFINED.equals(revision) && !SVNRevision.WORKING.equals(revision)) {
    parameters.add("-r");
    parameters.add(revision.toString());
  }
  if (depth != null && !SVNDepth.UNKNOWN.equals(depth)) {
    parameters.add("--depth");
    parameters.add(depth.toString());
  }
  if (allowUnversionedObstructions) {
    parameters.add("--force");
  }
  if (depthIsSticky && depth != null) {
    parameters.add("--set-depth");
    parameters.add(depth.toString());
  }
  if (makeParents) {
    parameters.add("--parents");
  }
  if (myIgnoreExternals) {
    parameters.add("--ignore-externals");
  }
  parameters.add("--accept");
  parameters.add("postpone");
  for (  File path : paths) {
    parameters.add(path.getPath());
  }
  final AtomicReference<SVNException> excRef=new AtomicReference<SVNException>();
  final ISVNEventHandler handler=getEventHandler();
  final UpdateOutputLineConverter converter=new UpdateOutputLineConverter(base);
  try {
    final LineCommandListener listener=new LineCommandListener(){
      final long[] myRevisions=new long[paths.length];
      @Override public void baseDirectory(      File file){
      }
      @Override public void onLineAvailable(      String line,      Key outputType){
        if (ProcessOutputTypes.STDOUT.equals(outputType)) {
          final SVNEvent event=converter.convert(line);
          if (event != null) {
            checkForUpdateCompleted(event);
            try {
              handler.handleEvent(event,0.5);
            }
 catch (            SVNException e) {
              cancel();
              excRef.set(e);
            }
          }
        }
      }
      private void checkForUpdateCompleted(      SVNEvent event){
        if (SVNEventAction.UPDATE_COMPLETED.equals(event.getAction())) {
          final long eventRevision=event.getRevision();
          for (int i=0; i < paths.length; i++) {
            final File path=paths[i];
            if (FileUtil.filesEqual(path,event.getFile())) {
              myRevisions[i]=eventRevision;
              break;
            }
          }
        }
      }
      @Override public void processTerminated(      int exitCode){
        super.processTerminated(exitCode);
        updatedToRevision.set(myRevisions);
      }
    }
;
    SvnLineCommand.runWithAuthenticationAttempt(SvnApplicationSettings.getInstance().getCommandLinePath(),base,SvnCommandName.up,listener,new IdeaSvnkitBasedAuthenticationCallback(SvnVcs.getInstance(myProject)),ArrayUtil.toStringArray(parameters));
  }
 catch (  SvnBindException e) {
    throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR,e));
  }
  if (excRef.get() != null) {
    throw excRef.get();
  }
  return updatedToRevision.get();
}
