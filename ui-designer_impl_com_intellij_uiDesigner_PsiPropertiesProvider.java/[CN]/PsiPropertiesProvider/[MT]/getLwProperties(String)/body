{
  if (myCache.containsKey(className)) {
    return myCache.get(className);
  }
  final PsiManager psiManager=PsiManager.getInstance(myModule.getProject());
  final GlobalSearchScope scope=GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(myModule);
  final PsiClass aClass=psiManager.findClass(className,scope);
  if (aClass == null) {
    return null;
  }
  final HashMap result=new HashMap();
  final PsiMethod[] methods=aClass.getAllMethods();
  for (  final PsiMethod method : methods) {
    if (!PropertyUtil.isSimplePropertySetter(method)) {
      continue;
    }
    final String name=PropertyUtil.getPropertyName(method);
    if (name == null) {
      throw new IllegalStateException();
    }
    final PsiMethod getter=PropertyUtil.findPropertyGetter(aClass,name,false,true);
    if (getter == null) {
      continue;
    }
    if (name.equals("preferredSize") || name.equals("minimumSize") || name.equals("maximumSize")) {
      continue;
    }
    final PsiType type=getter.getReturnType();
    final String propertyClassName=type.getCanonicalText();
    final LwIntrospectedProperty property;
    if (int.class.getName().equals(propertyClassName)) {
      property=new LwIntroIntProperty(name);
    }
 else     if (boolean.class.getName().equals(propertyClassName)) {
      property=new LwIntroBooleanProperty(name);
    }
 else     if (double.class.getName().equals(propertyClassName)) {
      property=new LwIntroDoubleProperty(name);
    }
 else     if (float.class.getName().equals(propertyClassName)) {
      property=new LwIntroFloatProperty(name);
    }
 else     if (String.class.getName().equals(propertyClassName)) {
      property=new LwRbIntroStringProperty(name);
    }
 else     if (Insets.class.getName().equals(propertyClassName)) {
      property=new LwIntroInsetsProperty(name);
    }
 else     if (Dimension.class.getName().equals(propertyClassName)) {
      property=new LwIntroDimensionProperty(name);
    }
 else     if (Rectangle.class.getName().equals(propertyClassName)) {
      property=new LwIntroRectangleProperty(name);
    }
 else     if (Color.class.getName().equals(propertyClassName)) {
      property=new LwIntroColorProperty(name);
    }
 else     if (Font.class.getName().equals(propertyClassName)) {
      property=new LwIntroFontProperty(name);
    }
 else     if (Icon.class.getName().equals(propertyClassName)) {
      property=new LwIntroIconProperty(name);
    }
 else {
      PsiClass propClass=psiManager.findClass(propertyClassName,scope);
      if (propClass == null)       continue;
      if (propClass.isEnum()) {
        final String enumClassName=RefactoringUtil.getInnerClassNameForClassLoader(propClass);
        final ClassLoader loader=LoaderFactory.getInstance(myModule.getProject()).getLoader(myModule);
        try {
          property=new LwIntroEnumProperty(name,loader.loadClass(enumClassName));
        }
 catch (        ClassNotFoundException e) {
          continue;
        }
      }
 else {
        PsiClass componentClass=psiManager.findClass(Component.class.getName(),scope);
        PsiClass listModelClass=psiManager.findClass(ListModel.class.getName(),scope);
        if (componentClass != null && InheritanceUtil.isInheritorOrSelf(propClass,componentClass,true)) {
          property=new LwIntroComponentProperty(name,propertyClassName);
        }
 else         if (componentClass != null && listModelClass != null && InheritanceUtil.isInheritorOrSelf(propClass,listModelClass,true)) {
          property=new LwIntroListModelProperty(name,propertyClassName);
        }
 else {
          continue;
        }
      }
    }
    result.put(name,property);
  }
  myCache.put(className,result);
  return result;
}
