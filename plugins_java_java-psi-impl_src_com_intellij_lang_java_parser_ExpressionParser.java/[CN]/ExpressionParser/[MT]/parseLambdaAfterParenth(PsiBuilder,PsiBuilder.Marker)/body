{
  final boolean isLambda;
  final boolean isTyped;
  final IElementType nextToken1=builder.lookAhead(1);
  final IElementType nextToken2=builder.lookAhead(2);
  if (nextToken1 == JavaTokenType.RPARENTH && nextToken2 == JavaTokenType.ARROW) {
    isLambda=true;
    isTyped=false;
  }
 else   if (nextToken1 == JavaTokenType.AT || ElementType.MODIFIER_BIT_SET.contains(nextToken1) || ElementType.PRIMITIVE_TYPE_BIT_SET.contains(nextToken1)) {
    isLambda=true;
    isTyped=true;
  }
 else   if (nextToken1 == JavaTokenType.IDENTIFIER) {
    if (nextToken2 == JavaTokenType.COMMA || nextToken2 == JavaTokenType.RPARENTH && builder.lookAhead(3) == JavaTokenType.ARROW) {
      isLambda=true;
      isTyped=false;
    }
 else     if (nextToken2 == JavaTokenType.ARROW) {
      isLambda=false;
      isTyped=false;
    }
 else {
      boolean arrow=false;
      final PsiBuilder.Marker marker=builder.mark();
      while (!builder.eof()) {
        builder.advanceLexer();
        final IElementType tokenType=builder.getTokenType();
        if (tokenType == JavaTokenType.ARROW) {
          arrow=true;
          break;
        }
        if (tokenType == JavaTokenType.RPARENTH) {
          arrow=builder.lookAhead(1) == JavaTokenType.ARROW;
          break;
        }
 else         if (tokenType == JavaTokenType.LPARENTH || tokenType == JavaTokenType.SEMICOLON || tokenType == JavaTokenType.LBRACE || tokenType == JavaTokenType.RBRACE) {
          break;
        }
      }
      marker.rollbackTo();
      isLambda=arrow;
      isTyped=true;
    }
  }
 else {
    isLambda=false;
    isTyped=false;
  }
  return isLambda ? parseLambdaExpression(builder,isTyped,typeList) : null;
}
