{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final PsiElement element=getElement();
  if (element instanceof PsiMethodCallExpression) {
    PsiMethodCallExpression methodCallExpression=(PsiMethodCallExpression)element;
    final PsiMethod superConstructor=methodCallExpression.resolveMethod();
    if (superConstructor != null) {
      InlineMethodProcessor.addInaccessibleMemberConflicts(superConstructor,new UsageInfo[]{new UsageInfo(methodCallExpression.getMethodExpression())},new ReferencedElementsCollector(){
        @Override protected void checkAddMember(        @NotNull PsiMember member){
          if (!PsiTreeUtil.isAncestor(superConstructor.getContainingClass(),member,false)) {
            super.checkAddMember(member);
          }
        }
      }
,conflicts);
      if (InlineMethodProcessor.checkBadReturns(superConstructor) && !InlineUtil.allUsagesAreTailCalls(superConstructor)) {
        conflicts.putValue(superConstructor,CommonRefactoringUtil.capitalize(RefactoringBundle.message("refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow","") + " of super constructor"));
      }
    }
  }
  return conflicts.isEmpty() ? null : conflicts.values().iterator().next();
}
