def submerge(repo, wctx, mctx, actx):
    if (mctx == actx):
        actx = wctx.p1()
    s1 = wctx.substate
    s2 = mctx.substate
    sa = actx.substate
    sm = {}
    repo.ui.debug(('subrepo merge %s %s %s\n' % (wctx, mctx, actx)))

    def debug(s, msg, r=''):
        if r:
            r = ('%s:%s:%s' % r)
        repo.ui.debug(('  subrepo %s: %s %s\n' % (s, msg, r)))
    for (s, l) in s1.items():
        if ((wctx != actx) and wctx.sub(s).dirty()):
            l = (l[0], (l[1] + '+'))
        a = sa.get(s, nullstate)
        if (s in s2):
            r = s2[s]
            if ((l == r) or (r == a)):
                sm[s] = l
                continue
            elif (l == a):
                debug(s, 'other changed, get', r)
                wctx.sub(s).get(r)
                sm[s] = r
            elif (l[0] != r[0]):
                if repo.ui.promptchoice((_(' subrepository sources for %s differ\nuse (l)ocal source (%s) or (r)emote source (%s)?') % (s, l[0], r[0])), (_('&Local'), _('&Remote')), 0):
                    debug(s, 'prompt changed, get', r)
                    wctx.sub(s).get(r)
                    sm[s] = r
            elif (l[1] == a[1]):
                debug(s, 'other side changed, get', r)
                wctx.sub(s).get(r)
                sm[s] = r
            else:
                debug(s, 'both sides changed, merge with', r)
                wctx.sub(s).merge(r)
                sm[s] = l
        elif (l == a):
            debug(s, 'remote removed, remove')
            wctx.sub(s).remove()
        elif repo.ui.promptchoice((_(' local changed subrepository %s which remote removed\nuse (c)hanged version or (d)elete?') % s), (_('&Changed'), _('&Delete')), 0):
            debug(s, 'prompt remove')
            wctx.sub(s).remove()
    for (s, r) in s2.items():
        if (s in s1):
            continue
        elif (s not in sa):
            debug(s, 'remote added, get', r)
            mctx.sub(s).get(r)
            sm[s] = r
        elif (r != sa[s]):
            if (repo.ui.promptchoice((_(' remote changed subrepository %s which local removed\nuse (c)hanged version or (d)elete?') % s), (_('&Changed'), _('&Delete')), 0) == 0):
                debug(s, 'prompt recreate', r)
                wctx.sub(s).get(r)
                sm[s] = r
    writestate(repo, sm)
