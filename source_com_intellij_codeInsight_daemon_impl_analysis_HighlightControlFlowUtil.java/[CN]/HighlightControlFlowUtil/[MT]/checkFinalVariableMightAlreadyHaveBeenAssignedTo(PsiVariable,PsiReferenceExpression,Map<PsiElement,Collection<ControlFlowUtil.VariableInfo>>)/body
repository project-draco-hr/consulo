{
  if (!PsiUtil.isAccessedForWriting(expression))   return null;
  PsiElement scope=variable instanceof PsiField ? variable.getParent() : variable.getParent() == null ? null : variable.getParent().getParent();
  PsiElement codeBlock=PsiUtil.getTopLevelEnclosingCodeBlock(expression,scope);
  if (codeBlock == null)   return null;
  Collection<ControlFlowUtil.VariableInfo> codeBlockProblems=getFinalVariableProblemsInBlock(finalVarProblems,codeBlock);
  boolean alreadyAssigned=false;
  for (  ControlFlowUtil.VariableInfo variableInfo : codeBlockProblems) {
    if (variableInfo.expression == expression) {
      alreadyAssigned=true;
      break;
    }
  }
  if (!alreadyAssigned) {
    if (!(variable instanceof PsiField))     return null;
    PsiField field=(PsiField)variable;
    PsiClass aClass=field.getContainingClass();
    if (aClass == null)     return null;
    PsiField[] fields=aClass.getFields();
    boolean isFieldStatic=field.hasModifierProperty(PsiModifier.STATIC);
    for (    PsiField psiField : fields) {
      PsiExpression initializer=psiField.getInitializer();
      if (psiField != field && psiField.hasModifierProperty(PsiModifier.STATIC) == isFieldStatic && initializer != null && initializer != codeBlock && !variableDefinitelyNotAssignedIn(field,initializer)) {
        alreadyAssigned=true;
        break;
      }
    }
    if (!alreadyAssigned) {
      PsiMember enclosingConstructorOrInitializer=PsiUtil.findEnclosingConstructorOrInitializer(expression);
      if (enclosingConstructorOrInitializer == null || !aClass.getManager().areElementsEquivalent(enclosingConstructorOrInitializer.getParent(),aClass)) {
        return null;
      }
      PsiClassInitializer[] initializers=aClass.getInitializers();
      for (      PsiClassInitializer initializer : initializers) {
        if (initializer.hasModifierProperty(PsiModifier.STATIC) == field.hasModifierProperty(PsiModifier.STATIC)) {
          PsiCodeBlock body=initializer.getBody();
          if (body == codeBlock)           return null;
          if (body == null)           continue;
          try {
            ControlFlow controlFlow=ControlFlowFactory.getControlFlow(body,LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());
            if (!ControlFlowUtil.isVariableDefinitelyNotAssigned(field,controlFlow)) {
              alreadyAssigned=true;
              break;
            }
          }
 catch (          AnalysisCanceledException e) {
            return null;
          }
        }
      }
    }
    if (!alreadyAssigned && !field.hasModifierProperty(PsiModifier.STATIC)) {
      PsiMethod ctr=codeBlock.getParent() instanceof PsiMethod ? (PsiMethod)codeBlock.getParent() : null;
      List<PsiMethod> redirectedConstructors=ctr != null && ctr.isConstructor() ? getRedirectedConstructors(ctr) : null;
      for (int j=0; redirectedConstructors != null && j < redirectedConstructors.size(); j++) {
        PsiMethod redirectedConstructor=redirectedConstructors.get(j);
        if (redirectedConstructor.getBody() != null && variableDefinitelyAssignedIn(variable,redirectedConstructor.getBody())) {
          alreadyAssigned=true;
          break;
        }
      }
    }
  }
  if (alreadyAssigned) {
    String description=MessageFormat.format("Variable ''{0}'' might already have been assigned to",new Object[]{variable.getName()});
    HighlightInfo highlightInfo=HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,description);
    QuickFixAction.registerQuickFixAction(highlightInfo,new ModifierFix(variable,PsiModifier.FINAL,false));
    QuickFixAction.registerQuickFixAction(highlightInfo,new DeferFinalAssignmentFix(variable,expression));
    return highlightInfo;
  }
  return null;
}
