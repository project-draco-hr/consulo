{
  final List<String> toRemove=new ArrayList<String>();
  for (Iterator<String> it=cache.getOutputUrlsIterator(); it.hasNext(); ) {
    final String outputPath=it.next();
    final String sourceUrl=cache.getSourceUrl(outputPath);
    final VirtualFile sourceFile=snapshot.getFileByUrl(sourceUrl);
    boolean needRecompile=false;
    boolean shouldDelete=false;
    if (myOutputFilesOnDisk.contains(outputPath)) {
      if (sourceFile == null) {
        shouldDelete=scope.belongs(sourceUrl);
      }
 else {
        if (toCompile.contains(sourceFile)) {
          shouldDelete=true;
        }
 else {
          final String currentOutputDir=getModuleOutputDirForFile(context,sourceFile);
          if (currentOutputDir != null) {
            final String className=cache.getClassName(outputPath);
            final String cachedOutputDir=(className == null) ? currentOutputDir : outputPath.substring(0,outputPath.length() - className.length() - ".class".length()- 1);
            if (CompilerUtil.pathsEqual(cachedOutputDir,currentOutputDir)) {
              shouldDelete=false;
            }
 else {
              shouldDelete=true;
              needRecompile=true;
            }
          }
 else {
            shouldDelete=true;
          }
        }
      }
    }
 else {
      needRecompile=true;
      shouldDelete=true;
    }
    if (shouldDelete) {
      toDelete.add(outputPath);
    }
    if (needRecompile) {
      if (sourceFile != null && scope.belongs(sourceUrl)) {
        if (!compilerConfiguration.isExcludedFromCompilation(sourceFile)) {
          toCompile.add(sourceFile);
          toRemove.add(outputPath);
        }
      }
    }
    if (sourceFile == null) {
      urlsWithSourceRemoved.add(outputPath);
    }
  }
  for (Iterator<String> it=toRemove.iterator(); it.hasNext(); ) {
    cache.remove(it.next());
  }
}
