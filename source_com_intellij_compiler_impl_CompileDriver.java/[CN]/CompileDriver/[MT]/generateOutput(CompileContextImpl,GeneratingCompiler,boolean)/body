{
  final GeneratingCompiler.GenerationItem[] allItems=compiler.getGenerationItems(context);
  final List<GeneratingCompiler.GenerationItem> toGenerate=new ArrayList<GeneratingCompiler.GenerationItem>();
  final StateCache<ValidityState> cache=getGeneratingCompilerCache(compiler);
  final Set<String> pathsToRemove=new HashSet<String>(Arrays.asList(cache.getUrls()));
  final Map<GeneratingCompiler.GenerationItem,String> itemToOutputPathMap=new com.intellij.util.containers.HashMap<GeneratingCompiler.GenerationItem,String>();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      for (      final GeneratingCompiler.GenerationItem item : allItems) {
        final Module itemModule=item.getModule();
        final String outputDirPath=getGenerationOutputPath(compiler,itemModule);
        final String outputPath=outputDirPath + "/" + item.getPath();
        itemToOutputPathMap.put(item,outputPath);
        final ValidityState savedState=cache.getState(outputPath);
        if (forceGenerate || savedState == null || !savedState.equalsTo(item.getValidityState())) {
          toGenerate.add(item);
        }
 else {
          pathsToRemove.remove(outputPath);
        }
      }
    }
  }
);
  final List<File> filesToRefresh=new ArrayList<File>();
  try {
    if (pathsToRemove.size() > 0) {
      context.getProgressIndicator().pushState();
      context.getProgressIndicator().setText(CompilerBundle.message("progress.synchronizing.output.directory"));
      for (      final String path : pathsToRemove) {
        final File file=new File(path);
        final boolean deleted=file.delete();
        if (deleted) {
          cache.remove(path);
          filesToRefresh.add(file);
        }
      }
      context.getProgressIndicator().popState();
    }
    Map<Module,Set<GeneratingCompiler.GenerationItem>> moduleToItemMap=buildModuleToGenerationItemMap(toGenerate.toArray(new GeneratingCompiler.GenerationItem[toGenerate.size()]));
    List<Module> modules=new ArrayList<Module>(moduleToItemMap.size());
    for (    final Module module : moduleToItemMap.keySet()) {
      modules.add(module);
    }
    ModuleCompilerUtil.sortModules(myProject,modules);
    for (    final Module module : modules) {
      context.getProgressIndicator().pushState();
      try {
        final Set<GeneratingCompiler.GenerationItem> items=moduleToItemMap.get(module);
        if (items != null && items.size() > 0) {
          final VirtualFile outputDir=getGenerationOutputDir(compiler,module);
          final GeneratingCompiler.GenerationItem[] successfullyGenerated=compiler.generate(context,items.toArray(new GeneratingCompiler.GenerationItem[items.size()]),outputDir);
          context.getProgressIndicator().setText(CompilerBundle.message("progress.updating.caches"));
          for (          final GeneratingCompiler.GenerationItem item : successfullyGenerated) {
            final String fullOutputPath=itemToOutputPathMap.get(item);
            cache.update(fullOutputPath,item.getValidityState());
            filesToRefresh.add(new File(fullOutputPath));
          }
        }
      }
  finally {
        context.getProgressIndicator().popState();
      }
    }
  }
  finally {
    context.getProgressIndicator().pushState();
    CompilerUtil.refreshIOFiles(filesToRefresh.toArray(new File[filesToRefresh.size()]));
    if (cache.isDirty()) {
      context.getProgressIndicator().setText(CompilerBundle.message("progress.saving.caches"));
      cache.save();
    }
    context.getProgressIndicator().popState();
  }
  return toGenerate.size() > 0 || filesToRefresh.size() > 0;
}
