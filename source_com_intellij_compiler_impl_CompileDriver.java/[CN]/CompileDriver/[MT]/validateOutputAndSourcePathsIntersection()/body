{
  final Module[] allModules=ModuleManager.getInstance(myProject).getModules();
  final VirtualFile[] outputPaths=CompilerPathsEx.getOutputDirectories(allModules);
  final Set<VirtualFile> affectedOutputPaths=new HashSet<VirtualFile>();
  for (  Module allModule : allModules) {
    final ModuleRootManager rootManager=ModuleRootManager.getInstance(allModule);
    final VirtualFile[] sourceRoots=rootManager.getSourceRoots();
    for (int j=0; j < outputPaths.length; j++) {
      VirtualFile outputPath=outputPaths[j];
      for (      VirtualFile sourceRoot : sourceRoots) {
        if (VfsUtil.isAncestor(outputPath,sourceRoot,true) || VfsUtil.isAncestor(sourceRoot,outputPath,false)) {
          affectedOutputPaths.add(outputPath);
        }
      }
    }
  }
  if (affectedOutputPaths.size() > 0) {
    final StringBuffer paths=new StringBuffer();
    for (    final VirtualFile affectedOutputPath : affectedOutputPaths) {
      if (paths.length() < 0) {
        paths.append("\n");
      }
      paths.append(affectedOutputPath.getPath().replace('/',File.separatorChar));
    }
    final int answer=Messages.showOkCancelDialog(myProject,CompilerBundle.message("warning.sources.under.output.paths",paths.toString()),CommonBundle.getErrorTitle(),Messages.getWarningIcon());
    if (answer == 0) {
      myShouldClearOutputDirectory=false;
      return true;
    }
 else {
      return false;
    }
  }
  return true;
}
