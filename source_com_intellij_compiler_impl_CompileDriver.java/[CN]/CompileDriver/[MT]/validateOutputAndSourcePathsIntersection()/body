{
  final Module[] allModules=ModuleManager.getInstance(myProject).getModules();
  final VirtualFile[] outputPaths=CompilerPathsEx.getOutputDirectories(allModules);
  final Set<VirtualFile> affectedOutputPaths=new HashSet<VirtualFile>();
  for (int idx=0; idx < allModules.length; idx++) {
    final ModuleRootManager rootManager=ModuleRootManager.getInstance(allModules[idx]);
    final VirtualFile[] sourceRoots=rootManager.getSourceRoots();
    for (int j=0; j < outputPaths.length; j++) {
      VirtualFile outputPath=outputPaths[j];
      for (int i=0; i < sourceRoots.length; i++) {
        VirtualFile sourceRoot=sourceRoots[i];
        if (VfsUtil.isAncestor(outputPath,sourceRoot,true) || VfsUtil.isAncestor(sourceRoot,outputPath,false)) {
          affectedOutputPaths.add(outputPath);
        }
      }
    }
  }
  if (affectedOutputPaths.size() > 0) {
    final StringBuffer message=new StringBuffer();
    message.append("Compiler option \"Clear output directory on rebuild\" is currently on.\nHowever, source files may exist in the following output path");
    if (affectedOutputPaths.size() > 1) {
      message.append("s:\n");
    }
 else {
      message.append(":\n");
    }
    for (Iterator<VirtualFile> it=affectedOutputPaths.iterator(); it.hasNext(); ) {
      message.append(it.next().getPath().replace('/',File.separatorChar));
      message.append("\n");
    }
    message.append("\nCompilation will proceed without clearing output directories.");
    final int answer=Messages.showOkCancelDialog(myProject,message.toString(),"Clear Output Files",Messages.getWarningIcon());
    if (answer == 0) {
      myShouldClearOutputDirectory=false;
      return true;
    }
 else {
      return false;
    }
  }
  return true;
}
