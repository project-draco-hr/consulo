{
  context.getProgressIndicator().pushState();
  try {
    final com.intellij.openapi.compiler.Compiler[] allCompilers=CompilerManager.getInstance(myProject).getCompilers(Compiler.class);
    context.getProgressIndicator().setText("Clearing output directories...");
    for (int idx=0; idx < allCompilers.length; idx++) {
      final Compiler compiler=allCompilers[idx];
      if (compiler instanceof GeneratingCompiler) {
        final StateCache<ValidityState> cache=getGeneratingCompilerCache((GeneratingCompiler)compiler);
        if (!myShouldClearOutputDirectory) {
          deleteUrls(cache.getUrlsIterator());
        }
        cache.wipe();
      }
 else       if (compiler instanceof FileProcessingCompiler) {
        final FileProcessingCompilerStateCache cache=getFileProcessingCompilerCache((FileProcessingCompiler)compiler);
        cache.wipe();
      }
 else       if (compiler instanceof TranslatingCompiler) {
        final TranslatingCompilerStateCache cache=getTranslatingCompilerCache((TranslatingCompiler)compiler);
        if (!myShouldClearOutputDirectory) {
          deleteUrls(cache.getOutputUrlsIterator());
        }
        cache.wipe();
      }
    }
    if (myShouldClearOutputDirectory) {
      final File[] files=getAllOutputDirectories();
      for (int i=0; i < files.length; i++) {
        deleteAllFilesIn(files[i]);
      }
      final List<File> createdFiles=new ArrayList<File>(files.length);
      for (int idx=0; idx < files.length; idx++) {
        final File file=files[idx];
        if (file.mkdirs()) {
          createdFiles.add(file);
        }
      }
      if (createdFiles.size() > 0) {
        CompilerUtil.refreshIOFiles(createdFiles.toArray(new File[createdFiles.size()]));
      }
    }
    clearCompilerSystemDirectory(context);
  }
  finally {
    context.getProgressIndicator().popState();
  }
}
