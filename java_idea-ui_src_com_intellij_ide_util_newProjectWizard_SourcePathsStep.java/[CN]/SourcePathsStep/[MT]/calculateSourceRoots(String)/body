{
  if (contentRootPath == null) {
    return EMPTY_STRING_STRING_ARRAY;
  }
  final File entryFile=new File(contentRootPath);
  if (!entryFile.exists()) {
    return EMPTY_STRING_STRING_ARRAY;
  }
  final File[] children=entryFile.listFiles();
  if (children == null || children.length == 0) {
    return EMPTY_STRING_STRING_ARRAY;
  }
  final Map<File,String> skippedPackages=new HashMap<File,String>();
  final MultiMap<File,String> foundLanguages=new MultiMap<File,String>();
  for (  SourceRootFinder finder : SourceRootFinder.EP_NAME.getExtensions()) {
    final List<Pair<File,String>> roots=finder.findRoots(entryFile);
    final String name=finder.getName();
    for (    Pair<File,String> root : roots) {
      if (!skippedPackages.containsKey(root.first)) {
        skippedPackages.put(root.first,root.second);
      }
      foundLanguages.putValue(root.first,name);
    }
  }
  final List<Trinity<String,String,Collection<String>>> paths=new ArrayList<Trinity<String,String,Collection<String>>>();
  for (  final File suggestedRoot : skippedPackages.keySet()) {
    try {
      if (FileUtil.isAncestor(entryFile,suggestedRoot,false)) {
        final String path=FileUtil.resolveShortWindowsName(suggestedRoot.getPath());
        paths.add(Trinity.create(path,skippedPackages.get(suggestedRoot),foundLanguages.get(suggestedRoot)));
      }
    }
 catch (    IOException e) {
      LOG.info(e);
    }
  }
  return paths;
}
