{
  myEditor=editor;
  myInlayTree=new RangeMarkerTree<InlayImpl>(editor.getDocument()){
    @NotNull @Override protected RMNode<InlayImpl> createNewNode(    @NotNull InlayImpl key,    int start,    int end,    boolean greedyToLeft,    boolean greedyToRight,    int layer){
      return new RMNode<InlayImpl>(this,key,start,end,greedyToLeft,greedyToRight){
        @Override protected Getter<InlayImpl> createGetter(        @NotNull InlayImpl interval){
          return interval;
        }
      }
;
    }
    @Override void fireBeforeRemoved(    @NotNull InlayImpl markerEx,    @NotNull @NonNls Object reason){
      if (markerEx.myOffsetBeforeDisposal == -1) {
        notifyRemoved(markerEx);
      }
    }
  }
;
  myEditor.getDocument().addDocumentListener(new PrioritizedDocumentListener(){
    @Override public int getPriority(){
      return EditorDocumentPriorities.INLAY_MODEL;
    }
    @Override public void beforeDocumentChange(    DocumentEvent event){
      int offset=event.getOffset();
      if (event.getOldLength() == 0 && offset == myEditor.getCaretModel().getOffset() && hasInlineElementAt(offset) && myEditor.getCaretModel().getVisualPosition().equals(myEditor.offsetToVisualPosition(offset,false,false))) {
        myStickToLargerOffsetsOnUpdate=true;
      }
    }
    @Override public void documentChanged(    DocumentEvent event){
      myStickToLargerOffsetsOnUpdate=false;
    }
  }
,this);
}
