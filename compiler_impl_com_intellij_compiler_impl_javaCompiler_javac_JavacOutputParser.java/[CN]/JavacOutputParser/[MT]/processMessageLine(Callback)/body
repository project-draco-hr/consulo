{
  if (super.processMessageLine(callback)) {
    return true;
  }
  final String line=callback.getCurrentLine();
  if (line == null) {
    return false;
  }
  if (JavacResourcesReader.MSG_PATTERNS_START.equals(line)) {
    myParserActions.clear();
    while (true) {
      final String patternLine=callback.getNextLine();
      if (JavacResourcesReader.MSG_PATTERNS_END.equals(patternLine)) {
        break;
      }
      addJavacPattern(patternLine);
    }
    return true;
  }
  int colonIndex1=line.indexOf(':');
  if (colonIndex1 == 1) {
    colonIndex1=line.indexOf(':',colonIndex1 + 1);
  }
  if (colonIndex1 >= 0) {
    @NonNls String part1=line.substring(0,colonIndex1).trim();
    if (part1.equalsIgnoreCase("error")) {
      addMessage(callback,CompilerMessageCategory.ERROR,line.substring(colonIndex1));
      return true;
    }
    if (part1.equalsIgnoreCase("warning")) {
      addMessage(callback,CompilerMessageCategory.WARNING,line.substring(colonIndex1));
      return true;
    }
    if (part1.equals("javac")) {
      addMessage(callback,CompilerMessageCategory.ERROR,line);
      return true;
    }
    final int colonIndex2=line.indexOf(':',colonIndex1 + 1);
    if (colonIndex2 >= 0) {
      final String filePath=part1.replace(File.separatorChar,'/');
      final Boolean fileExists=ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
        public Boolean compute(){
          return LocalFileSystem.getInstance().findFileByPath(filePath) != null ? Boolean.TRUE : Boolean.FALSE;
        }
      }
);
      if (!fileExists.booleanValue()) {
        return true;
      }
      try {
        final int lineNum=Integer.parseInt(line.substring(colonIndex1 + 1,colonIndex2).trim());
        String message=line.substring(colonIndex2 + 1).trim();
        CompilerMessageCategory category=CompilerMessageCategory.ERROR;
        if (message.startsWith(WARNING_PREFIX)) {
          message=message.substring(WARNING_PREFIX.length()).trim();
          category=CompilerMessageCategory.WARNING;
        }
        List<String> messages=new ArrayList<String>();
        messages.add(message);
        int colNum;
        String prevLine=null;
        do {
          final String nextLine=callback.getNextLine();
          if (nextLine == null) {
            return false;
          }
          if (nextLine.trim().equals("^")) {
            final int fakeColNum=nextLine.indexOf('^') + 1;
            final CharSequence chars=prevLine == null ? line : prevLine;
            final int offsetColNum=EditorUtil.calcOffset(null,chars,0,chars.length(),fakeColNum,8);
            colNum=EditorUtil.calcColumnNumber(null,chars,0,offsetColNum,myTabSize);
            break;
          }
          if (prevLine != null) {
            messages.add(prevLine);
          }
          prevLine=nextLine;
        }
 while (true);
        if (colNum > 0) {
          messages=convertMessages(messages);
          final StringBuilder buf=StringBuilderSpinAllocator.alloc();
          try {
            for (            final String m : messages) {
              if (buf.length() > 0) {
                buf.append("\n");
              }
              buf.append(m);
            }
            addMessage(callback,category,buf.toString(),VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL,filePath),lineNum,colNum);
          }
  finally {
            StringBuilderSpinAllocator.dispose(buf);
          }
          return true;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
  }
  if (line.endsWith("java.lang.OutOfMemoryError")) {
    addMessage(callback,CompilerMessageCategory.ERROR,CompilerBundle.message("error.javac.out.of.memory"));
    return true;
  }
  addMessage(callback,CompilerMessageCategory.INFORMATION,line);
  return true;
}
