{
  final PsiMethod method=PsiTreeUtil.getParentOfType(element,PsiMethod.class,false);
  if (method != null && isInsideMethodSignature(element,method) && (changeInfo == null || changeInfo instanceof MyJavaChangeInfo)) {
    final String newVisibility=VisibilityUtil.getVisibilityModifier(method.getModifierList());
    final PsiType returnType=method.getReturnType();
    final CanonicalTypes.Type newReturnType;
    final ParameterInfoImpl[] parameterInfos;
    try {
      newReturnType=returnType != null ? CanonicalTypes.createTypeWrapper(returnType) : null;
      parameterInfos=ParameterInfoImpl.fromMethod(method);
      for (      ParameterInfoImpl parameterInfo : parameterInfos) {
        if (!parameterInfo.getTypeWrapper().isValid()) {
          return null;
        }
      }
    }
 catch (    IncorrectOperationException e) {
      return null;
    }
    final MyJavaChangeInfo fromMethod=new MyJavaChangeInfo(newVisibility,method,newReturnType,parameterInfos,null,method.getName(),method.getName());
    if (changeInfo == null) {
      final PsiMethod deepestSuperMethod=method.findDeepestSuperMethod();
      if (deepestSuperMethod != null) {
        if (!deepestSuperMethod.getManager().isInProject(deepestSuperMethod))         return null;
      }
      fromMethod.setSuperMethod(deepestSuperMethod);
      return fromMethod;
    }
 else {
      final MyJavaChangeInfo info=(MyJavaChangeInfo)changeInfo;
      if (!info.getMethod().equals(method))       return null;
      if (!info.equals(fromMethod)) {
        createParametersInfo(element,parameterInfos,info);
        if (info.isReturnTypeChanged()) {
          final String visibility=info.getNewVisibility();
          if (Comparing.strEqual(visibility,PsiModifier.PRIVATE) && !info.isArrayToVarargs() && !info.isExceptionSetOrOrderChanged()&& !info.isExceptionSetChanged()&& !info.isNameChanged()&& !info.isParameterSetOrOrderChanged()&& !info.isParameterNamesChanged()&& !info.isParameterTypesChanged()) {
            return null;
          }
        }
        try {
          final MyJavaChangeInfo javaChangeInfo=new MyJavaChangeInfo(newVisibility,method,newReturnType,parameterInfos,info.getNewExceptions(),method.getName(),info.getOldName()){
            @Override protected void fillOldParams(            PsiMethod method){
              oldParameterNames=info.getOldParameterNames();
              oldParameterTypes=info.getOldParameterTypes();
              if (!method.isConstructor()) {
                try {
                  isReturnTypeChanged=info.isReturnTypeChanged || (info.getNewReturnType() != null ? !Comparing.strEqual(info.getNewReturnType().getTypeText(),newReturnType.getTypeText()) : newReturnType != null);
                }
 catch (                IncorrectOperationException e) {
                  isReturnTypeChanged=true;
                }
              }
            }
          }
;
          javaChangeInfo.setSuperMethod(info.getSuperMethod());
          return javaChangeInfo;
        }
 catch (        IncorrectOperationException e) {
          return null;
        }
      }
      return changeInfo;
    }
  }
 else {
    final PsiVariable variable=PsiTreeUtil.getParentOfType(element,PsiVariable.class);
    if (variable != null && JavaRefactoringSupportProvider.mayRenameInplace(variable,element)) {
      return new RenameChangeInfo(variable,changeInfo){
        @Override public Language getLanguage(){
          return StdLanguages.JAVA;
        }
      }
;
    }
  }
  return null;
}
