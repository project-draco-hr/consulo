{
  HierarchicalArrangementConditionNode grouped=grouper.group(matchCondition);
  DefaultTreeModel treeModel=(DefaultTreeModel)tree.getModel();
  Pair<ArrangementTreeNode,Integer> pair=ArrangementConfigUtil.map(null,grouped,null);
  ArrangementTreeNode topMostNode=ArrangementConfigUtil.getRoot(pair.first);
  ArrangementConfigUtil.markRows(root,tree.isRootVisible());
  ArrangementTreeNode bottomHierarchy=null;
  if (anchor != null) {
    bottomHierarchy=ArrangementConfigUtil.cutSubHierarchy(root,treeModel,anchor);
  }
  ArrangementConfigUtil.insert(root,root.getChildCount(),topMostNode,treeModel);
  if (bottomHierarchy != null) {
    ArrangementConfigUtil.insert(root,root.getChildCount(),bottomHierarchy,treeModel);
  }
  TIntIntHashMap rowChanges=ArrangementConfigUtil.collectRowChangesAndUnmark(root,tree.isRootVisible());
  topMostNode=ArrangementConfigUtil.getLastBefore(pair.first,root);
  int row=ArrangementConfigUtil.getRow(pair.first,tree.isRootVisible());
  ArrangementRuleEditingModelImpl model=new ArrangementRuleEditingModelImpl(treeModel,matchCondition,topMostNode,pair.first,grouper,row,tree.isRootVisible());
  return Pair.create(model,rowChanges);
}
