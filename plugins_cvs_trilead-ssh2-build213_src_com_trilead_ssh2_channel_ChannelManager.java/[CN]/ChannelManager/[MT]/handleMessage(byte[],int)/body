{
  if (msg == null) {
    if (log.isEnabled())     log.log(50,"HandleMessage: got shutdown");
synchronized (listenerThreads) {
      for (int i=0; i < listenerThreads.size(); i++) {
        IChannelWorkerThread lat=(IChannelWorkerThread)listenerThreads.elementAt(i);
        lat.stopWorking();
      }
      listenerThreadsAllowed=false;
    }
synchronized (channels) {
      shutdown=true;
      for (int i=0; i < channels.size(); i++) {
        Channel c=(Channel)channels.elementAt(i);
synchronized (c) {
          c.EOF=true;
          c.state=Channel.STATE_CLOSED;
          c.setReasonClosed("The connection is being shutdown");
          c.closeMessageRecv=true;
          c.notifyAll();
        }
      }
      channels.setSize(0);
      channels.trimToSize();
      channels.notifyAll();
      return;
    }
  }
switch (msg[0]) {
case Packets.SSH_MSG_CHANNEL_OPEN_CONFIRMATION:
    msgChannelOpenConfirmation(msg,msglen);
  break;
case Packets.SSH_MSG_CHANNEL_WINDOW_ADJUST:
msgChannelWindowAdjust(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_DATA:
msgChannelData(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_EXTENDED_DATA:
msgChannelExtendedData(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_REQUEST:
msgChannelRequest(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_EOF:
msgChannelEOF(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_OPEN:
msgChannelOpen(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_CLOSE:
msgChannelClose(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_SUCCESS:
msgChannelSuccess(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_FAILURE:
msgChannelFailure(msg,msglen);
break;
case Packets.SSH_MSG_CHANNEL_OPEN_FAILURE:
msgChannelOpenFailure(msg,msglen);
break;
case Packets.SSH_MSG_GLOBAL_REQUEST:
msgGlobalRequest(msg,msglen);
break;
case Packets.SSH_MSG_REQUEST_SUCCESS:
msgGlobalSuccess();
break;
case Packets.SSH_MSG_REQUEST_FAILURE:
msgGlobalFailure();
break;
default :
throw new IOException("Cannot handle unknown channel message " + (msg[0] & 0xff));
}
}
