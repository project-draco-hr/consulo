{
  FileEditor[] editors;
  FileEditorProvider[] providers;
  final EditorWithProviderComposite newSelectedComposite;
  boolean newEditorCreated=false;
  final boolean open=window.isFileOpen(file);
  if (open) {
    newSelectedComposite=window.findFileComposite(file);
    LOG.assertTrue(newSelectedComposite != null);
    editors=newSelectedComposite.getEditors();
    providers=newSelectedComposite.getProviders();
  }
 else {
    if (UISettings.getInstance().EDITOR_TAB_PLACEMENT == UISettings.TABS_NONE || UISettings.getInstance().PRESENTATION_MODE) {
      for (      EditorWithProviderComposite composite : window.getEditors()) {
        Disposer.dispose(composite);
      }
    }
    final FileEditorProviderManager editorProviderManager=FileEditorProviderManager.getInstance();
    providers=editorProviderManager.getProviders(myProject,file);
    if (DumbService.getInstance(myProject).isDumb()) {
      final List<FileEditorProvider> dumbAware=ContainerUtil.findAll(providers,new Condition<FileEditorProvider>(){
        @Override public boolean value(        FileEditorProvider fileEditorProvider){
          return DumbService.isDumbAware(fileEditorProvider);
        }
      }
);
      providers=dumbAware.toArray(new FileEditorProvider[dumbAware.size()]);
    }
    if (providers.length == 0) {
      return Pair.create(EMPTY_EDITOR_ARRAY,EMPTY_PROVIDER_ARRAY);
    }
    newEditorCreated=true;
    getProject().getMessageBus().syncPublisher(FileEditorManagerListener.Before.FILE_EDITOR_MANAGER).beforeFileOpened(this,file);
    editors=new FileEditor[providers.length];
    for (int i=0; i < providers.length; i++) {
      try {
        final FileEditorProvider provider=providers[i];
        LOG.assertTrue(provider != null,"Provider for file " + file + " is null. All providers: "+ Arrays.asList(providers));
        LOG.assertTrue(provider.accept(myProject,file),"Provider " + provider + " doesn't accept file "+ file);
        final FileEditor editor=provider.createEditor(myProject,file);
        LOG.assertTrue(editor.isValid());
        editors[i]=editor;
        editor.addPropertyChangeListener(myEditorPropertyChangeListener);
        editor.putUserData(DUMB_AWARE,DumbService.isDumbAware(provider));
        if (editor instanceof TextEditorImpl) {
          ((TextEditorImpl)editor).initFolding();
        }
      }
 catch (      Exception e) {
        LOG.error(e);
      }
catch (      AssertionError e) {
        LOG.error(e);
      }
    }
    newSelectedComposite=new EditorWithProviderComposite(file,editors,providers,this);
    if (index >= 0) {
      newSelectedComposite.getFile().putUserData(EditorWindow.INITIAL_INDEX_KEY,index);
    }
  }
  window.setEditor(newSelectedComposite,current,focusEditor);
  final EditorHistoryManager editorHistoryManager=EditorHistoryManager.getInstance(myProject);
  for (int i=0; i < editors.length; i++) {
    final FileEditor editor=editors[i];
    final FileEditorProvider provider=providers[i];
    FileEditorState state=null;
    if (entry != null) {
      state=entry.getState(provider);
    }
    if (state == null && !open) {
      state=editorHistoryManager.getState(file,provider);
    }
    if (state != null) {
      if (!isDumbAware(editor)) {
        final FileEditorState finalState=state;
        DumbService.getInstance(getProject()).runWhenSmart(new Runnable(){
          @Override public void run(){
            editor.setState(finalState);
          }
        }
);
      }
 else {
        editor.setState(state);
      }
    }
  }
  final FileEditorProvider[] _providers=newSelectedComposite.getProviders();
  final FileEditorProvider selectedProvider;
  if (entry == null) {
    selectedProvider=((FileEditorProviderManagerImpl)FileEditorProviderManager.getInstance()).getSelectedFileEditorProvider(editorHistoryManager,file,_providers);
  }
 else {
    selectedProvider=entry.mySelectedProvider;
  }
  if (selectedProvider != null) {
    final FileEditor[] _editors=newSelectedComposite.getEditors();
    for (int i=_editors.length - 1; i >= 0; i--) {
      final FileEditorProvider provider=_providers[i];
      if (provider.equals(selectedProvider)) {
        newSelectedComposite.setSelectedEditor(i);
        break;
      }
    }
  }
  window.getOwner().setCurrentWindow(window,focusEditor);
  window.getOwner().afterFileOpen(file);
  UIUtil.invokeLaterIfNeeded(new Runnable(){
    @Override public void run(){
      newSelectedComposite.getSelectedEditor().selectNotify();
    }
  }
);
  final IdeFocusManager focusManager=IdeFocusManager.getInstance(myProject);
  if (newEditorCreated) {
    if (window.isShowing()) {
      window.setPaintBlocked(true);
    }
    notifyPublisher(new Runnable(){
      @Override public void run(){
        window.setPaintBlocked(false);
        if (isFileOpen(file)) {
          getProject().getMessageBus().syncPublisher(FileEditorManagerListener.FILE_EDITOR_MANAGER).fileOpened(FileEditorManagerImpl.this,file);
        }
      }
    }
);
    final VirtualFile parentDir=file.getParent();
    if (parentDir != null) {
      final LocalFileSystem.WatchRequest request=LocalFileSystem.getInstance().addRootToWatch(parentDir.getPath(),false);
      file.putUserData(WATCH_REQUEST_KEY,request);
    }
  }
  ((IdeDocumentHistoryImpl)IdeDocumentHistory.getInstance(myProject)).onSelectionChanged();
  if (!ApplicationManagerEx.getApplicationEx().isUnitTestMode()) {
    if (focusEditor) {
      window.setAsCurrentWindow(true);
      ToolWindowManager.getInstance(myProject).activateEditorComponent();
      focusManager.toFront(window.getOwner());
    }
  }
  updateFileName(file);
  IdeDocumentHistory.getInstance(myProject).includeCurrentCommandAsNavigation();
  return Pair.create(editors,providers);
}
