{
  ASTNode node=element.getNode();
  if (node == null)   return;
  IElementType type=node.getElementType();
  if (BLOCK_SET.contains(type) && !isSingleClassBody(element) || type == CLOSABLE_BLOCK) {
    if (isMultiline(element)) {
      descriptors.add(new FoldingDescriptor(node,node.getTextRange()));
    }
  }
  if ((type.equals(mML_COMMENT) || type.equals(GROOVY_DOC_COMMENT)) && isMultiline(element) && isWellEndedComment(element)) {
    descriptors.add(new FoldingDescriptor(node,node.getTextRange()));
  }
  if (type.equals(mSL_COMMENT) && !usedComments.contains(element)) {
    usedComments.add(element);
    PsiElement end=null;
    for (PsiElement current=element.getNextSibling(); current != null; current=current.getNextSibling()) {
      IElementType elementType=current.getNode().getElementType();
      if (elementType == mSL_COMMENT) {
        end=current;
        usedComments.add(current);
        continue;
      }
      if (TokenSets.WHITE_SPACES_SET.contains(elementType)) {
        continue;
      }
      break;
    }
    if (end != null) {
      descriptors.add(new FoldingDescriptor(element,new TextRange(element.getTextRange().getStartOffset(),end.getTextRange().getEndOffset())));
    }
  }
  addFoldingForStrings(descriptors,node);
  Set<PsiElement> newUsedComments=new HashSet<PsiElement>();
  for (PsiElement child=element.getFirstChild(); child != null; child=child.getNextSibling()) {
    appendDescriptors(child,descriptors,newUsedComments);
  }
  if (element instanceof GroovyFile) {
    GroovyFile file=(GroovyFile)element;
    addFoldingsForImports(descriptors,file);
  }
}
