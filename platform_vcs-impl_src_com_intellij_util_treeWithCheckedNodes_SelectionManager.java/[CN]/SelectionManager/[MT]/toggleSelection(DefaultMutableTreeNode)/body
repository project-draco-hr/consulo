{
  final StateWorker stateWorker=new StateWorker(node,myNodeConvertor);
  if (stateWorker.getVf() == null)   return;
  final TreeNodeState state=getStateImpl(stateWorker);
  if (TreeNodeState.HAVE_SELECTED_ABOVE.equals(state))   return;
  if (TreeNodeState.CLEAR.equals(state) && (!myState.canAddSelection()))   return;
  final TreeNodeState futureState=myState.putAndPass(stateWorker.getVf(),TreeNodeState.SELECTED.equals(state) ? TreeNodeState.CLEAR : TreeNodeState.SELECTED);
  if (!TreeNodeState.SELECTED.equals(futureState)) {
    myState.clearAllCachedMatching(new Processor<VirtualFile>(){
      @Override public boolean process(      VirtualFile virtualFile){
        return VfsUtil.isAncestor(virtualFile,stateWorker.getVf(),false);
      }
    }
);
  }
  stateWorker.iterateParents(myState,new PairProcessor<VirtualFile,TreeNodeState>(){
    @Override public boolean process(    VirtualFile virtualFile,    TreeNodeState state){
      if (TreeNodeState.SELECTED.equals(futureState)) {
        myState.putAndPass(virtualFile,TreeNodeState.HAVE_SELECTED_BELOW);
      }
 else {
        myState.remove(virtualFile);
      }
      return true;
    }
  }
);
  myState.clearAllCachedMatching(new Processor<VirtualFile>(){
    @Override public boolean process(    VirtualFile vf){
      return VfsUtil.isAncestor(stateWorker.getVf(),vf,false);
    }
  }
);
  for (  VirtualFile selected : myState.getSelected()) {
    if (VfsUtil.isAncestor(stateWorker.getVf(),selected,true)) {
      myState.remove(selected);
    }
  }
}
