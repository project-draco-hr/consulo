{
  if (myHighlighterIterator != null && myHighlighterIterator.atEnd()) {
    return;
  }
  boolean isInSelection=isInSelection();
  boolean isInCaretRow=myStartOffset >= myCaretRowStart && myStartOffset < myCaretRowEnd;
  boolean isInGuardedBlock=!myUseOnlyFullLineHighlighters && myDocument.getOffsetGuard(myStartOffset) != null;
  TextAttributes syntax=myHighlighterIterator == null ? null : myHighlighterIterator.getTextAttributes();
  TextAttributes selection=isInSelection ? mySelectionAttributes : null;
  TextAttributes caret=isInCaretRow ? myCaretRowAttributes : null;
  TextAttributes fold=myCurrentFold != null ? myFoldTextAttributes : null;
  TextAttributes guard=isInGuardedBlock ? new TextAttributes(null,myReadOnlyColor,null,EffectType.BOXED,Font.PLAIN) : null;
  final int size=myCurrentHighlighters.size();
  if (size > 1) {
    ContainerUtil.quickSort(myCurrentHighlighters,BY_LAYER_THEN_ATTRIBUTES);
  }
  for (int i=0; i < size; i++) {
    RangeHighlighterEx highlighter=myCurrentHighlighters.get(i);
    if (highlighter.getTextAttributes() == TextAttributes.ERASE_MARKER) {
      syntax=null;
    }
  }
  List<TextAttributes> cachedAttributes=myCachedAttributesList;
  cachedAttributes.clear();
  int selectionAttributesIndex=-1;
  for (int i=0; i < size; i++) {
    RangeHighlighterEx highlighter=myCurrentHighlighters.get(i);
    if (highlighter.getLayer() < HighlighterLayer.SELECTION) {
      if (selectionAttributesIndex < 0) {
        selectionAttributesIndex=cachedAttributes.size();
      }
      if (selection != null) {
        cachedAttributes.add(selection);
        selection=null;
      }
    }
    if (fold != null && highlighter.getLayer() < HighlighterLayer.GUARDED_BLOCKS) {
      cachedAttributes.add(fold);
      fold=null;
    }
    if (guard != null && highlighter.getLayer() < HighlighterLayer.GUARDED_BLOCKS) {
      cachedAttributes.add(guard);
      guard=null;
    }
    if (caret != null && highlighter.getLayer() < HighlighterLayer.CARET_ROW) {
      cachedAttributes.add(caret);
      caret=null;
    }
    if (syntax != null && highlighter.getLayer() < HighlighterLayer.SYNTAX) {
      cachedAttributes.add(syntax);
      syntax=null;
    }
    TextAttributes textAttributes=highlighter.getTextAttributes();
    if (textAttributes != null && textAttributes != TextAttributes.ERASE_MARKER) {
      cachedAttributes.add(textAttributes);
    }
  }
  if (selectionAttributesIndex < 0) {
    selectionAttributesIndex=cachedAttributes.size();
  }
  if (selection != null)   cachedAttributes.add(selection);
  if (fold != null)   cachedAttributes.add(fold);
  if (guard != null)   cachedAttributes.add(guard);
  if (caret != null)   cachedAttributes.add(caret);
  if (syntax != null)   cachedAttributes.add(syntax);
  Color fore=null;
  Color back=isInGuardedBlock ? myReadOnlyColor : null;
  Color effect=null;
  EffectType effectType=null;
  int fontType=0;
  boolean selectionBackgroundIsPotentiallyVisible=cachedAttributes.isEmpty();
  for (int i=0; i < cachedAttributes.size(); i++) {
    TextAttributes attrs=cachedAttributes.get(i);
    if (fore == null) {
      fore=attrs.getForegroundColor();
    }
    if (back == null) {
      if (isInSelection && i == selectionAttributesIndex || !isInSelection && i >= selectionAttributesIndex) {
        selectionBackgroundIsPotentiallyVisible=true;
      }
      back=attrs.getBackgroundColor();
    }
    if (fontType == Font.PLAIN) {
      fontType=attrs.getFontType();
    }
    if (effect == null) {
      effect=attrs.getEffectColor();
      effectType=attrs.getEffectType();
    }
  }
  if (fore == null)   fore=myDefaultForeground;
  if (back == null)   back=myDefaultBackground;
  if (effectType == null)   effectType=EffectType.BOXED;
  if (fontType == Font.PLAIN)   fontType=myDefaultFontType;
  myMergedAttributes.setAttributes(fore,back,effect,null,effectType,fontType);
  myCurrentBackgroundColor=back;
  if (selectionBackgroundIsPotentiallyVisible && myCurrentVirtualSelectionIndex < mySelectionStarts.length && myStartOffset == mySelectionEnds[myCurrentVirtualSelectionIndex]) {
    myCurrentLineHasVirtualSelection=true;
    myCurrentPastLineEndBackgroundSegment=myVirtualSelectionStarts[myCurrentVirtualSelectionIndex] > 0 ? 0 : 1;
  }
 else {
    myCurrentLineHasVirtualSelection=false;
    myCurrentPastLineEndBackgroundSegment=0;
  }
}
