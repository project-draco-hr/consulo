{
  if (!myInlineThisOnly && checkReadOnly()) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myMethod))     return false;
  }
  final UsageInfo[] usagesIn=refUsages.get();
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.putValue(method,message);
    }
    for (    UsageInfo info : usagesIn) {
      final PsiElement element=info.getElement();
      if (element instanceof PsiDocMethodOrFieldRef && !PsiTreeUtil.isAncestor(myMethod,element,false)) {
        conflicts.putValue(element,"Inlined method is used in javadoc");
      }
      if (element instanceof PsiMethodReferenceExpression) {
        conflicts.putValue(element,"Inlined method is used in method reference");
      }
      final String errorMessage=checkCalledInSuperOrThisExpr(myMethod.getBody(),element);
      if (errorMessage != null) {
        conflicts.putValue(element,errorMessage);
      }
    }
  }
  ArrayList<PsiReference> refs=convertUsagesToRefs(usagesIn);
  myInliners=GenericInlineHandler.initializeInliners(myMethod,new InlineHandler.Settings(){
    @Override public boolean isOnlyOneReferenceToInline(){
      return myInlineThisOnly;
    }
  }
,refs);
  myInliners.put(JavaLanguage.INSTANCE,new InlineHandler.Inliner(){
    @Nullable @Override public MultiMap<PsiElement,String> getConflicts(    PsiReference reference,    PsiElement referenced){
      return MultiMap.emptyInstance();
    }
    @Override public void inlineUsage(    @NotNull UsageInfo usage,    @NotNull PsiElement referenced){
      if (usage instanceof NonCodeUsageInfo)       return;
      throw new UnsupportedOperationException("usage: " + usage.getClass().getName() + ", referenced: "+ referenced.getClass().getName()+ "text: "+ referenced.getText());
    }
  }
);
  for (  PsiReference ref : refs) {
    GenericInlineHandler.collectConflicts(ref,myMethod,myInliners,conflicts);
  }
  final PsiReturnStatement[] returnStatements=RefactoringUtil.findReturnStatements(myMethod);
  for (  PsiReturnStatement statement : returnStatements) {
    PsiExpression value=statement.getReturnValue();
    if (value != null && !(value instanceof PsiCallExpression)) {
      for (      UsageInfo info : usagesIn) {
        PsiReference reference=info.getReference();
        if (reference != null) {
          InlineUtil.TailCallType type=InlineUtil.getTailCallType(reference);
          if (type == InlineUtil.TailCallType.Simple) {
            conflicts.putValue(statement,"Inlined result would contain parse errors");
            break;
          }
        }
      }
    }
  }
  addInaccessibleMemberConflicts(myMethod,usagesIn,new ReferencedElementsCollector(),conflicts);
  addInaccessibleSuperCallsConflicts(usagesIn,conflicts);
  return showConflicts(conflicts,usagesIn);
}
