{
  boolean result=false;
  for (Iterator i=currNode.outIterator(); i.hasNext(); ) {
    MarkedEdge currEdge=(MarkedEdge)i.next();
    MarkedNode nextNode=(MarkedNode)currEdge.end();
    Mark theMark=functor.compute(currNode.getMark(),currEdge.getMark(),nextNode.getMark());
    if (!theMark.coincidesWith(nextNode.getMark())) {
      result=true;
      nextNode.setMark(theMark);
      worklist.addFirst(nextNode);
    }
  }
  return result;
}
