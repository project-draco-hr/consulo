{
  table.setDragEnabled(true);
  DnDSupport.createBuilder(table).setBeanProvider(new Function<DnDActionInfo,DnDDragStartBean>(){
    @Override public DnDDragStartBean fun(    DnDActionInfo info){
      final Point p=info.getPoint();
      final TableCellEditor cellEditor=table.getCellEditor();
      if (cellEditor != null) {
        cellEditor.stopCellEditing();
      }
      return new DnDDragStartBean(new TableRowDragInfo(table,Integer.valueOf(table.rowAtPoint(p))));
    }
  }
).setTargetChecker(new DnDTargetChecker(){
    @Override public boolean update(    DnDEvent event){
      final Object o=event.getAttachedObject();
      event.setDropPossible(o instanceof TableRowDragInfo && ((TableRowDragInfo)o).table == table);
      return false;
    }
  }
).setDropHandler(new DnDDropHandler(){
    @Override public void drop(    DnDEvent event){
      final Object o=event.getAttachedObject();
      final Point p=event.getPoint();
      if (o instanceof TableRowDragInfo && ((TableRowDragInfo)o).table == table) {
        int oldIndex=((TableRowDragInfo)o).row;
        if (oldIndex == -1)         return;
        int newIndex=table.rowAtPoint(p);
        if (newIndex == -1) {
          newIndex=table.getRowCount() - 1;
        }
        int min=Math.min(oldIndex,newIndex);
        int max=Math.max(oldIndex,newIndex);
        if (newIndex > oldIndex) {
          while (min < max) {
            model.exchangeRows(min,min + 1);
            min++;
          }
          table.getSelectionModel().setSelectionInterval(min,min);
        }
 else {
          while (max > min) {
            model.exchangeRows(max,max - 1);
            max--;
          }
          table.getSelectionModel().setSelectionInterval(max,max);
        }
      }
    }
  }
).install();
}
