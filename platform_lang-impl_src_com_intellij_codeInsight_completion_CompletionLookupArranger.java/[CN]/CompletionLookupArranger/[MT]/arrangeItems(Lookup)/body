{
  List<LookupElement> items=matchingItems(lookup);
  Collections.sort(items,new Comparator<LookupElement>(){
    public int compare(    LookupElement o1,    LookupElement o2){
      return mySortingWeights.get(o1).compareTo(mySortingWeights.get(o2));
    }
  }
);
  MultiMap<CompletionSorterImpl,LookupElement> inputBySorter=groupInputBySorter(items);
  final List<List<LookupElement>> groups=new ArrayList<List<LookupElement>>();
  for (  CompletionSorterImpl sorter : myClassifiers.keySet()) {
    ContainerUtil.addAll(groups,myClassifiers.get(sorter).classify((List<LookupElement>)inputBySorter.get(sorter)));
  }
  LinkedHashSet<LookupElement> model=new LinkedHashSet<LookupElement>();
  for (  List<LookupElement> group : groups) {
    addPrefixItems(lookup,model,true,group);
  }
  for (  List<LookupElement> group : groups) {
    addPrefixItems(lookup,model,false,group);
  }
  myFrozenItems.retainAll(items);
  model.addAll(myFrozenItems);
  if (!isAlphaSorted()) {
    addMostRelevantItems(model,groups);
    LookupElement lastSelection=lookup.getCurrentItem();
    if (items.contains(lastSelection)) {
      model.add(lastSelection);
    }
  }
  myFrozenItems.clear();
  if (((LookupImpl)lookup).isShown()) {
    myFrozenItems.addAll(model);
  }
  if (isAlphaSorted()) {
    Collections.sort(items,new Comparator<LookupElement>(){
      @Override public int compare(      LookupElement o1,      LookupElement o2){
        return o1.getLookupString().compareToIgnoreCase(o2.getLookupString());
      }
    }
);
    model.addAll(items);
  }
 else {
    for (    List<LookupElement> group : groups) {
      model.addAll(group);
    }
  }
  ArrayList<LookupElement> listModel=new ArrayList<LookupElement>(model);
  return new Pair<List<LookupElement>,Integer>(listModel,getItemToSelect(lookup,groups,listModel));
}
