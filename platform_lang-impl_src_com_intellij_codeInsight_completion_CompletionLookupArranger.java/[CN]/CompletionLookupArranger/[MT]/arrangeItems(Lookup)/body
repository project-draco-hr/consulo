{
  List<LookupElement> items=matchingItems(lookup);
  Collections.sort(items,new Comparator<LookupElement>(){
    public int compare(    LookupElement o1,    LookupElement o2){
      return mySortingWeights.get(o1).compareTo(mySortingWeights.get(o2));
    }
  }
);
  MultiMap<CompletionSorterImpl,LookupElement> inputBySorter=groupInputBySorter(items);
  final List<LookupElement> byRelevance=new ArrayList<LookupElement>();
  for (  CompletionSorterImpl sorter : myClassifiers.keySet()) {
    ContainerUtil.addAll(byRelevance,myClassifiers.get(sorter).classify((List<LookupElement>)inputBySorter.get(sorter)));
  }
  LinkedHashSet<LookupElement> model=new LinkedHashSet<LookupElement>();
  addPrefixItems(lookup,model,true,byRelevance);
  addPrefixItems(lookup,model,false,byRelevance);
  myFrozenItems.retainAll(items);
  model.addAll(myFrozenItems);
  if (!isAlphaSorted()) {
    for (int i=0; i < byRelevance.size() && model.size() < MAX_PREFERRED_COUNT; i++) {
      model.add(byRelevance.get(i));
    }
    LookupElement lastSelection=lookup.getCurrentItem();
    if (items.contains(lastSelection)) {
      model.add(lastSelection);
    }
  }
  myFrozenItems.clear();
  if (((LookupImpl)lookup).isShown()) {
    myFrozenItems.addAll(model);
  }
  if (isAlphaSorted()) {
    Collections.sort(items,new Comparator<LookupElement>(){
      @Override public int compare(      LookupElement o1,      LookupElement o2){
        return o1.getLookupString().compareToIgnoreCase(o2.getLookupString());
      }
    }
);
    model.addAll(items);
  }
 else {
    model.addAll(byRelevance);
  }
  ArrayList<LookupElement> listModel=new ArrayList<LookupElement>(model);
  return new Pair<List<LookupElement>,Integer>(listModel,getItemToSelect(lookup,byRelevance,listModel));
}
