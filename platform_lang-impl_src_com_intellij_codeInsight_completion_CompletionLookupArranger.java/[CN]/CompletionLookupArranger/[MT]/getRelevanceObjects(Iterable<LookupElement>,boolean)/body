{
  final LinkedHashMap<LookupElement,List<Pair<String,Object>>> map=ContainerUtil.newLinkedHashMap();
  final MultiMap<CompletionSorterImpl,LookupElement> inputBySorter=groupItemsBySorter(items);
  int sorterNumber=0;
  for (  CompletionSorterImpl sorter : inputBySorter.keySet()) {
    sorterNumber++;
    Collection<LookupElement> thisSorterItems=inputBySorter.get(sorter);
    for (    LookupElement element : thisSorterItems) {
      map.put(element,ContainerUtil.newArrayList(new Pair<String,Object>("frozen",myFrozenItems.contains(element)),new Pair<String,Object>("sorter",sorterNumber)));
    }
    ProcessingContext context=createContext(false);
    Classifier<LookupElement> classifier=myClassifiers.get(sorter);
    while (classifier != null) {
      final THashSet<LookupElement> itemSet=ContainerUtil.newIdentityTroveSet(thisSorterItems);
      List<LookupElement> unsortedItems=ContainerUtil.filter(myItems,new Condition<LookupElement>(){
        @Override public boolean value(        LookupElement lookupElement){
          return itemSet.contains(lookupElement);
        }
      }
);
      List<Pair<LookupElement,Object>> pairs=classifier.getSortingWeights(unsortedItems,context);
      if (!hideSingleValued || !haveSameWeights(pairs)) {
        for (        Pair<LookupElement,Object> pair : pairs) {
          map.get(pair.first).add(Pair.create(classifier.getPresentableName(),pair.second));
        }
      }
      classifier=classifier.getNext();
    }
  }
  return map;
}
