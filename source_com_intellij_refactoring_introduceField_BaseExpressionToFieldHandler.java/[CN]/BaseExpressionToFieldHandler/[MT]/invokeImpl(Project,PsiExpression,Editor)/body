{
  LOG.assertTrue(selectedExpr != null);
  final PsiFile file=selectedExpr.getContainingFile();
  LOG.assertTrue(file != null,"expr.getContainingFile() == null");
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + selectedExpr);
  }
  myParentClass=getParentClass(selectedExpr);
  if (myParentClass == null) {
    if (file instanceof JspFile) {
      CommonRefactoringUtil.showErrorMessage(getRefactoringName(),RefactoringBundle.message("error.not.supported.for.jsp",getRefactoringName()),getHelpID(),project);
      return false;
    }
 else {
      LOG.assertTrue(false);
      return false;
    }
  }
  if (!validClass(myParentClass)) {
    return false;
  }
  PsiType tempType=getTypeByExpression(selectedExpr);
  if (tempType == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("unknown.expression.type"));
    CommonRefactoringUtil.showErrorMessage(getRefactoringName(),message,getHelpID(),project);
    return false;
  }
  if (tempType == PsiType.VOID) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    CommonRefactoringUtil.showErrorMessage(getRefactoringName(),message,getHelpID(),project);
    return false;
  }
  PsiElement tempAnchorElement=RefactoringUtil.getParentExpressionAnchorElement(selectedExpr);
  if (tempAnchorElement == null) {
    String message=RefactoringBundle.message("refactoring.is.not.supported.in.the.current.context",getRefactoringName());
    CommonRefactoringUtil.showErrorMessage(getRefactoringName(),message,getHelpID(),project);
    return false;
  }
  if (!file.isWritable()) {
    if (!RefactoringMessageUtil.checkReadOnlyStatus(project,file))     return false;
  }
  final PsiClass parentClass=myParentClass;
  final OccurenceManager occurenceManager=createOccurenceManager(selectedExpr,parentClass);
  final PsiExpression[] occurrences=occurenceManager.getOccurences();
  final PsiElement anchorStatementIfAll=occurenceManager.getAnchorStatementForAll();
  ArrayList<RangeHighlighter> highlighters=null;
  if (editor != null) {
    final HighlightManager highlightManager;
    highlighters=new ArrayList<RangeHighlighter>();
    highlightManager=HighlightManager.getInstance(project);
    if (occurrences.length > 1) {
      highlightManager.addOccurrenceHighlights(editor,occurrences,highlightAttributes(),true,highlighters);
    }
  }
  final Settings settings=showRefactoringDialog(project,myParentClass,selectedExpr,tempType,occurrences,tempAnchorElement,anchorStatementIfAll);
  if (settings == null)   return false;
  if (settings.getForcedType() != null) {
    tempType=settings.getForcedType();
  }
  final PsiType type=tempType;
  final String fieldName=settings.getFieldName();
  final PsiElement anchorElementIfOne=tempAnchorElement;
  final boolean replaceAll=settings.isReplaceAll();
  if (replaceAll) {
    tempAnchorElement=anchorStatementIfAll;
  }
  final PsiElement anchorElement=tempAnchorElement;
  if (editor != null) {
    HighlightManager highlightManager=HighlightManager.getInstance(project);
    for (    RangeHighlighter highlighter : highlighters) {
      highlightManager.removeSegmentHighlighter(editor,highlighter);
    }
  }
  PsiElement anchor=getNormalizedAnchor(anchorElement);
  boolean tempDeleteSelf=false;
  if (selectedExpr.getParent() instanceof PsiExpressionStatement && anchor.equals(anchorElement)) {
    PsiStatement statement=(PsiStatement)selectedExpr.getParent();
    if (statement.getParent() instanceof PsiCodeBlock) {
      tempDeleteSelf=true;
    }
  }
  final boolean deleteSelf=tempDeleteSelf;
  final Runnable runnable=new Runnable(){
    public void run(){
      try {
        PsiExpression expr=selectedExpr;
        InitializationPlace initializerPlace=settings.getInitializerPlace();
        final PsiLocalVariable localVariable=settings.getLocalVariable();
        final boolean deleteLocalVariable=settings.isDeleteLocalVariable();
        PsiExpression initializer;
        if (localVariable != null) {
          initializer=localVariable.getInitializer();
        }
 else {
          initializer=expr;
        }
        final PsiMethod enclosingConstructor=getEnclosingConstructor(myParentClass,anchorElement);
        final PsiClass destClass=settings.getDestinationClass() == null ? myParentClass : settings.getDestinationClass();
        if (!destClass.getContainingFile().isWritable()) {
          if (!RefactoringMessageUtil.checkReadOnlyStatus(project,destClass.getContainingFile()))           return;
        }
        PsiField field=createField(fieldName,type,initializer,initializerPlace == IN_FIELD_DECLARATION && initializer != null);
        field.getModifierList().setModifierProperty(settings.getFieldVisibility(),true);
        if (settings.isDeclareFinal()) {
          field.getModifierList().setModifierProperty(PsiModifier.FINAL,true);
        }
        if (settings.isDeclareStatic()) {
          field.getModifierList().setModifierProperty(PsiModifier.STATIC,true);
        }
        if (settings.isAnnotateAsNonNls()) {
          PsiAnnotation annotation=myParentClass.getManager().getElementFactory().createAnnotationFromText("@" + AnnotationUtil.NON_NLS,myParentClass);
          field.getModifierList().addAfter(annotation,null);
          CodeStyleManager.getInstance(myParentClass.getProject()).shortenClassReferences(field.getModifierList());
        }
        PsiElement finalAnchorElement=null;
        if (destClass == myParentClass) {
          for (finalAnchorElement=anchorElement; finalAnchorElement != null && finalAnchorElement.getParent() != destClass; finalAnchorElement=finalAnchorElement.getParent()) {
            ;
          }
        }
        PsiMember anchorMember=finalAnchorElement instanceof PsiMember ? ((PsiMember)finalAnchorElement) : null;
        if ((anchorMember instanceof PsiField || anchorMember instanceof PsiClassInitializer) && anchorMember.hasModifierProperty(PsiModifier.STATIC) == field.hasModifierProperty(PsiModifier.STATIC)) {
          field=(PsiField)destClass.addBefore(field,anchorMember);
        }
 else {
          field=(PsiField)destClass.add(field);
        }
        PsiStatement assignStatement;
        if ((initializerPlace == IN_CURRENT_METHOD && initializer != null) || (initializerPlace == IN_CONSTRUCTOR && enclosingConstructor != null && initializer != null)) {
          final PsiElement anchorElementHere;
          if (replaceAll) {
            if (enclosingConstructor != null) {
              final PsiElement anchorInConstructor=occurenceManager.getAnchorStatementForAllInScope(enclosingConstructor);
              anchorElementHere=anchorInConstructor != null ? anchorInConstructor : anchorStatementIfAll;
            }
 else {
              anchorElementHere=anchorStatementIfAll;
            }
          }
 else {
            anchorElementHere=anchorElementIfOne;
          }
          assignStatement=createAssignment(field,initializer,anchorElementHere);
          anchorElementHere.getParent().addBefore(assignStatement,getNormalizedAnchor(anchorElementHere));
        }
        if (initializerPlace == IN_CONSTRUCTOR && initializer != null) {
          addInitializationToConstructors(initializer,field,enclosingConstructor);
        }
        if (initializerPlace == IN_SETUP_METHOD && initializer != null) {
          addInitializationToSetUp(initializer,field,occurenceManager,replaceAll);
        }
        if (expr.getParent() instanceof PsiParenthesizedExpression) {
          expr=(PsiExpression)expr.getParent();
        }
        if (deleteSelf) {
          PsiStatement statement=(PsiStatement)expr.getParent();
          statement.delete();
        }
        if (replaceAll) {
          List<PsiElement> array=new ArrayList<PsiElement>();
          for (          PsiExpression occurrence : occurrences) {
            if (occurrence instanceof PsiExpression) {
              occurrence=RefactoringUtil.outermostParenthesizedExpression(occurrence);
            }
            if (deleteSelf && occurrence.equals(expr))             continue;
            array.add(RefactoringUtil.replaceOccurenceWithFieldRef(occurrence,field,destClass));
          }
          if (editor != null) {
            if (!ApplicationManager.getApplication().isUnitTestMode()) {
              PsiElement[] exprsToHighlight=array.toArray(new PsiElement[array.size()]);
              HighlightManager highlightManager=HighlightManager.getInstance(project);
              highlightManager.addOccurrenceHighlights(editor,exprsToHighlight,highlightAttributes(),true,null);
              WindowManager.getInstance().getStatusBar(project).setInfo(RefactoringBundle.message("press.escape.to.remove.the.highlighting"));
            }
          }
        }
 else {
          if (!deleteSelf) {
            expr=RefactoringUtil.outermostParenthesizedExpression(expr);
            RefactoringUtil.replaceOccurenceWithFieldRef(expr,field,destClass);
          }
        }
        if (localVariable != null) {
          if (deleteLocalVariable) {
            localVariable.normalizeDeclaration();
            localVariable.getParent().delete();
          }
        }
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
  }
;
  CommandProcessor.getInstance().executeCommand(project,new Runnable(){
    public void run(){
      ApplicationManager.getApplication().runWriteAction(runnable);
    }
  }
,getRefactoringName(),null);
  return true;
}
