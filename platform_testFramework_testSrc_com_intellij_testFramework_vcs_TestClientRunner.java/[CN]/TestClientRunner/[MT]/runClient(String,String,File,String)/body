{
  final List<String> arguments=new ArrayList<String>();
  final File client=new File(myClientBinaryPath,SystemInfo.isWindows ? exeName + ".exe" : exeName);
  if (client.exists()) {
    arguments.add(client.toString());
  }
 else {
    arguments.add(exeName);
  }
  Collections.addAll(arguments,commandLine);
  if (myTraceClient) {
    LOG.info("*** running:\n" + arguments);
    if (StringUtil.isNotEmpty(stdin)) {
      LOG.info("*** stdin:\n" + stdin);
    }
  }
  final ProcessBuilder builder=new ProcessBuilder().command(arguments);
  if (workingDir != null) {
    builder.directory(workingDir);
  }
  if (myClientEnvironment != null) {
    builder.environment().putAll(myClientEnvironment);
  }
  final Process clientProcess=builder.start();
  if (stdin != null) {
    final OutputStream outputStream=clientProcess.getOutputStream();
    try {
      final byte[] bytes=stdin.getBytes();
      outputStream.write(bytes);
    }
  finally {
      outputStream.close();
    }
  }
  final CapturingProcessHandler handler=new CapturingProcessHandler(clientProcess,CharsetToolkit.getDefaultSystemCharset());
  final ProcessOutput result=handler.runProcess(100 * 1000,false);
  if (myTraceClient || result.isTimeout()) {
    LOG.debug("*** result: " + result.getExitCode());
    final String out=result.getStdout().trim();
    if (out.length() > 0) {
      LOG.debug("*** output:\n" + out);
    }
    final String err=result.getStderr().trim();
    if (err.length() > 0) {
      LOG.debug("*** error:\n" + err);
    }
  }
  if (result.isTimeout()) {
    String processList=LogUtil.getProcessList();
    handler.destroyProcess();
    throw new RuntimeException("Timeout waiting for VCS client to finish execution:\n" + processList);
  }
  return result;
}
