{
  final Map<String,Orderable> map=new HashMap<String,Orderable>();
  final HashMap<Orderable,LoadingOrder> cachedMap=new HashMap<Orderable,LoadingOrder>(orderables.length);
  final HashSet<Orderable> first=new HashSet<Orderable>(1);
  final HashSet<Orderable> hasBefore=new HashSet<Orderable>(orderables.length);
  for (  Orderable o : orderables) {
    final String id=o.getOrderId();
    if (StringUtil.isNotEmpty(id))     map.put(id,o);
    LoadingOrder order=o.getOrder();
    cachedMap.put(o,order);
    if (order.myFirst)     first.add(o);
    if (order.myBefore.size() != 0)     hasBefore.add(o);
  }
  DFSTBuilder<Orderable> builder=new DFSTBuilder<Orderable>(new GraphGenerator<Orderable>(new CachingSemiGraph<Orderable>(new GraphGenerator.SemiGraph<Orderable>(){
    @Override public Collection<Orderable> getNodes(){
      final ArrayList<Orderable> list=new ArrayList<Orderable>(Arrays.asList(orderables));
      Collections.reverse(list);
      return list;
    }
    @Override public Iterator<Orderable> getIn(    final Orderable n){
      final LoadingOrder order=cachedMap.get(n);
      Set<Orderable> predecessors=new LinkedHashSet<Orderable>();
      for (      final String id : order.myAfter) {
        final Orderable orderable=map.get(id);
        if (orderable != null) {
          predecessors.add(orderable);
        }
      }
      String id=n.getOrderId();
      if (StringUtil.isNotEmpty(id)) {
        for (        final Orderable orderable : hasBefore) {
          final LoadingOrder hisOrder=cachedMap.get(orderable);
          if (hisOrder.myBefore.contains(id)) {
            predecessors.add(orderable);
          }
        }
      }
      if (order.myLast) {
        for (        final Orderable orderable : orderables) {
          final LoadingOrder hisOrder=cachedMap.get(orderable);
          if (!hisOrder.myLast) {
            predecessors.add(orderable);
          }
        }
      }
      if (!order.myFirst) {
        for (        Orderable orderable : first) {
          predecessors.add(orderable);
        }
      }
      return predecessors.iterator();
    }
  }
)));
  if (!builder.isAcyclic()) {
    final Pair<Orderable,Orderable> dependency=builder.getCircularDependency();
    throw new SortingException("Could not satisfy sorting requirements",new Element[]{dependency.first.getDescribingElement(),dependency.second.getDescribingElement()});
  }
  Arrays.sort(orderables,builder.comparator());
}
