{
  if (prototype == null)   return;
  PsiMethod method=aClass.findMethodBySignature(prototype,true);
  if (method != null && method != refactoredMethod) {
    if (method.getContainingClass().equals(aClass)) {
      final String classDescr=aClass instanceof PsiAnonymousClass ? RefactoringBundle.message("current.class") : getDescription(aClass,false);
      conflicts.add(RefactoringBundle.message("method.0.is.already.defined.in.the.1",getMethodPrototypeString(prototype),classDescr));
    }
 else {
      if (method.getManager().getResolveHelper().isAccessible(method,aClass,null)) {
        String protoMethodInfo=getMethodPrototypeString(prototype);
        String className=CommonRefactoringUtil.htmlEmphasize(UsageViewUtil.getDescriptiveName(method.getContainingClass()));
        if (PsiUtil.getAccessLevel(prototype.getModifierList()) >= PsiUtil.getAccessLevel(method.getModifierList())) {
          boolean isMethodAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
          boolean isMyMethodAbstract=refactoredMethod != null && refactoredMethod.hasModifierProperty(PsiModifier.ABSTRACT);
          final String conflict=isMethodAbstract != isMyMethodAbstract ? RefactoringBundle.message("method.0.will.implement.method.of.the.base.class",protoMethodInfo,className) : RefactoringBundle.message("method.0.will.override.a.method.of.the.base.class",protoMethodInfo,className);
          conflicts.add(conflict);
        }
 else {
          conflicts.add(RefactoringBundle.message("method.0.will.hide.method.of.the.base.class",protoMethodInfo,className));
        }
      }
    }
  }
}
