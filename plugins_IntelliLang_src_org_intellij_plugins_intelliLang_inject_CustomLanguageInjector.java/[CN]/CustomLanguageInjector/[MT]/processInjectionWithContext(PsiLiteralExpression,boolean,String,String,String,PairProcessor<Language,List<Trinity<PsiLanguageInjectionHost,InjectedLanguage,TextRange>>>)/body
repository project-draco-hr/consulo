{
  final Ref<Boolean> unparsableRef=Ref.create(unparsable);
  final List<Object> objects=ContextComputationProcessor.collectOperands(place,prefix,suffix,unparsableRef);
  if (objects.isEmpty())   return;
  final List<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>> list=new ArrayList<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>>();
  final int len=objects.size();
  for (int i=0; i < len; i++) {
    String curPrefix=null;
    Object o=objects.get(i);
    if (o instanceof String) {
      curPrefix=(String)o;
      if (i == len - 1)       return;
      o=objects.get(++i);
    }
    String curSuffix=null;
    PsiLanguageInjectionHost curHost=null;
    if (o instanceof PsiLanguageInjectionHost) {
      curHost=(PsiLanguageInjectionHost)o;
      if (i == len - 2) {
        final Object next=objects.get(i + 1);
        if (next instanceof String) {
          i++;
          curSuffix=(String)next;
        }
      }
    }
    if (curHost == null) {
      unparsableRef.set(Boolean.TRUE);
    }
 else {
      list.add(Trinity.create(curHost,InjectedLanguage.create(langId,curPrefix,curSuffix,true),ElementManipulators.getManipulator(curHost).getRangeInElement(curHost)));
    }
  }
  for (  Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange> trinity : list) {
    trinity.first.putUserData(HAS_UNPARSABLE_FRAGMENTS,unparsableRef.get());
  }
  processor.process(InjectedLanguage.findLanguageById(langId),list);
}
