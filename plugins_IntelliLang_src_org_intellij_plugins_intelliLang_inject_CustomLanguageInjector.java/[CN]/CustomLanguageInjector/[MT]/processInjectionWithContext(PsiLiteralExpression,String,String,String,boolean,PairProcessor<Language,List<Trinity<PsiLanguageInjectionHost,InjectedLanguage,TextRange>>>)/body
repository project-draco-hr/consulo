{
  final List<Object> objects=ContextComputationProcessor.collectOperands(place,prefix,suffix);
  if (objects.isEmpty())   return;
  final List<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>> list=new ArrayList<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>>();
  boolean hasUnparsableParts=hasUnparsablePartsExt;
  final boolean dynamic=!objects.isEmpty();
  final int len=objects.size();
  for (int i=0; i < len; i++) {
    String curPrefix=null;
    String curSuffix=null;
    PsiLanguageInjectionHost curHost=null;
    Object o=objects.get(i);
    if (o instanceof String) {
      curPrefix=(String)o;
      o=objects.get(++i);
    }
    if (o instanceof PsiLanguageInjectionHost) {
      curHost=(PsiLanguageInjectionHost)o;
      if (i == len - 2) {
        final Object next=objects.get(i + 1);
        if (next instanceof String) {
          i++;
          curSuffix=(String)next;
        }
      }
    }
    if (curHost == null)     hasUnparsableParts=true;
 else     list.add(Trinity.create(curHost,InjectedLanguage.create(langId,curPrefix,curSuffix,dynamic),ElementManipulators.getManipulator(curHost).getRangeInElement(curHost)));
  }
  for (  Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange> trinity : list) {
    trinity.first.putUserData(HAS_UPARSABLE_FRAGMENTS,hasUnparsableParts ? Boolean.TRUE : Boolean.FALSE);
  }
  processor.process(InjectedLanguage.findLanguageById(langId),list);
}
