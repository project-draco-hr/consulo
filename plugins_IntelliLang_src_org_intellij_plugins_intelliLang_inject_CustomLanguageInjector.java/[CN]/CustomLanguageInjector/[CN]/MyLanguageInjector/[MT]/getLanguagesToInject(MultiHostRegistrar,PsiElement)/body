{
  final TreeSet<TextRange> ranges=new TreeSet<TextRange>(RANGE_COMPARATOR);
  myInjector.getInjectedLanguage(host,new PairProcessor<Language,List<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>>>(){
    public boolean process(    final Language language,    List<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>> list){
      if (language != null) {
        for (        Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange> trinity : list) {
          if (ranges.contains(trinity.third.shiftRight(trinity.first.getTextRange().getStartOffset())))           return true;
        }
        registrar.startInjecting(language);
        try {
          for (          Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange> trinity : list) {
            final PsiLanguageInjectionHost host=trinity.first;
            final TextRange textRange=trinity.third;
            final InjectedLanguage injectedLanguage=trinity.second;
            ranges.add(textRange.shiftRight(host.getTextRange().getStartOffset()));
            if (injectedLanguage.isDynamic()) {
              final StringBuilder prefix=new StringBuilder(injectedLanguage.getPrefix());
              final StringBuilder suffix=new StringBuilder(injectedLanguage.getSuffix());
              adjustPrefixAndSuffix(getUnescapedText(host,textRange.substring(host.getText())),prefix,suffix);
              addPlaceSafe(registrar,language,host,textRange,prefix.toString(),suffix.toString());
            }
 else {
              addPlaceSafe(registrar,language,host,textRange,injectedLanguage.getPrefix(),injectedLanguage.getSuffix());
            }
          }
        }
  finally {
          try {
            registrar.doneInjecting();
          }
 catch (          AssertionError e) {
            logError(language,host,null,e);
          }
catch (          Exception e) {
            logError(language,host,null,e);
          }
        }
      }
      return true;
    }
  }
);
}
