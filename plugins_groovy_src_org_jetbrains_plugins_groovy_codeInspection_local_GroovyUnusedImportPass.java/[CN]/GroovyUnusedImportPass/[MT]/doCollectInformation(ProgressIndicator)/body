{
  final Set<GrImportStatement> unusedImports=new HashSet<GrImportStatement>(GroovyImportOptimizer.getValidImportStatements(myFile));
  myFile.accept(new PsiRecursiveElementWalkingVisitor(){
    @Override public void visitElement(    PsiElement element){
      if (element instanceof GrReferenceElement) {
        for (        GroovyResolveResult result : ((GrReferenceElement)element).multiResolve(true)) {
          GroovyPsiElement context=result.getCurrentFileResolveContext();
          if (context instanceof GrImportStatement) {
            GrImportStatement importStatement=(GrImportStatement)context;
            unusedImports.remove(importStatement);
          }
        }
      }
      super.visitElement(element);
    }
  }
);
  myUnusedImports=unusedImports;
  if (!unusedImports.isEmpty() && CodeInsightSettings.getInstance().OPTIMIZE_IMPORTS_ON_THE_FLY) {
    final VirtualFile vfile=myFile.getVirtualFile();
    if (vfile != null && ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(vfile)) {
      final GrImportStatement[] imports=myFile.getImportStatements();
      if (imports.length > 0) {
        final int offset=myEditor.getCaretModel().getOffset();
        if (imports[0].getTextRange().getStartOffset() <= offset && offset <= imports[imports.length - 1].getTextRange().getEndOffset()) {
          return;
        }
      }
      myOptimizeRunnable=new GroovyImportOptimizer().processFile(myFile);
    }
  }
}
