{
  if (mySignature == null)   return null;
  boolean hasReceiver=false;
  final PsiType[] parameterTypes=mySignature.getParameterTypes();
  if (parameterTypes.length > 0) {
    final PsiClassType.ClassResolveResult classResolveResult=PsiUtil.resolveGenericsClassInType(parameterTypes[0]);
    if (LambdaUtil.isReceiverType(parameterTypes[0],myContainingClass,mySubstitutor)) {
      hasReceiver=true;
    }
  }
  final List<CandidateInfo> firstCandidates=new ArrayList<CandidateInfo>();
  final List<CandidateInfo> secondCandidates=new ArrayList<CandidateInfo>();
  for (  CandidateInfo conflict : conflicts) {
    if (!(conflict instanceof MethodCandidateInfo))     continue;
    final PsiMethod psiMethod=((MethodCandidateInfo)conflict).getElement();
    if (psiMethod == null)     continue;
    PsiSubstitutor subst=PsiSubstitutor.EMPTY;
    subst=subst.putAll(mySubstitutor);
    subst=subst.putAll(conflict.getSubstitutor());
    final PsiType[] signatureParameterTypes2=psiMethod.getSignature(subst).getParameterTypes();
    final boolean varArgs=psiMethod.isVarArgs();
    final boolean validConstructorRef=psiMethod.isConstructor() && (myContainingClass.getContainingClass() == null || myContainingClass.hasModifierProperty(PsiModifier.STATIC));
    final boolean staticOrValidConstructorRef=psiMethod.hasModifierProperty(PsiModifier.STATIC) || validConstructorRef;
    if ((parameterTypes.length == signatureParameterTypes2.length || varArgs && parameterTypes.length >= signatureParameterTypes2.length) && (!myBeginsWithReferenceType || staticOrValidConstructorRef)) {
      boolean correct=true;
      for (int i=0; i < parameterTypes.length; i++) {
        final PsiType type1=parameterTypes[i];
        final PsiType type2=varArgs && i >= signatureParameterTypes2.length - 1 ? ((PsiArrayType)signatureParameterTypes2[signatureParameterTypes2.length - 1]).getComponentType() : signatureParameterTypes2[i];
        correct&=TypeConversionUtil.isAssignable(type2,subst.substitute(GenericsUtil.eliminateWildcards(type1)));
      }
      if (correct) {
        firstCandidates.add(conflict);
      }
    }
    if (hasReceiver && parameterTypes.length == signatureParameterTypes2.length + 1 && !staticOrValidConstructorRef) {
      boolean correct=true;
      for (int i=0; i < signatureParameterTypes2.length; i++) {
        final PsiType type1=parameterTypes[i + 1];
        final PsiType type2=signatureParameterTypes2[i];
        correct&=TypeConversionUtil.isAssignable(type2,subst.substitute(GenericsUtil.eliminateWildcards(type1)));
      }
      if (correct) {
        secondCandidates.add(conflict);
      }
    }
  }
  final int acceptedCount=secondCandidates.size() + firstCandidates.size();
  if (acceptedCount != 1) {
    if (acceptedCount == 0) {
      conflicts.clear();
    }
    firstCandidates.addAll(secondCandidates);
    conflicts.retainAll(firstCandidates);
    return null;
  }
  return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);
}
