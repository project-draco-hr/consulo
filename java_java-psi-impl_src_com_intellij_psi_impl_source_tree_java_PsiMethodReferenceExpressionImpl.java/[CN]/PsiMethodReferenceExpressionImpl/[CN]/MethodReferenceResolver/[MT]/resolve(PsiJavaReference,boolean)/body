{
  final Ref<PsiClass> classRef=new Ref<PsiClass>();
  final Ref<PsiSubstitutor> substRef=new Ref<PsiSubstitutor>();
  final boolean beginsWithReferenceType=process(classRef,substRef);
  final PsiClass containingClass=classRef.get();
  final PsiSubstitutor substitutor=substRef.get();
  if (containingClass != null) {
    final PsiElement element=getReferenceNameElement();
    final boolean isConstructor=element instanceof PsiKeyword && PsiKeyword.NEW.equals(element.getText());
    if (element instanceof PsiIdentifier || isConstructor) {
      PsiType functionalInterfaceType=getFunctionalInterfaceType();
      if (functionalInterfaceType == null) {
        final Map<PsiMethodReferenceExpression,PsiType> map=LambdaUtil.ourRefs.get();
        if (map != null) {
          functionalInterfaceType=map.get(PsiMethodReferenceExpressionImpl.this);
        }
 else {
          functionalInterfaceType=null;
        }
      }
      final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
      final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
      final MethodSignature signature=interfaceMethod != null ? interfaceMethod.getSignature(resolveResult.getSubstitutor()) : null;
      final MethodReferenceConflictResolver conflictResolver=new MethodReferenceConflictResolver(containingClass,substitutor,signature,beginsWithReferenceType);
      final PsiConflictResolver[] resolvers;
      if (signature != null) {
        final PsiType[] parameterTypes=signature.getParameterTypes();
        resolvers=new PsiConflictResolver[]{conflictResolver,new JavaMethodsConflictResolver(PsiMethodReferenceExpressionImpl.this,parameterTypes){
          @Override public CandidateInfo resolveConflict(          List<CandidateInfo> conflicts){
            boolean varargs=false;
            for (            CandidateInfo conflict : conflicts) {
              final PsiElement psiElement=conflict.getElement();
              if (psiElement instanceof PsiMethod && ((PsiMethod)psiElement).isVarArgs()) {
                varargs=true;
                break;
              }
            }
            checkSpecifics(conflicts,varargs ? MethodCandidateInfo.ApplicabilityLevel.VARARGS : MethodCandidateInfo.ApplicabilityLevel.FIXED_ARITY);
            return conflicts.size() == 1 ? conflicts.get(0) : null;
          }
        }
};
      }
 else {
        resolvers=new PsiConflictResolver[]{conflictResolver};
      }
      final MethodCandidatesProcessor processor=new MethodCandidatesProcessor(PsiMethodReferenceExpressionImpl.this,resolvers,new SmartList<CandidateInfo>()){
        @Override protected MethodCandidateInfo createCandidateInfo(        final PsiMethod method,        PsiSubstitutor substitutor,        boolean staticProblem,        boolean accessible){
          final PsiExpressionList argumentList=getArgumentList();
          return new MethodCandidateInfo(method,substitutor,!accessible,staticProblem,argumentList,myCurrentFileContext,argumentList != null ? argumentList.getExpressionTypes() : null,getTypeArguments(),getLanguageLevel()){
            @Override public PsiSubstitutor inferTypeArguments(            ParameterTypeInferencePolicy policy){
              if (signature == null)               return PsiSubstitutor.EMPTY;
              final PsiType[] types=method.getSignature(PsiSubstitutor.EMPTY).getParameterTypes();
              final PsiType[] rightTypes=signature.getParameterTypes();
              if (types.length < rightTypes.length) {
                return PsiUtil.resolveGenericsClassInType(rightTypes[0]).getSubstitutor();
              }
 else               if (types.length > rightTypes.length) {
                return PsiUtil.resolveGenericsClassInType(types[0]).getSubstitutor();
              }
              return JavaPsiFacade.getInstance(getProject()).getResolveHelper().inferTypeArguments(method.getTypeParameters(),types,rightTypes,PsiUtil.getLanguageLevel(PsiMethodReferenceExpressionImpl.this));
            }
          }
;
        }
      }
;
      processor.setIsConstructor(isConstructor);
      processor.setName(isConstructor ? containingClass.getName() : element.getText());
      processor.setAccessClass(containingClass);
      if (beginsWithReferenceType) {
        if (containingClass.getContainingClass() == null || !containingClass.hasModifierProperty(PsiModifier.STATIC)) {
          PsiClass aClass=null;
          if (PsiTreeUtil.isAncestor(containingClass,PsiMethodReferenceExpressionImpl.this,false)) {
            aClass=containingClass;
          }
          if (PsiUtil.getEnclosingStaticElement(PsiMethodReferenceExpressionImpl.this,aClass) != null) {
            processor.handleEvent(JavaScopeProcessorEvent.START_STATIC,null);
          }
        }
      }
      ResolveState state=ResolveState.initial().put(PsiSubstitutor.KEY,substitutor);
      containingClass.processDeclarations(processor,state,PsiMethodReferenceExpressionImpl.this,PsiMethodReferenceExpressionImpl.this);
      return processor.getResult();
    }
  }
  return JavaResolveResult.EMPTY_ARRAY;
}
