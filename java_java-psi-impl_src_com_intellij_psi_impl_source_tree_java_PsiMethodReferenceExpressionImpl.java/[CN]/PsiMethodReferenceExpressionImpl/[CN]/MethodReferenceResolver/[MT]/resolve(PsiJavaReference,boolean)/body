{
  final Ref<PsiClass> classRef=new Ref<PsiClass>();
  final Ref<PsiSubstitutor> substRef=new Ref<PsiSubstitutor>();
  process(classRef,substRef);
  final PsiClass containingClass=classRef.get();
  final PsiSubstitutor substitutor=substRef.get();
  if (containingClass != null) {
    final PsiElement element=getReferenceNameElement();
    if (element instanceof PsiIdentifier) {
      final PsiType functionalInterfaceType=getFunctionalInterfaceType();
      final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
      final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
      final MethodReferenceConflictResolver conflictResolver=new MethodReferenceConflictResolver(containingClass,substitutor,interfaceMethod != null ? interfaceMethod.getSignature(resolveResult.getSubstitutor()) : null);
      final MethodCandidatesProcessor processor=new MethodCandidatesProcessor(PsiMethodReferenceExpressionImpl.this,new PsiConflictResolver[]{conflictResolver},new SmartList<CandidateInfo>());
      processor.setIsConstructor(false);
      processor.setName(element.getText());
      ResolveState state=ResolveState.initial().put(PsiSubstitutor.KEY,substitutor);
      containingClass.processDeclarations(processor,state,PsiMethodReferenceExpressionImpl.this,PsiMethodReferenceExpressionImpl.this);
      return processor.getResult();
    }
  }
  return JavaResolveResult.EMPTY_ARRAY;
}
