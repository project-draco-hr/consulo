{
  final PsiMethodReferenceUtil.QualifierResolveResult qualifierResolveResult=PsiMethodReferenceUtil.getQualifierResolveResult(PsiMethodReferenceExpressionImpl.this);
  final PsiClass containingClass=qualifierResolveResult.getContainingClass();
  PsiSubstitutor substitutor=qualifierResolveResult.getSubstitutor();
  if (containingClass != null) {
    final PsiElement element=getReferenceNameElement();
    final boolean isConstructor=element instanceof PsiKeyword && PsiKeyword.NEW.equals(element.getText());
    if (element instanceof PsiIdentifier || isConstructor) {
      PsiType functionalInterfaceType=null;
      final Map<PsiMethodReferenceExpression,PsiType> map=PsiMethodReferenceUtil.ourRefs.get();
      if (map != null) {
        functionalInterfaceType=map.get(PsiMethodReferenceExpressionImpl.this);
      }
      if (functionalInterfaceType == null) {
        functionalInterfaceType=getFunctionalInterfaceType();
      }
      final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
      final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
      final MethodSignature signature=interfaceMethod != null ? interfaceMethod.getSignature(LambdaUtil.getSubstitutor(interfaceMethod,resolveResult)) : null;
      final PsiType interfaceMethodReturnType=LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType);
      final LanguageLevel languageLevel=PsiUtil.getLanguageLevel(PsiMethodReferenceExpressionImpl.this);
      if (isConstructor && interfaceMethod != null) {
        final PsiTypeParameter[] typeParameters=containingClass.getTypeParameters();
        final boolean isRawSubst=PsiUtil.isRawSubstitutor(containingClass,substitutor);
        final PsiClassType returnType=JavaPsiFacade.getElementFactory(getProject()).createType(containingClass,isRawSubst ? PsiSubstitutor.EMPTY : substitutor);
        substitutor=LambdaUtil.inferFromReturnType(typeParameters,returnType,interfaceMethodReturnType,substitutor,languageLevel,PsiMethodReferenceExpressionImpl.this.getProject());
        if (containingClass.getConstructors().length == 0 && !containingClass.isEnum() && !containingClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
          ClassCandidateInfo candidateInfo=null;
          if ((containingClass.getContainingClass() == null || !isLocatedInStaticContext(containingClass)) && signature.getParameterTypes().length == 0) {
            candidateInfo=new ClassCandidateInfo(containingClass,substitutor);
          }
          return candidateInfo == null ? JavaResolveResult.EMPTY_ARRAY : new JavaResolveResult[]{candidateInfo};
        }
      }
      final MethodReferenceConflictResolver conflictResolver=new MethodReferenceConflictResolver(qualifierResolveResult,signature);
      final PsiConflictResolver[] resolvers;
      if (signature != null) {
        final PsiType[] parameterTypes=signature.getParameterTypes();
        resolvers=new PsiConflictResolver[]{conflictResolver,new MethodRefsSpecificResolver(parameterTypes)};
      }
 else {
        resolvers=new PsiConflictResolver[]{conflictResolver};
      }
      final MethodCandidatesProcessor processor=new MethodCandidatesProcessor(PsiMethodReferenceExpressionImpl.this,resolvers,new SmartList<CandidateInfo>()){
        @Override protected MethodCandidateInfo createCandidateInfo(        final PsiMethod method,        final PsiSubstitutor substitutor,        final boolean staticProblem,        final boolean accessible){
          final PsiExpressionList argumentList=getArgumentList();
          return new MethodCandidateInfo(method,substitutor,!accessible,staticProblem,argumentList,myCurrentFileContext,argumentList != null ? argumentList.getExpressionTypes() : null,getTypeArguments(),getLanguageLevel()){
            @Override public PsiSubstitutor inferTypeArguments(            ParameterTypeInferencePolicy policy){
              return inferTypeArgumentsFromInterfaceMethod(signature,interfaceMethodReturnType,method,substitutor,languageLevel);
            }
          }
;
        }
      }
;
      processor.setIsConstructor(isConstructor);
      processor.setName(isConstructor ? containingClass.getName() : element.getText());
      final PsiExpression expression=getQualifierExpression();
      if (expression == null || !(expression.getType() instanceof PsiArrayType)) {
        processor.setAccessClass(containingClass);
      }
      if (qualifierResolveResult.isReferenceTypeQualified() && isLocatedInStaticContext(containingClass)) {
        processor.handleEvent(JavaScopeProcessorEvent.START_STATIC,null);
      }
      ResolveState state=ResolveState.initial().put(PsiSubstitutor.KEY,substitutor);
      containingClass.processDeclarations(processor,state,PsiMethodReferenceExpressionImpl.this,PsiMethodReferenceExpressionImpl.this);
      return processor.getResult();
    }
  }
  return JavaResolveResult.EMPTY_ARRAY;
}
