{
  final Map<CompilerMessageCategory,List<String>> result=new HashMap<CompilerMessageCategory,List<String>>();
  result.put(ERROR,new ArrayList<String>());
  result.put(INFORMATION,new ArrayList<String>());
  result.put(WARNING,new ArrayList<String>());
  FileOutputStream fos=null;
  try {
    String keyStoreOsPath=DebugKeyProvider.getDefaultKeyStoreOsPath();
    DebugKeyProvider provider=createDebugKeyProvider(result,keyStoreOsPath);
    X509Certificate certificate=signed ? (X509Certificate)provider.getCertificate() : null;
    if (certificate != null && certificate.getNotAfter().compareTo(new Date()) < 0) {
      File keyStoreFile=new File(keyStoreOsPath);
      if (keyStoreFile.exists()) {
        keyStoreFile.delete();
      }
      provider=createDebugKeyProvider(result,keyStoreOsPath);
      certificate=(X509Certificate)provider.getCertificate();
    }
    if (certificate != null && certificate.getNotAfter().compareTo(new Date()) < 0) {
      String date=DateFormatUtil.formatPrettyDateTime(certificate.getNotAfter());
      result.get(ERROR).add(AndroidBundle.message("android.debug.certificate.expired.error",date,keyStoreOsPath));
      return result;
    }
    PrivateKey key=provider.getDebugKey();
    if (key == null) {
      result.get(ERROR).add(AndroidBundle.message("android.cannot.create.new.key.error"));
      return result;
    }
    if (!new File(apkPath).exists()) {
      result.get(CompilerMessageCategory.ERROR).add("File " + apkPath + " not found. Try to rebuild project");
      return result;
    }
    File dexEntryFile=new File(dexPath);
    if (!dexEntryFile.exists()) {
      result.get(CompilerMessageCategory.ERROR).add("File " + dexEntryFile.getPath() + " not found. Try to rebuild project");
      return result;
    }
    for (    String externalJar : externalJars) {
      if (new File(externalJar).isDirectory()) {
        result.get(CompilerMessageCategory.ERROR).add(externalJar + " is directory. Directory libraries are not supported");
      }
    }
    if (result.get(CompilerMessageCategory.ERROR).size() > 0) {
      return result;
    }
    fos=new FileOutputStream(outputApk);
    SignedJarBuilder builder=new SignedJarBuilder(fos,key,certificate);
    FileInputStream fis=new FileInputStream(apkPath);
    try {
      builder.writeZip(fis,null);
    }
  finally {
      fis.close();
    }
    builder.writeFile(dexEntryFile,AndroidUtils.CLASSES_FILE_NAME);
    final HashSet<String> added=new HashSet<String>();
    for (    VirtualFile sourceRoot : sourceRoots) {
      final HashSet<VirtualFile> sourceFolderResources=new HashSet<VirtualFile>();
      collectStandardSourceFolderResources(sourceRoot,new HashSet<VirtualFile>(),sourceFolderResources,project);
      writeStandardSourceFolderResources(sourceFolderResources,sourceRoot,builder,added);
    }
    Set<String> duplicates=new HashSet<String>();
    Set<String> entries=new HashSet<String>();
    for (    String externalJar : externalJars) {
      collectDuplicateEntries(externalJar,entries,duplicates);
    }
    for (    String duplicate : duplicates) {
      result.get(CompilerMessageCategory.WARNING).add("Duplicate entry " + duplicate + ". The file won't be added");
    }
    MyResourceFilter filter=new MyResourceFilter(duplicates);
    for (    String externalJar : externalJars) {
      fis=new FileInputStream(externalJar);
      try {
        builder.writeZip(fis,filter);
      }
  finally {
        fis.close();
      }
    }
    final HashSet<String> nativeLibs=new HashSet<String>();
    for (    VirtualFile nativeLibsFolder : nativeLibsFolders) {
      for (      VirtualFile child : nativeLibsFolder.getChildren()) {
        writeNativeLibraries(builder,nativeLibsFolder,child,signed,nativeLibs);
      }
    }
    builder.close();
  }
 catch (  IOException e) {
    return addExceptionMessage(e,result);
  }
catch (  CertificateException e) {
    return addExceptionMessage(e,result);
  }
catch (  DebugKeyProvider.KeytoolException e) {
    return addExceptionMessage(e,result);
  }
catch (  AndroidLocation.AndroidLocationException e) {
    return addExceptionMessage(e,result);
  }
catch (  NoSuchAlgorithmException e) {
    return addExceptionMessage(e,result);
  }
catch (  UnrecoverableEntryException e) {
    return addExceptionMessage(e,result);
  }
catch (  KeyStoreException e) {
    return addExceptionMessage(e,result);
  }
catch (  GeneralSecurityException e) {
    return addExceptionMessage(e,result);
  }
 finally {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException ignored) {
      }
    }
  }
  return result;
}
