{
  final MergeError error=mergeLineListener.getMergeError();
  LOG.info("merge error: " + error);
  if (error == MergeError.CONFLICT) {
    LOG.info("Conflict detected");
    final boolean allMerged=new MyConflictResolver(myProject,merger,myRoot).merge();
    return allMerged ? GitUpdateResult.SUCCESS : GitUpdateResult.INCOMPLETE;
  }
 else   if (error == MergeError.LOCAL_CHANGES) {
    LOG.info("Local changes would be overwritten by merge");
    final List<FilePath> paths=getFilesOverwrittenByMerge(mergeLineListener.getOutput());
    final Collection<Change> changes=getLocalChangesFilteredByFiles(paths);
    final ChangeListViewerDialog dialog=new ChangeListViewerDialog(myProject,changes,false){
      @Override protected String getDescription(){
        return "Your local changes to the following files would be overwritten by merge.<br/>" + "Please, commit your changes or stash them before you can merge.";
      }
    }
;
    UIUtil.invokeAndWaitIfNeeded(new Runnable(){
      @Override public void run(){
        dialog.show();
      }
    }
);
    return GitUpdateResult.ERROR;
  }
 else   if (untrackedFilesWouldBeOverwrittenByMergeDetector.wasMessageDetected()) {
    LOG.info("handleMergeFailure: untracked files would be overwritten by merge");
    UntrackedFilesNotifier.notifyUntrackedFilesOverwrittenBy(myProject,untrackedFilesWouldBeOverwrittenByMergeDetector.getFiles(),"merge");
    return GitUpdateResult.ERROR;
  }
 else {
    String errors=GitUIUtil.stringifyErrors(mergeHandler.errors());
    LOG.info("Unknown error: " + errors);
    GitUIUtil.notifyImportantError(myProject,"Error merging",errors);
    return GitUpdateResult.ERROR;
  }
}
