{
  LOG.info("doUpdate ");
  final GitMerger merger=new GitMerger(myProject);
  final GitLineHandler mergeHandler=new GitLineHandler(myProject,myRoot,GitCommand.MERGE);
  mergeHandler.addParameters("--no-stat","-v");
  mergeHandler.addParameters(myTrackedBranches.get(myRoot).getDest().getName());
  final MergeLineListener mergeLineListener=new MergeLineListener();
  mergeHandler.addLineListener(mergeLineListener);
  GitMessageWithFilesDetector untrackedFilesWouldBeOverwrittenByMergeDetector=new GitMessageWithFilesDetector(GitMessageWithFilesDetector.Event.UNTRACKED_FILES_OVERWRITTEN_BY,myRoot);
  mergeHandler.addLineListener(untrackedFilesWouldBeOverwrittenByMergeDetector);
  final GitTask mergeTask=new GitTask(myProject,mergeHandler,"Merging changes");
  mergeTask.setProgressIndicator(myProgressIndicator);
  mergeTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicReference<GitUpdateResult> updateResult=new AtomicReference<GitUpdateResult>();
  final AtomicBoolean failure=new AtomicBoolean();
  mergeTask.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      updateResult.set(GitUpdateResult.SUCCESS);
    }
    @Override protected void onCancel(){
      cancel();
      updateResult.set(GitUpdateResult.CANCEL);
    }
    @Override protected void onFailure(){
      failure.set(true);
    }
  }
);
  if (failure.get()) {
    updateResult.set(handleMergeFailure(mergeLineListener,untrackedFilesWouldBeOverwrittenByMergeDetector,merger,mergeHandler));
  }
  return updateResult.get();
}
