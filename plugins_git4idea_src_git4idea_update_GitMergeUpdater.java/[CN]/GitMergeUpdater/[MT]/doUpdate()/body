{
  final GitMerger merger=new GitMerger(myProject);
  final GitLineHandler pullHandler=makePullHandler(myRoot);
  final AtomicReference<MergeError> mergeError=new AtomicReference<MergeError>(MergeError.OTHER);
  pullHandler.addLineListener(new GitLineHandlerAdapter(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (line.contains("Automatic merge failed; fix conflicts and then commit the result")) {
        mergeError.set(MergeError.CONFLICT);
      }
 else       if (line.contains("Please, commit your changes or stash them before you can merge")) {
        mergeError.set(MergeError.LOCAL_CHANGES);
      }
    }
  }
);
  final GitTask pullTask=new GitTask(myProject,pullHandler,"git pull");
  pullTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicReference<GitUpdateResult> updateResult=new AtomicReference<GitUpdateResult>();
  pullTask.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      updateResult.set(GitUpdateResult.SUCCESS);
    }
    @Override protected void onCancel(){
      cancel();
      updateResult.set(GitUpdateResult.CANCEL);
    }
    @Override protected void onFailure(){
      final MergeError error=mergeError.get();
      if (error == MergeError.CONFLICT) {
        try {
          Collection<VirtualFile> unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,myRoot);
          if (unmergedFiles.isEmpty()) {
            merger.mergeCommit(myRoot);
            updateResult.set(GitUpdateResult.SUCCESS);
          }
 else {
            final Collection<VirtualFile> finalUnmergedFiles=unmergedFiles;
            UIUtil.invokeAndWaitIfNeeded(new Runnable(){
              public void run(){
                myVcsHelper.showMergeDialog(new ArrayList<VirtualFile>(finalUnmergedFiles),myVcs.getReverseMergeProvider());
              }
            }
);
            unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,myRoot);
            if (unmergedFiles.isEmpty()) {
              merger.mergeCommit(myRoot);
              updateResult.set(GitUpdateResult.SUCCESS);
            }
 else {
              updateResult.set(GitUpdateResult.INCOMPLETE);
              Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't continue rebase","You must resolve all conflicts first. <br/>" + "Then you may continue or abort rebase.",NotificationType.WARNING),myProject);
            }
          }
        }
 catch (        VcsException e) {
          updateResult.set(GitUpdateResult.INCOMPLETE);
          Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't continue rebase","Be sure to resolve all conflicts first. <br/>" + "Then you may continue or abort rebase.<br/>" + e.getLocalizedMessage(),NotificationType.WARNING),myProject);
        }
      }
 else {
        GitUIUtil.notifyImportantError(myProject,"Error merging",GitUIUtil.stringifyErrors(pullHandler.errors()));
        updateResult.set(GitUpdateResult.ERROR);
      }
    }
  }
);
  return updateResult.get();
}
