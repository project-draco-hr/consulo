{
  int parameterIndex=method.getParameterList().getParameterIndex(parameter);
  final Map<PsiLocalVariable,PsiParameter> passedLocals=new HashMap<PsiLocalVariable,PsiParameter>();
  final PsiExpression[] arguments=methodCall.getArgumentList().getExpressions();
  for (int i=0; i < arguments.length; i++) {
    if (i != parameterIndex && arguments[i] instanceof PsiReferenceExpression) {
      final PsiReferenceExpression referenceExpression=(PsiReferenceExpression)arguments[i];
      final PsiElement element=referenceExpression.resolve();
      if (element instanceof PsiLocalVariable) {
        passedLocals.put((PsiLocalVariable)element,method.getParameterList().getParameters()[i]);
      }
    }
  }
  PsiExpression initializerInMethod=(PsiExpression)initializer.copy();
  final Map<PsiElement,PsiElement> elementsToReplace=new HashMap<PsiElement,PsiElement>();
  final Ref<Boolean> refCannotEvaluate=new Ref<Boolean>();
  initializerInMethod.accept(new PsiRecursiveElementVisitor(){
    public void visitReferenceExpression(    final PsiReferenceExpression expression){
      try {
        final PsiElement element=expression.resolve();
        if (element instanceof PsiLocalVariable) {
          final PsiParameter param=passedLocals.get((PsiLocalVariable)element);
          if (param == null) {
            refCannotEvaluate.set(Boolean.TRUE);
            return;
          }
          final PsiExpression paramRef=method.getManager().getElementFactory().createExpressionFromText(param.getName(),expression);
          elementsToReplace.put(expression,paramRef);
        }
 else {
          refCannotEvaluate.set(Boolean.TRUE);
        }
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
  }
);
  if (!refCannotEvaluate.isNull()) {
    CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("inline.parameter.refactoring"),"Parameter initializer depends on values which are not available inside the method and cannot be inlined",null,method.getProject());
    return;
  }
  final Collection<PsiReference> parameterRefs=ReferencesSearch.search(parameter).findAll();
  String question=RefactoringBundle.message("inline.parameter.confirmation",parameter.getName(),initializer.getText());
  InlineParameterDialog dlg=new InlineParameterDialog(REFACTORING_NAME,question,HelpID.INLINE_VARIABLE,"OptionPane.questionIcon",true,method.getProject());
  if (!dlg.showDialog()) {
    return;
  }
  final boolean createLocal=dlg.isCreateLocal();
  for (  Map.Entry<PsiElement,PsiElement> e : elementsToReplace.entrySet()) {
    try {
      if (e.getKey() == initializerInMethod) {
        initializerInMethod=(PsiExpression)initializerInMethod.replace(e.getValue());
      }
 else {
        e.getKey().replace(e.getValue());
      }
    }
 catch (    IncorrectOperationException e1) {
      LOG.error(e1);
    }
  }
  final Collection<PsiFile> containingFiles=new HashSet<PsiFile>();
  containingFiles.add(method.getContainingFile());
  containingFiles.add(methodCall.getContainingFile());
  final Project project=method.getProject();
  final PsiExpression initializerInMethod1=initializerInMethod;
  new WriteCommandAction(project,RefactoringBundle.message("inline.parameter.command.name",parameter.getName()),containingFiles.toArray(new PsiFile[containingFiles.size()])){
    protected void run(    final Result result) throws Throwable {
      final PsiElementFactory factory=method.getManager().getElementFactory();
      if (!createLocal) {
        for (        PsiReference ref : parameterRefs) {
          InlineUtil.inlineVariable(parameter,initializerInMethod1,(PsiJavaCodeReferenceElement)ref.getElement());
        }
      }
      PsiDeclarationStatement localDeclaration=factory.createVariableDeclarationStatement(parameter.getName(),parameter.getType(),initializerInMethod1);
      SameParameterValueInspection.InlineParameterValueFix.removeParameter(method,parameter);
      if (createLocal) {
        final PsiCodeBlock body=method.getBody();
        if (body != null) {
          body.addAfter(localDeclaration,body.getLBrace());
        }
      }
    }
    protected UndoConfirmationPolicy getUndoConfirmationPolicy(){
      return UndoConfirmationPolicy.DEFAULT;
    }
  }
.execute();
}
