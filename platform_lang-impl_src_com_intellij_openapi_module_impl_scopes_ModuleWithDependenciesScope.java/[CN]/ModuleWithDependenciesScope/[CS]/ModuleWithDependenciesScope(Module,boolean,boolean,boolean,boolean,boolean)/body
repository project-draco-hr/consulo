{
  super(module.getProject());
  myModule=module;
  myCompileClasspath=compileClasspath;
  myIncludeLibraries=includeLibraries;
  myIncludeOtherModules=includeOtherModules;
  myIncludeTests=includeTests;
  myProjectFileIndex=ProjectRootManager.getInstance(getProject()).getFileIndex();
  OrderEnumerator en=ModuleRootManager.getInstance(module).orderEntries();
  en.recursively();
  if (myCompileClasspath) {
    en.exportedOnly().compileOnly();
  }
  if (runtimeClasspath) {
    en.runtimeOnly();
  }
  if (!myIncludeLibraries)   en.withoutLibraries().withoutSdk();
  if (!myIncludeOtherModules)   en.withoutDepModules();
  if (!myIncludeTests)   en.productionOnly();
  en.forEach(new Processor<OrderEntry>(){
    @Override public boolean process(    OrderEntry each){
      if (each instanceof ModuleOrderEntry) {
        myModules.add(((ModuleOrderEntry)each).getModule());
      }
 else       if (each instanceof ModuleSourceOrderEntry) {
        myModules.add(each.getOwnerModule());
      }
      return true;
    }
  }
);
  Collections.addAll(myRoots,en.roots(new NotNullFunction<OrderEntry,OrderRootType>(){
    @NotNull @Override public OrderRootType fun(    OrderEntry entry){
      if (entry instanceof ModuleOrderEntry || entry instanceof ModuleSourceOrderEntry)       return OrderRootType.SOURCES;
      return OrderRootType.CLASSES;
    }
  }
).getRoots());
}
