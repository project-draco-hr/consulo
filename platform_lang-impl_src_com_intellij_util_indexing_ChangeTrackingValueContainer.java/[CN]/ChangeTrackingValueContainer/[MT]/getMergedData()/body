{
  ValueContainerImpl<Value> merged=myMerged;
  if (merged != null) {
    return merged;
  }
synchronized (myInitializer.getLock()) {
    merged=myMerged;
    if (merged != null) {
      return merged;
    }
    FileId2ValueMapping<Value> fileId2ValueMapping=null;
    final ValueContainer<Value> fromDisk=myInitializer.compute();
    final ValueContainerImpl<Value> newMerged;
    if (fromDisk instanceof ValueContainerImpl) {
      newMerged=((ValueContainerImpl<Value>)fromDisk).copy();
    }
 else {
      newMerged=((ChangeTrackingValueContainer<Value>)fromDisk).getMergedData().copy();
    }
    if (myAdded != null && newMerged.size() > ValueContainerImpl.NUMBER_OF_VALUES_THRESHOLD) {
      fileId2ValueMapping=new FileId2ValueMapping<Value>(newMerged);
    }
    final FileId2ValueMapping<Value> finalFileId2ValueMapping=fileId2ValueMapping;
    if (myInvalidated != null) {
      myInvalidated.forEach(new TIntProcedure(){
        @Override public boolean execute(        int inputId){
          if (finalFileId2ValueMapping != null)           finalFileId2ValueMapping.removeFileId(inputId);
 else           newMerged.removeAssociatedValue(inputId);
          return true;
        }
      }
);
    }
    if (myAdded != null) {
      if (fileId2ValueMapping != null) {
        fileId2ValueMapping.disableOneValuePerFileValidation();
      }
      myAdded.forEach(new ContainerAction<Value>(){
        @Override public boolean perform(        final int inputId,        final Value value){
          if (finalFileId2ValueMapping != null)           finalFileId2ValueMapping.removeFileId(inputId);
 else           newMerged.removeAssociatedValue(inputId);
          newMerged.addValue(inputId,value);
          if (finalFileId2ValueMapping != null)           finalFileId2ValueMapping.associateFileIdToValue(inputId,value);
          return true;
        }
      }
);
    }
    setNeedsCompacting(fromDisk.needsCompacting());
    myMerged=newMerged;
    return newMerged;
  }
}
