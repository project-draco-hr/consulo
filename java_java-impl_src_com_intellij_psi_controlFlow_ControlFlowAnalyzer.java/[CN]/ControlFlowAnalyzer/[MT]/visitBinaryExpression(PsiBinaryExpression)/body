{
  startElement(expression);
  final PsiExpression lOperand=expression.getLOperand();
  final PsiExpression rOperand=expression.getROperand();
  IElementType signTokenType=expression.getOperationTokenType();
  boolean isAndAnd=signTokenType == JavaTokenType.ANDAND;
  boolean isOrOr=signTokenType == JavaTokenType.OROR;
  if ((isAndAnd || isOrOr) && myEnabledShortCircuit) {
    Object exprValue=myConstantEvaluationHelper.computeConstantExpression(lOperand);
    Boolean lvalue=null;
    if (exprValue instanceof Boolean) {
      myCurrentFlow.setConstantConditionOccurred(true);
      lvalue=shouldCalculateConstantExpression(expression) ? (Boolean)exprValue : null;
    }
    exprValue=myConstantEvaluationHelper.computeConstantExpression(rOperand);
    Boolean rvalue=null;
    if (exprValue instanceof Boolean) {
      myCurrentFlow.setConstantConditionOccurred(true);
      rvalue=shouldCalculateConstantExpression(expression) ? (Boolean)exprValue : null;
    }
    Boolean doShortcut;
    if (lvalue != null) {
      doShortcut=lvalue.booleanValue() != isAndAnd;
    }
 else     if (rvalue != null && rvalue.booleanValue() != isAndAnd) {
      doShortcut=Boolean.TRUE;
    }
 else {
      doShortcut=null;
    }
    generateLOperand(lOperand,rOperand,signTokenType);
    BranchingInstruction.Role role=isAndAnd ? myEndJumpRoles.peek() : myStartJumpRoles.peek();
    PsiElement gotoElement=isAndAnd ? myEndStatementStack.peekElement() : myStartStatementStack.peekElement();
    boolean gotoIsAtStart=isAndAnd ? myEndStatementStack.peekAtStart() : myStartStatementStack.peekAtStart();
    if (doShortcut == null) {
      myCurrentFlow.addInstruction(new ConditionalGoToInstruction(0,role,lOperand));
      addElementOffsetLater(gotoElement,gotoIsAtStart);
    }
 else     if (doShortcut.booleanValue()) {
      myCurrentFlow.addInstruction(new GoToInstruction(0,role));
      addElementOffsetLater(gotoElement,gotoIsAtStart);
    }
  }
 else {
    generateLOperand(lOperand,rOperand,signTokenType);
  }
  if (rOperand != null) {
    rOperand.accept(this);
  }
  finishElement(expression);
}
