{
  if (myDoNotZipCaches) {
    super.writeBytes(record,bytes,fixedSize);
    return;
  }
  waitForPendingWriteForRecord(record);
synchronized (myLock) {
    myPendingZipRequestsSize+=bytes.getLength();
    if (myPendingZipRequestsSize > MAX_PENDING_ZIP_SIZE) {
      scheduleZippedContentToWrite(zip(bytes,record),record,fixedSize);
    }
 else {
      myPendingZipRequests.put(record,myPendingZipRequestsExecutor.submit(new Callable<Object>(){
        @Override public Object call() throws IOException {
          scheduleZippedContentToWrite(zip(bytes,record),record,fixedSize);
          return null;
        }
      }
));
    }
    if (myPendingWriteRequestsSize > MAX_PENDING_WRITE_SIZE) {
      flushPendingWrites();
    }
  }
}
