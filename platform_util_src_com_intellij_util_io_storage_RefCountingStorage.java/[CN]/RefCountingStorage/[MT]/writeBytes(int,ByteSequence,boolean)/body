{
  if (myDoNotZipCaches) {
    super.writeBytes(record,bytes,fixedSize);
    return;
  }
  waitForPendingWriteForRecord(record);
synchronized (myLock) {
    myPendingWriteRequestsSize+=bytes.getLength();
    if (myPendingWriteRequestsSize > MAX_PENDING_WRITE_SIZE) {
      zipAndWrite(bytes,record,fixedSize);
    }
 else {
      myPendingWriteRequests.put(record,myPendingWriteRequestsExecutor.submit(new Callable<Object>(){
        @Override public Object call() throws IOException {
          zipAndWrite(bytes,record,fixedSize);
          return null;
        }
      }
));
    }
  }
}
