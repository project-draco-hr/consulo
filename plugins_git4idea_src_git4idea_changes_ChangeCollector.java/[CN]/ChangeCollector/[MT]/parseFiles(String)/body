{
  for (StringScanner sc=new StringScanner(list); sc.hasMoreData(); ) {
    if (sc.isEol()) {
      sc.nextLine();
      continue;
    }
    char status=sc.peek();
    sc.skipChars(2);
    if ('?' == status) {
      VirtualFile file=myVcsRoot.findFileByRelativePath(GitUtil.unescapePath(sc.line()));
      if (GitUtil.gitRootOrNull(file) == myVcsRoot) {
        myUnversioned.add(file);
      }
    }
 else {
      if ('M' == status) {
        sc.boundedToken('\t');
        String file=GitUtil.unescapePath(sc.line());
        VirtualFile vFile=myVcsRoot.findFileByRelativePath(file);
        if (GitUtil.gitRootOrNull(vFile) != myVcsRoot) {
          continue;
        }
        if (!myUnmergedNames.add(file)) {
          continue;
        }
        ContentRevision before=GitContentRevision.createRevision(myVcsRoot,file,new GitRevisionNumber("orig_head"),myProject,false);
        ContentRevision after=GitContentRevision.createRevision(myVcsRoot,file,null,myProject,false);
        myChanges.add(new Change(before,after,FileStatus.MERGED_WITH_CONFLICTS));
      }
 else {
        throw new VcsException("Unsupported type of the merge conflict detected: " + status);
      }
    }
  }
}
