{
  final Collection<VirtualFile> affected=dirtyScope.getAffectedContentRootsWithCheck();
  if (dirtyScope.getAffectedContentRoots().size() != affected.size()) {
    final Set<VirtualFile> set=new HashSet<VirtualFile>(affected);
    set.removeAll(dirtyScope.getAffectedContentRoots());
    for (    VirtualFile file : set) {
      ((VcsModifiableDirtyScope)dirtyScope).addDirtyDirRecursively(new FilePathImpl(file));
    }
  }
  Collection<VirtualFile> roots=GitUtil.gitRootsForPaths(affected);
  try {
    final MyNonChangedHolder holder=new MyNonChangedHolder(myProject,dirtyScope.getDirtyFilesNoExpand(),addGate,myFileDocumentManager,myVcsManager);
    for (    VirtualFile root : roots) {
      GitChangesCollector collector=isNewGitChangeProviderAvailable() ? GitNewChangesCollector.collect(myProject,myGit,myChangeListManager,dirtyScope,root) : GitOldChangesCollector.collect(myProject,myChangeListManager,dirtyScope,root);
      holder.changed(collector.getChanges());
      for (      Change file : collector.getChanges()) {
        builder.processChange(file,GitVcs.getKey());
      }
      for (      VirtualFile f : collector.getUnversionedFiles()) {
        builder.processUnversionedFile(f);
        holder.unversioned(f);
      }
      holder.feedBuilder(builder);
    }
  }
 catch (  VcsException e) {
    final GitVcs vcs=GitVcs.getInstance(myProject);
    if (vcs != null) {
      vcs.getExecutableValidator().showNotificationOrThrow(e);
    }
  }
}
