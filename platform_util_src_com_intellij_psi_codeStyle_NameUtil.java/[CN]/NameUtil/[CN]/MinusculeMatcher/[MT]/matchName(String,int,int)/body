{
  if (patternIndex == myPattern.length) {
    return FList.emptyList();
  }
  if (nameIndex == name.length()) {
    return null;
  }
  if ('.' == myPattern[patternIndex] && name.charAt(nameIndex) != '.') {
    return skipChars(name,patternIndex,nameIndex,false);
  }
  if ('*' == myPattern[patternIndex]) {
    return skipChars(name,patternIndex,nameIndex,true);
  }
  if (patternIndex == 0 && myOptions != MatchingCaseSensitivity.NONE && name.charAt(nameIndex) != myPattern[0]) {
    return null;
  }
  if (isWordSeparator(name.charAt(nameIndex))) {
    return skipSeparators(name,patternIndex,nameIndex);
  }
  if (StringUtil.toLowerCase(name.charAt(nameIndex)) != StringUtil.toLowerCase(myPattern[patternIndex])) {
    if (Character.isDigit(name.charAt(nameIndex))) {
      return matchName(name,patternIndex,nameIndex + 1);
    }
    return null;
  }
  if (myOptions == MatchingCaseSensitivity.ALL && name.charAt(nameIndex) != myPattern[patternIndex]) {
    return null;
  }
  int nextStart=NameUtil.nextWord(name,nameIndex);
  boolean uppers=isWordStart(myPattern[patternIndex]);
  int i=1;
  while (true) {
    if (patternIndex + i == myPattern.length) {
      return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex,i));
    }
    if (i + nameIndex == nextStart) {
      break;
    }
    char p=myPattern[patternIndex + i];
    if (uppers && isWordStart(p) && myOptions != MatchingCaseSensitivity.ALL) {
      p=StringUtil.toLowerCase(p);
    }
 else {
      uppers=false;
    }
    char w=name.charAt(i + nameIndex);
    if (myOptions != MatchingCaseSensitivity.ALL) {
      w=StringUtil.toLowerCase(w);
    }
    if (w != p) {
      break;
    }
    i++;
  }
  if (nextStart == name.length()) {
    if (patternIndex + i == myPattern.length - 1) {
      char last=myPattern[patternIndex + i];
      if (' ' == last && (i == 1 && isWordStart(myPattern[patternIndex]) || i + nameIndex == name.length()) || '*' == last) {
        return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex,i));
      }
    }
    return null;
  }
  while (i > 0) {
    FList<TextRange> ranges=matchName(name,patternIndex + i,nextStart);
    if (ranges != null) {
      TextRange head=ranges.getHead();
      if (head != null && head.getStartOffset() == nameIndex + i) {
        return ranges.getTail().prepend(new TextRange(nameIndex,head.getEndOffset()));
      }
      return ranges.prepend(TextRange.from(nameIndex,i));
    }
    i--;
  }
  return null;
}
