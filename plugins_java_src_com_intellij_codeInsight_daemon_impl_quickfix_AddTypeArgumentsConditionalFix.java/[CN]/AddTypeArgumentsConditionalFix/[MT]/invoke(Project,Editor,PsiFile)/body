{
  final PsiTypeParameter[] typeParameters=myMethod.getTypeParameters();
  final String typeArguments="<" + StringUtil.join(typeParameters,new Function<PsiTypeParameter,String>(){
    @Override public String fun(    PsiTypeParameter parameter){
      final PsiType substituteTypeParam=mySubstitutor.substitute(parameter);
      LOG.assertTrue(substituteTypeParam != null);
      return substituteTypeParam.getCanonicalText();
    }
  }
,", ") + ">";
  final PsiExpression expression=myExpression.getMethodExpression().getQualifierExpression();
  String withTypeArgsText;
  if (expression != null) {
    withTypeArgsText=expression.getText();
  }
 else {
    if (RefactoringUtil.isInStaticContext(myExpression,null) || myMethod.hasModifierProperty(PsiModifier.STATIC)) {
      final PsiClass aClass=myMethod.getContainingClass();
      LOG.assertTrue(aClass != null);
      withTypeArgsText=aClass.getQualifiedName();
    }
 else {
      withTypeArgsText="this";
    }
  }
  withTypeArgsText+="." + typeArguments + myExpression.getMethodExpression().getReferenceName();
  final PsiExpression withTypeArgs=JavaPsiFacade.getElementFactory(project).createExpressionFromText(withTypeArgsText + myExpression.getArgumentList().getText(),myExpression);
  myExpression.replace(withTypeArgs);
}
