{
  boolean comparing=op == JavaTokenType.EQEQ || op == JavaTokenType.NE;
  PsiExpression lExpr=operands[0];
  lExpr.accept(this);
  PsiType lType=lExpr.getType();
  PsiExpression rExpr;
  for (int i=1; i < operands.length; i++) {
    rExpr=operands[i];
    PsiType rType=rExpr.getType();
    boolean comparingRef=comparing && !TypeConversionUtil.isPrimitiveAndNotNull(lType) && !TypeConversionUtil.isPrimitiveAndNotNull(rType);
    boolean comparingPrimitiveNumerics=comparing && TypeConversionUtil.isPrimitiveAndNotNull(lType) && TypeConversionUtil.isPrimitiveAndNotNull(rType)&& TypeConversionUtil.isNumericType(lType)&& TypeConversionUtil.isNumericType(rType);
    PsiType castType=comparingPrimitiveNumerics ? PsiType.LONG : type;
    if (!comparingRef) {
      generateBoxingUnboxingInstructionFor(lExpr,castType);
    }
    lExpr=rExpr;
    lType=rType;
    rExpr.accept(this);
    if (!comparingRef) {
      generateBoxingUnboxingInstructionFor(rExpr,castType);
    }
    if (JavaTokenType.PLUS == op) {
      if (type == null || !type.equalsToText("java.lang.String")) {
        op=null;
      }
    }
    PsiElement psiAnchor=expression.isPhysical() ? expression : null;
    addInstruction(new BinopInstruction(op,psiAnchor,expression.getProject()));
  }
}
