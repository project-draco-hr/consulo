{
  PsiReferenceExpression methodExpression=expression.getMethodExpression();
  PsiExpression qualifierExpression=methodExpression.getQualifierExpression();
  PsiMethod resolved=expression.resolveMethod();
  if (resolved != null) {
    final PsiExpressionList argList=expression.getArgumentList();
    @NonNls String methodName=resolved.getName();
    PsiExpression[] params=argList.getExpressions();
    PsiClass owner=resolved.getContainingClass();
    final int exitPoint=getEndOffset(expression) - 1;
    if (owner != null) {
      final String className=owner.getQualifiedName();
      if ("java.lang.System".equals(className)) {
        if ("exit".equals(methodName)) {
          pushParameters(params,false,false);
          addInstruction(new ReturnInstruction());
          return true;
        }
      }
 else       if ("junit.framework.Assert".equals(className) || "org.junit.Assert".equals(className) || "org.testng.Assert".equals(className)) {
        boolean testng="org.testng.Assert".equals(className);
        if ("fail".equals(methodName)) {
          pushParameters(params,false,!testng);
          returnCheckingFinally();
          return true;
        }
 else         if ("assertTrue".equals(methodName)) {
          pushParameters(params,true,!testng);
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertFalse".equals(methodName)) {
          pushParameters(params,true,!testng);
          conditionalExit(exitPoint,true);
          return true;
        }
 else         if ("assertNull".equals(methodName)) {
          pushParameters(params,true,!testng);
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertNotNull".equals(methodName)) {
          pushParameters(params,true,!testng);
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          conditionalExit(exitPoint,true);
          return true;
        }
        return false;
      }
    }
    if (ConditionCheckManager.isCheck(resolved)) {
      if (ConditionCheckManager.isAssertIsNullCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isAssertIsNullCheckMethod(resolved,paramIndex++)) {
            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
            addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
            conditionalExit(exitPoint,false);
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
 else       if (ConditionCheckManager.isAssertIsNotNullCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isAssertIsNotNullCheckMethod(resolved,paramIndex++)) {
            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
            addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
            conditionalExit(exitPoint,true);
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
 else       if (ConditionCheckManager.isNullCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isNullCheckMethod(resolved,paramIndex++)) {
            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
            addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
 else       if (ConditionCheckManager.isNotNullCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isNotNullCheckMethod(resolved,paramIndex++)) {
            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
            addInstruction(new BinopInstruction(JavaTokenType.NE,null,expression.getProject()));
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
 else       if (ConditionCheckManager.isAssertTrueCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isAssertTrueCheckMethod(resolved,paramIndex++)) {
            conditionalExit(exitPoint,false);
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
 else       if (ConditionCheckManager.isAssertFalseCheckMethod(resolved)) {
        int paramIndex=0;
        for (        PsiExpression param : params) {
          param.accept(this);
          if (ConditionCheckManager.isAssertFalseCheckMethod(resolved,paramIndex++)) {
            conditionalExit(exitPoint,true);
          }
 else {
            addInstruction(new PopInstruction());
          }
        }
        return true;
      }
    }
    if (qualifierExpression != null) {
      if (qualifierExpression.textMatches("LOG")) {
        final PsiType qualifierType=qualifierExpression.getType();
        if (qualifierType != null && qualifierType.equalsToText("com.intellij.openapi.diagnostic.Logger")) {
          if ("error".equals(methodName)) {
            for (            PsiExpression param : params) {
              param.accept(this);
              addInstruction(new PopInstruction());
            }
            returnCheckingFinally();
            return true;
          }
 else           if ("assertTrue".equals(methodName)) {
            params[0].accept(this);
            for (int i=1; i < params.length; i++) {
              params[i].accept(this);
              addInstruction(new PopInstruction());
            }
            conditionalExit(exitPoint,false);
            return true;
          }
        }
      }
    }
  }
  return false;
}
