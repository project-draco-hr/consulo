{
  PsiReferenceExpression methodExpression=expression.getMethodExpression();
  PsiExpression qualifierExpression=methodExpression.getQualifierExpression();
  PsiMethod resolved=expression.resolveMethod();
  if (resolved != null) {
    final PsiExpressionList argList=expression.getArgumentList();
    @NonNls String methodName=resolved.getName();
    PsiExpression[] params=argList.getExpressions();
    PsiClass owner=resolved.getContainingClass();
    final int exitPoint=getEndOffset(expression) - 1;
    if (owner != null) {
      final String className=owner.getQualifiedName();
      if ("java.lang.System".equals(className)) {
        if ("exit".equals(methodName)) {
          pushParameters(params,false,false);
          addInstruction(new ReturnInstruction());
          return true;
        }
      }
 else       if ("junit.framework.Assert".equals(className) || "org.junit.Assert".equals(className) || "junit.framework.TestCase".equals(className)|| "org.testng.Assert".equals(className)) {
        boolean testng="org.testng.Assert".equals(className);
        if ("fail".equals(methodName)) {
          pushParameters(params,false,!testng);
          returnCheckingFinally();
          return true;
        }
 else         if ("assertTrue".equals(methodName)) {
          pushParameters(params,true,!testng);
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertFalse".equals(methodName)) {
          pushParameters(params,true,!testng);
          conditionalExit(exitPoint,true);
          return true;
        }
 else         if ("assertNull".equals(methodName)) {
          pushParameters(params,true,!testng);
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertNotNull".equals(methodName)) {
          pushParameters(params,true,!testng);
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          conditionalExit(exitPoint,true);
          return true;
        }
        return false;
      }
    }
    boolean assertNull=ConditionCheckManager.isAssertIsNullCheckMethod(resolved);
    boolean assertNotNull=ConditionCheckManager.isAssertIsNotNullCheckMethod(resolved);
    if (assertNull || assertNotNull) {
      for (int i=0; i < params.length; i++) {
        params[i].accept(this);
        if (ConditionCheckManager.isNullabilityAssertionMethod(resolved,i)) {
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(JavaTokenType.EQEQ,null,expression.getProject()));
          conditionalExit(exitPoint,assertNotNull);
        }
 else {
          addInstruction(new PopInstruction());
        }
      }
      return true;
    }
    boolean isNull=ConditionCheckManager.isNullCheckMethod(resolved);
    boolean isNotNull=ConditionCheckManager.isNotNullCheckMethod(resolved);
    if (isNull || isNotNull) {
      for (int i=0; i < params.length; i++) {
        params[i].accept(this);
        if (ConditionCheckManager.isNullCheckMethod(resolved,i)) {
          addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(new BinopInstruction(isNull ? JavaTokenType.EQEQ : JavaTokenType.NE,null,expression.getProject()));
        }
 else {
          addInstruction(new PopInstruction());
        }
      }
      return true;
    }
    boolean assertTrue=ConditionCheckManager.isAssertTrueCheckMethod(resolved);
    boolean assertFalse=ConditionCheckManager.isAssertFalseCheckMethod(resolved);
    if (assertTrue || assertFalse) {
      for (int i=0; i < params.length; i++) {
        params[i].accept(this);
        if (ConditionCheckManager.isBooleanAssertMethod(resolved,i)) {
          conditionalExit(exitPoint,assertFalse);
        }
 else {
          addInstruction(new PopInstruction());
        }
      }
      return true;
    }
    if (qualifierExpression != null) {
      if (qualifierExpression.textMatches("LOG")) {
        final PsiType qualifierType=qualifierExpression.getType();
        if (qualifierType != null && qualifierType.equalsToText("com.intellij.openapi.diagnostic.Logger")) {
          if ("error".equals(methodName)) {
            for (            PsiExpression param : params) {
              param.accept(this);
              addInstruction(new PopInstruction());
            }
            returnCheckingFinally();
            return true;
          }
 else           if ("assertTrue".equals(methodName)) {
            params[0].accept(this);
            for (int i=1; i < params.length; i++) {
              params[i].accept(this);
              addInstruction(new PopInstruction());
            }
            conditionalExit(exitPoint,false);
            return true;
          }
        }
      }
    }
  }
  return false;
}
