{
  final int offset=editor.getCaretModel().getOffset();
  final PsiElement element=file.findElementAt(offset);
  final PsiMethod method=PsiTreeUtil.getParentOfType(element,PsiMethod.class);
  if (method == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("locate.caret.inside.a.method"));
    showErrorMessage(message,project);
    return;
  }
  if (!file.isWritable()) {
    if (!RefactoringMessageUtil.checkReadOnlyStatus(project,file))     return;
  }
  if (method.isConstructor()) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("replace.with.method.call.does.not.work.for.constructors"));
    showErrorMessage(message,project);
  }
  final PsiCodeBlock body=method.getBody();
  if (body == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("method.does.not.have.a.body",method.getName()));
    showErrorMessage(message,project);
    return;
  }
  final PsiStatement[] statements=body.getStatements();
  if (statements.length == 0) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("method.has.an.empty.body",method.getName()));
    showErrorMessage(message,project);
    return;
  }
  final DuplicatesFinder duplicatesFinder;
  final PsiElement[] pattern;
  if (statements.length != 1 || !(statements[0] instanceof PsiReturnStatement)) {
    pattern=statements;
  }
 else {
    final PsiExpression returnValue=((PsiReturnStatement)statements[0]).getReturnValue();
    if (returnValue != null) {
      pattern=new PsiElement[]{returnValue};
    }
 else {
      pattern=statements;
    }
  }
  duplicatesFinder=new DuplicatesFinder(pattern,Arrays.asList(method.getParameterList().getParameters()),new ArrayList<PsiVariable>(),!method.hasModifierProperty(PsiModifier.STATIC));
  final List<Match> duplicates=duplicatesFinder.findDuplicates(file);
  if (duplicates.isEmpty()) {
    final String message=RefactoringBundle.message("idea.has.not.found.any.code.that.can.be.replaced.with.method.call",ApplicationNamesInfo.getInstance().getProductName());
    Messages.showInfoMessage(project,message,REFACTORING_NAME);
    return;
  }
  final int duplicatesNo=duplicates.size();
  final ArrayList<RangeHighlighter> highlighters=new ArrayList<RangeHighlighter>();
  for (  final Match match : duplicates) {
    DuplicatesImpl.highlightMatch(project,editor,match,highlighters);
  }
  final MethodDuplicatesDialog dialog=new MethodDuplicatesDialog(project,method,duplicatesNo);
  dialog.show();
  for (  final RangeHighlighter rangeHighlighter : highlighters) {
    HighlightManager.getInstance(project).removeSegmentHighlighter(editor,rangeHighlighter);
  }
  if (!dialog.isOK())   return;
  WindowManager.getInstance().getStatusBar(project).setInfo(getStatusMessage(duplicatesNo));
  DuplicatesImpl.invoke(project,editor,REFACTORING_NAME,new MethodDuplicatesMatchProvider(method,duplicates));
  WindowManager.getInstance().getStatusBar(project).setInfo("");
}
