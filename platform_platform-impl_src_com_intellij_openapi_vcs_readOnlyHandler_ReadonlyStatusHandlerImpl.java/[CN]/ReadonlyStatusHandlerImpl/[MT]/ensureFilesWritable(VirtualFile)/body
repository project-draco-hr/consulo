{
  if (files.length == 0) {
    return new OperationStatusImpl(VirtualFile.EMPTY_ARRAY);
  }
  ApplicationManager.getApplication().assertIsDispatchThread();
  Set<VirtualFile> realFiles=new THashSet<VirtualFile>(files.length);
  for (  VirtualFile file : files) {
    if (file instanceof VirtualFileWindow)     file=((VirtualFileWindow)file).getDelegate();
    if (file != null) {
      realFiles.add(file);
    }
  }
  files=VfsUtilCore.toVirtualFileArray(realFiles);
  for (  final WritingAccessProvider accessProvider : myAccessProviders) {
    Collection<VirtualFile> denied=ContainerUtil.filter(files,new Condition<VirtualFile>(){
      @Override public boolean value(      final VirtualFile virtualFile){
        return !accessProvider.isPotentiallyWritable(virtualFile);
      }
    }
);
    if (denied.isEmpty()) {
      denied=accessProvider.requestWriting(files);
    }
    if (!denied.isEmpty()) {
      return new OperationStatusImpl(VfsUtilCore.toVirtualFileArray(denied));
    }
  }
  final FileInfo[] fileInfos=createFileInfos(files);
  if (fileInfos.length == 0) {
    return createResultStatus(files);
  }
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    return createResultStatus(files);
  }
  final int savedEventCount=IdeEventQueue.getInstance().getEventCount();
  if (myState.SHOW_DIALOG) {
    new ReadOnlyStatusDialog(myProject,fileInfos).show();
  }
 else {
    processFiles(new ArrayList<FileInfo>(Arrays.asList(fileInfos)),null);
  }
  IdeEventQueue.getInstance().setEventCount(savedEventCount);
  return createResultStatus(files);
}
