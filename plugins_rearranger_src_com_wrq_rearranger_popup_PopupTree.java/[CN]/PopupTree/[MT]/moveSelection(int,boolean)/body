{
  TreePath[] paths=getSelectionPaths();
  LinkedList<DefaultMutableTreeNode> nodeList=new LinkedList<DefaultMutableTreeNode>();
  LinkedList<RangeEntry> ruleList=new LinkedList<RangeEntry>();
  if (paths == null || paths.length == 0) {
    return;
  }
  owner.setRearrangementOccurred(true);
  final DefaultMutableTreeNode peerNode=(DefaultMutableTreeNode)paths[0].getLastPathComponent();
  RangeEntry entry=(RangeEntry)peerNode.getUserObject();
  DefaultMutableTreeNode peerParent=(DefaultMutableTreeNode)peerNode.getParent();
  DefaultMutableTreeNode dstNode=(DefaultMutableTreeNode)peerParent.getChildAt(dstIndex);
  if (!before && dstIndex < peerParent.getChildCount()) {
    dstIndex++;
  }
  RuleInstance ruleInstance=entry.getMatchedRule();
  DefaultTreeModel model=(DefaultTreeModel)getModel();
  for (  TreePath path : paths) {
    DefaultMutableTreeNode srcNode=(DefaultMutableTreeNode)path.getLastPathComponent();
    DefaultMutableTreeNode srcParent=(DefaultMutableTreeNode)srcNode.getParent();
    int srcRow=srcParent.getIndex(srcNode);
    if (srcRow < dstIndex) {
      dstIndex--;
    }
    nodeList.add(srcNode);
    model.removeNodeFromParent(srcNode);
    RangeEntry match=(RangeEntry)srcNode.getUserObject();
    ruleInstance.getMatches().remove(match);
    ruleList.add(match);
  }
  clearSelection();
  TreePath visiblePath=null;
  int dstOffset=(ruleInstance.getMatches().indexOf(dstNode.getUserObject())) - peerParent.getIndex(dstNode);
  while (!nodeList.isEmpty()) {
    DefaultMutableTreeNode srcNode=nodeList.removeFirst();
    model.insertNodeInto(srcNode,peerParent,dstIndex);
    final TreePath treePath=new TreePath(srcNode.getPath());
    addSelectionPath(treePath);
    if (before) {
      if (visiblePath == null)       visiblePath=treePath;
    }
 else {
      visiblePath=treePath;
    }
    final RangeEntry match=ruleList.removeFirst();
    ruleInstance.getMatches().add(dstIndex + dstOffset,match);
    dstIndex++;
  }
  if (visiblePath != null) {
    scrollPathToVisible(visiblePath);
  }
}
