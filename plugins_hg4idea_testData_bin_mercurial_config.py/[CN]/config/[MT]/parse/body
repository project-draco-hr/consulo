def parse(self, src, data, sections=None, remap=None, include=None):
    sectionre = re.compile('\\[([^\\[]+)\\]')
    itemre = re.compile('([^=\\s][^=]*?)\\s*=\\s*(.*\\S|)')
    contre = re.compile('\\s+(\\S|\\S.*\\S)\\s*$')
    emptyre = re.compile('(;|#|\\s*$)')
    unsetre = re.compile('%unset\\s+(\\S+)')
    includere = re.compile('%include\\s+(\\S|\\S.*\\S)\\s*$')
    section = ''
    item = None
    line = 0
    cont = False
    for l in data.splitlines(True):
        line += 1
        if cont:
            m = contre.match(l)
            if m:
                if (sections and (section not in sections)):
                    continue
                v = ((self.get(section, item) + '\n') + m.group(1))
                self.set(section, item, v, ('%s:%d' % (src, line)))
                continue
            item = None
            cont = False
        m = includere.match(l)
        if m:
            inc = m.group(1)
            base = os.path.dirname(src)
            inc = os.path.normpath(os.path.join(base, inc))
            if include:
                try:
                    include(inc, remap=remap, sections=sections)
                except IOError as inst:
                    msg = (_('config error at %s:%d: cannot include %s (%s)') % (src, line, inc, inst.strerror))
                    raise error.ConfigError(msg)
            continue
        if emptyre.match(l):
            continue
        m = sectionre.match(l)
        if m:
            section = m.group(1)
            if remap:
                section = remap.get(section, section)
            if (section not in self):
                self._data[section] = sortdict()
            continue
        m = itemre.match(l)
        if m:
            item = m.group(1)
            cont = True
            if (sections and (section not in sections)):
                continue
            self.set(section, item, m.group(2), ('%s:%d' % (src, line)))
            continue
        m = unsetre.match(l)
        if m:
            name = m.group(1)
            if (sections and (section not in sections)):
                continue
            if (self.get(section, name) != None):
                del self._data[section][name]
            continue
        raise error.ConfigError((_("config error at %s:%d: '%s'") % (src, line, l.rstrip())))
