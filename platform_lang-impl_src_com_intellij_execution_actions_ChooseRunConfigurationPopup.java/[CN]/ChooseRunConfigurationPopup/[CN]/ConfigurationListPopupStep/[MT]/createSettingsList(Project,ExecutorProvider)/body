{
  final RunManagerEx manager=RunManagerEx.getInstanceEx(project);
  final List<ItemWrapper> result=new ArrayList<ItemWrapper>();
  final RunnerAndConfigurationSettings selectedConfiguration=manager.getSelectedConfiguration();
  if (selectedConfiguration != null) {
    boolean isFirst=true;
    final ExecutionTarget activeTarget=ExecutionTargetManager.getActiveTarget(project);
    for (    final ExecutionTarget eachTarget : ExecutionTargetManager.getTargetsToChooseFor(project,selectedConfiguration)) {
      result.add(new ItemWrapper<ExecutionTarget>(eachTarget,isFirst){
{
          setChecked(eachTarget.equals(activeTarget));
        }
        @Override public Icon getIcon(){
          return eachTarget.getIcon();
        }
        @Override public String getText(){
          return eachTarget.getDisplayName();
        }
        @Override public void perform(        @NotNull final Project project,        @NotNull final Executor executor,        @NotNull DataContext context){
          ExecutionTargetManager.setActiveTarget(project,eachTarget);
          doRunConfiguration(selectedConfiguration,executor,project);
        }
        @Override public boolean available(        Executor executor){
          return true;
        }
      }
);
      isFirst=false;
    }
  }
  final Map<RunnerAndConfigurationSettings,ItemWrapper> wrappedExisting=new LinkedHashMap<RunnerAndConfigurationSettings,ItemWrapper>();
  final ConfigurationType[] types=manager.getConfigurationFactories();
  for (  final ConfigurationType type : types) {
    if (!(type instanceof UnknownConfigurationType)) {
      Map<String,List<RunnerAndConfigurationSettings>> structure=manager.getStructure(type);
      for (      final Map.Entry<String,List<RunnerAndConfigurationSettings>> entry : structure.entrySet()) {
        if (entry.getValue().isEmpty())         continue;
        final String key=entry.getKey();
        if (key != null) {
          boolean isSelected=entry.getValue().contains(selectedConfiguration);
          FolderWrapper folderWrapper=new FolderWrapper(project,executorProvider,key + (isSelected ? "  (mnemonic is to \"" + selectedConfiguration.getName() + "\")" : ""),entry.getValue());
          if (isSelected) {
            folderWrapper.setMnemonic(1);
          }
          result.add(folderWrapper);
        }
 else {
          for (          RunnerAndConfigurationSettings configuration : entry.getValue()) {
            final ItemWrapper wrapped=ItemWrapper.wrap(project,configuration);
            if (configuration == selectedConfiguration) {
              wrapped.setMnemonic(1);
            }
            wrappedExisting.put(configuration,wrapped);
          }
        }
      }
    }
  }
  populateWithDynamicRunners(result,wrappedExisting,project,manager,selectedConfiguration);
  result.addAll(wrappedExisting.values());
  final ItemWrapper edit=new ItemWrapper(null){
    @Override public Icon getIcon(){
      return AllIcons.Actions.EditSource;
    }
    @Override public String getText(){
      return UIUtil.removeMnemonic(ActionsBundle.message("action.editRunConfigurations.text"));
    }
    @Override public void perform(    @NotNull final Project project,    @NotNull final Executor executor,    @NotNull DataContext context){
      final EditConfigurationsDialog dialog=new EditConfigurationsDialog(project){
        @Override protected void init(){
          setOKButtonText(executor.getStartActionText());
          setOKButtonIcon(executor.getIcon());
          myExecutor=executor;
          super.init();
        }
      }
;
      dialog.show();
      if (dialog.isOK()) {
        SwingUtilities.invokeLater(new Runnable(){
          @Override public void run(){
            doRunConfiguration(RunManager.getInstance(project).getSelectedConfiguration(),executor,project);
          }
        }
);
      }
    }
    @Override public boolean available(    Executor executor){
      return true;
    }
  }
;
  edit.setMnemonic(0);
  result.add(0,edit);
  return result.toArray(new ItemWrapper[result.size()]);
}
