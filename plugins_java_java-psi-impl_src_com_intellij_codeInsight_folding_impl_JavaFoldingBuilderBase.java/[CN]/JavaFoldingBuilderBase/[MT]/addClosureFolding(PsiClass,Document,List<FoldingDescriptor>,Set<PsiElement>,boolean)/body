{
  if (!JavaCodeFoldingSettings.getInstance().isCollapseLambdas()) {
    return false;
  }
  boolean isClosure=false;
  if (aClass instanceof PsiAnonymousClass) {
    final PsiAnonymousClass anonymousClass=(PsiAnonymousClass)aClass;
    final PsiElement element=anonymousClass.getParent();
    if (element instanceof PsiNewExpression) {
      final PsiNewExpression expression=(PsiNewExpression)element;
      final PsiExpressionList argumentList=expression.getArgumentList();
      if (argumentList != null && argumentList.getExpressions().length == 0) {
        final PsiMethod[] methods=anonymousClass.getMethods();
        PsiClass baseClass=anonymousClass.getBaseClassType().resolve();
        if (hasOnlyOneLambdaMethod(anonymousClass,!quick) && seemsLikeLambda(baseClass)) {
          final PsiMethod method=methods[0];
          final PsiCodeBlock body=method.getBody();
          if (body != null) {
            isClosure=true;
            int rangeStart=body.getTextRange().getStartOffset();
            int rangeEnd=body.getTextRange().getEndOffset();
            final PsiJavaToken lbrace=body.getLBrace();
            if (lbrace != null)             rangeStart=lbrace.getTextRange().getEndOffset();
            final PsiJavaToken rbrace=body.getRBrace();
            if (rbrace != null)             rangeEnd=rbrace.getTextRange().getStartOffset();
            final CharSequence seq=document.getCharsSequence();
            final PsiElement classRBrace=anonymousClass.getRBrace();
            if (classRBrace != null && rbrace != null) {
              final int methodEndLine=document.getLineNumber(rangeEnd);
              final int methodEndLineStart=document.getLineStartOffset(methodEndLine);
              if ("}".equals(seq.subSequence(methodEndLineStart,document.getLineEndOffset(methodEndLine)).toString().trim())) {
                int classEndStart=classRBrace.getTextRange().getStartOffset();
                int classEndCol=classEndStart - document.getLineStartOffset(document.getLineNumber(classEndStart));
                rangeEnd=classEndCol + methodEndLineStart;
              }
            }
            int firstLineStart=CharArrayUtil.shiftForward(seq,rangeStart," \t");
            if (firstLineStart < seq.length() - 1 && seq.charAt(firstLineStart) == '\n')             firstLineStart++;
            int lastLineEnd=CharArrayUtil.shiftBackward(seq,rangeEnd - 1," \t");
            if (lastLineEnd > 0 && seq.charAt(lastLineEnd) == '\n')             lastLineEnd--;
            if (lastLineEnd < firstLineStart)             return false;
            String type=quick ? "" : getOptionalLambdaType(anonymousClass,expression);
            String methodName=quick || !isImplementingLambdaMethod(baseClass) ? method.getName() : "";
            final String params=StringUtil.join(method.getParameterList().getParameters(),new Function<PsiParameter,String>(){
              @Override public String fun(              final PsiParameter psiParameter){
                return psiParameter.getName();
              }
            }
,", ");
            @NonNls final String lambdas=type + methodName + "("+ params+ ") -> {";
            final int closureStart=expression.getTextRange().getStartOffset();
            final int closureEnd=expression.getTextRange().getEndOffset();
            boolean oneLine=false;
            String contents=seq.subSequence(firstLineStart,lastLineEnd).toString();
            if (contents.indexOf('\n') < 0) {
              final int beforeLength=closureStart - document.getLineStartOffset(document.getLineNumber(closureStart));
              final int afterLength=document.getLineEndOffset(document.getLineNumber(closureEnd)) - closureEnd;
              final int resultLineLength=beforeLength + lambdas.length() + contents.length()+ 5+ afterLength;
              if (isBelowRightMargin(aClass.getProject(),resultLineLength)) {
                rangeStart=CharArrayUtil.shiftForward(seq,rangeStart," \n\t");
                rangeEnd=CharArrayUtil.shiftBackward(seq,rangeEnd - 1," \n\t") + 1;
                oneLine=true;
              }
            }
            if (rangeStart >= rangeEnd)             return false;
            FoldingGroup group=FoldingGroup.newGroup("lambda");
            final String prettySpace=oneLine ? " " : "";
            foldElements.add(new FoldingDescriptor(expression.getNode(),new TextRange(closureStart,rangeStart),group){
              @Override public String getPlaceholderText(){
                return lambdas + prettySpace;
              }
            }
);
            if (rbrace != null && rangeEnd + 1 < closureEnd) {
              foldElements.add(new FoldingDescriptor(rbrace.getNode(),new TextRange(rangeEnd,closureEnd),group){
                @Override public String getPlaceholderText(){
                  return prettySpace + "}";
                }
              }
);
            }
            addCodeBlockFolds(body,foldElements,processedComments,document,quick);
          }
        }
      }
    }
  }
  return isClosure;
}
