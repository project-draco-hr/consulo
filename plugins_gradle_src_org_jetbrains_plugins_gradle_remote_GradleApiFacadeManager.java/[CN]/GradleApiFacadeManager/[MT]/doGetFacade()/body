{
  if (!GradleUtil.isGradleAvailable()) {
    return GradleApiFacade.NULL_OBJECT;
  }
  Pair<GradleApiFacade,RemoteGradleProcessSettings> pair=myFacade.get();
  if (pair != null) {
    if (isValid(pair)) {
      return pair.first;
    }
    mySupport.stopAll(true);
    myFacade.compareAndSet(pair,null);
  }
  final GradleApiFacade facade=mySupport.acquire(this,"");
  if (facade == null) {
    throw new IllegalStateException("Can't obtain facade to working with gradle api at the remote process");
  }
  final GradleApiFacade result=new GradleApiFacadeWrapper(facade,myProgressManager);
  Pair<GradleApiFacade,RemoteGradleProcessSettings> newPair=new Pair<GradleApiFacade,RemoteGradleProcessSettings>(result,getRemoteSettings());
  if (!myFacade.compareAndSet(null,newPair)) {
    GradleLog.LOG.warn("Detected unexpected duplicate tooling api facade instance creation");
    return myFacade.get().first;
  }
  if (!StringUtil.isEmpty(newPair.second.getJavaHome())) {
    GradleLog.LOG.info("Instructing gradle to use java from " + newPair.second.getJavaHome());
  }
  result.applySettings(newPair.second);
  RemoteGradleProgressNotificationManager exported=myExportedProgressManager.get();
  if (exported == null) {
    try {
      exported=(RemoteGradleProgressNotificationManager)UnicastRemoteObject.exportObject(myProgressManager,0);
      myExportedProgressManager.set(exported);
    }
 catch (    RemoteException e) {
      exported=myExportedProgressManager.get();
    }
  }
  if (exported == null) {
    GradleLog.LOG.warn("Can't export progress manager");
  }
 else {
    result.applyProgressManager(exported);
  }
  return result;
}
