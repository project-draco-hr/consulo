{
  final List<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>();
  place.accept(new PsiRecursiveElementVisitor(){
    public void visitMethodCallExpression(    PsiMethodCallExpression methodCall){
      final PsiExpression[] args=methodCall.getArgumentList().getExpressions();
      if (args.length != 1 || !(args[0].getType() instanceof PsiClassType))       return;
      final PsiReferenceExpression methodExpression=methodCall.getMethodExpression();
      Iterator<Integer> indicesIterator=myIndices.iterator();
      for (Iterator<PsiMethod> methodsIterator=myMethods.iterator(); methodsIterator.hasNext(); ) {
        PsiMethod patternMethod=methodsIterator.next();
        Integer index=indicesIterator.next();
        if (!patternMethod.getName().equals(methodExpression.getReferenceName()))         continue;
        final ResolveResult resolveResult=methodExpression.advancedResolve(false);
        final PsiMethod psiMethod=(PsiMethod)resolveResult.getElement();
        if (psiMethod != null && isInheritorOrSelf(psiMethod,patternMethod)) {
          PsiTypeParameter[] typeParameters=psiMethod.getContainingClass().getTypeParameters();
          int i=index.intValue();
          if (typeParameters.length <= i)           return;
          final PsiTypeParameter typeParameter=typeParameters[i];
          PsiType typeParamMapping=resolveResult.getSubstitutor().substitute(typeParameter);
          if (typeParamMapping != null) {
            if (!typeParamMapping.isConvertibleFrom(args[0].getType())) {
              final String message=MessageFormat.format("For no non-null object of type ''{0}'' can ''{1}'' return 'true'",new Object[]{PsiFormatUtil.formatType(args[0].getType(),0,PsiSubstitutor.EMPTY),PsiFormatUtil.formatMethod(psiMethod,resolveResult.getSubstitutor(),PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_CONTAINING_CLASS,PsiFormatUtil.SHOW_TYPE)});
              problems.add(manager.createProblemDescriptor(args[0],message,null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
              return;
            }
          }
        }
      }
    }
    private boolean isInheritorOrSelf(    PsiMethod inheritorCandidate,    PsiMethod base){
      PsiClass aClass=inheritorCandidate.getContainingClass();
      PsiClass bClass=base.getContainingClass();
      if (aClass == null || bClass == null)       return false;
      PsiSubstitutor substitutor=TypeConversionUtil.getClassSubstitutor(bClass,aClass,PsiSubstitutor.EMPTY);
      if (substitutor == null)       return false;
      return MethodSignatureUtil.findMethodBySignature(bClass,inheritorCandidate.getSignature(substitutor),false) == base;
    }
  }
);
  if (problems.isEmpty())   return null;
  return problems.toArray(new ProblemDescriptor[problems.size()]);
}
