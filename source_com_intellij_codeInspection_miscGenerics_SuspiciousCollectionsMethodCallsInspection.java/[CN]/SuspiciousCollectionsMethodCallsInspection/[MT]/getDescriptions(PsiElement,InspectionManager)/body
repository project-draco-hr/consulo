{
  final List<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>();
  final List<PsiMethod> patternMethods=new ArrayList<PsiMethod>();
  final List<Integer> indices=new ArrayList<Integer>();
  try {
    setupPatternMethods(place.getManager(),place.getResolveScope(),patternMethods,indices);
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
    return null;
  }
  place.accept(new PsiRecursiveElementVisitor(){
    public void visitMethodCallExpression(    PsiMethodCallExpression methodCall){
      final PsiExpression[] args=methodCall.getArgumentList().getExpressions();
      if (args.length != 1)       return;
      PsiType argType=args[0].getType();
      if (argType instanceof PsiPrimitiveType) {
        argType=((PsiPrimitiveType)argType).getBoxedType(methodCall.getManager(),methodCall.getResolveScope());
      }
      if (!(argType instanceof PsiClassType))       return;
      final PsiReferenceExpression methodExpression=methodCall.getMethodExpression();
      final ResolveResult resolveResult=methodExpression.advancedResolve(false);
      final PsiMethod psiMethod=(PsiMethod)resolveResult.getElement();
      if (psiMethod == null)       return;
      Iterator<Integer> indicesIterator=indices.iterator();
      for (Iterator<PsiMethod> methodsIterator=patternMethods.iterator(); methodsIterator.hasNext(); ) {
        PsiMethod patternMethod=methodsIterator.next();
        Integer index=indicesIterator.next();
        if (!patternMethod.getName().equals(methodExpression.getReferenceName()))         continue;
        if (isInheritorOrSelf(psiMethod,patternMethod)) {
          PsiTypeParameter[] typeParameters=psiMethod.getContainingClass().getTypeParameters();
          int i=index.intValue();
          if (typeParameters.length <= i)           return;
          final PsiTypeParameter typeParameter=typeParameters[i];
          PsiType typeParamMapping=resolveResult.getSubstitutor().substitute(typeParameter);
          if (typeParamMapping != null) {
            String message=null;
            if (!typeParamMapping.isAssignableFrom(argType)) {
              if (!typeParamMapping.isConvertibleFrom(argType)) {
                String existsElementString=getExistsElementString(patternMethod);
                message=MessageFormat.format("For no non-null object of type ''{0}'' can ''{1}'' return {2}",new Object[]{PsiFormatUtil.formatType(argType,0,PsiSubstitutor.EMPTY),PsiFormatUtil.formatMethod(psiMethod,resolveResult.getSubstitutor(),PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_CONTAINING_CLASS,PsiFormatUtil.SHOW_TYPE),existsElementString});
              }
 else {
                message=MessageFormat.format("Suspicious call to ''{0}''",new Object[]{PsiFormatUtil.formatMethod(psiMethod,resolveResult.getSubstitutor(),PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_CONTAINING_CLASS,PsiFormatUtil.SHOW_TYPE)});
              }
            }
            if (message != null) {
              problems.add(manager.createProblemDescriptor(args[0],message,null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
            }
          }
        }
        return;
      }
    }
    private String getExistsElementString(    final PsiMethod method){
      if (PsiType.BOOLEAN.equals(method.getReturnType()))       return "'true'";
      if (PsiType.INT.equals(method.getReturnType()))       return "non-negative value";
      return "non-null value";
    }
    private boolean isInheritorOrSelf(    PsiMethod inheritorCandidate,    PsiMethod base){
      PsiClass aClass=inheritorCandidate.getContainingClass();
      PsiClass bClass=base.getContainingClass();
      if (aClass == null || bClass == null)       return false;
      PsiSubstitutor substitutor=TypeConversionUtil.getClassSubstitutor(bClass,aClass,PsiSubstitutor.EMPTY);
      if (substitutor == null)       return false;
      return MethodSignatureUtil.findMethodBySignature(bClass,inheritorCandidate.getSignature(substitutor),false) == base;
    }
  }
);
  if (problems.isEmpty())   return null;
  return problems.toArray(new ProblemDescriptor[problems.size()]);
}
