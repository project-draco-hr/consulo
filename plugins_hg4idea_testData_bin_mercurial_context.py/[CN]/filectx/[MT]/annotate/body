def annotate(self, follow=False, linenumber=None):
    'returns a list of tuples of (ctx, line) for each line\n        in the file, where ctx is the filectx of the node where\n        that line was last changed.\n        This returns tuples of ((ctx, linenumber), line) for each line,\n        if "linenumber" parameter is NOT "None".\n        In such tuples, linenumber means one at the first appearance\n        in the managed file.\n        To reduce annotation cost,\n        this returns fixed value(False is used) as linenumber,\n        if "linenumber" parameter is "False".'

    def decorate_compat(text, rev):
        return (([rev] * len(text.splitlines())), text)

    def without_linenumber(text, rev):
        return (([(rev, False)] * len(text.splitlines())), text)

    def with_linenumber(text, rev):
        size = len(text.splitlines())
        return ([(rev, i) for i in xrange(1, (size + 1))], text)
    decorate = (((linenumber is None) and decorate_compat) or (linenumber and with_linenumber) or without_linenumber)

    def pair(parent, child):
        for (a1, a2, b1, b2) in bdiff.blocks(parent[1], child[1]):
            child[0][b1:b2] = parent[0][a1:a2]
        return child
    getlog = util.lrucachefunc((lambda x: self._repo.file(x)))

    def getctx(path, fileid):
        log = (((path == self._path) and self._filelog) or getlog(path))
        return filectx(self._repo, path, fileid=fileid, filelog=log)
    getctx = util.lrucachefunc(getctx)

    def parents(f):
        p = f._path
        if (f._filerev is None):
            pl = [(n.path(), n.filerev()) for n in f.parents()]
        else:
            pl = [(p, n) for n in f._filelog.parentrevs(f._filerev)]
        if follow:
            r = f.renamed()
            if r:
                pl[0] = (r[0], getlog(r[0]).rev(r[1]))
        return [getctx(p, n) for (p, n) in pl if (n != nullrev)]
    if (self.rev() != self.linkrev()):
        base = self.filectx(self.filerev())
    else:
        base = self
    needed = {base: 1, }
    visit = [base]
    files = [base._path]
    while visit:
        f = visit.pop(0)
        for p in parents(f):
            if (p not in needed):
                needed[p] = 1
                visit.append(p)
                if (p._path not in files):
                    files.append(p._path)
            else:
                needed[p] += 1
    visit = []
    for f in files:
        visit.extend((n for n in needed if (n._path == f)))
    hist = {}
    for f in sorted(visit, key=(lambda x: x.rev())):
        curr = decorate(f.data(), f)
        for p in parents(f):
            curr = pair(hist[p], curr)
            needed[p] -= 1
            if (not needed[p]):
                del hist[p]
        hist[f] = curr
    return zip(hist[f][0], hist[f][1].splitlines(True))
