{
  Set<BuildTargetType<?>> targetTypes=new HashSet<BuildTargetType<?>>();
  Set<BuildTarget<?>> targets=new HashSet<BuildTarget<?>>();
  Map<BuildTarget<?>,Set<File>> files;
  for (  TargetTypeBuildScope scope : scopes) {
    BuildTargetType<?> targetType=BuilderRegistry.getInstance().getTargetType(scope.getTypeId());
    if (targetType == null) {
      LOG.info("Unknown target type: " + scope.getTypeId());
      continue;
    }
    if (scope.getAllTargets()) {
      targetTypes.add(targetType);
    }
 else {
      BuildTargetLoader<?> loader=targetType.createLoader(pd.jpsModel);
      for (      String targetId : scope.getTargetIdList()) {
        BuildTarget<?> target=loader.createTarget(targetId);
        if (target != null) {
          targets.add(target);
        }
 else {
          LOG.info("Unknown " + targetType + " target id: "+ targetId);
        }
      }
    }
  }
  final Timestamps timestamps=pd.timestamps.getStorage();
  if (!paths.isEmpty()) {
    files=new HashMap<BuildTarget<?>,Set<File>>();
    for (    String path : paths) {
      final File file=new File(path);
      final RootDescriptor rd=pd.getBuildRootIndex().getModuleAndRoot(null,file);
      if (rd != null) {
        Set<File> fileSet=files.get(rd.target);
        if (fileSet == null) {
          fileSet=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
          files.put(rd.target,fileSet);
        }
        fileSet.add(file);
        if (buildType == BuildType.FORCED_COMPILATION) {
          pd.fsState.markDirty(null,file,rd,timestamps);
        }
      }
    }
  }
 else {
    files=Collections.emptyMap();
  }
  return new CompileScopeImpl(buildType != BuildType.MAKE,targetTypes,targets,files);
}
