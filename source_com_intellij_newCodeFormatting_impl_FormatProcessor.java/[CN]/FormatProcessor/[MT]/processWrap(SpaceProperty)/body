{
  final WhiteSpace whiteSpace=myCurrentBlock.getWhiteSpace();
  final TextRange textRange=myCurrentBlock.getTextRange();
  final WrapImpl[] wraps=myCurrentBlock.getWraps();
  if (whiteSpace.containsLineFeeds() && !whiteSpace.containsLineFeedsInitially()) {
    whiteSpace.removeLineFeeds(spaceProperty,this);
  }
  boolean wrapIsPresent=whiteSpace.containsLineFeeds();
  for (int i=0; i < wraps.length; i++) {
    WrapImpl wrap=wraps[i];
    wrap.processNextEntry(textRange.getStartOffset());
  }
  WrapImpl wrap=getWrapToBeUsed(wraps);
  if (wrap != null || wrapIsPresent) {
    if (!wrapIsPresent && !canReplaceWrapCandidate(wrap)) {
      myCurrentBlock=myWrapCandidate;
      return true;
    }
 else {
      if (wrap != null && wrap.getFirstEntry() != null) {
        myCurrentBlock=wrap.getFirstEntry();
        wrap.markAsUsed();
        return true;
      }
 else {
        if (wrap != null && wrapCanBeUsedInTheFuture(wrap)) {
          wrap.markAsUsed();
        }
      }
    }
    whiteSpace.ensureLineFeed();
    myWrapCandidate=null;
  }
 else {
    for (int i=0; i < wraps.length; i++) {
      WrapImpl wrap1=wraps[i];
      if (isCandidateToBeWrapped(wrap1) && canReplaceWrapCandidate(wrap1)) {
        myWrapCandidate=myCurrentBlock;
      }
      if (wrapCanBeUsedInTheFuture(wrap1)) {
        wrap1.saveFirstEntry(myCurrentBlock);
      }
    }
  }
  if (!whiteSpace.containsLineFeeds() && lineOver() && myWrapCandidate != null && !whiteSpace.isReadOnly()) {
    myCurrentBlock=myWrapCandidate;
    return true;
  }
  return false;
}
