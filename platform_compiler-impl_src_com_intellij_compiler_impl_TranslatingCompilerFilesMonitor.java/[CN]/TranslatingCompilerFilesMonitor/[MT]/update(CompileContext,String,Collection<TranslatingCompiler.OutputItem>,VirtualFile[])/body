{
  final Project project=context.getProject();
  final int projectId=getProjectId(project);
  if (!successfullyCompiled.isEmpty()) {
    final LocalFileSystem lfs=LocalFileSystem.getInstance();
    final IOException[] exceptions={null};
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      @Override public void run(){
        try {
          final Map<VirtualFile,SourceFileInfo> compiledSources=new HashMap<VirtualFile,SourceFileInfo>();
          final Set<VirtualFile> forceRecompile=new HashSet<VirtualFile>();
          for (          TranslatingCompiler.OutputItem item : successfullyCompiled) {
            final VirtualFile sourceFile=item.getSourceFile();
            final boolean isSourceValid=sourceFile.isValid();
            SourceFileInfo srcInfo=compiledSources.get(sourceFile);
            if (isSourceValid && srcInfo == null) {
              srcInfo=loadSourceInfo(sourceFile);
              if (srcInfo != null) {
                srcInfo.clearPaths(projectId);
              }
 else {
                srcInfo=new SourceFileInfo();
              }
              compiledSources.put(sourceFile,srcInfo);
            }
            final String outputPath=item.getOutputPath();
            if (outputPath != null) {
              final VirtualFile outputFile=lfs.findFileByPath(outputPath);
              if (outputFile != null) {
                if (!sourceFile.equals(outputFile)) {
                  final String className=outputRoot == null ? null : MakeUtil.relativeClassPathToQName(outputPath.substring(outputRoot.length()),'/');
                  if (isSourceValid) {
                    srcInfo.addOutputPath(projectId,outputPath);
                    saveOutputInfo(outputFile,new OutputFileInfo(sourceFile.getPath(),className));
                  }
 else {
                    markOutputPathForDeletion(projectId,outputPath,className,sourceFile.getUrl());
                  }
                }
              }
 else {
                LOG.warn("TranslatingCompilerFilesMonitor.update():  Virtual file was not found for \"" + outputPath + "\"");
                if (isSourceValid) {
                  forceRecompile.add(sourceFile);
                }
              }
            }
          }
          final long compilationStartStamp=((CompileContextEx)context).getStartCompilationStamp();
          for (          Map.Entry<VirtualFile,SourceFileInfo> entry : compiledSources.entrySet()) {
            final SourceFileInfo info=entry.getValue();
            final VirtualFile file=entry.getKey();
            final long fileStamp=file.getTimeStamp();
            info.updateTimestamp(projectId,fileStamp);
            saveSourceInfo(file,info);
            if (LOG.isDebugEnabled() || ourDebugMode) {
              final String message="Unschedule recompilation (successfully compiled) " + file.getPresentableUrl();
              LOG.debug(message);
              if (ourDebugMode) {
                System.out.println(message);
              }
            }
            removeSourceForRecompilation(projectId,Math.abs(getFileId(file)));
            if (fileStamp > compilationStartStamp && !((CompileContextEx)context).isGenerated(file) || forceRecompile.contains(file)) {
              addSourceForRecompilation(projectId,file,info);
            }
          }
        }
 catch (        IOException e) {
          exceptions[0]=e;
        }
      }
    }
);
    if (exceptions[0] != null) {
      throw exceptions[0];
    }
  }
  if (filesToRecompile.length > 0) {
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      @Override public void run(){
        for (        VirtualFile file : filesToRecompile) {
          if (file.isValid()) {
            loadInfoAndAddSourceForRecompilation(projectId,file);
          }
        }
      }
    }
);
  }
}
