{
  final Project project=myFile.getProject();
  final GroovyCodeStyleSettings settings=CodeStyleSettingsManager.getSettings(project).getCustomSettings(GroovyCodeStyleSettings.class);
  final GroovyPsiElementFactory factory=GroovyPsiElementFactory.getInstance(project);
  TObjectIntHashMap<String> packageCountMap=new TObjectIntHashMap<String>();
  TObjectIntHashMap<String> classCountMap=new TObjectIntHashMap<String>();
  for (  String importedClass : importedClasses) {
    if (implicitlyImported.contains(importedClass) || innerClasses.contains(importedClass) || aliased.containsKey(importedClass)|| annotations.containsKey(importedClass)) {
      continue;
    }
    final String packageName=StringUtil.getPackageName(importedClass);
    if (!packageCountMap.containsKey(packageName))     packageCountMap.put(packageName,0);
    packageCountMap.increment(packageName);
  }
  for (  String importedMember : staticallyImportedMembers) {
    if (aliased.containsKey(importedMember) || annotations.containsKey(importedMember))     continue;
    final String className=StringUtil.getPackageName(importedMember);
    if (!classCountMap.containsKey(className))     classCountMap.put(className,0);
    classCountMap.increment(className);
  }
  final Set<String> onDemandImportedSimpleClassNames=new HashSet<String>();
  final List<GrImportStatement> result=new ArrayList<GrImportStatement>();
  packageCountMap.forEachEntry(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      if (i >= settings.CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND || settings.PACKAGES_TO_USE_IMPORT_ON_DEMAND.contains(s)) {
        final GrImportStatement imp=factory.createImportStatementFromText(s,false,true,null);
        String annos=annotations.get(s + ".*");
        if (annos != null) {
          imp.getAnnotationList().replace(factory.createModifierList(annos));
        }
        result.add(imp);
        final PsiPackage aPackage=JavaPsiFacade.getInstance(myFile.getProject()).findPackage(s);
        if (aPackage != null) {
          for (          PsiClass clazz : aPackage.getClasses(myFile.getResolveScope())) {
            onDemandImportedSimpleClassNames.add(clazz.getName());
          }
        }
      }
      return true;
    }
  }
);
  classCountMap.forEachEntry(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      if (i >= settings.NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND) {
        final GrImportStatement imp=factory.createImportStatementFromText(s,true,true,null);
        String annos=annotations.get(s + ".*");
        if (annos != null) {
          imp.getAnnotationList().replace(factory.createModifierList(annos));
        }
        result.add(imp);
      }
      return true;
    }
  }
);
  List<GrImportStatement> explicated=CollectionFactory.arrayList();
  for (  String importedClass : importedClasses) {
    final String parentName=StringUtil.getPackageName(importedClass);
    if (!annotations.containsKey(importedClass) && !aliased.containsKey(importedClass)) {
      if (packageCountMap.get(parentName) >= settings.CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND || settings.PACKAGES_TO_USE_IMPORT_ON_DEMAND.contains(parentName)) {
        continue;
      }
      if (implicitlyImported.contains(importedClass) && !onDemandImportedSimpleClassNames.contains(StringUtil.getShortName(importedClass))) {
        continue;
      }
    }
    final GrImportStatement imp=factory.createImportStatementFromText(importedClass,false,false,null);
    String annos=annotations.get(importedClass);
    if (annos != null) {
      imp.getAnnotationList().replace(factory.createModifierList(annos));
    }
    explicated.add(imp);
  }
  for (  String importedMember : staticallyImportedMembers) {
    final String className=StringUtil.getPackageName(importedMember);
    if (!annotations.containsKey(importedMember) && !aliased.containsKey(importedMember)) {
      if (classCountMap.get(className) >= settings.NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND)       continue;
    }
    result.add(factory.createImportStatementFromText(importedMember,true,false,null));
  }
  for (  GrImportStatement anImport : usedImports) {
    if (anImport.isAliasedImport() || isAnnotatedImport(anImport)) {
      if (anImport.isStatic()) {
        result.add(anImport);
      }
 else {
        explicated.add(anImport);
      }
    }
  }
  final Comparator<GrImportStatement> comparator=getComparator(settings);
  Collections.sort(result,comparator);
  Collections.sort(explicated,comparator);
  explicated.addAll(result);
  return explicated.toArray(new GrImportStatement[explicated.size()]);
}
