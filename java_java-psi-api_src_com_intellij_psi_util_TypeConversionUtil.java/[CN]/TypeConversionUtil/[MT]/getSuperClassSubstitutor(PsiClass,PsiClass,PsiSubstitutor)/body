{
  if (!superClass.hasTypeParameters() && superClass.getContainingClass() == null)   return PsiSubstitutor.EMPTY;
  final PsiManager manager=superClass.getManager();
  if (PsiUtil.isRawSubstitutor(derivedClass,derivedSubstitutor)) {
    return JavaPsiFacade.getInstance(manager.getProject()).getElementFactory().createRawSubstitutor(superClass);
  }
  final PsiClass objectClass=JavaPsiFacade.getInstance(manager.getProject()).findClass("java.lang.Object",superClass.getResolveScope());
  if (manager.areElementsEquivalent(superClass,objectClass)) {
    return PsiSubstitutor.EMPTY;
  }
  PsiSubstitutor substitutor;
  final Set<PsiClass> visited=new THashSet<PsiClass>();
  if (derivedClass instanceof PsiAnonymousClass) {
    final PsiClassType baseType=((PsiAnonymousClass)derivedClass).getBaseClassType();
    final JavaResolveResult result=baseType.resolveGenerics();
    if (result.getElement() == null)     return PsiSubstitutor.UNKNOWN;
    substitutor=getSuperClassSubstitutorInner(superClass,(PsiClass)result.getElement(),derivedSubstitutor.putAll(result.getSubstitutor()),visited,manager);
  }
 else {
    substitutor=getSuperClassSubstitutorInner(superClass,derivedClass,derivedSubstitutor,visited,manager);
  }
  if (substitutor == null) {
    final StringBuilder msg=new StringBuilder("Super: " + classInfo(superClass));
    msg.append("visited:\n");
    for (    PsiClass aClass : visited) {
      msg.append("  each: " + classInfo(aClass));
    }
    msg.append("hierarchy:\n");
    InheritanceUtil.processSupers(derivedClass,true,new Processor<PsiClass>(){
      @Override public boolean process(      PsiClass psiClass){
        msg.append("each: " + classInfo(psiClass));
        return true;
      }
    }
);
    LOG.error(msg.toString());
    return PsiSubstitutor.EMPTY;
  }
  return substitutor;
}
