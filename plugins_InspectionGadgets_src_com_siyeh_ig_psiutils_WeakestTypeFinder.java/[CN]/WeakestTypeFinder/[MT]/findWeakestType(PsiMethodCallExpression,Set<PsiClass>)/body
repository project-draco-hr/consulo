{
  final PsiReferenceExpression methodExpression=methodCallExpression.getMethodExpression();
  final PsiElement target=methodExpression.resolve();
  if (!(target instanceof PsiMethod)) {
    return false;
  }
  final PsiMethod method=(PsiMethod)target;
  final PsiReferenceList throwsList=method.getThrowsList();
  final PsiClassType[] classTypes=throwsList.getReferencedTypes();
  final Collection<PsiClassType> thrownTypes=new HashSet<PsiClassType>(Arrays.asList(classTypes));
  final PsiMethod[] superMethods=method.findDeepestSuperMethods();
  boolean checked=false;
  if (superMethods.length > 0) {
    final PsiType expectedType=ExpectedTypeUtils.findExpectedType(methodCallExpression,false);
    for (    PsiMethod superMethod : superMethods) {
      final PsiType returnType=superMethod.getReturnType();
      if (expectedType != null && returnType != null && !expectedType.isAssignableFrom(returnType)) {
        continue;
      }
      if (throwsIncompatibleException(superMethod,thrownTypes)) {
        continue;
      }
      if (!PsiUtil.isAccessible(superMethod,methodCallExpression,null)) {
        continue;
      }
      final PsiClass containingClass=superMethod.getContainingClass();
      checkClass(containingClass,weakestTypeClasses);
      checked=true;
    }
  }
  if (!checked) {
    final PsiType returnType=method.getReturnType();
    if (returnType instanceof PsiClassType) {
      final PsiClassType classType=(PsiClassType)returnType;
      final PsiClass aClass=classType.resolve();
      if (aClass instanceof PsiTypeParameter) {
        return false;
      }
    }
    final PsiClass containingClass=method.getContainingClass();
    checkClass(containingClass,weakestTypeClasses);
  }
  return true;
}
