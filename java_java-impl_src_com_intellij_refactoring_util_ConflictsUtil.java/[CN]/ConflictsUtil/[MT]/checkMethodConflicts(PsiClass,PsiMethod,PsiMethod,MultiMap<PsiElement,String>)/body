{
  if (prototype == null)   return;
  final String protoMethodInfo=getMethodPrototypeString(prototype);
  PsiMethod method=aClass != null ? aClass.findMethodBySignature(prototype,true) : null;
  if (method != null && method != refactoredMethod) {
    if (aClass.equals(method.getContainingClass())) {
      final String classDescr=aClass instanceof PsiAnonymousClass ? RefactoringBundle.message("current.class") : RefactoringUIUtil.getDescription(aClass,false);
      conflicts.putValue(method,RefactoringBundle.message("method.0.is.already.defined.in.the.1",getMethodPrototypeString(prototype),classDescr));
    }
 else {
      if (JavaPsiFacade.getInstance(method.getProject()).getResolveHelper().isAccessible(method,aClass,null)) {
        String className=CommonRefactoringUtil.htmlEmphasize(UsageViewUtil.getDescriptiveName(method.getContainingClass()));
        if (PsiUtil.getAccessLevel(prototype.getModifierList()) >= PsiUtil.getAccessLevel(method.getModifierList())) {
          boolean isMethodAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
          boolean isMyMethodAbstract=refactoredMethod != null && refactoredMethod.hasModifierProperty(PsiModifier.ABSTRACT);
          final String conflict=isMethodAbstract != isMyMethodAbstract ? RefactoringBundle.message("method.0.will.implement.method.of.the.base.class",protoMethodInfo,className) : RefactoringBundle.message("method.0.will.override.a.method.of.the.base.class",protoMethodInfo,className);
          conflicts.putValue(method,conflict);
        }
 else {
          conflicts.putValue(method,RefactoringBundle.message("method.0.will.hide.method.of.the.base.class",protoMethodInfo,className));
        }
      }
    }
  }
  if (aClass != null && prototype.hasModifierProperty(PsiModifier.PRIVATE)) {
    ClassInheritorsSearch.search(aClass).forEach(new Processor<PsiClass>(){
      @Override public boolean process(      PsiClass aClass){
        final PsiMethod[] methods=aClass.findMethodsBySignature(prototype,false);
        for (        PsiMethod method : methods) {
          conflicts.putValue(method,"Method " + RefactoringUIUtil.getDescription(method,true) + " will override method of the base class "+ RefactoringUIUtil.getDescription(aClass,false));
        }
        return true;
      }
    }
);
  }
}
