{
  IntPair nfa1, nfa2;
  int start, end;
  RegExp2 r;
  if (Options.DEBUG)   Out.debug("Inserting RegExp : " + regExp);
  if (regExp.isCharClass(macros)) {
    start=numStates;
    end=numStates + 1;
    ensureCapacity(end + 1);
    if (end + 1 > numStates)     numStates=end + 1;
    insertCCLNFA(regExp,start,end);
    return new IntPair(start,end);
  }
switch (regExp.type) {
case sym.BAR:
    r=(RegExp2)regExp;
  nfa1=insertNFA(r.r1);
nfa2=insertNFA(r.r2);
start=nfa2.end + 1;
end=nfa2.end + 2;
addEpsilonTransition(start,nfa1.start);
addEpsilonTransition(start,nfa2.start);
addEpsilonTransition(nfa1.end,end);
addEpsilonTransition(nfa2.end,end);
return new IntPair(start,end);
case sym.CONCAT:
r=(RegExp2)regExp;
nfa1=insertNFA(r.r1);
nfa2=insertNFA(r.r2);
addEpsilonTransition(nfa1.end,nfa2.start);
return new IntPair(nfa1.start,nfa2.end);
case sym.STAR:
nfa1=insertNFA((RegExp)((RegExp1)regExp).content);
start=nfa1.end + 1;
end=nfa1.end + 2;
addEpsilonTransition(nfa1.end,end);
addEpsilonTransition(start,nfa1.start);
addEpsilonTransition(start,end);
addEpsilonTransition(nfa1.end,nfa1.start);
return new IntPair(start,end);
case sym.PLUS:
nfa1=insertNFA((RegExp)((RegExp1)regExp).content);
start=nfa1.end + 1;
end=nfa1.end + 2;
addEpsilonTransition(nfa1.end,end);
addEpsilonTransition(start,nfa1.start);
addEpsilonTransition(nfa1.end,nfa1.start);
return new IntPair(start,end);
case sym.QUESTION:
nfa1=insertNFA((RegExp)((RegExp1)regExp).content);
addEpsilonTransition(nfa1.start,nfa1.end);
return new IntPair(nfa1.start,nfa1.end);
case sym.BANG:
return complement(insertNFA((RegExp)((RegExp1)regExp).content));
case sym.TILDE:
return insertNFA(regExp.resolveTilde(macros));
case sym.STRING:
return insertStringNFA(false,(String)((RegExp1)regExp).content);
case sym.STRING_I:
return insertStringNFA(true,(String)((RegExp1)regExp).content);
case sym.MACROUSE:
return insertNFA(macros.getDefinition((String)((RegExp1)regExp).content));
}
throw new Error("Unknown expression type " + regExp.type + " in NFA construction");
}
