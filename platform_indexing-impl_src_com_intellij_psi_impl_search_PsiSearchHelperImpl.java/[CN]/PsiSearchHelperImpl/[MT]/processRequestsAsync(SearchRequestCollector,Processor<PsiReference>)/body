{
  final Map<SearchRequestCollector,Processor<PsiReference>> collectors=ContainerUtil.newHashMap();
  collectors.put(collector,processor);
  appendCollectorsFromQueryRequests(collectors);
  final ProgressIndicator progress=ProgressIndicatorProvider.getGlobalProgressIndicator();
  final DoWhile doWhile=new DoWhile(){
    @NotNull @Override protected AsyncFuture<Boolean> body(){
      final AsyncFutureResult<Boolean> result=AsyncFutureFactory.getInstance().createAsyncFutureResult();
      MultiMap<Set<IdIndexEntry>,RequestWithProcessor> globals=new MultiMap<Set<IdIndexEntry>,RequestWithProcessor>();
      final List<Computable<Boolean>> customs=ContainerUtil.newArrayList();
      final Set<RequestWithProcessor> locals=ContainerUtil.newLinkedHashSet();
      Map<RequestWithProcessor,Processor<PsiElement>> localProcessors=new THashMap<RequestWithProcessor,Processor<PsiElement>>();
      distributePrimitives(collectors,locals,globals,customs,localProcessors,progress);
      AsyncFuture<Boolean> future=processGlobalRequestsOptimizedAsync(globals,progress,localProcessors);
      future.addConsumer(SameThreadExecutor.INSTANCE,new DefaultResultConsumer<Boolean>(result){
        @Override public void onSuccess(        Boolean value){
          if (!value.booleanValue()) {
            result.set(value);
          }
 else {
            final Iterate<RequestWithProcessor> iterate=new Iterate<RequestWithProcessor>(locals){
              @NotNull @Override protected AsyncFuture<Boolean> process(              RequestWithProcessor local){
                return processSingleRequestAsync(local.request,local.refProcessor);
              }
            }
;
            iterate.getResult().addConsumer(SameThreadExecutor.INSTANCE,new DefaultResultConsumer<Boolean>(result){
              @Override public void onSuccess(              Boolean value){
                if (!value.booleanValue()) {
                  result.set(false);
                  return;
                }
                for (                Computable<Boolean> custom : customs) {
                  if (!custom.compute()) {
                    result.set(false);
                    return;
                  }
                }
                result.set(true);
              }
            }
);
          }
        }
      }
);
      return result;
    }
    @Override protected boolean condition(){
      return appendCollectorsFromQueryRequests(collectors);
    }
  }
;
  return doWhile.getResult();
}
