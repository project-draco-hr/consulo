{
  myManager.startBatchFilesProcessingMode();
  try {
    final AtomicInteger counter=new AtomicInteger(alreadyProcessedFiles);
    final AtomicBoolean canceled=new AtomicBoolean(false);
    boolean completed=true;
    while (true) {
      List<VirtualFile> failedList=new SmartList<VirtualFile>();
      final List<VirtualFile> failedFiles=Collections.synchronizedList(failedList);
      final Processor<VirtualFile> processor=new Processor<VirtualFile>(){
        @Override public boolean process(        final VirtualFile vfile){
          try {
            TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();
            processVirtualFile(vfile,progress,localProcessor,canceled,counter,totalSize);
          }
 catch (          ApplicationUtil.CannotRunReadActionException action) {
            failedFiles.add(vfile);
          }
          return !canceled.get();
        }
      }
;
      if (ApplicationManager.getApplication().isWriteAccessAllowed() || ((ApplicationEx)ApplicationManager.getApplication()).isWriteActionPending()) {
        completed&=ContainerUtil.process(files,processor);
      }
 else {
        completed&=JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files,progress,false,false,processor);
      }
      if (failedFiles.isEmpty()) {
        break;
      }
      DumbService.getInstance(myManager.getProject()).runReadActionInSmartMode(EmptyRunnable.getInstance());
      files=failedList;
    }
    return completed;
  }
  finally {
    myManager.finishBatchFilesProcessingMode();
  }
}
