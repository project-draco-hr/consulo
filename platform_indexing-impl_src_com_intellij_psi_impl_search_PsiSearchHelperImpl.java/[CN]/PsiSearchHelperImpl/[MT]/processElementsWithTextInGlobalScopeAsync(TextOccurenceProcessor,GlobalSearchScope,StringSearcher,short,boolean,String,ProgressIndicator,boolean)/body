{
  if (Thread.holdsLock(PsiLock.LOCK)) {
    throw new AssertionError("You must not run search from within updating PSI activity. Please consider invokeLatering it instead.");
  }
  if (progress != null) {
    progress.pushState();
    progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  }
  String text=searcher.getPattern();
  Set<VirtualFile> fileSet=new THashSet<VirtualFile>();
  getFilesWithText(scope,searchContext,caseSensitively,text,progress,fileSet);
  if (progress != null) {
    progress.setText(PsiBundle.message("psi.search.for.word.progress",text));
  }
  final Processor<PsiElement> localProcessor=localProcessor(processor,progress,processInjectedPsi,searcher);
  if (containerName != null) {
    List<VirtualFile> intersectionWithContainerFiles=new ArrayList<VirtualFile>();
    getFilesWithText(scope,searchContext,caseSensitively,text + " " + containerName,progress,intersectionWithContainerFiles);
    if (!intersectionWithContainerFiles.isEmpty()) {
      int totalSize=fileSet.size();
      AsyncFuture<Boolean> intersectionResult=processPsiFileRootsAsync(intersectionWithContainerFiles,totalSize,0,progress,localProcessor);
      AsyncFuture<Boolean> result;
      try {
        if (intersectionResult.get()) {
          fileSet.removeAll(intersectionWithContainerFiles);
          if (fileSet.isEmpty()) {
            result=intersectionResult;
          }
 else {
            AsyncFuture<Boolean> restResult=processPsiFileRootsAsync(new ArrayList<VirtualFile>(fileSet),totalSize,intersectionWithContainerFiles.size(),progress,localProcessor);
            result=bind(intersectionResult,restResult);
          }
        }
 else {
          result=intersectionResult;
        }
      }
 catch (      ExecutionException e) {
        Throwable cause=e.getCause();
        if (cause instanceof RuntimeException)         throw (RuntimeException)cause;
        if (cause instanceof Error)         throw (Error)cause;
        result=AsyncFutureFactory.wrapException(cause);
      }
catch (      InterruptedException e) {
        result=AsyncFutureFactory.wrapException(e);
      }
      return popStateAfter(result,progress);
    }
  }
  AsyncFuture<Boolean> result=fileSet.isEmpty() ? AsyncFutureFactory.wrap(Boolean.TRUE) : processPsiFileRootsAsync(new ArrayList<VirtualFile>(fileSet),fileSet.size(),0,progress,localProcessor);
  return popStateAfter(result,progress);
}
