{
  if (singles.isEmpty()) {
    return true;
  }
  if (singles.size() == 1) {
    final Collection<? extends RequestWithProcessor> requests=singles.values();
    if (requests.size() == 1) {
      final RequestWithProcessor theOnly=requests.iterator().next();
      return processSingleRequest(theOnly.request,theOnly.refProcessor);
    }
  }
  progress.pushState();
  progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  boolean result;
  try {
    final MultiMap<VirtualFile,RequestWithProcessor> intersectionCandidateFiles=createMultiMap();
    final MultiMap<VirtualFile,RequestWithProcessor> restCandidateFiles=createMultiMap();
    collectFiles(singles,progress,intersectionCandidateFiles,restCandidateFiles);
    if (intersectionCandidateFiles.isEmpty() && restCandidateFiles.isEmpty()) {
      return true;
    }
    final Set<String> allWords=new TreeSet<String>();
    for (    RequestWithProcessor singleRequest : localProcessors.keySet()) {
      allWords.add(singleRequest.request.word);
    }
    progress.setText(PsiBundle.message("psi.search.for.word.progress",getPresentableWordsDescription(allWords)));
    if (intersectionCandidateFiles.isEmpty()) {
      result=processCandidates(localProcessors,restCandidateFiles,progress,restCandidateFiles.size(),0);
    }
 else {
      int totalSize=restCandidateFiles.size() + intersectionCandidateFiles.size();
      result=processCandidates(localProcessors,intersectionCandidateFiles,progress,totalSize,0);
      if (result) {
        result=processCandidates(localProcessors,restCandidateFiles,progress,totalSize,intersectionCandidateFiles.size());
      }
    }
  }
  finally {
    progress.popState();
  }
  return result;
}
