{
  assertEDT();
  final List<LookupElement> items=getSortedItems();
  SortedMap<Comparable,List<LookupElement>> itemsMap=new TreeMap<Comparable,List<LookupElement>>();
  for (  final LookupElement item : items) {
    final Comparable relevance=myArranger.getRelevance(item);
    List<LookupElement> list=itemsMap.get(relevance);
    if (list == null) {
      itemsMap.put(relevance,list=new ArrayList<LookupElement>());
    }
    list.add(item);
  }
  List<LookupElement> list=new ArrayList<LookupElement>();
  Set<LookupElement> firstItems=new THashSet<LookupElement>();
  addExactPrefixItems(firstItems,items,list);
  addMostRelevantItems(firstItems,itemsMap.values(),list);
  addPreselectedItem(firstItems,preselectedItem,list);
  myPreferredItemsCount=firstItems.size();
  addRemainingItemsLexicographically(firstItems,items,list);
  final int oldSize;
synchronized (myModelItems) {
    oldSize=myModelItems.size() - 1;
    myModelItems.clear();
  }
  fireIntervalRemoved(this,0,oldSize);
  if (!list.isEmpty()) {
synchronized (myModelItems) {
      myModelItems.addAll(list);
    }
    fireIntervalAdded(this,0,list.size() - 1);
  }
  return list;
}
