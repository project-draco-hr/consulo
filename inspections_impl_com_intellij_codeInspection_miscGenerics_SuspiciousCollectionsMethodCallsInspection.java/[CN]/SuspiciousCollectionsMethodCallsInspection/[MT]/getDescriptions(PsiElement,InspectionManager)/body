{
  final List<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>();
  final List<PsiMethod> patternMethods=new ArrayList<PsiMethod>();
  final IntArrayList indices=new IntArrayList();
  try {
    setupPatternMethods(place.getManager(),place.getResolveScope(),patternMethods,indices);
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
    return null;
  }
  place.accept(new PsiRecursiveElementVisitor(){
    public void visitMethodCallExpression(    PsiMethodCallExpression methodCall){
      final PsiReferenceExpression methodExpression=methodCall.getMethodExpression();
      final PsiExpression qualifier=methodExpression.getQualifierExpression();
      if (qualifier == null || qualifier instanceof PsiThisExpression || qualifier instanceof PsiSuperExpression)       return;
      final PsiExpression[] args=methodCall.getArgumentList().getExpressions();
      if (args.length != 1)       return;
      PsiType argType=args[0].getType();
      if (argType instanceof PsiPrimitiveType) {
        argType=((PsiPrimitiveType)argType).getBoxedType(methodCall);
      }
      if (!(argType instanceof PsiClassType))       return;
      final JavaResolveResult resolveResult=methodExpression.advancedResolve(false);
      final PsiMethod calleeMethod=(PsiMethod)resolveResult.getElement();
      if (calleeMethod == null)       return;
      PsiMethod contextMethod=PsiTreeUtil.getParentOfType(methodCall,PsiMethod.class);
      for (int i=0; i < patternMethods.size(); i++) {
        PsiMethod patternMethod=patternMethods.get(i);
        int index=indices.get(i);
        if (!patternMethod.getName().equals(methodExpression.getReferenceName()))         continue;
        if (contextMethod != null && isInheritorOrSelf(contextMethod,patternMethod))         return;
        if (isInheritorOrSelf(calleeMethod,patternMethod)) {
          PsiTypeParameter[] typeParameters=calleeMethod.getContainingClass().getTypeParameters();
          if (typeParameters.length <= index)           return;
          final PsiTypeParameter typeParameter=typeParameters[index];
          PsiType typeParamMapping=resolveResult.getSubstitutor().substitute(typeParameter);
          if (typeParamMapping != null) {
            String message=null;
            if (!typeParamMapping.isAssignableFrom(argType)) {
              if (!typeParamMapping.isConvertibleFrom(argType)) {
                PsiType qualifierType=qualifier.getType();
                LOG.assertTrue(qualifierType != null);
                message=InspectionsBundle.message("inspection.suspicious.collections.method.calls.problem.descriptor",PsiFormatUtil.formatType(qualifierType,0,PsiSubstitutor.EMPTY),PsiFormatUtil.formatType(argType,0,PsiSubstitutor.EMPTY));
              }
 else {
                message=InspectionsBundle.message("inspection.suspicious.collections.method.calls.problem.descriptor1",PsiFormatUtil.formatMethod(calleeMethod,resolveResult.getSubstitutor(),PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_CONTAINING_CLASS,PsiFormatUtil.SHOW_TYPE));
              }
            }
            if (message != null) {
              problems.add(manager.createProblemDescriptor(args[0],message,(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
            }
          }
          return;
        }
      }
    }
    private boolean isInheritorOrSelf(    PsiMethod inheritorCandidate,    PsiMethod base){
      PsiClass aClass=inheritorCandidate.getContainingClass();
      PsiClass bClass=base.getContainingClass();
      if (aClass == null || bClass == null)       return false;
      PsiSubstitutor substitutor=TypeConversionUtil.getClassSubstitutor(bClass,aClass,PsiSubstitutor.EMPTY);
      if (substitutor == null)       return false;
      return MethodSignatureUtil.findMethodBySignature(bClass,inheritorCandidate.getSignature(substitutor),false) == base;
    }
  }
);
  if (problems.isEmpty())   return null;
  return problems.toArray(new ProblemDescriptor[problems.size()]);
}
