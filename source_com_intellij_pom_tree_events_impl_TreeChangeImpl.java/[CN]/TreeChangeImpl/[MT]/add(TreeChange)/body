{
  final TreeChangeImpl impl=(TreeChangeImpl)value;
  LOG.assertTrue(impl.myParent == myParent);
  final Iterator<Pair<ASTNode,Integer>> newChangesIterator=impl.myOffsets.iterator();
  while (newChangesIterator.hasNext()) {
    Pair<ASTNode,Integer> pair=newChangesIterator.next();
    final ASTNode child=pair.getFirst();
    final ChangeInfo change=impl.getChangeByChild(child);
    if (change.getChangeType() == ChangeInfo.REMOVED) {
      final ChangeInfo oldChange=getChangeByChild(child);
      if (oldChange != null) {
switch (oldChange.getChangeType()) {
case ChangeInfo.ADD:
          removeChangeInternal(child);
        break;
case ChangeInfo.CONTENTS_CHANGED:
      ((ChangeInfoImpl)change).setOldLength(oldChange.getOldLength());
    myChanges.put(child,change);
  break;
}
}
 else {
myChanges.put(child,change);
addChangeAtOffset(child,getOldOffset(pair.getSecond().intValue()));
}
}
 else if (change.getChangeType() == ChangeInfo.REPLACE) {
ReplaceChangeInfo replaceChangeInfo=(ReplaceChangeInfo)change;
final ChangeInfo oldChange=getChangeByChild(replaceChangeInfo.getReplaced());
if (oldChange != null) {
switch (oldChange.getChangeType()) {
case ChangeInfo.ADD:
removeChangeInternal(child);
addChange(child,ChangeInfoImpl.create(ChangeInfo.ADD,child));
break;
case ChangeInfo.CONTENTS_CHANGED:
((ChangeInfoImpl)change).setOldLength(oldChange.getOldLength());
default :
addChange(child,oldChange);
break;
}
}
 else addChange(child,change);
}
 else addChange(child,change);
}
}
