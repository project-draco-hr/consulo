{
  final int oldEndOffset=myEnd;
  if (newEndOffset == oldEndOffset)   return;
  if (myStart >= newEndOffset) {
    InitialInfoBuilder.assertInvalidRanges(myStart,newEndOffset,model,"some block intersects with whitespace");
  }
  myEnd=newEndOffset;
  TextRange range=new TextRange(myStart,myEnd);
  myInitial=model.getText(range);
  if (!coveredByBlock(model)) {
    InitialInfoBuilder.assertInvalidRanges(myStart,myEnd,model,"nonempty text is not covered by block");
  }
  final int tabsize=options.TAB_SIZE;
  for (int i=oldEndOffset - myStart; i < newEndOffset - myStart; i++) {
switch (myInitial.charAt(i)) {
case '\n':
      setLineFeeds(getLineFeeds() + 1);
    mySpaces=0;
  myIndentSpaces=0;
break;
case ' ':
mySpaces++;
break;
case '\t':
myIndentSpaces+=tabsize;
break;
}
}
if (getLineFeeds() > 0) myFlags|=CONTAINS_LF_INITIALLY;
 else myFlags&=~CONTAINS_LF_INITIALLY;
final int totalSpaces=getTotalSpaces();
if (totalSpaces > 0) myFlags|=CONTAINS_SPACES_INITIALLY;
 else myFlags&=~CONTAINS_SPACES_INITIALLY;
}
