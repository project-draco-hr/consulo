{
  OT oldNode=myOldTree.prepareForGetChildren(oldN);
  NT newNode=myNewTree.prepareForGetChildren(newN);
  if (level >= myNewChildrenLists.size()) {
    myNewChildrenLists.add(new Ref<NT[]>());
    myOldChildrenLists.add(new Ref<OT[]>());
  }
  final Ref<OT[]> oldChildrenR=myOldChildrenLists.get(level);
  final int oldSize=myOldTree.getChildren(oldNode,oldChildrenR);
  final OT[] oldChildren=oldChildrenR.get();
  final Ref<NT[]> newChildrenR=myNewChildrenLists.get(level);
  final int newSize=myNewTree.getChildren(newNode,newChildrenR);
  final NT[] newChildren=newChildrenR.get();
  if (Math.abs(oldSize - newSize) > CHANGE_PARENT_VERSUS_CHILDREN_THRESHOLD) {
    myConsumer.nodeReplaced(oldNode,newNode);
    disposeLevel(oldChildren,oldSize,newChildren,newSize);
    return;
  }
  final ShallowNodeComparator<OT,NT> comparator=myComparator;
  if (oldSize == 0 && newSize == 0) {
    if (!comparator.hashcodesEqual(oldNode,newNode) || !comparator.typesEqual(oldNode,newNode)) {
      myConsumer.nodeReplaced(oldNode,newNode);
    }
    disposeLevel(oldChildren,oldSize,newChildren,newSize);
    return;
  }
  boolean walkedDeep=false;
  ThreeState[] deeps;
  if (oldSize == newSize) {
    while (myDeepStates.size() <= level)     myDeepStates.add(new ThreeState[oldSize]);
    deeps=myDeepStates.get(level);
    if (deeps.length < oldSize) {
      deeps=new ThreeState[oldSize];
      myDeepStates.set(level,deeps);
    }
 else {
      Arrays.fill(deeps,0,oldSize,null);
    }
  }
 else {
    deeps=null;
  }
  int start=0;
  while (start < oldSize && start < newSize) {
    OT oldChild=oldChildren[start];
    NT newChild=newChildren[start];
    if (!comparator.typesEqual(oldChild,newChild))     break;
    final ThreeState dp=comparator.deepEqual(oldChild,newChild);
    if (deeps != null)     deeps[start]=dp;
    if (dp != ThreeState.YES) {
      if (!comparator.hashcodesEqual(oldChild,newChild))       break;
      if (dp == ThreeState.UNSURE) {
        build(oldChild,newChild,level + 1);
        walkedDeep=true;
      }
 else       if (dp == ThreeState.NO) {
        myConsumer.nodeReplaced(oldChild,newChild);
      }
    }
    start++;
  }
  int oldEnd=oldSize - 1;
  int newEnd=newSize - 1;
  if (oldSize == newSize && start == newSize) {
    disposeLevel(oldChildren,oldSize,newChildren,newSize);
    return;
  }
  while (oldEnd >= start && newEnd >= start) {
    OT oldChild=oldChildren[oldEnd];
    NT newChild=newChildren[newEnd];
    if (!comparator.typesEqual(oldChild,newChild))     break;
    final ThreeState dp=comparator.deepEqual(oldChild,newChild);
    if (deeps != null)     deeps[oldEnd]=dp;
    if (dp != ThreeState.YES) {
      if (!comparator.hashcodesEqual(oldChild,newChild))       break;
      if (dp == ThreeState.UNSURE) {
        build(oldChild,newChild,level + 1);
        walkedDeep=true;
      }
 else       if (dp == ThreeState.NO) {
        myConsumer.nodeReplaced(oldChild,newChild);
      }
    }
    oldEnd--;
    newEnd--;
  }
  if (oldSize == newSize) {
    for (int i=start; i <= newEnd; i++) {
      final OT oldChild=oldChildren[i];
      final NT newChild=newChildren[i];
      if (comparator.typesEqual(oldChild,newChild)) {
        final ThreeState de=deeps[i];
        if (de == ThreeState.UNSURE) {
          build(oldChild,newChild,level + 1);
        }
 else         if (de == ThreeState.NO || de == null) {
          myConsumer.nodeReplaced(oldChild,newChild);
        }
      }
 else {
        myConsumer.nodeReplaced(oldChild,newChild);
      }
    }
  }
 else {
    if (!walkedDeep && start == 0 && newEnd == newSize - 1 && oldEnd == oldSize - 1 && start < oldEnd && start < newEnd) {
      myConsumer.nodeReplaced(oldNode,newNode);
      disposeLevel(oldChildren,oldSize,newChildren,newSize);
      return;
    }
    for (int i=start; i <= oldEnd; i++) {
      final OT oldChild=oldChildren[i];
      myConsumer.nodeDeleted(oldNode,oldChild);
    }
    for (int i=start; i <= newEnd; i++) {
      myConsumer.nodeInserted(oldNode,newChildren[i],i);
    }
  }
  disposeLevel(oldChildren,oldSize,newChildren,newSize);
}
