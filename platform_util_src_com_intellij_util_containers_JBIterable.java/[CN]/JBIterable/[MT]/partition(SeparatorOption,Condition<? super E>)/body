{
  return intercept(new Function<Iterator<E>,Iterator<JBIterable<E>>>(){
    @Override public Iterator<JBIterable<E>> fun(    Iterator<E> iterator){
      final Iterator<E> orig=iterator;
      return new JBIterator<JBIterable<E>>(){
        List<E> stored;
        JBIterator<E> it;
        @Override protected JBIterable<E> nextImpl(){
          if (it != null && it.hasNext())           once(it).size();
          it=null;
          List<E> sep=stored;
          stored=null;
          if (option == SeparatorOption.EXTRACT && sep != null)           return JBIterable.from(sep);
          if (!orig.hasNext()) {
            return option == SeparatorOption.TAIL && sep != null ? JBIterable.from(sep) : stop();
          }
          it=JBIterator.wrap(orig);
          JBIterable<E> next=once(it.takeWhile(new Condition<E>(){
            @Override public boolean value(            E e){
              if (!separatorCondition.value(e))               return true;
              stored=Collections.singletonList(e);
              return false;
            }
          }
));
switch (option) {
case HEAD:
            return next.append(new JBIterable<E>(){
              @Override public Iterator<E> iterator(){
                return stored != null ? stored.iterator() : JBIterable.<E>empty().iterator();
              }
            }
);
case TAIL:
          return sep != null ? JBIterable.from(sep).append(next) : next;
case EXTRACT:
case SKIP:
        return next;
default :
      throw new AssertionError(option);
  }
}
}
;
}
}
);
}
