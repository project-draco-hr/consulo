{
  if (childDescr == null) {
    boolean isInMap=myElementToNodeMap.containsValue(childNode);
    LOG.error("childDescr == null, builder=" + this + ", childNode="+ childNode.getClass()+ ", isInMap = "+ isInMap+ ", node = "+ node);
    return;
  }
  Object oldElement=childDescr.getElement();
  if (oldElement == null) {
    LOG.error("oldElement == null, builder=" + this + ", childDescr="+ childDescr);
    return;
  }
  boolean changes=childDescr.update();
  Object newElement=childDescr.getElement();
  Integer index=newElement != null ? elementToIndexMap.get(newElement) : null;
  if (index != null) {
    if (childDescr.getIndex() != index.intValue()) {
      changes=true;
    }
    childDescr.setIndex(index.intValue());
  }
  if (index != null && changes) {
    updateNodeImageAndPosition(childNode);
  }
  if (!oldElement.equals(newElement)) {
    removeMapping(oldElement,childNode);
    if (newElement != null) {
      createMapping(newElement,childNode);
    }
  }
  if (index == null) {
    int selectedIndex=-1;
    if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
      selectedIndex=node.getIndex(childNode);
    }
    myTreeModel.removeNodeFromParent(childNode);
    disposeNode(childNode);
    if (selectedIndex >= 0) {
      if (node.getChildCount() > 0) {
        if (node.getChildCount() > selectedIndex) {
          TreeNode newChildNode=node.getChildAt(selectedIndex);
          myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(newChildNode)));
        }
 else {
          TreeNode newChild=node.getChildAt(node.getChildCount() - 1);
          myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(newChild)));
        }
      }
 else {
        myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(node)));
      }
    }
  }
 else {
    elementToIndexMap.remove(newElement);
    updateNodeChildren(childNode);
  }
  if (node.equals(myRootNode)) {
    myTreeModel.nodeChanged(myRootNode);
  }
}
