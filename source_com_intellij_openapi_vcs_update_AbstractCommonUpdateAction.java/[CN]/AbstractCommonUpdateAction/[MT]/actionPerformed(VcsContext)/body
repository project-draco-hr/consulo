{
  final Project project=context.getProject();
  boolean showUpdateOptions=myActionInfo.showOptions(project);
  final UpdatedFiles updatedFiles=UpdatedFiles.create();
  if (project != null) {
    try {
      if (ApplicationManager.getApplication().isDispatchThread()) {
        ApplicationManager.getApplication().saveAll();
      }
      final FilePath[] filePaths=myScopeInfo.getRoots(context,myActionInfo);
      final FilePath[] roots=filterDescindingFiles(filterRoots(filePaths,context),project);
      if (roots.length == 0) {
        return;
      }
      final Map<AbstractVcs,Collection<FilePath>> vcsToVirtualFiles=createVcsToFilesMap(roots,project);
      if (showUpdateOptions || OptionsDialog.shiftIsPressed(context.getModifiers())) {
        showOptionsDialog(vcsToVirtualFiles,project,context);
      }
      final ArrayList<VcsException> vcsExceptions=new ArrayList<VcsException>();
      final List<UpdateSession> updateSessions=new ArrayList<UpdateSession>();
      Task.Backgroundable task=new Task.Backgroundable(project,getTemplatePresentation().getText(),true,VcsConfiguration.getInstance(project).getUpdateOption()){
        public void run(        final ProgressIndicator indicator){
          ProjectManagerEx.getInstanceEx().blockReloadingProjectOnExternalChanges();
          ProjectLevelVcsManager.getInstance(project).startBackgroundVcsOperation();
          ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
          int toBeProcessed=vcsToVirtualFiles.size();
          int processed=0;
          for (          AbstractVcs vcs : vcsToVirtualFiles.keySet()) {
            final UpdateEnvironment updateEnvironment=myActionInfo.getEnvironment(vcs);
            updateEnvironment.fillGroups(updatedFiles);
            Collection<FilePath> files=vcsToVirtualFiles.get(vcs);
            UpdateSession updateSession=updateEnvironment.updateDirectories(files.toArray(new FilePath[files.size()]),updatedFiles,progressIndicator);
            processed++;
            if (progressIndicator != null) {
              progressIndicator.setFraction((double)processed / (double)toBeProcessed);
            }
            vcsExceptions.addAll(updateSession.getExceptions());
            updateSessions.add(updateSession);
          }
          if (progressIndicator != null) {
            progressIndicator.setText(VcsBundle.message("progress.text.synchronizing.files"));
            progressIndicator.setText2("");
          }
          final Semaphore semaphore=new Semaphore();
          semaphore.down();
          ApplicationManager.getApplication().invokeLater(new Runnable(){
            public void run(){
              VcsUtil.refreshFiles(roots,new Runnable(){
                public void run(){
                  semaphore.up();
                }
              }
);
            }
          }
);
          semaphore.waitFor();
        }
        public void onSuccess(){
          if (!someSessionWasCanceled(updateSessions)) {
            for (            final UpdateSession updateSession : updateSessions) {
              updateSession.onRefreshFilesCompleted();
            }
          }
          if (!someSessionWasCanceled(updateSessions)) {
            ApplicationManager.getApplication().invokeLater(new Runnable(){
              public void run(){
                if (!vcsExceptions.isEmpty()) {
                  AbstractVcsHelper.getInstance(project).showErrors(vcsExceptions,VcsBundle.message("message.title.vcs.update.errors",getTemplatePresentation().getText()));
                }
 else {
                  final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
                  if (indicator != null) {
                    indicator.setText(VcsBundle.message("progress.text.updating.done"));
                  }
                }
                if (updatedFiles.isEmpty() && vcsExceptions.isEmpty()) {
                  Messages.showMessageDialog(getAllFilesAreUpToDateMessage(roots),getTemplatePresentation().getText(),Messages.getInformationIcon());
                }
 else                 if (!updatedFiles.isEmpty()) {
                  RestoreUpdateTree restoreUpdateTree=RestoreUpdateTree.getInstance(project);
                  restoreUpdateTree.registerUpdateInformation(updatedFiles,myActionInfo);
                  final ProjectLevelVcsManagerEx vcsManagerEx=ProjectLevelVcsManagerEx.getInstanceEx(project);
                  final UpdateInfoTree updateInfoTree=vcsManagerEx.showUpdateProjectInfo(updatedFiles,getTemplatePresentation().getText(),myActionInfo);
                  updateInfoTree.setCanGroupByChangeList(true);
                  final MessageBusConnection messageBusConnection=project.getMessageBus().connect();
                  messageBusConnection.subscribe(CommittedChangesCache.COMMITTED_TOPIC,new CommittedChangesAdapter(){
                    public void incomingChangesUpdated(                    final List<CommittedChangeList> receivedChanges){
                      if (receivedChanges != null) {
                        updateInfoTree.setChangeLists(receivedChanges);
                        messageBusConnection.disconnect();
                      }
                    }
                  }
);
                  final CommittedChangesCache cache=CommittedChangesCache.getInstance(project);
                  cache.processUpdatedFiles(updatedFiles);
                }
                ProjectManagerEx.getInstanceEx().unblockReloadingProjectOnExternalChanges();
              }
            }
);
          }
          ProjectLevelVcsManager.getInstance(project).stopBackgroundVcsOperation();
        }
        public void onCancel(){
          onSuccess();
        }
      }
;
      ProgressManager.getInstance().run(task);
    }
 catch (    ProcessCanceledException e1) {
    }
  }
}
