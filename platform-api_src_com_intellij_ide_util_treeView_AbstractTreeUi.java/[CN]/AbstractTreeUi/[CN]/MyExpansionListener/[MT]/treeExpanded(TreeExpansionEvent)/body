{
  dropUpdaterStateIfExternalChange();
  TreePath path=event.getPath();
  final DefaultMutableTreeNode node=(DefaultMutableTreeNode)path.getLastPathComponent();
  if (!myUnbuiltNodes.contains(node))   return;
  myUnbuiltNodes.remove(node);
  final Alarm alarm=new Alarm(Alarm.ThreadToUse.SHARED_THREAD);
  alarm.addRequest(new Runnable(){
    public void run(){
      myTree.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
    }
  }
,WAIT_CURSOR_DELAY);
  getBuilder().expandNodeChildren(node);
  final Object element=getElementFor(node);
  for (int i=0; i < node.getChildCount(); i++) {
    removeIfLoading(node.getChildAt(i));
  }
  if (node.getChildCount() == 0) {
    addNodeAction(element,new NodeAction(){
      public void onReady(      final DefaultMutableTreeNode node){
        expand(element,null);
      }
    }
);
  }
  int n=alarm.cancelAllRequests();
  if (n == 0) {
    myTree.setCursor(Cursor.getDefaultCursor());
  }
  processSmartExpand(node);
}
