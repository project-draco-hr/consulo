{
  getTreeStructure().commit();
  final boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath()));
  final boolean wasLeaf=node.getChildCount() == 0;
  final NodeDescriptor descriptor=(NodeDescriptor)node.getUserObject();
  if (descriptor == null)   return;
  if (myUnbuiltNodes.contains(node)) {
    processUnbuilt(node,descriptor,pass);
    processNodeActionsIfReady(node);
    return;
  }
  if (getTreeStructure().isToBuildChildrenInBackground(getBuilder().getTreeStructureElement(descriptor))) {
    if (queueBackgroundUpdate(node,descriptor,pass))     return;
  }
  final Map<Object,Integer> elementToIndexMap=collectElementToIndexMap(descriptor,preloadedChildren);
  myUpdatingChildren.add(node);
  processAllChildren(node,elementToIndexMap,pass).doWhenDone(new Runnable(){
    public void run(){
      if (canYield()) {
        removeLoadingNode(node);
      }
      ArrayList<TreeNode> nodesToInsert=collectNodesToInsert(descriptor,elementToIndexMap);
      insertNodesInto(nodesToInsert,node);
      updateNodesToInsert(nodesToInsert,pass);
      if (wasExpanded) {
        expand(node);
      }
      if (wasExpanded || wasLeaf) {
        expand(node,descriptor,wasLeaf);
      }
      myUpdatingChildren.remove(node);
      final Object element=getElementFor(node);
      addNodeAction(element,new NodeAction(){
        public void onReady(        final DefaultMutableTreeNode node){
          removeLoadingNode(node);
        }
      }
);
      processNodeActionsIfReady(node);
    }
  }
);
}
