{
  String newMethodName=getMethodName();
  PsiMethod prototype;
  try {
    PsiManager manager=PsiManager.getInstance(myProject);
    PsiElementFactory factory=manager.getElementFactory();
    final CanonicalTypes.Type returnType=getReturnType();
    if (returnType != null) {
      prototype=factory.createMethod(newMethodName,returnType.getType(myMethod,manager));
    }
 else {
      prototype=null;
    }
    ParameterInfo[] parameters=getParameters();
    for (    ParameterInfo info : parameters) {
      final PsiType parameterType=info.createType(myMethod,manager);
      if (!RefactoringUtil.isResolvableType(parameterType)) {
        final int ret=Messages.showOkCancelDialog(myProject,"Type " + info.getTypeText() + " cannot be resolved.\nContinue?","Change Method Signature",Messages.getErrorIcon());
        if (ret != 0)         return false;
      }
      if (prototype != null) {
        PsiParameter param=factory.createParameter(info.getName(),parameterType);
        prototype.getParameterList().add(param);
      }
    }
  }
 catch (  IncorrectOperationException e) {
    prototype=null;
  }
  if (prototype == null)   return true;
  PsiClass aClass=myMethod.getContainingClass();
  return RefactoringMessageUtil.checkMethodConflicts(aClass != null ? (PsiElement)aClass : (PsiElement)myMethod.getContainingFile(),myMethod,prototype);
}
