{
  final Lexer lexer=myHighlighter.getHighlightingLexer();
  final SyntaxHighlighterOverEditorHighlighter highlighter=myHighlighter;
  LOG.assertTrue(start <= end);
  int i=StringUtil.indexOf(chars,'\n',start,end);
  if (i != -1)   end=i;
  if (myDocumentStamp != myDocument.getModificationStamp()) {
    highlighter.restart(chars);
    myDocumentStamp=myDocument.getModificationStamp();
  }
 else   if (lexer.getTokenType() == null || lexer.getTokenStart() > start) {
    highlighter.resetPosition(0);
  }
  boolean isBeginning=true;
  for (; lexer.getTokenType() != null; lexer.advance()) {
    int hiStart=lexer.getTokenStart();
    int hiEnd=lexer.getTokenEnd();
    if (hiStart >= end)     break;
    hiStart=Math.max(hiStart,start);
    hiEnd=Math.min(hiEnd,end);
    if (hiStart >= hiEnd) {
      continue;
    }
    if (isBeginning) {
      String text=chars.subSequence(hiStart,hiEnd).toString();
      if (text.trim().isEmpty())       continue;
    }
    isBeginning=false;
    IElementType tokenType=lexer.getTokenType();
    TextAttributesKey[] tokenHighlights=highlighter.getTokenHighlights(tokenType);
    processIntersectingRange(usageInfo2UsageAdapter,chars,hiStart,hiEnd,tokenHighlights,selectUsageWithBold,result);
  }
  return result.toArray(new TextChunk[result.size()]);
}
