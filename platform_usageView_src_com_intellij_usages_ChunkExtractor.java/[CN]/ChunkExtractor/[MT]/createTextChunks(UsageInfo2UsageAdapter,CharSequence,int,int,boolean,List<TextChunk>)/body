{
  final Lexer lexer=myLexer;
  final SyntaxHighlighter highlighter=myHighlighter;
  LOG.assertTrue(start <= end);
  int i=StringUtil.indexOf(chars,'\n',start,end);
  if (i != -1)   end=i;
  if (lexer.getTokenStart() > start || myDocumentStamp != myDocument.getModificationStamp()) {
    lexer.start(chars);
    myDocumentStamp=myDocument.getModificationStamp();
  }
  boolean isBeginning=true;
  for (; lexer.getTokenType() != null; lexer.advance()) {
    int hiStart=lexer.getTokenStart();
    int hiEnd=lexer.getTokenEnd();
    if (hiStart >= end)     break;
    hiStart=Math.max(hiStart,start);
    hiEnd=Math.min(hiEnd,end);
    if (hiStart >= hiEnd) {
      continue;
    }
    String text=chars.subSequence(hiStart,hiEnd).toString();
    if (isBeginning && text.trim().isEmpty())     continue;
    isBeginning=false;
    IElementType tokenType=lexer.getTokenType();
    TextAttributesKey[] tokenHighlights=highlighter.getTokenHighlights(tokenType);
    processIntersectingRange(usageInfo2UsageAdapter,chars,hiStart,hiEnd,tokenHighlights,selectUsageWithBold,result);
  }
  return result.toArray(new TextChunk[result.size()]);
}
