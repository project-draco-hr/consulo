{
  int absoluteStartOffset=usageInfo2UsageAdapter.getNavigationOffset();
  if (absoluteStartOffset == -1)   return TextChunk.EMPTY_ARRAY;
  Document visibleDocument=myDocument instanceof DocumentWindow ? ((DocumentWindow)myDocument).getDelegate() : myDocument;
  int visibleStartOffset=myDocument instanceof DocumentWindow ? ((DocumentWindow)myDocument).injectedToHost(absoluteStartOffset) : absoluteStartOffset;
  int lineNumber=myDocument.getLineNumber(absoluteStartOffset);
  int visibleLineNumber=visibleDocument.getLineNumber(visibleStartOffset);
  int visibleColumnNumber=visibleStartOffset - visibleDocument.getLineStartOffset(visibleLineNumber);
  final List<TextChunk> result=new ArrayList<TextChunk>();
  appendPrefix(result,visibleLineNumber,visibleColumnNumber);
  int lineStartOffset=myDocument.getLineStartOffset(lineNumber);
  int lineEndOffset=lineStartOffset < myDocument.getTextLength() ? myDocument.getLineEndOffset(lineNumber) : 0;
  if (lineStartOffset > lineEndOffset)   return TextChunk.EMPTY_ARRAY;
  final CharSequence chars=myDocument.getCharsSequence();
  if (myLexer.getTokenStart() > absoluteStartOffset) {
    myLexer.start(chars);
  }
  if (lineEndOffset - lineStartOffset > MAX_LINE_TO_SHOW) {
    lineStartOffset=Math.max(lineStartOffset,absoluteStartOffset - OFFSET_BEFORE_TO_SHOW_WHEN_LONG_LINE);
    lineEndOffset=Math.min(lineEndOffset,absoluteStartOffset + OFFSET_AFTER_TO_SHOW_WHEN_LONG_LINE);
  }
  if (myDocument instanceof DocumentWindow) {
    List<TextRange> editable=InjectedLanguageManager.getInstance(file.getProject()).intersectWithAllEditableFragments(file,new TextRange(lineStartOffset,lineEndOffset));
    for (    TextRange range : editable) {
      createTextChunks(usageInfo2UsageAdapter,chars,range.getStartOffset(),range.getEndOffset(),result);
    }
    return result.toArray(new TextChunk[result.size()]);
  }
  return createTextChunks(usageInfo2UsageAdapter,chars,lineStartOffset,lineEndOffset,result);
}
