{
  ArrangementCompositeMatchCondition condition=new ArrangementCompositeMatchCondition();
  condition.addOperand(new ArrangementAtomMatchCondition(FIELD));
  condition.addOperand(new ArrangementAtomMatchCondition(PUBLIC));
  StdArrangementEntryMatcher matcher=new StdArrangementEntryMatcher(condition);
  assertEquals(condition,matcher.getCondition());
  final TypeAwareArrangementEntry fieldEntry=myMockery.mock(TypeAwareArrangementEntry.class,"field");
  final ModifierAwareArrangementEntry publicEntry=myMockery.mock(ModifierAwareArrangementEntry.class,"public");
  final TypeAndModifierAware privateFieldEntry=myMockery.mock(TypeAndModifierAware.class,"private field");
  final TypeAndModifierAware publicMethodEntry=myMockery.mock(TypeAndModifierAware.class,"public method");
  final TypeAndModifierAware publicFieldEntry=myMockery.mock(TypeAndModifierAware.class,"public field");
  final TypeAndModifierAware publicStaticFieldEntry=myMockery.mock(TypeAndModifierAware.class,"public static field");
  myMockery.checking(new Expectations(){
{
      allowing(fieldEntry).getTypes();
      will(returnValue(ContainerUtilRt.newHashSet(FIELD)));
      allowing(publicEntry).getModifiers();
      will(returnValue(ContainerUtilRt.newHashSet(PUBLIC)));
      allowing(privateFieldEntry).getTypes();
      will(returnValue(ContainerUtilRt.newHashSet(FIELD)));
      allowing(privateFieldEntry).getModifiers();
      will(returnValue(ContainerUtilRt.newHashSet(PRIVATE)));
      allowing(publicMethodEntry).getTypes();
      will(returnValue(ContainerUtilRt.newHashSet(METHOD)));
      allowing(publicMethodEntry).getModifiers();
      will(returnValue(ContainerUtilRt.newHashSet(PUBLIC)));
      allowing(publicFieldEntry).getTypes();
      will(returnValue(ContainerUtilRt.newHashSet(FIELD)));
      allowing(publicFieldEntry).getModifiers();
      will(returnValue(ContainerUtilRt.newHashSet(PUBLIC)));
      allowing(publicStaticFieldEntry).getTypes();
      will(returnValue(ContainerUtilRt.newHashSet(FIELD)));
      allowing(publicStaticFieldEntry).getModifiers();
      will(returnValue(ContainerUtilRt.newHashSet(PUBLIC,STATIC)));
    }
  }
);
  assertFalse(matcher.isMatched(fieldEntry));
  assertFalse(matcher.isMatched(publicEntry));
  assertFalse(matcher.isMatched(privateFieldEntry));
  assertFalse(matcher.isMatched(publicMethodEntry));
  assertTrue(matcher.isMatched(publicFieldEntry));
  assertTrue(matcher.isMatched(publicStaticFieldEntry));
}
