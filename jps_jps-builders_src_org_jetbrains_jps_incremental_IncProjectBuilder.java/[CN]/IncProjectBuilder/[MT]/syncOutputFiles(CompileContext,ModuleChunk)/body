{
  final BuildDataManager dataManager=context.getProjectDescriptor().dataManager;
  try {
    final Collection<String> allOutputs=new LinkedList<String>();
    FSOperations.processFilesToRecompile(context,chunk,new FileProcessor(){
      private final Map<ModuleBuildTarget,SourceToOutputMapping> storageMap=new HashMap<ModuleBuildTarget,SourceToOutputMapping>();
      @Override public boolean apply(      ModuleBuildTarget target,      File file,      String sourceRoot) throws IOException {
        SourceToOutputMapping srcToOut=storageMap.get(target);
        if (srcToOut == null) {
          srcToOut=dataManager.getSourceToOutputMap(target);
          storageMap.put(target,srcToOut);
        }
        final String srcPath=FileUtil.toSystemIndependentName(file.getPath());
        final Collection<String> outputs=srcToOut.getState(srcPath);
        if (outputs != null) {
          final JavaBuilderLogger logger=context.getLoggingManager().getJavaBuilderLogger();
          for (          String output : outputs) {
            if (logger.isEnabled()) {
              allOutputs.add(output);
            }
            new File(output).delete();
          }
          if (!outputs.isEmpty()) {
            context.processMessage(new FileDeletedEvent(outputs));
          }
          srcToOut.remove(srcPath);
        }
        return true;
      }
    }
);
    final JavaBuilderLogger logger=context.getLoggingManager().getJavaBuilderLogger();
    if (logger.isEnabled()) {
      if (context.isMake() && allOutputs.size() > 0) {
        logger.log("Cleaning output files:");
        final String[] buffer=new String[allOutputs.size()];
        int i=0;
        for (        String output : allOutputs) {
          buffer[i++]=output;
        }
        Arrays.sort(buffer);
        for (        String output : buffer) {
          logger.log(output);
        }
        logger.log("End of files");
      }
    }
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
