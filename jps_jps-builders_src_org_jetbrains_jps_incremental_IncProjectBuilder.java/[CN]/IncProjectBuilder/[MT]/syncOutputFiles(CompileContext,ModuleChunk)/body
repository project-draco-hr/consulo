{
  final BuildDataManager dataManager=context.getDataManager();
  final boolean compilingTests=context.isCompilingTests();
  try {
    final Collection<String> allOutputs=new LinkedList<String>();
    context.processFilesToRecompile(chunk,new FileProcessor(){
      private final Map<Module,SourceToOutputMapping> storageMap=new HashMap<Module,SourceToOutputMapping>();
      @Override public boolean apply(      Module module,      File file,      String sourceRoot) throws IOException {
        SourceToOutputMapping srcToOut=storageMap.get(module);
        if (srcToOut == null) {
          srcToOut=dataManager.getSourceToOutputMap(module.getName(),compilingTests);
          storageMap.put(module,srcToOut);
        }
        final String srcPath=FileUtil.toSystemIndependentName(file.getPath());
        final Collection<String> outputs=srcToOut.getState(srcPath);
        if (outputs != null) {
          final JavaBuilderLogger logger=context.getLoggingManager().getJavaBuilderLogger();
          for (          String output : outputs) {
            if (logger.isEnabled()) {
              allOutputs.add(output);
            }
            new File(output).delete();
          }
          srcToOut.remove(srcPath);
        }
        return true;
      }
    }
);
    final JavaBuilderLogger logger=context.getLoggingManager().getJavaBuilderLogger();
    if (logger.isEnabled()) {
      if (context.isMake() && allOutputs.size() > 0) {
        logger.log("Cleaning output files:");
        final String[] buffer=new String[allOutputs.size()];
        int i=0;
        for (        String output : allOutputs) {
          buffer[i++]=output;
        }
        Arrays.sort(buffer);
        for (        String output : buffer) {
          logger.log(output);
        }
        logger.log("End of files");
      }
    }
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
