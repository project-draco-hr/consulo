{
  final LowMemoryWatcher memWatcher=LowMemoryWatcher.register(new Runnable(){
    @Override public void run(){
      myProjectDescriptor.dataManager.flush(false);
      myProjectDescriptor.timestamps.getStorage().force();
    }
  }
);
  CompileContextImpl context=null;
  try {
    context=createContext(scope);
    runBuild(context,forceCleanCaches);
    myProjectDescriptor.dataManager.saveVersion();
    reportRebuiltModules(context);
  }
 catch (  ProjectBuildException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof PersistentEnumerator.CorruptedException || cause instanceof MappingFailedException || cause instanceof IOException) {
      myMessageDispatcher.processMessage(new CompilerMessage("",BuildMessage.Kind.INFO,"Internal caches are corrupted or have outdated format, forcing project rebuild: " + e.getMessage()));
      throw new RebuildRequestedException(cause);
    }
 else {
      reportRebuiltModules(context);
      if (cause == null) {
        final String msg=e.getMessage();
        if (!StringUtil.isEmpty(msg)) {
          myMessageDispatcher.processMessage(new ProgressMessage(msg));
        }
      }
 else {
        myMessageDispatcher.processMessage(new CompilerMessage("",cause));
      }
    }
  }
 finally {
    memWatcher.stop();
    flushContext(context);
synchronized (myAsyncTasks) {
      for (      Future task : myAsyncTasks) {
        try {
          task.get();
        }
 catch (        Throwable th) {
          LOG.info(th);
        }
      }
    }
  }
}
