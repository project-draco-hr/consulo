{
  final Collection<Module> allProjectModules=scope.getProject().getModules().values();
  final Collection<Module> modulesToClean=new HashSet<Module>();
  if (context.isMake()) {
    for (    Module module : scope.getAffectedModules()) {
      if (context.isDirty(module)) {
        modulesToClean.add(module);
      }
    }
  }
 else {
    modulesToClean.addAll(scope.getAffectedModules());
    final Set<Module> allModules=new HashSet<Module>(allProjectModules);
    allModules.removeAll(scope.getAffectedModules());
    if (allModules.isEmpty()) {
      context.getBuildDataManager().clean();
    }
  }
  if (!modulesToClean.isEmpty()) {
    final Set<File> toDelete=new HashSet<File>();
    final Set<File> allSourceRoots=new HashSet<File>();
    for (    Module module : modulesToClean) {
      toDelete.add(new File(module.getOutputPath()));
      toDelete.add(new File(module.getTestOutputPath()));
    }
    for (    Module module : allProjectModules) {
      for (      Object root : module.getSourceRoots()) {
        allSourceRoots.add(new File((String)root));
      }
      for (      Object root : module.getTestRoots()) {
        allSourceRoots.add(new File((String)root));
      }
    }
    for (    File outputRoot : toDelete) {
      boolean okToDelete=true;
      if (PathUtil.isUnder(allSourceRoots,outputRoot)) {
        okToDelete=false;
      }
 else {
        final Set<File> _outRoot=Collections.singleton(outputRoot);
        for (        File srcRoot : allSourceRoots) {
          if (PathUtil.isUnder(_outRoot,srcRoot)) {
            okToDelete=false;
            break;
          }
        }
      }
      if (okToDelete) {
        FileUtil.delete(outputRoot);
      }
 else {
        context.processMessage(new CompilerMessage("JPS BUILD",BuildMessage.Kind.WARNING,"Output path " + outputRoot.getPath() + " intersects with a source root. The output cannot be cleaned."));
      }
    }
  }
}
