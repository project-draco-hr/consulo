{
  try {
    final Set<String> allChunkRemovedSources=new HashSet<String>();
    for (    Module module : chunk.getModules()) {
      final Collection<String> deletedPaths=myProjectDescriptor.fsState.getDeletedPaths(module,context.isCompilingTests());
      if (deletedPaths.isEmpty()) {
        continue;
      }
      allChunkRemovedSources.addAll(deletedPaths);
      final String moduleName=module.getName().toLowerCase(Locale.US);
      final SourceToOutputMapping sourceToOutputStorage=context.getDataManager().getSourceToOutputMap(moduleName,context.isCompilingTests());
      for (      String deletedSource : deletedPaths) {
        final Collection<String> outputs=sourceToOutputStorage.getState(deletedSource);
        if (outputs != null) {
          final JavaBuilderLogger logger=context.getLoggingManager().getJavaBuilderLogger();
          if (logger.isEnabled()) {
            if (outputs.size() > 0) {
              final String[] buffer=new String[outputs.size()];
              int i=0;
              for (              final String o : outputs) {
                buffer[i++]=o;
              }
              Arrays.sort(buffer);
              logger.log("Cleaning output files:");
              for (              final String o : buffer) {
                logger.log(o);
              }
              logger.log("End of files");
            }
          }
          for (          String output : outputs) {
            FileUtil.delete(new File(output));
          }
          sourceToOutputStorage.remove(deletedSource);
        }
        final SourceToFormMapping sourceToFormMap=context.getDataManager().getSourceToFormMap();
        final String formPath=sourceToFormMap.getState(deletedSource);
        if (formPath != null) {
          final File formFile=new File(formPath);
          if (formFile.exists()) {
            context.markDirty(formFile);
          }
          sourceToFormMap.remove(deletedSource);
        }
      }
    }
    if (!allChunkRemovedSources.isEmpty()) {
      final Set<String> currentData=Paths.CHUNK_REMOVED_SOURCES_KEY.get(context);
      if (currentData != null) {
        allChunkRemovedSources.addAll(currentData);
      }
      Paths.CHUNK_REMOVED_SOURCES_KEY.set(context,allChunkRemovedSources);
      for (      Module module : chunk.getModules()) {
        myProjectDescriptor.fsState.clearDeletedPaths(module,context.isCompilingTests());
      }
    }
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
}
