{
  final MultiMap<File,BuildTarget<?>> rootsToDelete=new MultiMapBasedOnSet<File,BuildTarget<?>>();
  final Set<File> allSourceRoots=new HashSet<File>();
  ProjectDescriptor projectDescriptor=context.getProjectDescriptor();
  List<? extends BuildTarget<?>> allTargets=projectDescriptor.getBuildTargetIndex().getAllTargets();
  for (  BuildTarget<?> target : allTargets) {
    if (context.getScope().isAffected(target)) {
      final Collection<File> outputs=target.getOutputRoots(context);
      for (      File file : outputs) {
        rootsToDelete.putValue(file,target);
      }
    }
  }
  ModuleExcludeIndex moduleIndex=projectDescriptor.getModuleExcludeIndex();
  for (  BuildTarget<?> target : allTargets) {
    for (    BuildRootDescriptor descriptor : projectDescriptor.getBuildRootIndex().getTargetRoots(target,context)) {
      if (!descriptor.isGenerated()) {
        File rootFile=descriptor.getRootFile();
        if (moduleIndex.isInContent(rootFile) && !moduleIndex.isExcluded(rootFile)) {
          allSourceRoots.add(rootFile);
        }
      }
    }
  }
  final List<File> filesToDelete=new ArrayList<File>();
  for (  Map.Entry<File,Collection<BuildTarget<?>>> entry : rootsToDelete.entrySet()) {
    context.checkCanceled();
    boolean okToDelete=true;
    final File outputRoot=entry.getKey();
    if (JpsPathUtil.isUnder(allSourceRoots,outputRoot)) {
      okToDelete=false;
    }
 else {
      final Set<File> _outRoot=Collections.singleton(outputRoot);
      for (      File srcRoot : allSourceRoots) {
        if (JpsPathUtil.isUnder(_outRoot,srcRoot)) {
          okToDelete=false;
          break;
        }
      }
    }
    if (okToDelete) {
      final File[] children=outputRoot.listFiles();
      if (children != null) {
        filesToDelete.addAll(Arrays.asList(children));
      }
 else       if (outputRoot.isFile()) {
        filesToDelete.add(outputRoot);
      }
      registerTargetsWithClearedOutput(context,entry.getValue());
    }
 else {
      context.processMessage(new CompilerMessage("",BuildMessage.Kind.WARNING,"Output path " + outputRoot.getPath() + " intersects with a source root. Only files that were created by build will be cleaned."));
      for (      BuildTarget<?> target : entry.getValue()) {
        clearOutputFiles(context,target);
      }
    }
  }
  context.processMessage(new ProgressMessage("Cleaning output directories..."));
  myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete));
}
