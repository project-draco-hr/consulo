{
  final Collection<JpsModule> modulesToClean=context.getProjectDescriptor().jpsProject.getModules();
  final Map<File,Set<Pair<String,Boolean>>> rootsToDelete=new HashMap<File,Set<Pair<String,Boolean>>>();
  final Set<File> annotationOutputs=new HashSet<File>();
  final Set<File> allSourceRoots=new HashSet<File>();
  final ProjectPaths paths=context.getProjectPaths();
  for (  JpsModule module : modulesToClean) {
    final File out=paths.getModuleOutputDir(module,false);
    if (out != null) {
      appendRootInfo(rootsToDelete,out,module,false);
    }
    final File testOut=paths.getModuleOutputDir(module,true);
    if (testOut != null) {
      appendRootInfo(rootsToDelete,testOut,module,true);
    }
    final AnnotationProcessingProfile profile=context.getAnnotationProcessingProfile(module);
    if (profile.isEnabled()) {
      File annotationOut=paths.getAnnotationProcessorGeneratedSourcesOutputDir(module,false,profile.getGeneratedSourcesDirName());
      if (annotationOut != null) {
        annotationOutputs.add(annotationOut);
      }
      annotationOut=paths.getAnnotationProcessorGeneratedSourcesOutputDir(module,true,profile.getGeneratedSourcesDirName());
      if (annotationOut != null) {
        annotationOutputs.add(annotationOut);
      }
    }
    final List<RootDescriptor> moduleRoots=context.getProjectDescriptor().rootsIndex.getModuleRoots(context,module);
    for (    RootDescriptor d : moduleRoots) {
      allSourceRoots.add(d.root);
    }
  }
  final List<File> filesToDelete=new ArrayList<File>();
  for (  Map.Entry<File,Set<Pair<String,Boolean>>> entry : rootsToDelete.entrySet()) {
    context.checkCanceled();
    boolean okToDelete=true;
    final File outputRoot=entry.getKey();
    if (JpsPathUtil.isUnder(allSourceRoots,outputRoot)) {
      okToDelete=false;
    }
 else {
      final Set<File> _outRoot=Collections.singleton(outputRoot);
      for (      File srcRoot : allSourceRoots) {
        if (JpsPathUtil.isUnder(_outRoot,srcRoot)) {
          okToDelete=false;
          break;
        }
      }
    }
    if (okToDelete) {
      filesToDelete.add(outputRoot);
    }
 else {
      context.processMessage(new CompilerMessage(BUILD_NAME,BuildMessage.Kind.WARNING,"Output path " + outputRoot.getPath() + " intersects with a source root. The output cannot be cleaned."));
      for (      Pair<String,Boolean> info : entry.getValue()) {
        clearOutputFiles(context,info.first,info.second);
      }
    }
  }
  for (  File annotationOutput : annotationOutputs) {
    filesToDelete.add(annotationOutput);
  }
  context.processMessage(new ProgressMessage("Cleaning output directories..."));
  myAsyncTasks.add(FileUtil.asyncDelete(filesToDelete));
}
