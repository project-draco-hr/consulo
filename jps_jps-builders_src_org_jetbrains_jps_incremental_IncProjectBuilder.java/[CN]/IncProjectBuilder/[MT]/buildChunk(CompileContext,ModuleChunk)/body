{
  boolean doneSomething=false;
  try {
    context.ensureFSStateInitialized(chunk);
    if (context.isMake()) {
      processDeletedPaths(context,chunk);
      doneSomething|=context.hasRemovedSources();
    }
    context.onChunkBuildStart(chunk);
    doneSomething=runModuleLevelBuilders(context,chunk);
  }
 catch (  ProjectBuildException e) {
    throw e;
  }
catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
 finally {
    try {
      for (      BuilderCategory category : BuilderCategory.values()) {
        for (        ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
          builder.cleanupResources(context,chunk);
        }
      }
    }
  finally {
      try {
        context.onChunkBuildComplete(chunk);
      }
 catch (      Exception e) {
        throw new ProjectBuildException(e);
      }
 finally {
        final Collection<RootDescriptor> tempRoots=context.getRootsIndex().clearTempRoots();
        if (!tempRoots.isEmpty()) {
          final Set<File> rootFiles=new HashSet<File>();
          for (          RootDescriptor rd : tempRoots) {
            rootFiles.add(rd.root);
            context.getProjectDescriptor().fsState.clearRecompile(rd);
          }
          myAsyncTasks.add(FileUtil.asyncDelete(rootFiles));
        }
        try {
          final Map<String,Collection<String>> map=Utils.REMOVED_SOURCES_KEY.get(context);
          if (map != null) {
            final boolean forTests=context.isCompilingTests();
            for (            Map.Entry<String,Collection<String>> entry : map.entrySet()) {
              final String moduleName=entry.getKey();
              final Collection<String> paths=entry.getValue();
              if (paths != null) {
                for (                String path : paths) {
                  myProjectDescriptor.fsState.registerDeleted(moduleName,new File(path),forTests,null);
                }
              }
            }
          }
        }
 catch (        IOException e) {
          throw new ProjectBuildException(e);
        }
        Utils.REMOVED_SOURCES_KEY.set(context,null);
        if (doneSomething && GENERATE_CLASSPATH_INDEX) {
          final boolean forTests=context.isCompilingTests();
          final Future<?> future=SharedThreadPool.INSTANCE.submit(new Runnable(){
            @Override public void run(){
              createClasspathIndex(chunk,forTests);
            }
          }
);
          myAsyncTasks.add(future);
        }
      }
    }
  }
}
