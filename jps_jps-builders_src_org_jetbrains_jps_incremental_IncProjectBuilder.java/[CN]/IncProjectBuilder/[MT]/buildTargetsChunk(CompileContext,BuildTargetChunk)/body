{
  boolean doneSomething=false;
  try {
    Utils.ERRORS_DETECTED_KEY.set(context,Boolean.FALSE);
    ensureFSStateInitialized(context,chunk);
    if (context.isMake()) {
      processDeletedPaths(context,chunk.getTargets());
      doneSomething|=Utils.hasRemovedSources(context);
    }
    myProjectDescriptor.fsState.beforeChunkBuildStart(context,chunk);
    doneSomething=runBuildersForChunk(context,chunk);
  }
 catch (  ProjectBuildException e) {
    throw e;
  }
catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
 finally {
    try {
      onChunkBuildComplete(context,chunk);
    }
 catch (    Exception e) {
      throw new ProjectBuildException(e);
    }
 finally {
      for (      BuildRootDescriptor rd : context.getProjectDescriptor().getBuildRootIndex().clearTempRoots(context)) {
        context.getProjectDescriptor().fsState.clearRecompile(rd);
      }
      try {
        final Map<BuildTarget<?>,Collection<String>> map=Utils.REMOVED_SOURCES_KEY.get(context);
        if (map != null) {
          for (          Map.Entry<BuildTarget<?>,Collection<String>> entry : map.entrySet()) {
            final BuildTarget<?> target=entry.getKey();
            final Collection<String> paths=entry.getValue();
            if (paths != null) {
              for (              String path : paths) {
                myProjectDescriptor.fsState.registerDeleted(target,new File(path),null);
              }
            }
          }
        }
      }
 catch (      IOException e) {
        throw new ProjectBuildException(e);
      }
      Utils.REMOVED_SOURCES_KEY.set(context,null);
      if (doneSomething && GENERATE_CLASSPATH_INDEX) {
        final Future<?> future=SharedThreadPool.getInstance().executeOnPooledThread(new Runnable(){
          @Override public void run(){
            createClasspathIndex(chunk);
          }
        }
);
        myAsyncTasks.add(future);
      }
    }
  }
}
