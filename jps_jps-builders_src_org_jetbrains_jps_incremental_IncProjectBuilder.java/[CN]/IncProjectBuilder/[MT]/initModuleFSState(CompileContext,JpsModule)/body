{
  boolean forceMarkDirty=false;
  final File currentOutput=context.getProjectPaths().getModuleOutputDir(module,context.isCompilingTests());
  final ProjectDescriptor pd=context.getProjectDescriptor();
  if (currentOutput != null) {
    Pair<String,String> outputsPair=pd.dataManager.getOutputRootsLayout().getState(module.getName());
    if (outputsPair != null) {
      final String previousPath=context.isCompilingTests() ? outputsPair.second : outputsPair.first;
      forceMarkDirty=StringUtil.isEmpty(previousPath) || !FileUtil.filesEqual(currentOutput,new File(previousPath));
    }
 else {
      forceMarkDirty=true;
    }
  }
  final Timestamps timestamps=pd.timestamps.getStorage();
  final HashSet<File> currentFiles=new HashSet<File>();
  FSOperations.markDirtyFiles(context,module,timestamps,forceMarkDirty,context.isCompilingTests() ? FSOperations.DirtyMarkScope.TESTS : FSOperations.DirtyMarkScope.PRODUCTION,currentFiles);
  final BuildFSState fsState=pd.fsState;
  fsState.clearDeletedPaths(module.getName(),context.isCompilingTests());
  final SourceToOutputMapping sourceToOutputMap=pd.dataManager.getSourceToOutputMap(module.getName(),context.isCompilingTests());
  for (final Iterator<String> it=sourceToOutputMap.getKeysIterator(); it.hasNext(); ) {
    final String path=it.next();
    final File file=new File(path);
    if (!currentFiles.contains(file)) {
      fsState.registerDeleted(module.getName(),file,context.isCompilingTests(),timestamps);
    }
  }
}
