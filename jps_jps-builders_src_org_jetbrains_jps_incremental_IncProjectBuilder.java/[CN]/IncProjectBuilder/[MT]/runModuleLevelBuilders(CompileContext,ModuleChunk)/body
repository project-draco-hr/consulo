{
  boolean doneSomething=false;
  boolean rebuildFromScratchRequested=false;
  float stageCount=myTotalModuleLevelBuilderCount;
  final int modulesInChunk=chunk.getModules().size();
  int buildersPassed=0;
  boolean nextPassRequired;
  ChunkBuildOutputConsumerImpl outputConsumer=new ChunkBuildOutputConsumerImpl(context);
  try {
    do {
      nextPassRequired=false;
      myProjectDescriptor.fsState.beforeNextRoundStart(context,chunk);
      DirtyFilesHolder<JavaSourceRootDescriptor,ModuleBuildTarget> dirtyFilesHolder=new DirtyFilesHolderBase<JavaSourceRootDescriptor,ModuleBuildTarget>(context){
        @Override public void processDirtyFiles(        @NotNull FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget> processor) throws IOException {
          FSOperations.processFilesToRecompile(context,chunk,processor);
        }
      }
;
      if (!context.isProjectRebuild()) {
        final Map<ModuleBuildTarget,Set<File>> cleanedSources=BuildOperations.cleanOutputsCorrespondingToChangedFiles(context,dirtyFilesHolder);
        for (        Map.Entry<ModuleBuildTarget,Set<File>> entry : cleanedSources.entrySet()) {
          final ModuleBuildTarget target=entry.getKey();
          final Set<File> files=entry.getValue();
          if (!files.isEmpty()) {
            final SourceToOutputMapping mapping=context.getProjectDescriptor().dataManager.getSourceToOutputMap(target);
            for (            File srcFile : files) {
              mapping.setOutputs(srcFile.getPath(),Collections.<String>emptyList());
            }
          }
        }
      }
      BUILDER_CATEGORY_LOOP:       for (      BuilderCategory category : BuilderCategory.values()) {
        final List<ModuleLevelBuilder> builders=myBuilderRegistry.getBuilders(category);
        if (builders.isEmpty()) {
          continue;
        }
        for (        ModuleLevelBuilder builder : builders) {
          if (context.isMake()) {
            processDeletedPaths(context,chunk.getTargets());
          }
          final ModuleLevelBuilder.ExitCode buildResult=builder.build(context,chunk,dirtyFilesHolder,outputConsumer);
          doneSomething|=(buildResult != ModuleLevelBuilder.ExitCode.NOTHING_DONE);
          if (buildResult == ModuleLevelBuilder.ExitCode.ABORT) {
            throw new ProjectBuildException("Builder " + builder.getPresentableName() + " requested build stop");
          }
          context.checkCanceled();
          if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) {
            if (!nextPassRequired) {
              myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
              stageCount+=myTotalModuleLevelBuilderCount;
              myTargetsProcessed+=(buildersPassed * modulesInChunk) / stageCount;
            }
            nextPassRequired=true;
          }
 else           if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) {
            if (!rebuildFromScratchRequested && !context.isProjectRebuild()) {
              LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk "+ chunk.getName());
              rebuildFromScratchRequested=true;
              try {
                FSOperations.markDirty(context,chunk);
                myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
                stageCount=myTotalModuleLevelBuilderCount;
                buildersPassed=0;
                nextPassRequired=true;
                break BUILDER_CATEGORY_LOOP;
              }
 catch (              Exception e) {
                throw new ProjectBuildException(e);
              }
            }
 else {
              LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild");
            }
          }
          buildersPassed++;
          updateDoneFraction(context,modulesInChunk / (stageCount));
        }
      }
    }
 while (nextPassRequired);
  }
  finally {
    outputConsumer.fireFileGeneratedEvents();
    for (    BuilderCategory category : BuilderCategory.values()) {
      for (      ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
        builder.cleanupChunkResources(context);
      }
    }
  }
  return doneSomething;
}
