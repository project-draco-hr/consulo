{
  for (  BuilderCategory category : BuilderCategory.values()) {
    for (    ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
      builder.chunkBuildStarted(context,chunk);
    }
  }
  boolean doneSomething=false;
  boolean rebuildFromScratchRequested=false;
  float stageCount=myTotalModuleLevelBuilderCount;
  final int modulesInChunk=chunk.getModules().size();
  int buildersPassed=0;
  boolean nextPassRequired;
  ChunkBuildOutputConsumerImpl outputConsumer=new ChunkBuildOutputConsumerImpl(context);
  try {
    do {
      nextPassRequired=false;
      myProjectDescriptor.fsState.beforeNextRoundStart(context,chunk);
      DirtyFilesHolder<JavaSourceRootDescriptor,ModuleBuildTarget> dirtyFilesHolder=new DirtyFilesHolderBase<JavaSourceRootDescriptor,ModuleBuildTarget>(context){
        @Override public void processDirtyFiles(        @NotNull FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget> processor) throws IOException {
          FSOperations.processFilesToRecompile(context,chunk,processor);
        }
      }
;
      if (!context.isProjectRebuild()) {
        final Map<ModuleBuildTarget,Set<File>> cleanedSources=BuildOperations.cleanOutputsCorrespondingToChangedFiles(context,dirtyFilesHolder);
        for (        Map.Entry<ModuleBuildTarget,Set<File>> entry : cleanedSources.entrySet()) {
          final ModuleBuildTarget target=entry.getKey();
          final Set<File> files=entry.getValue();
          if (!files.isEmpty()) {
            final SourceToOutputMapping mapping=context.getProjectDescriptor().dataManager.getSourceToOutputMap(target);
            for (            File srcFile : files) {
              mapping.setOutputs(srcFile.getPath(),Collections.<String>emptyList());
            }
          }
        }
      }
      BUILDER_CATEGORY_LOOP:       for (      BuilderCategory category : BuilderCategory.values()) {
        final List<ModuleLevelBuilder> builders=myBuilderRegistry.getBuilders(category);
        if (builders.isEmpty()) {
          continue;
        }
        for (        ModuleLevelBuilder builder : builders) {
          processDeletedPaths(context,chunk.getTargets());
          final ModuleLevelBuilder.ExitCode buildResult=builder.build(context,chunk,dirtyFilesHolder,outputConsumer);
          doneSomething|=(buildResult != ModuleLevelBuilder.ExitCode.NOTHING_DONE);
          if (buildResult == ModuleLevelBuilder.ExitCode.ABORT) {
            throw new ProjectBuildException("Builder " + builder.getPresentableName() + " requested build stop");
          }
          context.checkCanceled();
          if (buildResult == ModuleLevelBuilder.ExitCode.ADDITIONAL_PASS_REQUIRED) {
            if (!nextPassRequired) {
              myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
              stageCount+=myTotalModuleLevelBuilderCount;
              myTargetsProcessed+=(buildersPassed * modulesInChunk) / stageCount;
            }
            nextPassRequired=true;
          }
 else           if (buildResult == ModuleLevelBuilder.ExitCode.CHUNK_REBUILD_REQUIRED) {
            if (!rebuildFromScratchRequested && !context.isProjectRebuild()) {
              LOG.info("Builder " + builder.getPresentableName() + " requested rebuild of module chunk "+ chunk.getName());
              rebuildFromScratchRequested=true;
              try {
                context.getProjectDescriptor().fsState.clearContextRoundData(context);
                FSOperations.markDirty(context,chunk,null);
                myTargetsProcessed-=(buildersPassed * modulesInChunk) / stageCount;
                stageCount=myTotalModuleLevelBuilderCount;
                buildersPassed=0;
                nextPassRequired=true;
                outputConsumer.clear();
                break BUILDER_CATEGORY_LOOP;
              }
 catch (              Exception e) {
                throw new ProjectBuildException(e);
              }
            }
 else {
              LOG.debug("Builder " + builder.getPresentableName() + " requested second chunk rebuild");
            }
          }
          buildersPassed++;
          updateDoneFraction(context,modulesInChunk / (stageCount));
        }
      }
    }
 while (nextPassRequired);
  }
  finally {
    for (    CompiledClass compiledClass : outputConsumer.getCompiledClasses().values()) {
      if (compiledClass.isDirty()) {
        compiledClass.save();
      }
    }
    outputConsumer.fireFileGeneratedEvents();
    outputConsumer.clear();
    for (    BuilderCategory category : BuilderCategory.values()) {
      for (      ModuleLevelBuilder builder : myBuilderRegistry.getBuilders(category)) {
        builder.chunkBuildFinished(context,chunk);
      }
    }
  }
  return doneSomething;
}
