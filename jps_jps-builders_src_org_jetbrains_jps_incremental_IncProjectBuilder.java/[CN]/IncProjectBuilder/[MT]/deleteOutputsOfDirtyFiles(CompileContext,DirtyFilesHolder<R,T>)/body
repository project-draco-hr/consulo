{
  if (context.isProjectRebuild()) {
    return;
  }
  final BuildDataManager dataManager=context.getProjectDescriptor().dataManager;
  try {
    ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
    final Collection<String> outputsToLog=logger.isEnabled() ? new LinkedList<String>() : null;
    final THashSet<File> dirsToDelete=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<R,T>(){
      private final Map<T,SourceToOutputMapping> storageMap=new HashMap<T,SourceToOutputMapping>();
      @Override public boolean apply(      T target,      File file,      R sourceRoot) throws IOException {
        SourceToOutputMapping srcToOut=storageMap.get(target);
        if (srcToOut == null) {
          srcToOut=dataManager.getSourceToOutputMap(target);
          storageMap.put(target,srcToOut);
        }
        final String srcPath=file.getPath();
        final Collection<String> outputs=srcToOut.getOutputs(srcPath);
        if (outputs != null) {
          for (          String output : outputs) {
            if (outputsToLog != null) {
              outputsToLog.add(output);
            }
            final File outFile=new File(output);
            outFile.delete();
            final File parent=outFile.getParentFile();
            if (parent != null) {
              dirsToDelete.add(parent);
            }
          }
          if (!outputs.isEmpty()) {
            context.processMessage(new FileDeletedEvent(outputs));
          }
          srcToOut.setOutputs(srcPath,Collections.<String>emptyList());
        }
        return true;
      }
    }
);
    if (outputsToLog != null && context.isMake()) {
      logger.logDeletedFiles(outputsToLog);
    }
    pruneEmptyDirs(dirsToDelete);
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
