{
  final CompileScope scope=context.getScope();
  final ProjectDescriptor pd=context.getProjectDescriptor();
  BuildTargetIndex targetIndex=pd.getBuildTargetIndex();
  try {
    if (BuildRunner.PARALLEL_BUILD_ENABLED) {
      final List<ChunkGroup> chunkGroups=buildChunkGroups(targetIndex);
      for (      ChunkGroup group : chunkGroups) {
        final List<BuildTargetChunk> groupChunks=group.getChunks();
        final int chunkCount=groupChunks.size();
        if (chunkCount == 0) {
          continue;
        }
        try {
          if (chunkCount == 1) {
            buildChunkIfAffected(createContextWrapper(context),scope,groupChunks.iterator().next());
          }
 else {
            final CountDownLatch latch=new CountDownLatch(chunkCount);
            final Ref<Throwable> exRef=new Ref<Throwable>(null);
            if (LOG.isDebugEnabled()) {
              final StringBuilder logBuilder=new StringBuilder("Building chunks in parallel: ");
              for (              BuildTargetChunk chunk : groupChunks) {
                logBuilder.append(chunk.toString()).append("; ");
              }
              LOG.debug(logBuilder.toString());
            }
            for (            final BuildTargetChunk chunk : groupChunks) {
              final CompileContext chunkLocalContext=createContextWrapper(context);
              myParallelBuildExecutor.execute(new Runnable(){
                @Override public void run(){
                  try {
                    buildChunkIfAffected(chunkLocalContext,scope,chunk);
                  }
 catch (                  Throwable e) {
synchronized (exRef) {
                      if (exRef.isNull()) {
                        exRef.set(e);
                      }
                    }
                    LOG.info(e);
                  }
 finally {
                    latch.countDown();
                  }
                }
              }
);
            }
            try {
              latch.await();
            }
 catch (            InterruptedException e) {
              LOG.info(e);
            }
            final Throwable exception=exRef.get();
            if (exception != null) {
              if (exception instanceof ProjectBuildException) {
                throw (ProjectBuildException)exception;
              }
 else {
                throw new ProjectBuildException(exception);
              }
            }
          }
        }
  finally {
          pd.dataManager.closeSourceToOutputStorages(groupChunks);
          pd.dataManager.flush(true);
        }
      }
    }
 else {
      for (      BuildTargetChunk chunk : targetIndex.getSortedTargetChunks()) {
        try {
          buildChunkIfAffected(context,scope,chunk);
        }
  finally {
          pd.dataManager.closeSourceToOutputStorages(Collections.singleton(chunk));
          pd.dataManager.flush(true);
        }
      }
    }
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
}
