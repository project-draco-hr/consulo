{
  checkNameStorage();
  final Map<StubIndexKey,Map<Object,StubIdList>> newStubTree;
  try {
    newStubTree=getStubTree(newData);
  }
 catch (  SerializerNotFoundException e) {
    throw new StorageException(e);
  }
  final StubIndexImpl stubIndex=getStubIndex();
  final Collection<StubIndexKey> allStubIndices=stubIndex.getAllStubIndexKeys();
  try {
    for (    StubIndexKey key : allStubIndices) {
      stubIndex.getWriteLock(key).lock();
    }
    try {
      getWriteLock().lock();
      IndexingStamp.State state=IndexingStamp.State.FILE_CONTENT_CHANGED;
      if (content != null) {
        VirtualFile file=content.getFile();
        ID stubId=IndexInfrastructure.getStubId(INDEX_ID,file.getFileType());
        state=IndexingStamp.getIndexingState(file,stubId);
      }
      final Map<Integer,SerializedStubTree> oldData;
      if (state == IndexingStamp.State.INDEX_VERSION_CHANGED) {
        oldData=Collections.emptyMap();
      }
 else {
        oldData=readOldData(inputId);
      }
      final Map<StubIndexKey,Map<Object,StubIdList>> oldStubTree;
      try {
        oldStubTree=getStubTree(oldData);
      }
 catch (      SerializerNotFoundException e) {
        throw new StorageException(e);
      }
      super.updateWithMap(inputId,newData,oldKeysGetter,content);
      updateStubIndices(getAffectedIndices(oldStubTree,newStubTree),inputId,oldStubTree,newStubTree);
    }
  finally {
      getWriteLock().unlock();
    }
  }
  finally {
    for (    StubIndexKey key : allStubIndices) {
      stubIndex.getWriteLock(key).unlock();
    }
  }
}
