{
  HashSet<Instruction>[] constConditions=runner.getConstConditionalExpressions();
  HashSet<Instruction> trueSet=constConditions[0];
  HashSet<Instruction> falseSet=constConditions[1];
  Set<Instruction> npeSet=runner.getNPEInstructions();
  Set<Instruction> cceSet=runner.getCCEInstructions();
  Set<Instruction> redundantInstanceofs=runner.getRedundantInstanceofs();
  ArrayList<Instruction> allProblems=new ArrayList<Instruction>();
  for (  Instruction instr : trueSet) {
    allProblems.add((Instruction)instr);
  }
  for (  Instruction instr : falseSet) {
    allProblems.add(instr);
  }
  for (  Instruction methodCallInstruction : npeSet) {
    allProblems.add(methodCallInstruction);
  }
  for (  Instruction typeCastInstruction : cceSet) {
    allProblems.add(typeCastInstruction);
  }
  for (  Instruction instruction : redundantInstanceofs) {
    allProblems.add(instruction);
  }
  Collections.sort(allProblems,new Comparator(){
    public int compare(    Object o1,    Object o2){
      int i1=((Instruction)o1).getIndex();
      int i2=((Instruction)o2).getIndex();
      if (i1 == i2)       return 0;
      if (i1 > i2)       return 1;
      return -1;
    }
  }
);
  ArrayList<ProblemDescriptor> descriptions=new ArrayList<ProblemDescriptor>(allProblems.size());
  HashSet<PsiElement> reportedAnchors=new HashSet<PsiElement>();
  for (int i=0; i < allProblems.size(); i++) {
    Instruction instruction=allProblems.get(i);
    if (instruction instanceof MethodCallInstruction) {
      MethodCallInstruction mcInstruction=(MethodCallInstruction)instruction;
      if (mcInstruction.getCallExpression() instanceof PsiMethodCallExpression) {
        PsiMethodCallExpression callExpression=(PsiMethodCallExpression)mcInstruction.getCallExpression();
        LocalQuickFix fix=createAssertNotNullFix(callExpression.getMethodExpression().getQualifierExpression());
        descriptions.add(manager.createProblemDescriptor(mcInstruction.getCallExpression(),"Method invocation <code>#ref</code> #loc may produce <code>java.lang.NullPointerException</code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
      }
    }
 else     if (instruction instanceof FieldReferenceInstruction) {
      FieldReferenceInstruction frInstruction=(FieldReferenceInstruction)instruction;
      PsiExpression expression=frInstruction.getExpression();
      if (expression instanceof PsiArrayAccessExpression) {
        LocalQuickFix fix=createAssertNotNullFix(((PsiArrayAccessExpression)expression).getArrayExpression());
        descriptions.add(manager.createProblemDescriptor(expression,"Array access <code>#ref</code> #loc may produce <code>java.lang.NullPointerException</code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
      }
 else {
        LocalQuickFix fix=createAssertNotNullFix(((PsiReferenceExpression)expression).getQualifierExpression());
        descriptions.add(manager.createProblemDescriptor(expression,"Member variable access <code>#ref</code> #loc may produce <code>java.lang.NullPointerException</code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
      }
    }
 else     if (instruction instanceof TypeCastInstruction) {
      TypeCastInstruction tcInstruction=(TypeCastInstruction)instruction;
      PsiTypeCastExpression typeCast=tcInstruction.getCastExpression();
      descriptions.add(manager.createProblemDescriptor(typeCast.getCastType(),"Casting <code>" + typeCast.getOperand().getText() + "</code> to <code>#ref</code> #loc may produce <code>java.lang.ClassCastException</code>.",(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
 else     if (instruction instanceof BranchingInstruction) {
      PsiElement psiAnchor=((BranchingInstruction)instruction).getPsiAnchor();
      if (instruction instanceof BinopInstruction && ((BinopInstruction)instruction).isInstanceofRedundant()) {
        if (((BinopInstruction)instruction).canBeNull()) {
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is redundant and can be replaced with <code>!= null</code>",new RedundantInstanceofFix(),ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
 else {
          final LocalQuickFix localQuickFix=createSimplifyBooleanExpressionFix(psiAnchor,true);
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is always true</code>",localQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
      }
 else       if (psiAnchor instanceof PsiSwitchLabelStatement) {
        if (falseSet.contains(instruction)) {
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Switch label<code>#ref</code> #loc is unreachable.",(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
      }
 else       if (psiAnchor != null) {
        if (!reportedAnchors.contains(psiAnchor)) {
          if (onTheLeftSideOfConditionalAssignemnt(psiAnchor)) {
            descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc at the left side of assignment expression is always <code>" + (trueSet.contains(instruction) ? "true" : "false") + "</code>. Can be simplified to normal assignment.",(LocalQuickFix)null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
          }
 else {
            final LocalQuickFix localQuickFix=createSimplifyBooleanExpressionFix(psiAnchor,trueSet.contains(instruction));
            descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is always <code>" + (trueSet.contains(instruction) ? "true" : "false") + "</code>.",localQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
          }
          reportedAnchors.add(psiAnchor);
        }
      }
    }
  }
  Set<PsiExpression> exprs=runner.getNullableArguments();
  for (  PsiExpression expr : exprs) {
    final String text=isNullLiteralExpression(expr) ? "Passing <code>null</code> argument to parameter annotated as @NotNull" : "Argument <code>#ref</code> #loc might be null";
    descriptions.add(manager.createProblemDescriptor(expr,text,(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
  }
  exprs=runner.getNullableAssignments();
  for (  PsiExpression expr : exprs) {
    final String exprText=isNullLiteralExpression(expr) ? "<code>null</code>" : "Expression <code>#ref</code> might evaluate to null but";
    descriptions.add(manager.createProblemDescriptor(expr,exprText + " is assigned to a variable that is annotated with @NotNull",(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
  }
  final HashSet<PsiReturnStatement> statements=runner.getNullableReturns();
  for (  PsiReturnStatement statement : statements) {
    final PsiExpression expr=statement.getReturnValue();
    final String exprText=isNullLiteralExpression(expr) ? "<code>null</code>" : "Expression <code>#ref</code> might evaluate to null but";
    if (runner.isInNotNullMethod()) {
      descriptions.add(manager.createProblemDescriptor(expr,exprText + " is returned by the method declared as @NotNull",(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
 else     if (AnnotationUtil.isAnnotatingApplicable(statement)) {
      descriptions.add(manager.createProblemDescriptor(expr,exprText + " is returned by the method which isn't declared as @Nullable",new AnnotateMethodFix(AnnotationUtil.NULLABLE),ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
  }
  return descriptions.toArray(new ProblemDescriptor[descriptions.size()]);
}
