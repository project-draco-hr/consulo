{
  HashSet[] constConditions=runner.getConstConditionalExpressions();
  HashSet trueSet=constConditions[0];
  HashSet falseSet=constConditions[1];
  Set npeSet=runner.getNPEInstructions();
  Set cceSet=runner.getCCEInstructions();
  Set redundantInstanceofs=runner.getRedundantInstanceofs();
  ArrayList<Instruction> allProblems=new ArrayList<Instruction>();
  for (Iterator iterator=trueSet.iterator(); iterator.hasNext(); ) {
    Instruction branchingInstruction=(Instruction)iterator.next();
    allProblems.add(branchingInstruction);
  }
  for (Iterator iterator=falseSet.iterator(); iterator.hasNext(); ) {
    Instruction branchingInstruction=(Instruction)iterator.next();
    allProblems.add(branchingInstruction);
  }
  for (Iterator iterator=npeSet.iterator(); iterator.hasNext(); ) {
    Instruction methodCallInstruction=(Instruction)iterator.next();
    allProblems.add(methodCallInstruction);
  }
  for (Iterator iterator=cceSet.iterator(); iterator.hasNext(); ) {
    Instruction typeCastInstruction=(Instruction)iterator.next();
    allProblems.add(typeCastInstruction);
  }
  for (Iterator iterator=redundantInstanceofs.iterator(); iterator.hasNext(); ) {
    Instruction instruction=(Instruction)iterator.next();
    allProblems.add(instruction);
  }
  Collections.sort(allProblems,new Comparator(){
    public int compare(    Object o1,    Object o2){
      int i1=((Instruction)o1).getIndex();
      int i2=((Instruction)o2).getIndex();
      if (i1 == i2)       return 0;
      if (i1 > i2)       return 1;
      return -1;
    }
  }
);
  ArrayList<ProblemDescriptor> descriptions=new ArrayList<ProblemDescriptor>(allProblems.size());
  HashSet<PsiElement> reportedAnchors=new HashSet<PsiElement>();
  for (int i=0; i < allProblems.size(); i++) {
    Instruction instruction=allProblems.get(i);
    if (instruction instanceof MethodCallInstruction) {
      MethodCallInstruction mcInstruction=(MethodCallInstruction)instruction;
      PsiMethodCallExpression callExpression=mcInstruction.getCallExpression();
      LocalQuickFix fix=createAssertNotNullFix(callExpression.getMethodExpression().getQualifierExpression());
      descriptions.add(manager.createProblemDescriptor(mcInstruction.getCallExpression(),"Method invocation <code>#ref</code> #loc may produce <code>java.lang.NullPointerException</code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
 else     if (instruction instanceof FieldReferenceInstruction) {
      FieldReferenceInstruction frInstruction=(FieldReferenceInstruction)instruction;
      PsiExpression expression=frInstruction.getExpression();
      if (expression instanceof PsiArrayAccessExpression) {
        LocalQuickFix fix=createAssertNotNullFix(((PsiArrayAccessExpression)expression).getArrayExpression());
        descriptions.add(manager.createProblemDescriptor(expression,"Array access <code>#ref</code> #loc may produce <code>java.lang.NullPointerException<./code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
      }
 else {
        LocalQuickFix fix=createAssertNotNullFix(((PsiReferenceExpression)expression).getQualifierExpression());
        descriptions.add(manager.createProblemDescriptor(expression,"Member variable access <code>#ref</code> #loc may produce <code>java.lang.NullPointerException<./code>.",fix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
      }
    }
 else     if (instruction instanceof TypeCastInstruction) {
      TypeCastInstruction tcInstruction=(TypeCastInstruction)instruction;
      PsiTypeCastExpression typeCast=tcInstruction.getCastExpression();
      descriptions.add(manager.createProblemDescriptor(typeCast.getCastType(),"Casting <code>" + typeCast.getOperand().getText() + "</code> to <code>#ref</code> #loc may produce <code>java.lang.ClassCastException</code>.",null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
 else     if (instruction instanceof BranchingInstruction) {
      PsiElement psiAnchor=((BranchingInstruction)instruction).getPsiAnchor();
      if (instruction instanceof BinopInstruction && ((BinopInstruction)instruction).isInstanceofRedundant()) {
        if (((BinopInstruction)instruction).canBeNull()) {
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is redundant and can be replaced with <code>!= null</code>",new RedundantInstanceofFix(),ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
 else {
          final LocalQuickFix localQuickFix=createSimplifyBooleanExpressionFix(true);
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is always true</code>",localQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
      }
 else       if (psiAnchor instanceof PsiSwitchLabelStatement) {
        if (falseSet.contains(instruction)) {
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Switch label<code>#ref</code> #loc is unreachable.",null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
      }
 else       if (psiAnchor != null) {
        if (!reportedAnchors.contains(psiAnchor)) {
          final LocalQuickFix localQuickFix=createSimplifyBooleanExpressionFix(trueSet.contains(instruction));
          descriptions.add(manager.createProblemDescriptor(psiAnchor,"Condition <code>#ref</code> #loc is always <code>" + (trueSet.contains(instruction) ? "true" : "false") + "</code>.",localQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
          reportedAnchors.add(psiAnchor);
        }
      }
    }
  }
  return descriptions.toArray(new ProblemDescriptor[descriptions.size()]);
}
