{
  final List<Change> textChanges=new ArrayList<Change>();
  final List<ShelvedBinaryFile> binaryFiles=new ArrayList<ShelvedBinaryFile>();
  for (  Change change : changes) {
    if (ChangesUtil.getFilePath(change).isDirectory()) {
      continue;
    }
    if (change.getBeforeRevision() instanceof BinaryContentRevision || change.getAfterRevision() instanceof BinaryContentRevision) {
      binaryFiles.add(shelveBinaryFile(change));
    }
 else {
      textChanges.add(change);
    }
  }
  final ShelvedChangeList changeList;
  try {
    File patchPath=getPatchPath(commitMessage);
    ProgressManager.checkCanceled();
    final List<FilePatch> patches=IdeaTextPatchBuilder.buildPatch(myProject,textChanges,myProject.getBaseDir().getPresentableUrl(),false);
    ProgressManager.checkCanceled();
    CommitContext commitContext=new CommitContext();
    baseRevisionsOfDvcsIntoContext(textChanges,commitContext);
    myFileProcessor.savePathFile(new CompoundShelfFileProcessor.ContentProvider(){
      public void writeContentTo(      final Writer writer,      CommitContext commitContext) throws IOException {
        UnifiedDiffWriter.write(myProject,patches,writer,"\n",commitContext);
      }
    }
,patchPath,commitContext);
    changeList=new ShelvedChangeList(patchPath.toString(),commitMessage.replace('\n',' '),binaryFiles);
    myShelvedChangeLists.add(changeList);
    ProgressManager.checkCanceled();
    if (rollback) {
      final String operationName=UIUtil.removeMnemonic(RollbackChangesDialog.operationNameByChanges(myProject,changes));
      new RollbackWorker(myProject,operationName).doRollback(changes,true,null,VcsBundle.message("shelve.changes.action"));
    }
  }
  finally {
    notifyStateChanged();
  }
  return changeList;
}
