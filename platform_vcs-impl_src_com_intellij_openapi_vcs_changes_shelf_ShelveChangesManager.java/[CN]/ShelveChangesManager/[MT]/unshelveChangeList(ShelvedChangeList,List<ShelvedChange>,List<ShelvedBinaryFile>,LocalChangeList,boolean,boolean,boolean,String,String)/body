{
  final List<FilePatch> remainingPatches=new ArrayList<>();
  final CommitContext commitContext=new CommitContext();
  final List<TextFilePatch> textFilePatches;
  try {
    textFilePatches=loadTextPatches(myProject,changeList,changes,remainingPatches,commitContext);
  }
 catch (  IOException e) {
    LOG.info(e);
    PatchApplier.showError(myProject,"Cannot load patch(es): " + e.getMessage(),true);
    return;
  }
catch (  PatchSyntaxException e) {
    PatchApplier.showError(myProject,"Cannot load patch(es): " + e.getMessage(),true);
    LOG.info(e);
    return;
  }
  final List<FilePatch> patches=new ArrayList<>(textFilePatches);
  final List<ShelvedBinaryFile> remainingBinaries=new ArrayList<>();
  final List<ShelvedBinaryFile> binaryFilesToUnshelve=getBinaryFilesToUnshelve(changeList,binaryFiles,remainingBinaries);
  for (  final ShelvedBinaryFile shelvedBinaryFile : binaryFilesToUnshelve) {
    patches.add(new ShelvedBinaryFilePatch(shelvedBinaryFile));
  }
  ApplicationManager.getApplication().invokeAndWait(new Runnable(){
    @Override public void run(){
      final BinaryPatchApplier binaryPatchApplier=new BinaryPatchApplier();
      final PatchApplier<ShelvedBinaryFilePatch> patchApplier=new PatchApplier<>(myProject,myProject.getBaseDir(),patches,targetChangeList,binaryPatchApplier,commitContext,reverse,leftConflictTitle,rightConflictTitle);
      patchApplier.setIsSystemOperation(systemOperation);
      patchApplier.execute(showSuccessNotification,systemOperation);
      if (isRemoveFilesFromShelf() || systemOperation) {
        remainingPatches.addAll(patchApplier.getRemainingPatches());
        if (remainingPatches.isEmpty() && remainingBinaries.isEmpty()) {
          recycleChangeList(changeList);
        }
 else {
          saveRemainingPatches(changeList,remainingPatches,remainingBinaries,commitContext);
        }
      }
    }
  }
,ModalityState.defaultModalityState());
}
