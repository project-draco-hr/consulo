{
  if (newList != null) {
    for (Iterator<ShelvedBinaryFile> shelvedChangeListIterator=listCopy.getBinaryFiles().iterator(); shelvedChangeListIterator.hasNext(); ) {
      final ShelvedBinaryFile binaryFile=shelvedChangeListIterator.next();
      for (      ShelvedBinaryFile newBinary : newList.getBinaryFiles()) {
        if (Comparing.equal(newBinary.BEFORE_PATH,binaryFile.BEFORE_PATH) && Comparing.equal(newBinary.AFTER_PATH,binaryFile.AFTER_PATH)) {
          shelvedChangeListIterator.remove();
        }
      }
    }
    for (Iterator<ShelvedChange> iterator=listCopy.getChanges(myProject).iterator(); iterator.hasNext(); ) {
      final ShelvedChange change=iterator.next();
      for (      ShelvedChange newChange : newList.getChanges(myProject)) {
        if (Comparing.equal(change.getBeforePath(),newChange.getBeforePath()) && Comparing.equal(change.getAfterPath(),newChange.getAfterPath())) {
          iterator.remove();
        }
      }
    }
    try {
      final CommitContext commitContext=new CommitContext();
      final List<FilePatch> patches=new ArrayList<FilePatch>();
      for (      ShelvedChange change : listCopy.getChanges(myProject)) {
        patches.add(change.loadFilePatch(myProject,commitContext));
      }
      writePatchesToFile(myProject,listCopy.PATH,patches,commitContext);
    }
 catch (    IOException e) {
      LOG.info(e);
    }
catch (    PatchSyntaxException e) {
      LOG.info(e);
    }
  }
  if ((!listCopy.getBinaryFiles().isEmpty()) || (!listCopy.getChanges(myProject).isEmpty())) {
    listCopy.setRecycled(true);
    myRecycledShelvedChangeLists.add(listCopy);
    notifyStateChanged();
  }
}
