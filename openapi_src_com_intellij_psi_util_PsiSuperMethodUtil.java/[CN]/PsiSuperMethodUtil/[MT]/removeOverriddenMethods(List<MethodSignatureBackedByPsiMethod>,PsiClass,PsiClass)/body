{
  for (int i=sameSignatureMethods.size() - 1; i >= 0; i--) {
    final MethodSignatureBackedByPsiMethod methodBackedMethodSignature1=sameSignatureMethods.get(i);
    PsiMethod method1=methodBackedMethodSignature1.getMethod();
    final PsiClass class1=method1.getContainingClass();
    if (method1.hasModifierProperty(PsiModifier.STATIC) || method1.hasModifierProperty(PsiModifier.PRIVATE))     continue;
    boolean overridden=false;
    for (int j=0; j < sameSignatureMethods.size(); j++) {
      if (i == j)       continue;
      final MethodSignatureBackedByPsiMethod methodBackedMethodSignature2=sameSignatureMethods.get(j);
      if (MethodSignatureUtil.isSubsignature(methodBackedMethodSignature1,methodBackedMethodSignature2)) {
        PsiMethod method2=methodBackedMethodSignature2.getMethod();
        final PsiClass class2=method2.getContainingClass();
        if (InheritanceUtil.isInheritorOrSelf(class2,class1,true) && !(!place.isInterface() && "java.lang.Object".equals(class1.getQualifiedName()) && class2.isInterface()) && !(method1.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) && !method1.getManager().arePackagesTheSame(class1,class2))) {
          overridden=true;
          break;
        }
        if (!method2.hasModifierProperty(PsiModifier.ABSTRACT) && PsiUtil.isAccessible(method1,contextClass,contextClass) && PsiUtil.isAccessible(method2,contextClass,contextClass)) {
          overridden=true;
          break;
        }
      }
    }
    if (overridden) {
      sameSignatureMethods.remove(i);
    }
  }
}
