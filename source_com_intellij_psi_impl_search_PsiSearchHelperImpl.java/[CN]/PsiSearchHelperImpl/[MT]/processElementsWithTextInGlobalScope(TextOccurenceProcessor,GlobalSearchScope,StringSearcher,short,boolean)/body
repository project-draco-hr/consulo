{
  LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK),"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.");
  final ProgressIndicator progress=ProgressManager.getInstance().getProgressIndicator();
  if (progress != null) {
    progress.pushState();
    progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  }
  myManager.startBatchFilesProcessingMode();
  try {
    List<String> words=StringUtil.getWordsIn(searcher.getPattern());
    if (words.isEmpty())     return true;
    Set<PsiFile> fileSet=new THashSet<PsiFile>();
    final Application application=ApplicationManager.getApplication();
    for (    final String word : words) {
      List<PsiFile> psiFiles=application.runReadAction(new Computable<List<PsiFile>>(){
        public List<PsiFile> compute(){
          return Arrays.asList(myManager.getCacheManager().getFilesWithWord(word,searchContext,scope,caseSensitively));
        }
      }
);
      if (fileSet.isEmpty()) {
        fileSet.addAll(psiFiles);
      }
 else {
        fileSet.retainAll(psiFiles);
      }
      if (fileSet.isEmpty())       break;
    }
    final PsiFile[] files=fileSet.toArray(new PsiFile[fileSet.size()]);
    if (progress != null) {
      progress.setText(PsiBundle.message("psi.search.for.word.progress",searcher.getPattern()));
    }
    final AtomicInteger counter=new AtomicInteger(0);
    final AtomicBoolean canceled=new AtomicBoolean(false);
    final Job<?> processFilesJob=JobScheduler.getInstance().createJob("Process usages in files",Job.DEFAULT_PRIORITY);
    for (    final PsiFile file : files) {
      if (file instanceof PsiBinaryFile)       continue;
      processFilesJob.addTask(new Runnable(){
        public void run(){
          ((ProgressManagerImpl)ProgressManager.getInstance()).executeProcessUnderProgress(new Runnable(){
            public void run(){
              ApplicationManager.getApplication().runReadAction(new Runnable(){
                public void run(){
                  try {
                    PsiElement[] psiRoots=file.getPsiRoots();
                    Set<PsiElement> processed=new HashSet<PsiElement>(psiRoots.length * 2,(float)0.5);
                    for (                    PsiElement psiRoot : psiRoots) {
                      if (CachesBasedRefSearcher.DEBUG) {
                        System.out.println("Scanning root:" + psiRoot + " lang:"+ psiRoot.getLanguage()+ " file:"+ psiRoot.getContainingFile().getName());
                      }
                      ProgressManager.getInstance().checkCanceled();
                      if (!processed.add(psiRoot))                       continue;
                      if (!LowLevelSearchUtil.processElementsContainingWordInElement(processor,psiRoot,searcher,false)) {
                        if (CachesBasedRefSearcher.DEBUG)                         System.out.println(" cancelling subsequent file scan");
                        processFilesJob.cancel();
                        return;
                      }
                    }
                    if (progress != null) {
                      double fraction=(double)counter.incrementAndGet() / files.length;
                      progress.setFraction(fraction);
                    }
                    myManager.dropResolveCaches();
                  }
 catch (                  ProcessCanceledException e) {
                    processFilesJob.cancel();
                    canceled.set(true);
                  }
                }
              }
);
            }
          }
,progress);
        }
      }
);
    }
    try {
      processFilesJob.scheduleAndWaitForResults();
      if (CachesBasedRefSearcher.DEBUG) {
        System.out.println("Job finished");
      }
    }
 catch (    Throwable throwable) {
      LOG.error(throwable);
      return false;
    }
    if (canceled.get()) {
      throw new ProcessCanceledException();
    }
    return !processFilesJob.isCanceled();
  }
  finally {
    if (progress != null) {
      progress.popState();
    }
    myManager.finishBatchFilesProcessingMode();
  }
}
