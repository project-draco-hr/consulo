{
  configureByFile(BASE_PATH + getTestName(false) + ".java");
  PsiElement elementAt=getFile().findElementAt(getEditor().getCaretModel().getOffset());
  final PsiClass sourceClass=PsiTreeUtil.getParentOfType(elementAt,PsiClass.class);
  assertNotNull(sourceClass);
  PsiClass targetClass=sourceClass.getSuperClass();
  assertTrue(targetClass.isWritable());
  MemberInfo[] infos=new MemberInfo[membersToFind.length];
  for (int i=0; i < membersToFind.length; i++) {
    final Class<? extends PsiMember> clazz=membersToFind[i].getSecond();
    final String name=membersToFind[i].getFirst();
    PsiMember member=null;
    if (PsiClass.class.isAssignableFrom(clazz)) {
      member=sourceClass.findInnerClassByName(name,false);
    }
 else     if (PsiMethod.class.isAssignableFrom(clazz)) {
      final PsiMethod[] methods=sourceClass.findMethodsByName(name,false);
      assertEquals(1,methods.length);
      member=methods[0];
    }
 else     if (PsiField.class.isAssignableFrom(clazz)) {
      member=sourceClass.findFieldByName(name,false);
    }
    assertNotNull(member);
    infos[i]=new MemberInfo(member);
  }
  final int[] countMoved=new int[]{0};
  final MoveMemberListener listener=new MoveMemberListener(){
    public void memberMoved(    PsiClass aClass,    PsiMember member){
      assertEquals(sourceClass,aClass);
      countMoved[0]++;
    }
  }
;
  RefactoringListenerManager.getInstance(getProject()).addMoveMembersListener(listener);
  new PullUpHelper(sourceClass,targetClass,infos,new JavaDocPolicy(JavaDocPolicy.ASIS)).moveMembersToBase();
  RefactoringListenerManager.getInstance(getProject()).removeMoveMembersListener(listener);
  assertEquals(countMoved[0],membersToFind.length);
  checkResultByFile(BASE_PATH + getTestName(false) + "_after.java");
}
