{
  WorkingCopy workingCopy=null;
  final File ioFile=new File(root.getPath());
  File workingCopyRoot=null;
  try {
    workingCopyRoot=SVNWCUtil.getWorkingCopyRoot(ioFile,true);
    if (workingCopyRoot != null) {
      SVNWCAccess wcAccess=SVNWCAccess.newInstance(null);
      try {
        wcAccess.probeOpen(workingCopyRoot,false,0);
        SVNEntry entry=wcAccess.getVersionedEntry(workingCopyRoot,false);
        final SVNURL url=entry.getSVNURL();
        if (url != null) {
          workingCopy=new WorkingCopy(workingCopyRoot,url,false);
        }
      }
  finally {
        wcAccess.close();
      }
    }
  }
 catch (  SVNException e) {
  }
  if (workingCopyRoot == null) {
    workingCopyRoot=SvnUtil.getWcCopyRootIf17(ioFile,null);
    if (workingCopyRoot != null) {
      final SVNInfo svnInfo;
      try {
        svnInfo=SvnVcs.getInstance(myProject).createWCClient().doInfo(workingCopyRoot,SVNRevision.UNDEFINED);
        workingCopy=new WorkingCopy(workingCopyRoot,svnInfo.getURL(),true);
      }
 catch (      SVNException e) {
      }
    }
  }
synchronized (myLock) {
    if (workingCopy == null) {
      myRootMapping.remove(root);
      myUnversioned.add(root);
    }
 else {
      myUnversioned.remove(root);
      myRootMapping.put(root,workingCopy);
    }
  }
  return workingCopy;
}
