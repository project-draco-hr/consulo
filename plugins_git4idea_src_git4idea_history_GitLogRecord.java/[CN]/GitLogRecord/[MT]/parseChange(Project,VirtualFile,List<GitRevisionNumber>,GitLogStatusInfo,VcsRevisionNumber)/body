{
  final ContentRevision before;
  final ContentRevision after;
  FileStatus status=null;
  final String path=statusInfo.getFirstPath();
  @Nullable GitRevisionNumber firstParent=parentRevisions.isEmpty() ? null : parentRevisions.get(0);
switch (statusInfo.getType()) {
case ADDED:
    before=null;
  status=FileStatus.ADDED;
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false,true);
break;
case UNRESOLVED:
status=FileStatus.MERGED_WITH_CONFLICTS;
case MODIFIED:
if (status == null) {
status=FileStatus.MODIFIED;
}
final FilePath filePath=GitContentRevision.createPath(vcsRoot,path,false,true,true);
before=GitContentRevision.createRevision(vcsRoot,path,firstParent,project,false,false,true);
after=GitContentRevision.createMultipleParentsRevision(project,filePath,(GitRevisionNumber)thisRevision,parentRevisions);
break;
case DELETED:
status=FileStatus.DELETED;
final FilePath filePathDeleted=GitContentRevision.createPath(vcsRoot,path,true,true,true);
before=GitContentRevision.createRevision(filePathDeleted,firstParent,project,null);
after=null;
break;
case COPIED:
case RENAMED:
status=FileStatus.MODIFIED;
String secondPath=statusInfo.getSecondPath();
final FilePath filePathAfterRename=GitContentRevision.createPath(vcsRoot,secondPath == null ? path : secondPath,false,false,true);
before=GitContentRevision.createRevision(vcsRoot,path,firstParent,project,true,true,true);
after=GitContentRevision.createMultipleParentsRevision(project,filePathAfterRename,(GitRevisionNumber)thisRevision,parentRevisions);
break;
case TYPE_CHANGED:
status=FileStatus.MODIFIED;
final FilePath filePath2=GitContentRevision.createPath(vcsRoot,path,false,true,true);
before=GitContentRevision.createRevision(vcsRoot,path,firstParent,project,false,false,true);
after=GitContentRevision.createMultipleParentsRevision(project,filePath2,(GitRevisionNumber)thisRevision,parentRevisions);
break;
default :
throw new AssertionError("Unknown file status: " + statusInfo);
}
return new Change(before,after,status);
}
