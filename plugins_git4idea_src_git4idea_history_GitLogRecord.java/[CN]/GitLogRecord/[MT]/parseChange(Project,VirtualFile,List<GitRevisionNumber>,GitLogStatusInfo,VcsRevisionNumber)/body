{
  final ContentRevision before;
  final ContentRevision after;
  FileStatus status=null;
  final String path=statusInfo.getFirstPath();
switch (statusInfo.getType()) {
case ADDED:
case COPIED:
    before=null;
  status=FileStatus.ADDED;
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false,true);
break;
case UNRESOLVED:
status=FileStatus.MERGED_WITH_CONFLICTS;
case MODIFIED:
if (status == null) {
status=FileStatus.MODIFIED;
}
final FilePath filePath=GitContentRevision.createPath(vcsRoot,path,false,true,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePath,parentRevisions);
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false,true);
break;
case DELETED:
status=FileStatus.DELETED;
final FilePath filePathDeleted=GitContentRevision.createPath(vcsRoot,path,true,true,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePathDeleted,parentRevisions);
after=null;
break;
case RENAMED:
status=FileStatus.MODIFIED;
final FilePath filePathAfterRename=GitContentRevision.createPath(vcsRoot,statusInfo.getSecondPath(),false,false,true);
after=GitContentRevision.createMultipleParentsRevision(project,filePathAfterRename,parentRevisions);
before=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,true,true,true);
break;
case TYPE_CHANGED:
status=FileStatus.MODIFIED;
final FilePath filePath2=GitContentRevision.createPath(vcsRoot,path,false,true,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePath2,parentRevisions);
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false,true);
break;
default :
throw new AssertionError("Unknown file status: " + statusInfo);
}
return new Change(before,after,status);
}
