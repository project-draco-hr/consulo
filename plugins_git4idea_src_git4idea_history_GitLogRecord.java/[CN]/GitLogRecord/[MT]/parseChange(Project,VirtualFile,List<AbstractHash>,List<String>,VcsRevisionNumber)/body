{
  final ContentRevision before;
  final ContentRevision after;
  FileStatus status=null;
  final String path=parts.get(1);
  final List<GitRevisionNumber> parentRevisions=new ArrayList<GitRevisionNumber>(parents.size());
  for (  AbstractHash parent : parents) {
    parentRevisions.add(new GitRevisionNumber(parent.getString()));
  }
switch (parts.get(0).charAt(0)) {
case 'C':
case 'A':
    before=null;
  status=FileStatus.ADDED;
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false);
break;
case 'U':
status=FileStatus.MERGED_WITH_CONFLICTS;
case 'M':
if (status == null) {
status=FileStatus.MODIFIED;
}
final FilePath filePath=GitContentRevision.createPath(vcsRoot,path,false,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePath,parentRevisions);
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false);
break;
case 'D':
status=FileStatus.DELETED;
final FilePath filePathDeleted=GitContentRevision.createPath(vcsRoot,path,true,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePathDeleted,parentRevisions);
after=null;
break;
case 'R':
status=FileStatus.MODIFIED;
final FilePath filePathBeforeRename=GitContentRevision.createPath(vcsRoot,parts.get(2),true,true);
before=GitContentRevision.createMultipleParentsRevision(project,filePathBeforeRename,parentRevisions);
after=GitContentRevision.createRevision(vcsRoot,path,thisRevision,project,false,false);
break;
default :
throw new VcsException("Unknown file status: " + Arrays.asList(parts));
}
return new Change(before,after,status);
}
