{
  return new ProcessListener(){
    public void startNotified(    ProcessEvent event){
      final ProcessHandler processHandler=event.getProcessHandler();
      processHandler.putUserData(ProcessHandler.SILENTLY_DESTROY_ON_CLOSE,Boolean.TRUE);
      final Object o;
synchronized (myProcMap) {
        o=myProcMap.get(key);
        if (o instanceof PendingInfo) {
          myProcMap.put(key,new PendingInfo(((PendingInfo)o).ref,processHandler));
        }
      }
    }
    public void processTerminated(    ProcessEvent event){
      handleProcessTerminated(key,null);
      fireModificationCountChanged();
    }
    public void processWillTerminate(    ProcessEvent event,    boolean willBeDestroyed){
    }
    public void onTextAvailable(    ProcessEvent event,    Key outputType){
      final String text=StringUtil.notNullize(event.getText());
      if (outputType == ProcessOutputTypes.STDERR) {
        LOG.warn(text.trim());
      }
 else {
        LOG.info(text.trim());
      }
      Info result=null;
      final PendingInfo info;
synchronized (myProcMap) {
        final Object o=myProcMap.get(key);
        logText(key.second,event,outputType,o);
        if (o instanceof PendingInfo) {
          info=(PendingInfo)o;
          if (outputType == ProcessOutputTypes.STDOUT) {
            final String prefix="Port/ID:";
            if (text.startsWith(prefix)) {
              final String pair=text.substring(prefix.length()).trim();
              final int idx=pair.indexOf("/");
              result=new Info(info.handler,Integer.parseInt(pair.substring(0,idx)),pair.substring(idx + 1));
              myProcMap.put(key,result);
              myProcMap.notifyAll();
            }
          }
 else           if (outputType == ProcessOutputTypes.STDERR) {
            info.stderr.append(text);
          }
        }
 else {
          info=null;
        }
      }
      if (result != null) {
synchronized (info.ref) {
          info.ref.set(result);
          info.ref.notifyAll();
        }
        fireModificationCountChanged();
        try {
          RemoteDeadHand.TwoMinutesTurkish.startCooking("localhost",result.port);
        }
 catch (        Exception e) {
          LOG.error(e);
        }
      }
    }
  }
;
}
