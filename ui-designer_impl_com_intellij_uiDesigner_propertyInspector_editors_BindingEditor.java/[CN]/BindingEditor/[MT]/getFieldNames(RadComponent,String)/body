{
  final ArrayList<String> result=new ArrayList<String>();
  if (currentName != null) {
    result.add(currentName);
  }
  final String className=myEditor.getRootContainer().getClassToBind();
  if (className == null) {
    return result.toArray(new String[result.size()]);
  }
  final PsiClass aClass=FormEditingUtil.findClassToBind(myEditor.getModule(),className);
  if (aClass == null) {
    return result.toArray(new String[result.size()]);
  }
  final PsiField[] fields=aClass.getFields();
  for (int i=0; i < fields.length; i++) {
    final PsiField field=fields[i];
    if (field.hasModifierProperty(PsiModifier.STATIC)) {
      continue;
    }
    final String fieldName=field.getName();
    if (fieldName.equals(currentName)) {
      continue;
    }
    if (!GuiEditorUtil.isBindingUnique(component,fieldName,myEditor.getRootContainer())) {
      continue;
    }
    final String componentClassName;
    if (component instanceof RadErrorComponent) {
      componentClassName=component.getComponentClassName();
    }
 else     if (component instanceof RadHSpacer || component instanceof RadVSpacer) {
      componentClassName=Spacer.class.getName();
    }
 else {
      componentClassName=component.getComponentClass().getName();
    }
    final PsiType componentType;
    try {
      componentType=PsiManager.getInstance(myEditor.getProject()).getElementFactory().createTypeFromText(componentClassName,null);
    }
 catch (    IncorrectOperationException e) {
      continue;
    }
    if (componentType == null) {
      continue;
    }
    final PsiType fieldType=field.getType();
    if (fieldType == null) {
      continue;
    }
    if (!fieldType.isAssignableFrom(componentType)) {
      continue;
    }
    result.add(fieldName);
  }
  final String[] names=result.toArray(new String[result.size()]);
  Arrays.sort(names);
  return names;
}
