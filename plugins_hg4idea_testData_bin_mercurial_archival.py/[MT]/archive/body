def archive(repo, dest, node, kind, decode=True, matchfn=None, prefix=None, mtime=None):
    'create archive of repo as it was at node.\n\n    dest can be name of directory, name of archive file, or file\n    object to write archive to.\n\n    kind is type of archive to create.\n\n    decode tells whether to put files through decode filters from\n    hgrc.\n\n    matchfn is function to filter names of files to write to archive.\n\n    prefix is name of path to put before every archive member.'

    def write(name, mode, islink, getdata):
        if (matchfn and (not matchfn(name))):
            return
        data = getdata()
        if decode:
            data = repo.wwritedata(name, data)
        archiver.addfile(name, mode, islink, data)
    if (kind not in archivers):
        raise util.Abort((_("unknown archive type '%s'") % kind))
    ctx = repo[node]
    archiver = archivers[kind](dest, prefix, (mtime or ctx.date()[0]))
    if repo.ui.configbool('ui', 'archivemeta', True):

        def metadata():
            base = ('repo: %s\nnode: %s\nbranch: %s\n' % (hex(repo.changelog.node(0)), hex(node), ctx.branch()))
            tags = ''.join((('tag: %s\n' % t) for t in ctx.tags() if (repo.tagtype(t) == 'global')))
            if (not tags):
                repo.ui.pushbuffer()
                opts = {'template': '{latesttag}\n{latesttagdistance}', 'style': '', 'patch': None, 'git': None, }
                cmdutil.show_changeset(repo.ui, repo, opts).show(ctx)
                (ltags, dist) = repo.ui.popbuffer().split('\n')
                tags = ''.join((('latesttag: %s\n' % t) for t in ltags.split(':')))
                tags += ('latesttagdistance: %s\n' % dist)
            return (base + tags)
        write('.hg_archival.txt', 420, False, metadata)
    for f in ctx:
        ff = ctx.flags(f)
        write(f, ((('x' in ff) and 493) or 420), ('l' in ff), ctx[f].data)
    archiver.done()
