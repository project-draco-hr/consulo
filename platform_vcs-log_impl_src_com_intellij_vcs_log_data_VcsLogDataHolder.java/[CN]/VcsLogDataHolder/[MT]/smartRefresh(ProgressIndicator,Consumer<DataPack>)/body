{
  if (myLogData == null || !myLogData.isFullLogReady()) {
    LOG.error("The full log is not ready!");
  }
  StopWatch methodLog=StopWatch.start("smartRefresh");
  Map<VirtualFile,List<? extends TimedVcsCommit>> logsToBuild=ContainerUtil.newHashMap();
  Map<VirtualFile,Collection<VcsRef>> refsByRoot=ContainerUtil.newHashMap();
  int topCommitCount=myLogData.getTopCommitsCount();
  for (  Map.Entry<VirtualFile,RecentCommitsInfo> entry : collectInfoFromVcs(false,mySettings.getRecentCommitsCount())) {
    VirtualFile root=entry.getKey();
    RecentCommitsInfo info=entry.getValue();
    Collection<VcsRef> oldRefs=myLogData.getRefs(root);
    Pair<List<TimedVcsCommit>,Integer> joinResult=myLogJoiner.addCommits(myLogData.getLog(root),oldRefs,info.firstBlockCommits,info.newRefs);
    if (!Comparing.haveEqualElements(oldRefs,info.newRefs)) {
      myContainingBranchesGetter.clearCache();
    }
    List<TimedVcsCommit> refreshedLog=joinResult.getFirst();
    int newCommitsCount=joinResult.getSecond();
    topCommitCount+=newCommitsCount;
    logsToBuild.put(root,refreshedLog);
    refsByRoot.put(root,info.newRefs);
  }
  List<? extends TimedVcsCommit> compoundLog=myMultiRepoJoiner.join(logsToBuild.values());
  List<? extends TimedVcsCommit> topPartOfTheLog=compoundLog.subList(0,topCommitCount);
  List<? extends TimedVcsCommit> logToBuild=myFullLogShowing ? compoundLog : topPartOfTheLog;
  DataPack dataPack=DataPack.build(convertToGraphCommits(logToBuild),collectAllRefs(refsByRoot),indicator,myIndexGetter,myHashGetter,myLogProviders);
  myLogData=new LogData(logsToBuild,refsByRoot,topPartOfTheLog,dataPack,true);
  handleOnSuccessInEdt(onSuccess,dataPack);
  methodLog.report();
}
