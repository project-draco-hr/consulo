{
  myRule=new StdArrangementRule(new StdArrangementEntryMatcher(newCondition));
  HierarchicalArrangementConditionNode grouped=ArrangementUtil.group(newCondition,myGroupingRules);
  Pair<ArrangementTreeNode,Integer> replacement=ArrangementConfigUtil.map(null,grouped,null);
  ArrangementTreeNode newBottom=replacement.first;
  ArrangementTreeNode newTop=ArrangementConfigUtil.getRoot(newBottom);
  final TIntIntHashMap rowChanges=ArrangementConfigUtil.replace(myTopMost,myBottomMost,newTop,myTreeModel,myRootVisible);
  myBottomMost=newBottom;
  myTopMost=newTop;
  refreshTreeNodes();
  int newRow=ArrangementConfigUtil.getRow(myBottomMost,myRootVisible);
  if (myRow != newRow) {
    rowChanges.put(myRow,newRow);
    myRow=newRow;
  }
  refreshConditions();
  for (  Listener listener : myListeners) {
    listener.onChanged(this,rowChanges);
  }
  if (ArrangementConstants.LOG_RULE_MODIFICATION) {
    LOG.info(String.format("Arrangement rule is modified: '%s', row: %d",myRule,myRow));
  }
}
