{
  final Project project=element.getProject();
  final GrParametersOwner owner=PsiTreeUtil.getParentOfType(element,GrParametersOwner.class);
  final Collection<PsiElement> occurrences=new ArrayList<PsiElement>();
  final boolean success=collectOwnerOccurrences(project,owner,occurrences);
  if (!success)   return;
  final boolean isClosure=owner instanceof GrClosableBlock;
  if (!checkOwnerOccurences(project,occurrences,isClosure))   return;
  final GrParameter fisrtParam=getFirstParameter(owner);
  final PsiReference ref=element.getReference();
switch (analyzeForNamedArguments(owner,occurrences)) {
case ERROR:
{
      final GrNamedElement namedElement=getReferencedElement(owner);
      LOG.assertTrue(namedElement != null);
      final String msg=GroovyIntentionsBundle.message("wrong.first.parameter.type",isClosure ? CLOSURE_CAPTION_CAP : METHOD_CAPTION_CAP,namedElement.getName(),fisrtParam.getName());
      showErrorMessage(msg,project);
      return;
    }
case MUST_BE_MAP:
{
    if (element == fisrtParam || ref != null && ref.resolve() == fisrtParam) {
      final String msg=GroovyIntentionsBundle.message("convert.cannot.itself");
      showErrorMessage(msg,project);
      return;
    }
    performRefactoring(owner,occurrences,false);
    break;
  }
case IS_NOT_MAP:
{
  performRefactoring(owner,occurrences,true);
  break;
}
case MAY_BE_MAP:
{
if (!(element == fisrtParam || ref != null && ref.resolve() == fisrtParam)) {
  final FirstParameterDialog dialog=new FirstParameterDialog();
  dialog.show();
  if (dialog.isOK()) {
    performRefactoring(owner,occurrences,!dialog.createNewFirst());
  }
}
 else {
  performRefactoring(owner,occurrences,true);
}
break;
}
}
}
