{
  List<PsiClass> classesToImport=getClassesToImport();
  if (classesToImport.isEmpty())   return false;
  try {
    String name=myRef.getQualifiedName();
    Pattern pattern=Pattern.compile(DaemonCodeAnalyzerSettings.getInstance().NO_AUTO_IMPORT_PATTERN);
    Matcher matcher=pattern.matcher(name);
    if (matcher.matches())     return false;
  }
 catch (  PatternSyntaxException e) {
  }
  final PsiFile psiFile=myRef.getContainingFile();
  if (classesToImport.size() > 1) {
    reduceSuggestedClassesBasedOnDependencyRuleViolation(psiFile,classesToImport);
  }
  PsiClass[] classes=classesToImport.toArray(new PsiClass[classesToImport.size()]);
  final Project project=myRef.getProject();
  CodeInsightUtil.sortIdenticalShortNameClasses(classes,psiFile);
  final QuestionAction action=new AddImportAction(project,myRef,editor,classes);
  DaemonCodeAnalyzerImpl codeAnalyzer=(DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(project);
  if (classes.length == 1 && CodeStyleSettingsManager.getSettings(project).ADD_UNAMBIGIOUS_IMPORTS_ON_THE_FLY && (allowCaretNearRef || !isCaretNearRef(editor,myRef)) && !PsiUtil.isInJspFile(psiFile) && codeAnalyzer.canChangeFileSilently(psiFile) && !hasUnresolvedImportWhichCanImport(psiFile,classes[0].getName())) {
    CommandProcessor.getInstance().runUndoTransparentAction(new Runnable(){
      public void run(){
        action.execute();
      }
    }
);
    return false;
  }
  if (doShow) {
    String hintText=ShowAutoImportPass.getMessage(classes.length > 1,classes[0].getQualifiedName());
    HintManager.getInstance().showQuestionHint(editor,hintText,myRef.getTextOffset(),myRef.getTextRange().getEndOffset(),action);
  }
  return true;
}
