{
  file.getViewProvider().beforeContentsSynchronized();
  final PsiFileImpl fileImpl=(PsiFileImpl)file;
  Project project=fileImpl.getProject();
  final CharTable charTable=fileImpl.getTreeElement().getCharTable();
  final FileElement treeFileElement=fileImpl.getTreeElement();
  final int textLength=treeFileElement.getTextLength() + lengthShift;
  if (treeFileElement.getElementType() instanceof ITemplateDataElementType || isTooDeep(file)) {
    makeFullParse(treeFileElement,newFileText,textLength,fileImpl);
    return;
  }
  final ASTNode leafAtStart=treeFileElement.findLeafElementAt(startOffset);
  final ASTNode leafAtEnd=treeFileElement.findLeafElementAt(endOffset);
  ASTNode node=leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart,leafAtEnd) : treeFileElement;
  Language baseLanguage=file.getViewProvider().getBaseLanguage();
  while (node != null && !(node instanceof FileElement)) {
    IElementType elementType=node.getElementType();
    if (elementType instanceof IReparseableElementType) {
      final TextRange textRange=node.getTextRange();
      final IReparseableElementType reparseable=(IReparseableElementType)elementType;
      if (reparseable.getLanguage() == baseLanguage) {
        final int start=textRange.getStartOffset();
        final int end=start + textRange.getLength() + lengthShift;
        if (end > newFileText.length() && ApplicationManagerEx.getApplicationEx().isInternal()) {
          String newTextBefore=newFileText.subSequence(0,start).toString();
          String oldTextBefore=file.getText().subSequence(0,start).toString();
          String message="IOOBE: type=" + elementType + "; oldText="+ node.getText()+ "; newText="+ newFileText.subSequence(start,newFileText.length())+ "; length="+ node.getTextLength();
          if (oldTextBefore.equals(newTextBefore)) {
            message+="; oldTextBefore==newTextBefore";
          }
 else {
            message+="; oldTextBefore=" + oldTextBefore + "; newTextBefore="+ newTextBefore;
          }
          throw new AssertionError(message);
        }
        CharSequence newTextStr=newFileText.subSequence(start,end);
        if (reparseable.isParsable(newTextStr,project)) {
          ASTNode chameleon=reparseable.createNode(newTextStr);
          if (chameleon != null) {
            DummyHolder holder=DummyHolderFactory.createHolder(fileImpl.getManager(),null,node.getPsi(),charTable);
            holder.getTreeElement().rawAddChildren((TreeElement)chameleon);
            if (holder.getTextLength() != newTextStr.length()) {
              if (ApplicationManagerEx.getApplicationEx().isInternal() && !ApplicationManager.getApplication().isUnitTestMode()) {
                LOG.error("Inconsistent reparse: text=" + newTextStr + "; treeText="+ holder.getText()+ "; type="+ elementType);
              }
 else {
                LOG.error("Inconsistent reparse: type=" + elementType);
              }
            }
            mergeTrees(fileImpl,node,chameleon);
            return;
          }
        }
      }
    }
    node=node.getTreeParent();
  }
  makeFullParse(node,newFileText,textLength,fileImpl);
}
