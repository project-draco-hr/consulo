{
  final List<String> conflicts=new ArrayList<String>();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(mySuperClass,myMemberInfos);
  for (  MemberInfo info : myMemberInfos) {
    final PsiMember member=info.getMember();
    pushDownConflicts.checkMemberPlacementInTargetClassConflict(myTargetClass,member);
    ReferencesSearch.search(member,member.getResolveScope(),false).forEach(new Processor<PsiReference>(){
      public boolean process(      final PsiReference reference){
        final PsiElement element=reference.getElement();
        if (element instanceof PsiReferenceExpression) {
          final PsiReferenceExpression referenceExpression=(PsiReferenceExpression)element;
          final PsiExpression qualifier=referenceExpression.getQualifierExpression();
          if (qualifier != null) {
            final PsiType qualifierType=qualifier.getType();
            LOG.assertTrue(qualifierType != null);
            if (!TypeConversionUtil.isAssignable(qualifierType,myTargetClassType)) {
              conflicts.add("Non consistent substitution found for " + element.getText());
            }
          }
        }
        return true;
      }
    }
);
  }
  conflicts.addAll(pushDownConflicts.getConflicts());
  return showConflicts(conflicts);
}
