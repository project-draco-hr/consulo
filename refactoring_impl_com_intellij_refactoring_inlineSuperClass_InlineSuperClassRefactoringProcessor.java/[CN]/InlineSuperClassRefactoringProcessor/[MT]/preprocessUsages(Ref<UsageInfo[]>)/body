{
  final List<String> conflicts=new ArrayList<String>();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(mySuperClass,myMemberInfos);
  for (  MemberInfo info : myMemberInfos) {
    final PsiMember member=info.getMember();
    pushDownConflicts.checkMemberPlacementInTargetClassConflict(myTargetClass,member);
    ReferencesSearch.search(member,member.getResolveScope(),false).forEach(new Processor<PsiReference>(){
      public boolean process(      final PsiReference reference){
        final PsiElement element=reference.getElement();
        if (element instanceof PsiReferenceExpression) {
          final PsiReferenceExpression referenceExpression=(PsiReferenceExpression)element;
          final PsiExpression qualifier=referenceExpression.getQualifierExpression();
          if (qualifier != null) {
            final PsiType qualifierType=qualifier.getType();
            if (qualifierType instanceof PsiClassType) {
              final PsiClassType.ClassResolveResult resolveResult=((PsiClassType)qualifierType).resolveGenerics();
              if (resolveResult.getElement().equals(mySuperClass) && !resolveResult.getSubstitutor().equals(TypeConversionUtil.getSuperClassSubstitutor(mySuperClass,myTargetClass,PsiSubstitutor.EMPTY))) {
                conflicts.add("Non consistent substitution detected");
              }
            }
          }
        }
        return true;
      }
    }
);
  }
  conflicts.addAll(pushDownConflicts.getConflicts());
  return showConflicts(conflicts);
}
