{
  Pair<List<GitRepository>,List<Change>> conflictingRepositoriesAndAffectedChanges=getConflictingRepositoriesAndAffectedChanges(repository,localChangesOverwrittenByCheckout,myPreviousBranch,myStartPointReference);
  List<GitRepository> allConflictingRepositories=conflictingRepositoriesAndAffectedChanges.getFirst();
  List<Change> affectedChanges=conflictingRepositoriesAndAffectedChanges.getSecond();
  int smartCheckoutDecision=GitSmartOperationDialog.showAndGetAnswer(myProject,affectedChanges,"checkout",true);
  if (smartCheckoutDecision == GitSmartOperationDialog.SMART_EXIT_CODE) {
    boolean smartCheckedOutSuccessfully=smartCheckout(allConflictingRepositories,myStartPointReference,myNewBranch,getIndicator());
    if (smartCheckedOutSuccessfully) {
      for (      GitRepository conflictingRepository : allConflictingRepositories) {
        markSuccessful(conflictingRepository);
        refresh(conflictingRepository);
      }
      return true;
    }
 else {
      return false;
    }
  }
 else   if (smartCheckoutDecision == GitSmartOperationDialog.FORCE_EXIT_CODE) {
    return checkoutOrNotify(allConflictingRepositories,myStartPointReference,myNewBranch,true);
  }
 else {
    fatalLocalChangesError(myStartPointReference);
    return false;
  }
}
