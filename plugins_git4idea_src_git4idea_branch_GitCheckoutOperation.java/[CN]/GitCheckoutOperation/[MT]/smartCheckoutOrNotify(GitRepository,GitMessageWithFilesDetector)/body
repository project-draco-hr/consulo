{
  Pair<List<GitRepository>,List<Change>> conflictingRepositoriesAndAffectedChanges=getConflictingRepositoriesAndAffectedChanges(repository,localChangesOverwrittenByCheckout,myCurrentBranchOrRev,myStartPointReference);
  List<GitRepository> allConflictingRepositories=conflictingRepositoriesAndAffectedChanges.getFirst();
  List<Change> affectedChanges=conflictingRepositoriesAndAffectedChanges.getSecond();
  int smartCheckoutDecision=myUiHandler.showSmartOperationDialog(myProject,affectedChanges,"checkout",true);
  if (smartCheckoutDecision == GitSmartOperationDialog.SMART_EXIT_CODE) {
    boolean smartCheckedOutSuccessfully=smartCheckout(allConflictingRepositories,myStartPointReference,myNewBranch,getIndicator());
    if (smartCheckedOutSuccessfully) {
      for (      GitRepository conflictingRepository : allConflictingRepositories) {
        markSuccessful(conflictingRepository);
        refresh(conflictingRepository);
      }
      return true;
    }
 else {
      return false;
    }
  }
 else   if (smartCheckoutDecision == GitSmartOperationDialog.FORCE_EXIT_CODE) {
    boolean forceCheckoutSucceeded=checkoutOrNotify(allConflictingRepositories,myStartPointReference,myNewBranch,true);
    if (forceCheckoutSucceeded) {
      markSuccessful(ArrayUtil.toObjectArray(allConflictingRepositories,GitRepository.class));
      refresh(ArrayUtil.toObjectArray(allConflictingRepositories,GitRepository.class));
    }
    return forceCheckoutSucceeded;
  }
 else {
    fatalLocalChangesError(myStartPointReference);
    return false;
  }
}
