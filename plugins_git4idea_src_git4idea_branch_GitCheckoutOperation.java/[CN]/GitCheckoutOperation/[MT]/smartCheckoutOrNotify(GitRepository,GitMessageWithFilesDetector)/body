{
  List<Change> affectedChanges=GitUtil.convertPathsToChanges(repository,localChangesOverwrittenByCheckout.getRelativeFilePaths(),true);
  Map<GitRepository,List<Change>> conflictingChangesInRepositories=collectLocalChangesConflictingWithBranch(myProject,getRemainingRepositoriesExceptGiven(repository),myPreviousBranch,myStartPointReference);
  Set<GitRepository> otherProblematicRepositories=conflictingChangesInRepositories.keySet();
  List<GitRepository> allConflictingRepositories=new ArrayList<GitRepository>(otherProblematicRepositories);
  allConflictingRepositories.add(repository);
  for (  List<Change> changes : conflictingChangesInRepositories.values()) {
    affectedChanges.addAll(changes);
  }
  int smartCheckoutDecision=GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject,affectedChanges);
  if (smartCheckoutDecision == GitWouldBeOverwrittenByCheckoutDialog.SMART_CHECKOUT) {
    boolean smartCheckedOutSuccessfully=smartCheckout(allConflictingRepositories,myStartPointReference,myNewBranch,getIndicator());
    if (smartCheckedOutSuccessfully) {
      GitRepository[] otherRepositories=ArrayUtil.toObjectArray(otherProblematicRepositories,GitRepository.class);
      markSuccessful(repository);
      markSuccessful(otherRepositories);
      refresh(repository);
      refresh(otherRepositories);
      return true;
    }
 else {
      return false;
    }
  }
 else   if (smartCheckoutDecision == GitWouldBeOverwrittenByCheckoutDialog.FORCE_CHECKOUT_EXIT_CODE) {
    return checkoutOrNotify(allConflictingRepositories,myStartPointReference,myNewBranch,true);
  }
 else {
    fatalLocalChangesError();
    return false;
  }
}
