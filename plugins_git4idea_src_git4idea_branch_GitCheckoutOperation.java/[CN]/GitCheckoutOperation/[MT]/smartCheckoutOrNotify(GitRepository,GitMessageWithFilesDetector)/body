{
  List<Change> affectedChanges=getChangesAffectedByCheckout(repository,localChangesOverwrittenByCheckout.getRelativeFilePaths(),true);
  Map<GitRepository,List<Change>> conflictingChangesInRepositories=collectLocalChangesOnAllOtherRepositories(repository);
  Set<GitRepository> otherProblematicRepositories=conflictingChangesInRepositories.keySet();
  Collection<GitRepository> allConflictingRepositories=new ArrayList<GitRepository>(otherProblematicRepositories);
  allConflictingRepositories.add(repository);
  for (  List<Change> changes : conflictingChangesInRepositories.values()) {
    affectedChanges.addAll(changes);
  }
  if (GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject,affectedChanges)) {
    boolean smartCheckedOutSuccessfully=smartCheckout(allConflictingRepositories,myStartPointReference,myNewBranch,getIndicator());
    if (smartCheckedOutSuccessfully) {
      GitRepository[] otherRepositories=ArrayUtil.toObjectArray(otherProblematicRepositories,GitRepository.class);
      markSuccessful(repository);
      markSuccessful(otherRepositories);
      refresh(repository);
      refresh(otherRepositories);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    fatalLocalChangesError();
    return false;
  }
}
