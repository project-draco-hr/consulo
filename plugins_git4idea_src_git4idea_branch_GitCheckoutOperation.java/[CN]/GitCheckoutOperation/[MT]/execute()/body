{
  boolean fatalErrorHappened=false;
  while (hasMoreRepositories() && !fatalErrorHappened) {
    final GitRepository repository=next();
    VirtualFile root=repository.getRoot();
    GitMessageWithFilesDetector localChangesOverwrittenByCheckout=new GitMessageWithFilesDetector(LOCAL_CHANGES_OVERWRITTEN_BY_CHECKOUT,root);
    GitSimpleEventDetector unmergedFiles=new GitSimpleEventDetector(GitSimpleEventDetector.Event.UNMERGED_PREVENTING_CHECKOUT);
    GitMessageWithFilesDetector untrackedOverwrittenByCheckout=new GitMessageWithFilesDetector(UNTRACKED_FILES_OVERWRITTEN_BY,root);
    GitCommandResult result=myGit.checkout(repository,myStartPointReference,myNewBranch,false,localChangesOverwrittenByCheckout,unmergedFiles,untrackedOverwrittenByCheckout);
    if (result.success()) {
      refresh(repository);
      markSuccessful(repository);
    }
 else     if (unmergedFiles.hasHappened()) {
      fatalUnmergedFilesError();
      fatalErrorHappened=true;
    }
 else     if (localChangesOverwrittenByCheckout.wasMessageDetected()) {
      boolean smartCheckoutSucceeded=smartCheckoutOrNotify(repository,localChangesOverwrittenByCheckout);
      if (!smartCheckoutSucceeded) {
        fatalErrorHappened=true;
      }
    }
 else     if (untrackedOverwrittenByCheckout.wasMessageDetected()) {
      fatalUntrackedFilesError(untrackedOverwrittenByCheckout.getFiles());
      fatalErrorHappened=true;
    }
 else {
      fatalError(getCommonErrorTitle(),result.getErrorOutputAsJoinedString());
      fatalErrorHappened=true;
    }
  }
  if (!fatalErrorHappened) {
    notifySuccess();
    updateRecentBranch();
  }
}
