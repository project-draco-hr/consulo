{
  x-=x0;
  y-=y0;
  if (r1 == 0 || r2 == 0) {
    return new double[0];
  }
  double fS=sweepFlag;
  double psai=angle;
  r1=Math.abs(r1);
  r2=Math.abs(r2);
  double ctx=-x / 2;
  double cty=-y / 2;
  double cpsi=Math.cos(psai * Math.PI / 180);
  double spsi=Math.sin(psai * Math.PI / 180);
  double rxd=cpsi * ctx + spsi * cty;
  double ryd=-1 * spsi * ctx + cpsi * cty;
  double rxdd=rxd * rxd;
  double rydd=ryd * ryd;
  double r1x=r1 * r1;
  double r2y=r2 * r2;
  double lamda=rxdd / r1x + rydd / r2y;
  double sds;
  if (lamda > 1) {
    r1=Math.sqrt(lamda) * r1;
    r2=Math.sqrt(lamda) * r2;
    sds=0;
  }
 else {
    double seif=1;
    if (largeArcFlag == fS) {
      seif=-1;
    }
    sds=seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));
  }
  double txd=sds * r1 * ryd / r2;
  double tyd=-1 * sds * r2* rxd / r1;
  double tx=cpsi * txd - spsi * tyd + x / 2;
  double ty=spsi * txd + cpsi * tyd + y / 2;
  double rad=Math.atan2((ryd - tyd) / r2,(rxd - txd) / r1) - Math.atan2(0,1);
  double s1=(rad >= 0) ? rad : 2 * Math.PI + rad;
  rad=Math.atan2((-ryd - tyd) / r2,(-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2,(rxd - txd) / r1);
  double dr=(rad >= 0) ? rad : 2 * Math.PI + rad;
  if (fS == 0 && dr > 0) {
    dr-=2 * Math.PI;
  }
 else   if (fS != 0 && dr < 0) {
    dr+=2 * Math.PI;
  }
  double sse=dr * 2 / Math.PI;
  int seg=(int)Math.ceil(sse < 0 ? -1 * sse : sse);
  double segr=dr / seg;
  double t=8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);
  double cpsir1=cpsi * r1;
  double cpsir2=cpsi * r2;
  double spsir1=spsi * r1;
  double spsir2=spsi * r2;
  double mc=Math.cos(s1);
  double ms=Math.sin(s1);
  double x2=-t * (cpsir1 * ms + spsir2 * mc);
  double y2=-t * (spsir1 * ms - cpsir2 * mc);
  double x3=0;
  double y3=0;
  double[] result=new double[seg * 6];
  for (int n=0; n < seg; ++n) {
    s1+=segr;
    mc=Math.cos(s1);
    ms=Math.sin(s1);
    x3=cpsir1 * mc - spsir2 * ms + tx;
    y3=spsir1 * mc + cpsir2 * ms + ty;
    double dx=-t * (cpsir1 * ms + spsir2 * mc);
    double dy=-t * (spsir1 * ms - cpsir2 * mc);
    int index=n * 6;
    result[index]=x2 + x0;
    result[index + 1]=y2 + y0;
    result[index + 2]=x3 - dx + x0;
    result[index + 3]=y3 - dy + y0;
    result[index + 4]=x3 + x0;
    result[index + 5]=y3 + y0;
    x2=x3 + dx;
    y2=y3 + dy;
  }
  return result;
}
