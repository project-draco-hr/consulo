{
  final OrFilter filter=new OrFilter();
  if (isInCode() && !(getParent() instanceof PsiImportStatement)) {
    filter.addFilter(new AndFilter(ElementClassFilter.METHOD,new NotFilter(new ConstructorFilter())));
    filter.addFilter(ElementClassFilter.VARIABLE);
  }
switch (getKind()) {
case CLASS_OR_PACKAGE_NAME_KIND:
    addClassFilter(filter);
  filter.addFilter(ElementClassFilter.PACKAGE_FILTER);
break;
case CLASS_NAME_KIND:
addClassFilter(filter);
if (isQualified()) {
filter.addFilter(ElementClassFilter.PACKAGE_FILTER);
}
break;
case PACKAGE_NAME_KIND:
filter.addFilter(ElementClassFilter.PACKAGE_FILTER);
break;
case CLASS_FQ_NAME_KIND:
case CLASS_FQ_OR_PACKAGE_NAME_KIND:
filter.addFilter(ElementClassFilter.PACKAGE_FILTER);
if (isQualified()) {
filter.addFilter(ElementClassFilter.CLASS);
}
break;
case CLASS_IN_QUALIFIED_NEW_KIND:
final PsiElement parent=getParent();
if (parent instanceof PsiNewExpression) {
final PsiNewExpression newExpr=(PsiNewExpression)parent;
final PsiType type=newExpr.getQualifier().getType();
final PsiClass aClass=PsiUtil.resolveClassInType(type);
if (aClass != null) {
aClass.processDeclarations(new FilterScopeProcessor(new AndFilter(ElementClassFilter.CLASS,new ModifierFilter(PsiModifier.STATIC,false)),processor),ResolveState.initial(),null,this);
}
}
return;
default :
throw new RuntimeException("Unknown reference type");
}
final FilterScopeProcessor proc=new FilterScopeProcessor(filter,processor);
PsiScopesUtil.resolveAndWalk(proc,this,null,true);
}
