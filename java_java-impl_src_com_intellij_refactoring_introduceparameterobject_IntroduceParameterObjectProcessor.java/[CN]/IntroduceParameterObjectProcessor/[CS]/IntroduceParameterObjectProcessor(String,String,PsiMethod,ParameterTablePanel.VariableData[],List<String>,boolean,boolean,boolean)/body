{
  super(method.getProject());
  this.method=method;
  this.className=className;
  this.packageName=packageName;
  this.getterNames=getterNames;
  this.keepMethodAsDelegate=keepMethodAsDelegate;
  myUseExistingClass=useExistingClass;
  myCreateInnerClass=createInnerClass;
  this.parameters=new ArrayList<ParameterTablePanel.VariableData>(Arrays.asList(parameters));
  final PsiParameterList parameterList=method.getParameterList();
  final PsiParameter[] methodParams=parameterList.getParameters();
  paramsToMerge=new int[parameters.length];
  for (int p=0; p < parameters.length; p++) {
    ParameterTablePanel.VariableData parameter=parameters[p];
    for (int i=0; i < methodParams.length; i++) {
      final PsiParameter methodParam=methodParams[i];
      if (parameter.variable.equals(methodParam)) {
        paramsToMerge[p]=i;
        break;
      }
    }
  }
  final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
  final JavaRecursiveElementWalkingVisitor visitor=new TypeParametersVisitor(typeParamSet);
  for (  ParameterTablePanel.VariableData parameter : parameters) {
    parameter.variable.accept(visitor);
  }
  typeParams=new ArrayList<PsiTypeParameter>(typeParamSet);
  final String qualifiedName=StringUtil.getQualifiedName(packageName,className);
  final GlobalSearchScope scope=GlobalSearchScope.allScope(myProject);
  existingClass=JavaPsiFacade.getInstance(myProject).findClass(qualifiedName,scope);
}
