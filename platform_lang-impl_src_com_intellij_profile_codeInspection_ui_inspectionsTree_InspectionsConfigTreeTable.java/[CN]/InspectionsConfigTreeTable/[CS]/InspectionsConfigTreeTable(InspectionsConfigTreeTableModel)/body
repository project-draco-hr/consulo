{
  super(model);
  final TableColumn severitiesColumn=getColumnModel().getColumn(SEVERITIES_COLUMN);
  severitiesColumn.setMaxWidth(JBUI.scale(20));
  final TableColumn isEnabledColumn=getColumnModel().getColumn(IS_ENABLED_COLUMN);
  isEnabledColumn.setMaxWidth(JBUI.scale(20 + getAdditionalPadding()));
  isEnabledColumn.setCellRenderer(new ThreeStateCheckBoxRenderer());
  isEnabledColumn.setCellEditor(new ThreeStateCheckBoxRenderer());
  addMouseMotionListener(new MouseAdapter(){
    @Override public void mouseMoved(    final MouseEvent e){
      final Point point=e.getPoint();
      final int column=columnAtPoint(point);
      if (column != SEVERITIES_COLUMN) {
        return;
      }
      final int row=rowAtPoint(point);
      final Object maybeIcon=getModel().getValueAt(row,column);
      if (maybeIcon instanceof MultiScopeSeverityIcon) {
        final MultiScopeSeverityIcon icon=(MultiScopeSeverityIcon)maybeIcon;
        final LinkedHashMap<String,HighlightDisplayLevel> scopeToAverageSeverityMap=icon.getScopeToAverageSeverityMap();
        final JComponent component;
        if (scopeToAverageSeverityMap.size() == 1 && icon.getDefaultScopeName().equals(ContainerUtil.getFirstItem(scopeToAverageSeverityMap.keySet()))) {
          final HighlightDisplayLevel level=ContainerUtil.getFirstItem(scopeToAverageSeverityMap.values());
          final JLabel label=new JLabel();
          label.setIcon(level.getIcon());
          label.setText(SingleInspectionProfilePanel.renderSeverity(level.getSeverity()));
          component=label;
        }
 else {
          component=new ScopesAndSeveritiesHintTable(scopeToAverageSeverityMap,icon.getDefaultScopeName());
        }
        IdeTooltipManager.getInstance().show(new IdeTooltip(InspectionsConfigTreeTable.this,point,component),false);
      }
    }
  }
);
  new DoubleClickListener(){
    @Override protected boolean onDoubleClick(    MouseEvent event){
      final TreePath path=getTree().getPathForRow(getTree().getLeadSelectionRow());
      if (path != null) {
        final InspectionConfigTreeNode node=(InspectionConfigTreeNode)path.getLastPathComponent();
        if (node.isLeaf()) {
          model.swapInspectionEnableState();
        }
      }
      return true;
    }
  }
.installOn(this);
  setTransferHandler(new TransferHandler(){
    @Nullable @Override protected Transferable createTransferable(    JComponent c){
      final TreePath path=getTree().getPathForRow(getTree().getLeadSelectionRow());
      if (path != null) {
        return new TextTransferable(StringUtil.join(ContainerUtil.mapNotNull(path.getPath(),new NullableFunction<Object,String>(){
          @Nullable @Override public String fun(          Object o){
            return o == path.getPath()[0] ? null : o.toString();
          }
        }
)," | "));
      }
      return null;
    }
    @Override public int getSourceActions(    JComponent c){
      return COPY;
    }
  }
);
  registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      model.swapInspectionEnableState();
      updateUI();
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,0),JComponent.WHEN_FOCUSED);
  getEmptyText().setText("No enabled inspections available");
}
