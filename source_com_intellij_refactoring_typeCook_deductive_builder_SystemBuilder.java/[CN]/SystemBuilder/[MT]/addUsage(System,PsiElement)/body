{
class TypeEvaluator {
    PsiType valuateType(    final PsiExpression expr){
      return evaluateType(expr);
    }
    PsiType evaluateType(    final PsiExpression expr){
      if (expr instanceof PsiArrayAccessExpression && !mySettings.preserveRawArrays()) {
        final PsiType at=evaluateType(((PsiArrayAccessExpression)expr).getArrayExpression());
        if (at instanceof PsiArrayType) {
          return ((PsiArrayType)at).getComponentType();
        }
      }
 else       if (expr instanceof PsiAssignmentExpression) {
        return evaluateType(((PsiAssignmentExpression)expr).getLExpression());
      }
 else       if (expr instanceof PsiCallExpression) {
        final PsiCallExpression call=((PsiCallExpression)expr);
        final PsiMethod method=call.resolveMethod();
        if (method != null) {
          final PsiClass aClass=method.getContainingClass();
          final PsiTypeParameter[] aTypeParms=method.getTypeParameterList().getTypeParameters();
          final PsiParameter[] parameters=method.getParameterList().getParameters();
          final PsiExpression[] arguments=call.getArgumentList().getExpressions();
          final PsiExpression aQualifier=expr instanceof PsiMethodCallExpression ? ((PsiMethodCallExpression)expr).getMethodExpression().getQualifierExpression() : null;
          final HashSet<PsiTypeParameter> typeParameters=new HashSet<PsiTypeParameter>();
          for (int i=0; i < aTypeParms.length; i++) {
            typeParameters.add(aTypeParms[i]);
          }
          PsiSubstitutor qualifierSubstitutor=PsiSubstitutor.EMPTY;
          PsiSubstitutor supertypeSubstitutor=PsiSubstitutor.EMPTY;
          PsiType aType=null;
          if (method.isConstructor()) {
            if (isCooked(expr)) {
              aType=getType(expr);
              qualifierSubstitutor=Util.resolveType(aType).getSubstitutor();
            }
 else {
              final PsiClass cClass=method.getContainingClass();
              final PsiTypeParameter[] classParms=Util.getTypeParametersList(cClass);
              for (int i=0; i < classParms.length; i++) {
                final PsiTypeParameter classParm=classParms[i];
                final PsiTypeVariable var=myTypeVariableFactory.create();
                qualifierSubstitutor=qualifierSubstitutor.put(classParm,var);
              }
              aType=myManager.getElementFactory().createType(method.getContainingClass(),qualifierSubstitutor);
            }
          }
 else {
            aType=getType(method);
          }
          if (aQualifier != null) {
            final PsiType qualifierType=evaluateType(aQualifier);
            final PsiClassType.ClassResolveResult result=Util.resolveType(qualifierType);
            if (result.getElement() != null) {
              final PsiClass qualifierClass=result.getElement();
              qualifierSubstitutor=result.getSubstitutor();
              if (!qualifierClass.equals(aClass)) {
                supertypeSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(aClass,qualifierClass,PsiSubstitutor.EMPTY);
                aType=Util.substituteType(aType,supertypeSubstitutor);
              }
              aType=Util.substituteType(aType,qualifierSubstitutor);
            }
          }
          final HashMap<PsiTypeParameter,PsiType> mapping=new HashMap<PsiTypeParameter,PsiType>();
          for (int i=0; i < Math.min(parameters.length,arguments.length); i++) {
            final PsiType argumenType=evaluateType(arguments[i]);
            PsiType parmType=null;
            if (isCooked(parameters[i])) {
              parmType=getType(parameters[i]);
              system.addSubtypeConstraint(argumenType,parmType);
            }
 else {
              parmType=Util.substituteType(Util.substituteType(parameters[i].getType(),supertypeSubstitutor),qualifierSubstitutor);
              if (!Util.bindsTypeVariables(parmType) && !Util.bindsTypeParameters(parmType,typeParameters)) {
                parmType=Util.banalize(parmType);
              }
              final PsiType theType=new Object(){
                PsiType introduceAdditionalTypeVariables(                final PsiType type,                final PsiSubstitutor qualifier,                final PsiSubstitutor supertype){
                  final int level=type.getArrayDimensions();
                  final PsiClassType.ClassResolveResult result=Util.resolveType(type);
                  final PsiClass aClass=result.getElement();
                  if (aClass != null) {
                    if (aClass instanceof PsiTypeParameter) {
                      final PsiTypeParameter tp=((PsiTypeParameter)aClass);
                      final PsiClassType[] extypes=tp.getExtendsListTypes();
                      PsiType pv=mapping.get(tp);
                      if (pv == null) {
                        pv=myTypeVariableFactory.create();
                        mapping.put(tp,pv);
                      }
                      for (int j=0; j < extypes.length; j++) {
                        final PsiClassType ext=extypes[j];
                        final PsiType extype=Util.substituteType(new Object(){
                          public PsiType substitute(                          final PsiType ext){
                            final PsiClassType.ClassResolveResult result=Util.resolveType(ext);
                            final PsiClass aClass=result.getElement();
                            if (aClass != null) {
                              if (aClass instanceof PsiTypeParameter) {
                                final PsiType type=mapping.get(aClass);
                                if (type != null) {
                                  return type;
                                }
                                return ext;
                              }
                              final PsiSubstitutor aSubst=result.getSubstitutor();
                              PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
                              for (final Iterator<PsiTypeParameter> p=aSubst.getSubstitutionMap().keySet().iterator(); p.hasNext(); ) {
                                final PsiTypeParameter parm=p.next();
                                PsiType type=aSubst.substitute(parm);
                                if (type != null) {
                                  type=substitute(type);
                                }
                                theSubst=theSubst.put(parm,type);
                              }
                              return aClass.getManager().getElementFactory().createType(aClass,theSubst);
                            }
                            return ext;
                          }
                        }
.substitute(ext),qualifier);
                        system.addSubtypeConstraint(pv,extype);
                      }
                      return Util.createArrayType(pv,level);
                    }
                    final Map<PsiTypeParameter,PsiType> substitutionMap=result.getSubstitutor().getSubstitutionMap();
                    PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
                    for (Iterator<PsiTypeParameter> t=substitutionMap.keySet().iterator(); t.hasNext(); ) {
                      final PsiTypeParameter p=t.next();
                      final PsiType pType=substitutionMap.get(p);
                      if (pType instanceof PsiWildcardType) {
                        final PsiWildcardType wildcard=((PsiWildcardType)pType);
                        final PsiType theBound=wildcard.getBound();
                        if (theBound != null) {
                          final PsiType bound=Util.substituteType(Util.substituteType(theBound,supertype),qualifier);
                          if (Util.bindsTypeVariables(bound)) {
                            final PsiType var=myTypeVariableFactory.create();
                            if (wildcard.isExtends()) {
                              system.addSubtypeConstraint(var,bound);
                            }
 else {
                              system.addSubtypeConstraint(bound,var);
                            }
                            theSubst=theSubst.put(p,var);
                          }
 else                           if (Util.bindsTypeParameters(bound,typeParameters)) {
                            final PsiType var=myTypeVariableFactory.create();
                            PsiSubstitutor subst=PsiSubstitutor.EMPTY;
                            for (int i=0; i < aTypeParms.length; i++) {
                              final PsiTypeParameter aTypeParm=aTypeParms[i];
                              PsiType parmVar=mapping.get(aTypeParm);
                              if (parmVar == null) {
                                parmVar=myTypeVariableFactory.create();
                                mapping.put(aTypeParm,parmVar);
                              }
                              subst=subst.put(aTypeParm,parmVar);
                            }
                            final PsiType bnd=Util.substituteType(bound,subst);
                            if (wildcard.isExtends()) {
                              system.addSubtypeConstraint(bnd,var);
                            }
 else {
                              system.addSubtypeConstraint(var,bnd);
                            }
                            theSubst=theSubst.put(p,var);
                          }
 else {
                            theSubst=theSubst.put(p,pType);
                          }
                        }
                      }
 else {
                        theSubst=theSubst.put(p,introduceAdditionalTypeVariables(pType,qualifier,supertype));
                      }
                    }
                    return Util.createArrayType(aClass.getManager().getElementFactory().createType(aClass,theSubst),level);
                  }
                  return Util.createArrayType(type,level);
                }
              }
.introduceAdditionalTypeVariables(parmType,qualifierSubstitutor,supertypeSubstitutor);
              system.addSubtypeConstraint(argumenType,theType);
            }
          }
          final PsiType rawType=expr.getType();
          if (rawType != null) {
            new Object(){
              void traversePair(              final PsiType aType,              final PsiType rawType){
                final PsiClassType.ClassResolveResult aResult=Util.resolveType(aType);
                final PsiClassType.ClassResolveResult rawResult=Util.resolveType(rawType);
                final PsiClass aClass=aResult.getElement();
                final PsiClass rawClass=rawResult.getElement();
                if (rawClass != null && aClass != null) {
                  if (typeParameters.contains(aClass)) {
                    final PsiTypeParameter parm=(PsiTypeParameter)aClass;
                    if (mapping.get(parm) == null) {
                      mapping.put(parm,rawType);
                    }
                    return;
                  }
                  final PsiSubstitutor rawSubst=rawResult.getSubstitutor();
                  final PsiSubstitutor aSubat=aResult.getSubstitutor();
                  for (final Iterator<PsiTypeParameter> p=rawSubst.getSubstitutionMap().keySet().iterator(); p.hasNext(); ) {
                    final PsiTypeParameter parm=p.next();
                    final PsiType a=aSubat.substitute(parm);
                    final PsiType raw=rawSubst.substitute(parm);
                    if (a != null && raw != null) {
                      traversePair(a,raw);
                    }
                  }
                }
              }
            }
.traversePair(aType,rawType);
          }
          PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
          for (Iterator<PsiTypeParameter> i=mapping.keySet().iterator(); i.hasNext(); ) {
            final PsiTypeParameter parm=i.next();
            final PsiType type=mapping.get(parm);
            theSubst=theSubst.put(parm,type);
          }
          return Util.substituteType(aType,theSubst);
        }
      }
 else       if (expr instanceof PsiParenthesizedExpression) {
        return evaluateType(((PsiParenthesizedExpression)expr).getExpression());
      }
 else       if (expr instanceof PsiConditionalExpression) {
        return evaluateType(((PsiConditionalExpression)expr).getThenExpression());
      }
 else       if (expr instanceof PsiNewExpression) {
        final PsiExpression qualifier=((PsiNewExpression)expr).getQualifier();
        if (qualifier != null) {
          final PsiClassType.ClassResolveResult qualifierResult=Util.resolveType(evaluateType(qualifier));
          if (qualifierResult.getElement() != null) {
            final PsiSubstitutor qualifierSubs=qualifierResult.getSubstitutor();
            final PsiClassType.ClassResolveResult result=Util.resolveType(expr.getType());
            if (result.getElement() != null) {
              final PsiClass aClass=result.getElement();
              return aClass.getManager().getElementFactory().createType(aClass,result.getSubstitutor().putAll(qualifierSubs));
            }
          }
        }
      }
 else       if (expr instanceof PsiReferenceExpression) {
        final PsiReferenceExpression ref=((PsiReferenceExpression)expr);
        final PsiExpression qualifier=ref.getQualifierExpression();
        if (qualifier == null) {
          return getType(ref.resolve());
        }
 else {
          final PsiType qualifierType=evaluateType(qualifier);
          final PsiElement element=ref.resolve();
          final PsiClassType.ClassResolveResult result=Util.resolveType(qualifierType);
          if (result.getElement() != null) {
            final PsiClass aClass=result.getElement();
            final PsiSubstitutor aSubst=result.getSubstitutor();
            if (element instanceof PsiField) {
              final PsiField field=(PsiField)element;
              final PsiType fieldType=getType(field);
              final PsiClass superClass=field.getContainingClass();
              PsiType aType=fieldType;
              if (!aClass.equals(superClass) && field.isPhysical()) {
                aType=Util.substituteType(aType,TypeConversionUtil.getSuperClassSubstitutor(superClass,aClass,PsiSubstitutor.EMPTY));
              }
              return Util.substituteType(aType,aSubst);
            }
          }
 else           if (element != null) {
            return getType(element);
          }
        }
      }
      return getType(expr);
    }
  }
  final TypeEvaluator e=new TypeEvaluator();
  if (element instanceof PsiVariable) {
    final PsiExpression initializer=((PsiVariable)element).getInitializer();
    if (initializer != null) {
      final PsiExpression core=new Object(){
        PsiExpression undress(        final PsiExpression expr){
          if (expr instanceof PsiParenthesizedExpression) {
            return undress(((PsiParenthesizedExpression)expr).getExpression());
          }
          return expr;
        }
      }
.undress(initializer);
      if (core instanceof PsiArrayInitializerExpression) {
        final PsiExpression[] inits=((PsiArrayInitializerExpression)core).getInitializers();
        final PsiType type=getType(element);
        for (int i=0; i < inits.length; i++) {
          system.addSubtypeConstraint(e.valuateType(inits[i]).createArrayType(),type);
        }
      }
 else       if (core instanceof PsiNewExpression) {
        final PsiArrayInitializerExpression init=((PsiNewExpression)core).getArrayInitializer();
        if (init != null) {
          final PsiExpression[] inits=init.getInitializers();
          final PsiType type=getType(element);
          for (int i=0; i < inits.length; i++) {
            system.addSubtypeConstraint(e.valuateType(inits[i]).createArrayType(),type);
          }
        }
        system.addSubtypeConstraint(e.valuateType(core),getType(element));
      }
 else {
        system.addSubtypeConstraint(e.valuateType(core),getType(element));
      }
    }
    if (element instanceof PsiParameter) {
      final PsiMethod method=PsiTreeUtil.getParentOfType(element,PsiMethod.class);
      if (method != null) {
        final PsiSearchHelper helper=myManager.getSearchHelper();
        final PsiReference[] refs=helper.findReferences(method,helper.getUseScope(method),true);
        for (int i=0; i < refs.length; i++) {
          final PsiElement ref=refs[i].getElement();
          if (ref != null) {
            final PsiCallExpression call=PsiTreeUtil.getParentOfType(ref,PsiCallExpression.class);
            if (call != null) {
              final PsiExpression arg=call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex((PsiParameter)element)];
              system.addSubtypeConstraint(e.valuateType(arg),myTypes.get(element));
            }
          }
        }
      }
    }
    return;
  }
 else   if (element instanceof PsiMethod) {
    final PsiType reType=getType(element);
    element.accept(new PsiRecursiveElementVisitor(){
      public void visitReturnStatement(      final PsiReturnStatement statement){
        super.visitReturnStatement(statement);
        final PsiExpression retExpr=statement.getReturnValue();
        if (retExpr != null) {
          system.addSubtypeConstraint(e.valuateType(retExpr),reType);
        }
      }
    }
);
    return;
  }
  final PsiStatement root=(PsiStatement)PsiTreeUtil.getParentOfType(element,PsiStatement.class);
  if (root != null) {
    final PsiAnchor anchor=new PsiAnchor(root);
    if (!myVisitedConstructions.contains(anchor)) {
      root.accept(new PsiRecursiveElementVisitor(){
        public void visitAssignmentExpression(        final PsiAssignmentExpression expression){
          super.visitAssignmentExpression(expression);
          system.addSubtypeConstraint(e.valuateType(expression.getRExpression()),e.valuateType(expression.getLExpression()));
        }
        public void visitConditionalExpression(        final PsiConditionalExpression expression){
          super.visitConditionalExpression(expression);
          system.addSubtypeConstraint(e.valuateType(expression.getThenExpression()),e.valuateType(expression.getElseExpression()));
          system.addSubtypeConstraint(e.valuateType(expression.getElseExpression()),e.valuateType(expression.getThenExpression()));
        }
        public void visitCallExpression(        final PsiCallExpression expression){
          super.visitCallExpression(expression);
          e.valuateType(expression);
        }
        public void visitReturnStatement(        final PsiReturnStatement statement){
          super.visitReturnStatement(statement);
          final PsiMethod method=PsiTreeUtil.getParentOfType(statement,PsiMethod.class);
          if (method != null) {
            system.addSubtypeConstraint(e.valuateType(statement.getReturnValue()),getType(method));
          }
        }
        public void visitTypeCastExpression(        final PsiTypeCastExpression expression){
          super.visitTypeCastExpression(expression);
          system.addCast(expression);
          final PsiType operandType=e.valuateType(expression.getOperand());
          final PsiType castType=e.valuateType(expression);
          if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {
            system.addSubtypeConstraint(operandType,castType);
          }
 else {
            final PsiClassType.ClassResolveResult operandResult=Util.resolveType(operandType);
            final PsiClassType.ClassResolveResult castResult=Util.resolveType(castType);
            final PsiClass operandClass=operandResult.getElement();
            final PsiClass castClass=castResult.getElement();
            if (operandClass != null && castClass != null) {
              if (InheritanceUtil.isCorrectDescendant(operandClass,castClass,true)) {
                system.addSubtypeConstraint(operandType,castType);
              }
            }
          }
        }
        public void visitVariable(        final PsiVariable variable){
          super.visitVariable(variable);
          final PsiExpression init=variable.getInitializer();
          if (init != null) {
            system.addSubtypeConstraint(e.valuateType(init),getType(variable));
          }
        }
        public void visitNewExpression(        final PsiNewExpression expression){
          super.visitNewExpression(expression);
          final PsiArrayInitializerExpression init=expression.getArrayInitializer();
          if (init != null) {
            final PsiExpression[] inits=init.getInitializers();
            final PsiType type=getType(expression);
            for (int i=0; i < inits.length; i++) {
              system.addSubtypeConstraint(e.valuateType(inits[i]).createArrayType(),type);
            }
          }
        }
        public void visitReferenceExpression(        final PsiReferenceExpression expression){
          final PsiExpression qualifierExpression=expression.getQualifierExpression();
          if (qualifierExpression != null) {
            qualifierExpression.accept(this);
          }
        }
      }
);
      myVisitedConstructions.add(anchor);
    }
  }
}
