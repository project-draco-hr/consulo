{
class TypeEvaluator {
    public PsiType inferTypeForMethodTypeParameter(    final PsiTypeParameter typeParameter,    final PsiParameter[] parameters,    PsiExpression[] arguments,    PsiSubstitutor partialSubstitutor,    PsiElement parent){
      PsiType substitution=PsiType.NULL;
      PsiResolveHelper helper=typeParameter.getManager().getResolveHelper();
      if (parameters.length > 0) {
        for (int j=0; j < arguments.length; j++) {
          PsiExpression argument=arguments[j];
          final PsiParameter parameter=parameters[Math.min(j,parameters.length - 1)];
          if (j >= parameters.length && !parameter.isVarArgs())           break;
          PsiType parameterType=parameter.getType();
          PsiType argumentType=evaluateType(argument);
          if (parameterType instanceof PsiEllipsisType) {
            parameterType=((PsiEllipsisType)parameterType).getComponentType();
            if (arguments.length == parameters.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {
              argumentType=((PsiArrayType)argumentType).getComponentType();
            }
          }
          final PsiType currentSubstitution=helper.getSubstitutionForTypeParameter(typeParameter,parameterType,argumentType,true);
          if (currentSubstitution == null) {
            substitution=null;
            break;
          }
 else           if (currentSubstitution instanceof PsiWildcardType) {
            if (substitution instanceof PsiWildcardType)             return PsiType.NULL;
          }
 else           if (currentSubstitution == PsiType.NULL)           continue;
          if (substitution == PsiType.NULL) {
            substitution=currentSubstitution;
            continue;
          }
          if (!substitution.equals(currentSubstitution)) {
            if (substitution instanceof PsiTypeVariable || currentSubstitution instanceof PsiTypeVariable || !substitution.isAssignableFrom(currentSubstitution)) {
              substitution=GenericsUtil.getLeastUpperBound(substitution,currentSubstitution,typeParameter.getManager());
              if (substitution == null) {
                break;
              }
            }
          }
        }
      }
      if (substitution == PsiType.NULL) {
        substitution=inferMethodTypeParameterFromParent(typeParameter,partialSubstitutor,parent);
      }
      return substitution;
    }
    private PsiType inferMethodTypeParameterFromParent(    final PsiTypeParameter typeParameter,    PsiSubstitutor substitutor,    PsiElement parent){
      PsiTypeParameterListOwner owner=typeParameter.getOwner();
      PsiType substitution=PsiType.NULL;
      if (owner instanceof PsiMethod) {
        if (parent instanceof PsiMethodCallExpression) {
          PsiMethodCallExpression methodCall=(PsiMethodCallExpression)parent;
          substitution=inferMethodTypeParameterFromParent(methodCall.getParent(),methodCall,typeParameter,substitutor);
        }
      }
      return substitution;
    }
    private PsiType inferMethodTypeParameterFromParent(    PsiElement parent,    PsiMethodCallExpression methodCall,    final PsiTypeParameter typeParameter,    PsiSubstitutor substitutor){
      PsiType type=null;
      if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {
        type=getType(parent);
      }
 else       if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {
        type=evaluateType(((PsiAssignmentExpression)parent).getLExpression());
      }
 else       if (parent instanceof PsiTypeCastExpression && methodCall.equals(((PsiTypeCastExpression)parent).getOperand())) {
        type=evaluateType((PsiExpression)parent);
      }
 else       if (parent instanceof PsiReturnStatement) {
        PsiMethod method=PsiTreeUtil.getParentOfType(parent,PsiMethod.class);
        if (method != null) {
          type=getType(method);
        }
      }
      if (type == null) {
        type=PsiType.getJavaLangObject(methodCall.getManager(),methodCall.getResolveScope());
      }
      PsiType returnType=((PsiMethod)typeParameter.getOwner()).getReturnType();
      PsiType guess=parent.getManager().getResolveHelper().getSubstitutionForTypeParameter(typeParameter,returnType,type,false);
      if (guess == PsiType.NULL) {
        PsiType superType=substitutor.substitute(typeParameter.getSuperTypes()[0]);
        return superType == null ? PsiType.getJavaLangObject(methodCall.getManager(),methodCall.getResolveScope()) : superType;
      }
      if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {
        PsiClassType[] extendsTypes=typeParameter.getExtendsListTypes();
        PsiSubstitutor newSubstitutor=substitutor.put(typeParameter,guess);
        for (int i=0; i < extendsTypes.length; i++) {
          PsiType extendsType=newSubstitutor.substitute(extendsTypes[i]);
          if (!extendsType.isAssignableFrom(guess)) {
            if (guess.isAssignableFrom(extendsType)) {
              guess=extendsType;
              newSubstitutor=substitutor.put(typeParameter,guess);
            }
 else {
              break;
            }
          }
        }
      }
      return guess;
    }
    PsiType evaluateType(    final PsiExpression expr){
      if (expr instanceof PsiArrayAccessExpression && !mySettings.preserveRawArrays()) {
        final PsiType at=evaluateType(((PsiArrayAccessExpression)expr).getArrayExpression());
        if (at instanceof PsiArrayType) {
          return ((PsiArrayType)at).getComponentType();
        }
      }
 else       if (expr instanceof PsiAssignmentExpression) {
        return evaluateType(((PsiAssignmentExpression)expr).getLExpression());
      }
 else       if (expr instanceof PsiCallExpression) {
        final PsiCallExpression call=((PsiCallExpression)expr);
        final PsiMethod method=call.resolveMethod();
        if (method != null) {
          final PsiClass aClass=method.getContainingClass();
          final PsiTypeParameter[] methodTypeParams=method.getTypeParameters();
          final PsiParameter[] parameters=method.getParameterList().getParameters();
          final PsiExpression[] arguments=call.getArgumentList().getExpressions();
          final PsiExpression aQualifier=expr instanceof PsiMethodCallExpression ? ((PsiMethodCallExpression)expr).getMethodExpression().getQualifierExpression() : null;
          final HashSet<PsiTypeParameter> typeParameters=new HashSet<PsiTypeParameter>(Arrays.asList(methodTypeParams));
          PsiSubstitutor qualifierSubstitutor=PsiSubstitutor.EMPTY;
          PsiSubstitutor supertypeSubstitutor=PsiSubstitutor.EMPTY;
          PsiType aType;
          if (method.isConstructor()) {
            if (isCooked(expr)) {
              aType=getType(expr);
              qualifierSubstitutor=Util.resolveType(aType).getSubstitutor();
            }
 else {
              final PsiClass cClass=method.getContainingClass();
              final Iterator<PsiTypeParameter> iterator=PsiUtil.typeParametersIterator(cClass);
              while (iterator.hasNext()) {
                final PsiTypeParameter classParm=iterator.next();
                final PsiTypeVariable var=myTypeVariableFactory.create();
                qualifierSubstitutor=qualifierSubstitutor.put(classParm,var);
              }
              aType=myManager.getElementFactory().createType(method.getContainingClass(),qualifierSubstitutor);
            }
          }
 else {
            aType=getType(method);
          }
          if (aQualifier != null) {
            final PsiType qualifierType=evaluateType(aQualifier);
            final PsiClassType.ClassResolveResult result=Util.resolveType(qualifierType);
            if (result.getElement() != null) {
              final PsiClass qualifierClass=result.getElement();
              qualifierSubstitutor=TypeConversionUtil.getClassSubstitutor(aClass,qualifierClass,result.getSubstitutor());
              if (qualifierSubstitutor != null) {
                aType=qualifierSubstitutor.substitute(aType);
              }
            }
          }
          final HashMap<PsiTypeParameter,PsiType> mapping=new HashMap<PsiTypeParameter,PsiType>();
          for (int i=0; i < Math.min(parameters.length,arguments.length); i++) {
            final PsiType argumentType=evaluateType(arguments[i]);
            PsiType parmType;
            if (isCooked(parameters[i])) {
              parmType=getType(parameters[i]);
              system.addSubtypeConstraint(argumentType,parmType);
            }
 else {
              parmType=qualifierSubstitutor.substitute(supertypeSubstitutor.substitute(parameters[i].getType()));
              if (!Util.bindsTypeVariables(parmType) && !Util.bindsTypeParameters(parmType,typeParameters)) {
                parmType=Util.banalize(parmType);
              }
              final PsiType theType=new Object(){
                PsiType introduceAdditionalTypeVariables(                final PsiType type,                final PsiSubstitutor qualifier,                final PsiSubstitutor supertype){
                  final int level=type.getArrayDimensions();
                  final PsiClassType.ClassResolveResult result=Util.resolveType(type);
                  final PsiClass aClass=result.getElement();
                  if (aClass != null) {
                    if (aClass instanceof PsiTypeParameter) {
                      final PsiTypeParameter tp=((PsiTypeParameter)aClass);
                      final PsiClassType[] extypes=tp.getExtendsListTypes();
                      PsiType pv=mapping.get(tp);
                      if (pv == null) {
                        pv=myTypeVariableFactory.create();
                        mapping.put(tp,pv);
                      }
                      for (int j=0; j < extypes.length; j++) {
                        final PsiClassType ext=extypes[j];
                        final PsiType extype=qualifier.substitute(new Object(){
                          public PsiType substitute(                          final PsiType ext){
                            final PsiClassType.ClassResolveResult result=Util.resolveType(ext);
                            final PsiClass aClass=result.getElement();
                            if (aClass != null) {
                              if (aClass instanceof PsiTypeParameter) {
                                final PsiType type=mapping.get(aClass);
                                if (type != null) {
                                  return type;
                                }
                                return ext;
                              }
                              final PsiSubstitutor aSubst=result.getSubstitutor();
                              PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
                              for (final Iterator<PsiTypeParameter> p=aSubst.getSubstitutionMap().keySet().iterator(); p.hasNext(); ) {
                                final PsiTypeParameter parm=p.next();
                                PsiType type=aSubst.substitute(parm);
                                if (type != null) {
                                  type=substitute(type);
                                }
                                theSubst=theSubst.put(parm,type);
                              }
                              return aClass.getManager().getElementFactory().createType(aClass,theSubst);
                            }
                            return ext;
                          }
                        }
.substitute(ext));
                        system.addSubtypeConstraint(pv,extype);
                      }
                      return Util.createArrayType(pv,level);
                    }
                    final Map<PsiTypeParameter,PsiType> substitutionMap=result.getSubstitutor().getSubstitutionMap();
                    PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
                    for (Iterator<PsiTypeParameter> t=substitutionMap.keySet().iterator(); t.hasNext(); ) {
                      final PsiTypeParameter p=t.next();
                      final PsiType pType=substitutionMap.get(p);
                      if (pType instanceof PsiWildcardType) {
                        final PsiWildcardType wildcard=((PsiWildcardType)pType);
                        final PsiType theBound=wildcard.getBound();
                        if (theBound != null) {
                          final PsiType bound=qualifier.substitute(supertype.substitute(theBound));
                          if (Util.bindsTypeVariables(bound)) {
                            final PsiType var=myTypeVariableFactory.create();
                            if (wildcard.isExtends()) {
                              system.addSubtypeConstraint(var,bound);
                            }
 else {
                              system.addSubtypeConstraint(bound,var);
                            }
                            theSubst=theSubst.put(p,var);
                          }
 else                           if (Util.bindsTypeParameters(bound,typeParameters)) {
                            final PsiType var=myTypeVariableFactory.create();
                            PsiSubstitutor subst=PsiSubstitutor.EMPTY;
                            for (int i=0; i < methodTypeParams.length; i++) {
                              final PsiTypeParameter aTypeParm=methodTypeParams[i];
                              PsiType parmVar=mapping.get(aTypeParm);
                              if (parmVar == null) {
                                parmVar=myTypeVariableFactory.create();
                                mapping.put(aTypeParm,parmVar);
                              }
                              subst=subst.put(aTypeParm,parmVar);
                            }
                            final PsiType bnd=subst.substitute(bound);
                            if (wildcard.isExtends()) {
                              system.addSubtypeConstraint(bnd,var);
                            }
 else {
                              system.addSubtypeConstraint(var,bnd);
                            }
                            theSubst=theSubst.put(p,var);
                          }
 else {
                            theSubst=theSubst.put(p,pType);
                          }
                        }
                      }
 else {
                        theSubst=theSubst.put(p,introduceAdditionalTypeVariables(pType,qualifier,supertype));
                      }
                    }
                    return Util.createArrayType(aClass.getManager().getElementFactory().createType(aClass,theSubst),level);
                  }
                  return Util.createArrayType(type,level);
                }
              }
.introduceAdditionalTypeVariables(parmType,qualifierSubstitutor,supertypeSubstitutor);
              system.addSubtypeConstraint(argumentType,theType);
            }
          }
          PsiSubstitutor theSubst=PsiSubstitutor.EMPTY;
          for (Iterator<PsiTypeParameter> i=mapping.keySet().iterator(); i.hasNext(); ) {
            final PsiTypeParameter parm=i.next();
            final PsiType type=mapping.get(parm);
            theSubst=theSubst.put(parm,type);
          }
          for (int i=0; i < methodTypeParams.length; i++) {
            PsiTypeParameter typeParam=methodTypeParams[i];
            final PsiType inferred=inferTypeForMethodTypeParameter(typeParam,parameters,arguments,theSubst,expr);
            theSubst=theSubst.put(typeParam,inferred);
          }
          return theSubst.substitute(aType);
        }
      }
 else       if (expr instanceof PsiParenthesizedExpression) {
        return evaluateType(((PsiParenthesizedExpression)expr).getExpression());
      }
 else       if (expr instanceof PsiConditionalExpression) {
        return evaluateType(((PsiConditionalExpression)expr).getThenExpression());
      }
 else       if (expr instanceof PsiReferenceExpression) {
        final PsiReferenceExpression ref=((PsiReferenceExpression)expr);
        final PsiExpression qualifier=ref.getQualifierExpression();
        if (qualifier == null) {
          return getType(ref.resolve());
        }
 else {
          final PsiType qualifierType=evaluateType(qualifier);
          final PsiElement element=ref.resolve();
          final PsiClassType.ClassResolveResult result=Util.resolveType(qualifierType);
          if (result.getElement() != null) {
            final PsiClass aClass=result.getElement();
            final PsiSubstitutor aSubst=result.getSubstitutor();
            if (element instanceof PsiField) {
              final PsiField field=(PsiField)element;
              final PsiType fieldType=getType(field);
              final PsiClass superClass=field.getContainingClass();
              PsiType aType=fieldType;
              if (!aClass.equals(superClass) && field.isPhysical()) {
                aType=TypeConversionUtil.getSuperClassSubstitutor(superClass,aClass,PsiSubstitutor.EMPTY).substitute(aType);
              }
              return aSubst.substitute(aType);
            }
          }
 else           if (element != null) {
            return getType(element);
          }
        }
      }
      return getType(expr);
    }
  }
  final TypeEvaluator e=new TypeEvaluator();
  if (element instanceof PsiVariable) {
    final PsiExpression initializer=((PsiVariable)element).getInitializer();
    if (initializer != null) {
      final PsiExpression core=deparenthesizeExpression(initializer);
      if (core instanceof PsiArrayInitializerExpression) {
        final PsiExpression[] inits=((PsiArrayInitializerExpression)core).getInitializers();
        final PsiType type=getType(element);
        for (int i=0; i < inits.length; i++) {
          system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(),type);
        }
      }
 else       if (core instanceof PsiNewExpression) {
        final PsiArrayInitializerExpression init=((PsiNewExpression)core).getArrayInitializer();
        if (init != null) {
          final PsiExpression[] inits=init.getInitializers();
          final PsiType type=getType(element);
          for (int i=0; i < inits.length; i++) {
            system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(),type);
          }
        }
        system.addSubtypeConstraint(e.evaluateType(core),getType(element));
      }
 else {
        system.addSubtypeConstraint(e.evaluateType(core),getType(element));
      }
    }
    if (element instanceof PsiParameter) {
      final PsiMethod method=PsiTreeUtil.getParentOfType(element,PsiMethod.class);
      if (method != null) {
        final PsiSearchHelper helper=myManager.getSearchHelper();
        final PsiReference[] refs=helper.findReferences(method,helper.getUseScope(method),true);
        for (int i=0; i < refs.length; i++) {
          final PsiElement ref=refs[i].getElement();
          if (ref != null) {
            final PsiCallExpression call=PsiTreeUtil.getParentOfType(ref,PsiCallExpression.class);
            if (call != null) {
              final PsiExpression arg=call.getArgumentList().getExpressions()[method.getParameterList().getParameterIndex((PsiParameter)element)];
              system.addSubtypeConstraint(e.evaluateType(arg),myTypes.get(element));
            }
          }
        }
      }
    }
    return;
  }
 else   if (element instanceof PsiMethod) {
    final PsiType reType=getType(element);
    element.accept(new PsiRecursiveElementVisitor(){
      public void visitReturnStatement(      final PsiReturnStatement statement){
        super.visitReturnStatement(statement);
        final PsiExpression retExpr=statement.getReturnValue();
        if (retExpr != null) {
          system.addSubtypeConstraint(e.evaluateType(retExpr),reType);
        }
      }
    }
);
    return;
  }
  final PsiStatement root=PsiTreeUtil.getParentOfType(element,PsiStatement.class);
  if (root != null) {
    final PsiAnchor anchor=new PsiAnchor(root);
    if (!myVisitedConstructions.contains(anchor)) {
      root.accept(new PsiRecursiveElementVisitor(){
        public void visitAssignmentExpression(        final PsiAssignmentExpression expression){
          super.visitAssignmentExpression(expression);
          system.addSubtypeConstraint(e.evaluateType(expression.getRExpression()),e.evaluateType(expression.getLExpression()));
        }
        public void visitConditionalExpression(        final PsiConditionalExpression expression){
          super.visitConditionalExpression(expression);
          system.addSubtypeConstraint(e.evaluateType(expression.getThenExpression()),e.evaluateType(expression.getElseExpression()));
          system.addSubtypeConstraint(e.evaluateType(expression.getElseExpression()),e.evaluateType(expression.getThenExpression()));
        }
        public void visitCallExpression(        final PsiCallExpression expression){
          super.visitCallExpression(expression);
          e.evaluateType(expression);
        }
        public void visitReturnStatement(        final PsiReturnStatement statement){
          super.visitReturnStatement(statement);
          final PsiMethod method=PsiTreeUtil.getParentOfType(statement,PsiMethod.class);
          if (method != null) {
            system.addSubtypeConstraint(e.evaluateType(statement.getReturnValue()),getType(method));
          }
        }
        public void visitTypeCastExpression(        final PsiTypeCastExpression expression){
          super.visitTypeCastExpression(expression);
          final PsiType operandType=e.evaluateType(expression.getOperand());
          final PsiType castType=e.evaluateType(expression);
          if (operandType == null || castType == null)           return;
          if (Util.bindsTypeVariables(operandType)) {
            system.addCast(expression);
          }
          if (operandType.getDeepComponentType() instanceof PsiTypeVariable || castType.getDeepComponentType() instanceof PsiTypeVariable) {
            system.addSubtypeConstraint(operandType,castType);
          }
 else {
            final PsiClassType.ClassResolveResult operandResult=Util.resolveType(operandType);
            final PsiClassType.ClassResolveResult castResult=Util.resolveType(castType);
            final PsiClass operandClass=operandResult.getElement();
            final PsiClass castClass=castResult.getElement();
            if (operandClass != null && castClass != null) {
              if (InheritanceUtil.isCorrectDescendant(operandClass,castClass,true)) {
                system.addSubtypeConstraint(operandType,castType);
              }
            }
          }
        }
        public void visitVariable(        final PsiVariable variable){
          super.visitVariable(variable);
          final PsiExpression init=variable.getInitializer();
          if (init != null) {
            system.addSubtypeConstraint(e.evaluateType(init),getType(variable));
          }
        }
        public void visitNewExpression(        final PsiNewExpression expression){
          super.visitNewExpression(expression);
          final PsiArrayInitializerExpression init=expression.getArrayInitializer();
          if (init != null) {
            final PsiExpression[] inits=init.getInitializers();
            final PsiType type=getType(expression);
            for (int i=0; i < inits.length; i++) {
              system.addSubtypeConstraint(e.evaluateType(inits[i]).createArrayType(),type);
            }
          }
        }
        public void visitReferenceExpression(        final PsiReferenceExpression expression){
          final PsiExpression qualifierExpression=expression.getQualifierExpression();
          if (qualifierExpression != null) {
            qualifierExpression.accept(this);
          }
        }
      }
);
      myVisitedConstructions.add(anchor);
    }
  }
}
