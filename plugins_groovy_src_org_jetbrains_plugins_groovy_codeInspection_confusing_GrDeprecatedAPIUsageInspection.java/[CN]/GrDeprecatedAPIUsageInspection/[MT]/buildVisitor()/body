{
  return new BaseInspectionVisitor(){
    @Override public void visitReferenceExpression(    GrReferenceExpression ref){
      super.visitReferenceExpression(ref);
      checkRef(ref);
    }
    @Override public void visitCodeReferenceElement(    GrCodeReferenceElement ref){
      super.visitCodeReferenceElement(ref);
      checkRef(ref);
    }
    private void checkRef(    GrReferenceElement ref){
      PsiElement resolved=ref.resolve();
      if (isDeprecated(resolved)) {
        PsiElement toHighlight=getElementToHighlight(ref);
        registerError(toHighlight,GroovyBundle.message("0.is.deprecated",ref.getReferenceName()),LocalQuickFix.EMPTY_ARRAY,ProblemHighlightType.LIKE_DEPRECATED);
      }
    }
    @NotNull public PsiElement getElementToHighlight(    @NotNull GrReferenceElement refElement){
      final PsiElement refNameElement=refElement.getReferenceNameElement();
      return refNameElement != null ? refNameElement : refElement;
    }
    private boolean isDeprecated(    PsiElement resolved){
      if (resolved instanceof PsiDocCommentOwner && PsiImplUtil.isDeprecatedByDocTag((PsiDocCommentOwner)resolved)) {
        return true;
      }
      if (resolved instanceof PsiModifierListOwner && PsiImplUtil.isDeprecatedByAnnotation((PsiModifierListOwner)resolved)) {
        return true;
      }
      return false;
    }
  }
;
}
