{
  if (references.size() <= 1) {
    return references.toArray(new PsiReference[references.size()]);
  }
  Collections.sort(references,START_OFFSET_COMPARATOR);
  final List<PsiReference> intersecting=new ArrayList<PsiReference>();
  final List<PsiReference> notIntersecting=new ArrayList<PsiReference>();
  TextRange intersectingRange=references.get(0).getRangeInElement();
  boolean intersected=false;
  for (int i=1; i < references.size(); i++) {
    final PsiReference reference=references.get(i);
    final TextRange range=reference.getRangeInElement();
    final int offset=range.getStartOffset();
    if (intersectingRange.getStartOffset() <= offset && intersectingRange.getEndOffset() >= offset) {
      intersected=true;
      intersecting.add(references.get(i - 1));
      if (i == references.size() - 1) {
        intersecting.add(reference);
      }
      intersectingRange=intersectingRange.union(range);
    }
 else {
      if (intersected) {
        intersecting.add(references.get(i - 1));
        intersected=false;
      }
 else {
        notIntersecting.add(references.get(i - 1));
      }
      intersectingRange=range;
      if (i == references.size() - 1) {
        notIntersecting.add(reference);
      }
    }
  }
  List<PsiReference> result=doMerge(element,intersecting);
  result.addAll(notIntersecting);
  return result.toArray(new PsiReference[result.size()]);
}
