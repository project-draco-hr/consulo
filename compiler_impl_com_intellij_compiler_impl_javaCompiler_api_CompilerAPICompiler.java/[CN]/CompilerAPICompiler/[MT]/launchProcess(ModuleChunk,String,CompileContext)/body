{
  final IOException[] ex={null};
  @NonNls final List<String> commandLine=ApplicationManager.getApplication().runReadAction(new Computable<List<String>>(){
    public List<String> compute(){
      try {
        List<String> commandLine=new ArrayList<String>();
        JavacSettings javacSettings=JavacSettings.getInstance(myProject);
        final List<String> additionalOptions=JavacCompiler.addAdditionalSettings(commandLine,javacSettings,false,false,false,false,false);
        JavacCompiler.addCommandLineOptions(chunk,commandLine,outputDir,chunk.getJdk(),false,false,null,false,false);
        commandLine.addAll(additionalOptions);
        return commandLine;
      }
 catch (      IOException e) {
        ex[0]=e;
      }
      return null;
    }
  }
);
  if (ex[0] != null) {
    throw ex[0];
  }
  return new Process(){
    public OutputStream getOutputStream(){
      throw new UnsupportedOperationException();
    }
    public InputStream getInputStream(){
      return null;
    }
    public InputStream getErrorStream(){
      return null;
    }
    public void destroy(){
    }
    public int waitFor(){
      try {
        compile(commandLine,chunk,outputDir);
        myExitCode=0;
        return myExitCode;
      }
 catch (      Exception e) {
        compileContext.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
        myExitCode=-1;
        return -1;
      }
    }
    public int exitValue(){
      return myExitCode;
    }
  }
;
}
