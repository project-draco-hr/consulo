{
  final Project project=LangDataKeys.PROJECT.getData(e.getDataContext());
  final Set<String> answer=new HashSet<String>();
  final MultiMap<String,PsiExpression> calls=new MultiMap<String,PsiExpression>();
  final JavaPsiFacade psiFacade=JavaPsiFacade.getInstance(project);
  Processor<PsiReference> consumer=new Processor<PsiReference>(){
    @Override public boolean process(    PsiReference reference){
      PsiCallExpression call=PsiTreeUtil.getParentOfType(reference.getElement(),PsiCallExpression.class,false);
      if (call == null)       return true;
      if (call.getArgumentList() == null)       return true;
      if (call.getArgumentList().getExpressions() == null)       return true;
      PsiFile file=reference.getElement().getContainingFile();
      if ("AllIcons.java".equals(file.getName()))       return true;
      for (      PsiExpression arg : call.getArgumentList().getExpressions()) {
        if (arg instanceof PsiLiteralExpression) {
          Object value=((PsiLiteralExpression)arg).getValue();
          processValue(value,call,file);
        }
 else {
          Object value=psiFacade.getConstantEvaluationHelper().computeConstantExpression(arg,false);
          processValue(value,call,file);
        }
      }
      return true;
    }
    private void processValue(    Object value,    PsiCallExpression call,    PsiFile file){
      if (value instanceof String) {
        String str=(String)value;
        if (str.startsWith("\"")) {
          str=str.substring(0);
          if (str.endsWith("\"")) {
            str=str.substring(0,str.length() - 1);
          }
        }
        if (!str.startsWith("/")) {
          if (file instanceof PsiClassOwner) {
            str="/" + ((PsiClassOwner)file).getPackageName().replace('.','/') + "/"+ str;
          }
        }
        calls.putValue(str,call);
        answer.add(str);
      }
    }
  }
;
  GlobalSearchScope allScope=GlobalSearchScope.allScope(project);
  PsiClass iconLoader=psiFacade.findClass("com.intellij.openapi.util.IconLoader",allScope);
  PsiMethod getIconMethod=iconLoader.findMethodsByName("getIcon",false)[0];
  PsiMethod findIconMethod=iconLoader.findMethodsByName("findIcon",false)[0];
  if (true) {
    MethodReferencesSearch.search(getIconMethod,false).forEach(consumer);
    MethodReferencesSearch.search(findIconMethod,false).forEach(consumer);
  }
  final ProjectFileIndex index=ProjectRootManager.getInstance(project).getFileIndex();
  if (true) {
    PsiClass javaeeIcons=psiFacade.findClass("com.intellij.javaee.oss.JavaeeIcons",allScope);
    MethodReferencesSearch.search(javaeeIcons.findMethodsByName("getIcon",false)[0],false).forEach(consumer);
    MethodReferencesSearch.search(findIconMethod,false).forEach(consumer);
  }
  List<PsiClass> iconClasses=new ArrayList<PsiClass>();
  iconClasses.add(psiFacade.findClass("com.intellij.icons.AllIcons",allScope));
  for (  PsiClass iconClass : psiFacade.findPackage("icons").getClasses(allScope)) {
    if (iconClass.getName().endsWith("Icons")) {
      iconClasses.add(iconClass);
    }
  }
  final HashMap<String,String> mappings=new HashMap<String,String>();
  for (  PsiClass iconClass : iconClasses) {
    int size=mappings.size();
    collectFields(iconClass,"",mappings);
    System.out.println("Found " + (mappings.size() - size) + " icons in "+ iconClass.getQualifiedName());
  }
  final List<XmlAttribute> victims=new ArrayList<XmlAttribute>();
  PsiSearchHelper.SERVICE.getInstance(project).processAllFilesWithWordInText("icon",new DelegatingGlobalSearchScope(GlobalSearchScope.projectScope(project)){
    @Override public boolean contains(    VirtualFile file){
      return super.contains(file) && file.getFileType() == XmlFileType.INSTANCE && index.isInSource(file);
    }
  }
,new Processor<PsiFile>(){
    @Override public boolean process(    PsiFile file){
      file.accept(new XmlRecursiveElementVisitor(){
        @Override public void visitXmlTag(        XmlTag tag){
          super.visitXmlTag(tag);
          String icon=tag.getAttributeValue("icon");
          if (icon != null) {
            answer.add(icon);
            if (mappings.containsKey(icon)) {
              victims.add(tag.getAttribute("icon"));
            }
          }
        }
      }
);
      return true;
    }
  }
,true);
  for (  final XmlAttribute victim : victims) {
    String value=victim.getValue();
    final String replacement=mappings.get(value);
    if (replacement != null) {
      new WriteCommandAction<Void>(project,victim.getContainingFile()){
        @Override protected void run(        Result<Void> result) throws Throwable {
          victim.setValue(replacement);
        }
      }
.execute();
    }
  }
  PsiClass presentation=psiFacade.findClass("com.intellij.ide.presentation.Presentation",allScope);
  final MultiMap<String,PsiAnnotation> annotations=new MultiMap<String,PsiAnnotation>();
  AnnotationTargetsSearch.search(presentation).forEach(new Processor<PsiModifierListOwner>(){
    @Override public boolean process(    PsiModifierListOwner owner){
      PsiAnnotation annotation=owner.getModifierList().findAnnotation("com.intellij.ide.presentation.Presentation");
      PsiAnnotationMemberValue icon=annotation.findAttributeValue("icon");
      if (icon instanceof PsiLiteralExpression) {
        Object value=((PsiLiteralExpression)icon).getValue();
        if (value instanceof String) {
          annotations.putValue((String)value,annotation);
        }
      }
      return true;
    }
  }
);
  if (true) {
    ArrayList<String> sorted=new ArrayList<String>(answer);
    Collections.sort(sorted);
    for (    String icon : sorted) {
      System.out.println(icon);
    }
    final JVMElementFactory factory=JVMElementFactories.getFactory(JavaLanguage.INSTANCE,project);
    for (    Map.Entry<String,Collection<PsiExpression>> entry : calls.entrySet()) {
      String path=entry.getKey();
      final String replacement=mappings.get(path);
      if (replacement != null) {
        for (        final PsiExpression call : entry.getValue()) {
          new WriteCommandAction(project,call.getContainingFile()){
            @Override protected void run(            Result result) throws Throwable {
              if (call instanceof PsiLiteralExpression) {
                call.replace(factory.createExpressionFromText("\"" + replacement + "\"",call));
              }
 else {
                JavaCodeStyleManager styleManager=JavaCodeStyleManager.getInstance(project);
                String packageName=replacement.startsWith("AllIcons.") ? "com.intellij.icons." : "icons.";
                PsiElement expr=factory.createExpressionFromText(packageName + replacement,call);
                styleManager.shortenClassReferences(call.replace(expr));
              }
            }
          }
.execute();
        }
      }
    }
    for (    Map.Entry<String,Collection<PsiAnnotation>> entry : annotations.entrySet()) {
      String path=entry.getKey();
      final String replacement=mappings.get(path);
      if (replacement != null) {
        for (        final PsiAnnotation annotation : entry.getValue()) {
          if (annotation instanceof PsiCompiledElement)           continue;
          new WriteCommandAction(project,annotation.getContainingFile()){
            @Override protected void run(            Result result) throws Throwable {
              annotation.getNode();
              annotation.setDeclaredAttributeValue("icon",JavaPsiFacade.getInstance(annotation.getProject()).getElementFactory().createAnnotationFromText("@A(\"" + replacement + "\")",null).findDeclaredAttributeValue(null));
            }
          }
.execute();
        }
      }
    }
  }
}
