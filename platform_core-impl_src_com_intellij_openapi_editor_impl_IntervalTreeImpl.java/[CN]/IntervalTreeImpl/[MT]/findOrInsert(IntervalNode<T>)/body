{
  assertUnderWriteLock();
  node.color=Color.RED;
  node.setParent(null);
  node.setValid(true);
  node.maxEnd=0;
  node.clearDelta();
  node.setLeft(null);
  node.setRight(null);
  List<IntervalNode<T>> gced=new SmartList<IntervalNode<T>>();
  if (root == null) {
    root=node;
  }
 else {
    IntervalNode<T> current=getRoot();
    while (true) {
      pushDelta(current);
      int compResult=compareNodes(node,0,current,0,gced);
      if (compResult == 0) {
        return current;
      }
      if (compResult < 0) {
        if (current.getLeft() == null) {
          current.setLeft(node);
          break;
        }
        current=current.getLeft();
      }
 else {
        if (current.getRight() == null) {
          current.setRight(node);
          break;
        }
        current=current.getRight();
      }
    }
    node.setParent(current);
  }
  node.setCachedValues(0,true,modCount);
  correctMaxUp(node);
  onInsertNode();
  keySize+=node.intervals.size();
  insertCase1(node);
  verifyProperties();
  deleteNodes(gced);
  return node;
}
