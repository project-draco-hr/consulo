{
  boolean isSynthetic=(access & Opcodes.ACC_SYNTHETIC) != 0;
  if (isSynthetic)   return null;
  if (SYNTHETIC_CLINIT_METHOD.equals(name))   return null;
  boolean isDeprecated=(access & Opcodes.ACC_DEPRECATED) != 0;
  boolean isConstructor=SYNTHETIC_INIT_METHOD.equals(name);
  boolean isVarargs=(access & Opcodes.ACC_VARARGS) != 0;
  boolean isAnnotationMethod=myResult.isAnnotationType();
  if (!isConstructor && !isCorrectName(name))   return null;
  final byte flags=PsiMethodStubImpl.packFlags(isConstructor,isAnnotationMethod,isVarargs,isDeprecated,false);
  String canonicalMethodName=isConstructor ? myResult.getName() : name;
  final List<String> args=new ArrayList<String>();
  final List<String> throwables=exceptions != null ? new ArrayList<String>() : null;
  PsiMethodStubImpl stub=new PsiMethodStubImpl(myResult,StringRef.fromString(canonicalMethodName),flags,null);
  final PsiModifierListStub modList=new PsiModifierListStubImpl(stub,packMethodFlags(access));
  boolean parsedViaGenericSignature=false;
  String returnType;
  if (signature == null) {
    returnType=parseMethodViaDescription(desc,stub,args);
  }
 else {
    try {
      returnType=parseMethodViaGenericSignature(signature,stub,args,throwables);
      parsedViaGenericSignature=true;
    }
 catch (    ClsFormatException e) {
      returnType=parseMethodViaDescription(desc,stub,args);
    }
  }
  stub.setReturnType(TypeInfo.fromString(returnType));
  final boolean isNonStaticInnerClassConstructor=isConstructor && !(myParent instanceof PsiFileStub) && (myModList.getModifiersMask() & Opcodes.ACC_STATIC) == 0;
  final boolean shouldSkipFirstParamForNonStaticInnerClassConstructor=!parsedViaGenericSignature && isNonStaticInnerClassConstructor;
  final PsiParameterListStubImpl parameterList=new PsiParameterListStubImpl(stub);
  final int paramCount=args.size();
  final PsiParameterStubImpl[] paramStubs=new PsiParameterStubImpl[paramCount];
  for (int i=0; i < paramCount; i++) {
    if (shouldSkipFirstParamForNonStaticInnerClassConstructor && i == 0)     continue;
    String arg=args.get(i);
    boolean isEllipsisParam=isVarargs && i == paramCount - 1;
    final TypeInfo typeInfo=TypeInfo.fromString(arg,isEllipsisParam);
    PsiParameterStubImpl parameterStub=new PsiParameterStubImpl(parameterList,"p" + (i + 1),typeInfo,isEllipsisParam);
    paramStubs[i]=parameterStub;
    new PsiModifierListStubImpl(parameterStub,0);
  }
  String[] thrownTypes=buildThrowsList(exceptions,throwables,parsedViaGenericSignature);
  new PsiClassReferenceListStubImpl(JavaStubElementTypes.THROWS_LIST,stub,thrownTypes,PsiReferenceList.Role.THROWS_LIST);
  final boolean isEnumConstructor=isConstructor && myResult.isEnum();
  int localVarIgnoreCount=(access & Opcodes.ACC_STATIC) != 0 ? 0 : 1;
  if (isEnumConstructor) {
    localVarIgnoreCount+=2;
  }
  final int paramIgnoreCount=isEnumConstructor ? 2 : isNonStaticInnerClassConstructor ? 1 : 0;
  return new AnnotationParamCollectingVisitor(stub,modList,localVarIgnoreCount,paramIgnoreCount,paramCount,paramStubs);
}
