{
  LOG.assertTrue(file != null);
  window.myInsideTabChange++;
  FileEditor[] editors;
  FileEditorProvider[] providers;
  try {
    final EditorWithProviderComposite newSelectedComposite;
    boolean newEditorCreated=false;
    final boolean open=window.isFileOpen(file);
    if (open) {
      newSelectedComposite=window.findFileComposite(file);
      LOG.assertTrue(newSelectedComposite != null);
      editors=newSelectedComposite.getEditors();
      providers=newSelectedComposite.getProviders();
    }
 else {
      final FileEditorProviderManager editorProviderManager=FileEditorProviderManager.getInstance();
      providers=editorProviderManager.getProviders(myProject,file);
      if (providers.length == 0) {
        return Pair.create(EMPTY_EDITOR_ARRAY,EMPTY_PROVIDER_ARRAY);
      }
      newEditorCreated=true;
      editors=new FileEditor[providers.length];
      for (int i=0; i < providers.length; i++) {
        try {
          final FileEditorProvider provider=providers[i];
          LOG.assertTrue(provider != null);
          LOG.assertTrue(provider.accept(myProject,file));
          final FileEditor editor=provider.createEditor(myProject,file);
          editors[i]=editor;
          LOG.assertTrue(editor != null);
          LOG.assertTrue(editor.isValid());
          editor.addPropertyChangeListener(myEditorPropertyChangeListener);
        }
 catch (        Exception e) {
          LOG.error(e);
        }
catch (        AssertionError e) {
          LOG.error(e);
        }
      }
      newSelectedComposite=new EditorWithProviderComposite(file,editors,providers,this);
      newSelectedComposite.addEditorManagerListener(myEditorManagerListener);
    }
    window.setEditor(newSelectedComposite);
    final EditorHistoryManager editorHistoryManager=EditorHistoryManager.getInstance(myProject);
    for (int i=0; i < editors.length; i++) {
      final FileEditor editor=editors[i];
      if (editor instanceof TextEditor) {
        ((EditorEx)((TextEditor)editor).getEditor()).stopOptimizedScrolling();
      }
      final FileEditorProvider provider=providers[i];
      FileEditorState state=null;
      if (entry != null) {
        state=entry.getState(provider);
      }
      if (state == null && !open) {
        state=editorHistoryManager.getState(file,provider);
      }
      if (state != null) {
        editor.setState(state);
      }
    }
    final FileEditorProvider selectedProvider=editorHistoryManager.getSelectedProvider(file);
    if (selectedProvider != null) {
      final FileEditor[] _editors=newSelectedComposite.getEditors();
      final FileEditorProvider[] _providers=newSelectedComposite.getProviders();
      for (int i=_editors.length - 1; i >= 0; i--) {
        final FileEditorProvider provider=_providers[i];
        if (provider.equals(selectedProvider)) {
          newSelectedComposite.setSelectedEditor(i);
          break;
        }
      }
    }
    mySplitters.setCurrentWindow(window,false);
    newSelectedComposite.getSelectedEditor().selectNotify();
    if (newEditorCreated) {
      myDispatcher.getMulticaster().fileOpened(this,file);
      final VirtualFile parentDir=file.getParent();
      if (parentDir != null) {
        final LocalFileSystem.WatchRequest request=LocalFileSystem.getInstance().addRootToWatch(parentDir.getPath(),false);
        file.putUserData(WATCH_REQUEST_KEY,request);
      }
    }
    ((IdeDocumentHistoryImpl)IdeDocumentHistory.getInstance(myProject)).onSelectionChanged();
    if (!ApplicationManagerEx.getApplicationEx().isUnitTestMode()) {
      if ((focusEditor || ToolWindowManager.getInstance(myProject).isEditorComponentActive()) && !myDoNotTransferFocus) {
        window.setAsCurrentWindow(false);
        ToolWindowManager.getInstance(myProject).activateEditorComponent();
      }
    }
    updateFileName(file);
    IdeDocumentHistory.getInstance(myProject).includeCurrentCommandAsNavigation();
  }
  finally {
    window.myInsideTabChange--;
  }
  return Pair.create(editors,providers);
}
