{
  BasicAction.saveAll();
  GitVcsSettings settings=GitVcsSettings.getInstance(project);
  GitCheckoutDialog dialog=new GitCheckoutDialog(project,settings);
  dialog.show();
  if (!dialog.isOK()) {
    return;
  }
  final VirtualFile destinationParent=LocalFileSystem.getInstance().findFileByIoFile(new File(dialog.getParentDirectory()));
  if (destinationParent == null) {
    return;
  }
  GitCommandRunnable cmdr=new GitCommandRunnable(project,settings,destinationParent);
  cmdr.setCommand(GitCommand.CLONE_CMD);
  @NonNls ArrayList<String> args=new ArrayList<String>();
  args.add(dialog.getSourceRepositoryURL());
  if (dialog.getOriginName().length() != 0) {
    args.add("-o");
    args.add(dialog.getOriginName());
  }
  args.add(dialog.getDirectoryName());
  final String sourceRepositoryURL=dialog.getSourceRepositoryURL();
  cmdr.setArgs(args.toArray(new String[args.size()]));
  ProgressManager manager=ProgressManager.getInstance();
  manager.runProcessWithProgressSynchronously(cmdr,GitBundle.message("cloning.repository",sourceRepositoryURL),false,project);
  @SuppressWarnings({"ThrowableResultOfMethodCallIgnored"}) VcsException ex=cmdr.getException();
  if (ex != null) {
    GitUtil.showOperationError(project,ex,"git clone");
  }
 else {
    if (listener != null) {
      listener.directoryCheckedOut(new File(dialog.getParentDirectory(),dialog.getDirectoryName()));
    }
  }
  if (listener != null) {
    listener.checkoutCompleted();
  }
  VcsDirtyScopeManager mgr=VcsDirtyScopeManager.getInstance(project);
  mgr.fileDirty(destinationParent);
  destinationParent.refresh(true,true);
}
