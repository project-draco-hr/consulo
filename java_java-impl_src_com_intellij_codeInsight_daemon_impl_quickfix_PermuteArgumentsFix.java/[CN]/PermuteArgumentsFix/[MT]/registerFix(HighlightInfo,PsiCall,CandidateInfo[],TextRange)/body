{
  PsiExpression[] expressions=callExpression.getArgumentList().getExpressions();
  if (expressions.length < 2)   return;
  List<PsiCall> permutations=new ArrayList<PsiCall>();
  for (  CandidateInfo candidate : candidates) {
    if (candidate instanceof MethodCandidateInfo) {
      MethodCandidateInfo methodCandidate=(MethodCandidateInfo)candidate;
      PsiMethod method=methodCandidate.getElement();
      PsiSubstitutor substitutor=methodCandidate.getSubstitutor();
      PsiParameter[] parameters=method.getParameterList().getParameters();
      if (expressions.length != parameters.length || parameters.length == 0)       continue;
      int minIncompatibleIndex=parameters.length;
      int maxIncompatibleIndex=0;
      int incompatibilitiesCount=0;
      for (int i=0; i < parameters.length; i++) {
        PsiParameter parameter=parameters[i];
        PsiType type=substitutor.substitute(parameter.getType());
        if (TypeConversionUtil.areTypesAssignmentCompatible(type,expressions[i]))         continue;
        if (minIncompatibleIndex == parameters.length)         minIncompatibleIndex=i;
        maxIncompatibleIndex=i;
        incompatibilitiesCount++;
      }
      try {
        registerSwapFixes(expressions,callExpression,permutations,methodCandidate,incompatibilitiesCount,minIncompatibleIndex,maxIncompatibleIndex);
        registerShiftFixes(expressions,callExpression,permutations,methodCandidate,minIncompatibleIndex,maxIncompatibleIndex);
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
  }
  if (permutations.size() == 1) {
    PermuteArgumentsFix fix=new PermuteArgumentsFix(callExpression,permutations.get(0));
    QuickFixAction.registerQuickFixAction(info,fixRange,fix);
  }
}
