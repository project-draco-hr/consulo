{
  for (  final MemberInfo memberInfo : myDelegateMethodInfos) {
    if (!memberInfo.isChecked())     continue;
    final PsiMethod method=(PsiMethod)memberInfo.getMember();
    final Project project=method.getProject();
    final String getterName=PropertyUtil.suggestGetterName(project,field);
    final int[] paramPermutation=DelegationUtils.getParameterPermutation(method);
    final PsiMethod delegatedMethod=DelegationUtils.getDelegatedMethod(method);
    LOG.assertTrue(!DelegationUtils.isAbstract(method));
    @Modifier String visibility=PsiModifier.PRIVATE;
    visibility=processUsagesForMethod(memberInfo.isToAbstract(),method,paramPermutation,getterName,delegatedMethod,visibility,usages);
    final PsiMethod[] deepestSuperMethods=method.findDeepestSuperMethods();
    for (    PsiMethod superMethod : deepestSuperMethods) {
      visibility=processUsagesForMethod(memberInfo.isToAbstract(),superMethod,paramPermutation,getterName,delegatedMethod,visibility,usages);
    }
    final PsiClass delegateClass=delegatedMethod.getContainingClass();
    if (VisibilityUtil.compare(visibility,VisibilityUtil.getVisibilityModifier(delegateClass.getModifierList())) < 0) {
      usages.add(new ChangeClassVisibilityUsageInfo(delegateClass,visibility));
    }
    if (!delegateClass.isInterface() && VisibilityUtil.compare(visibility,VisibilityUtil.getVisibilityModifier(delegatedMethod.getModifierList())) < 0) {
      usages.add(new ChangeMethodVisibilityUsageInfo(delegatedMethod,visibility));
    }
  }
}
