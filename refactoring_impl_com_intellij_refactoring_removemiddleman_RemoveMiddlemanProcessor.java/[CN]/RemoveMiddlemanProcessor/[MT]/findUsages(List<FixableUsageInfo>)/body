{
  final Set<PsiMethod> methods=DelegationUtils.getDelegatingMethodsForField(field);
  for (  final PsiMethod method : methods) {
    final Project project=method.getProject();
    final String getterName=PropertyUtil.suggestGetterName(project,field);
    final int[] paramPermutation=DelegationUtils.getParameterPermutation(method);
    final PsiMethod delegatedMethod=DelegationUtils.getDelegatedMethod(method);
    final String delegatedMethodName=delegatedMethod.getName();
    final Set<PsiMethod> siblingMethods=MethodInheritanceUtils.calculateSiblingMethods(method);
    for (    PsiMethod siblingMethod : siblingMethods) {
      processUsagesForMethod(siblingMethod,paramPermutation,getterName,delegatedMethodName,usages);
    }
    final PsiClass delegateClass=delegatedMethod.getContainingClass();
    if (!delegateClass.hasModifierProperty(PsiModifier.PUBLIC)) {
      usages.add(new MakeClassPublic(delegateClass));
    }
    if (!delegateClass.isInterface() && !delegatedMethod.hasModifierProperty(PsiModifier.PUBLIC)) {
      usages.add(new MakeMethodPublic(delegatedMethod));
    }
    final PsiMethod[] superMethods=delegatedMethod.findSuperMethods();
    for (    PsiMethod superMethod : superMethods) {
      final PsiClass containingSuperClass=superMethod.getContainingClass();
      if (!containingSuperClass.isInterface() && !superMethod.hasModifierProperty(PsiModifier.PUBLIC)) {
        usages.add(new MakeMethodPublic(superMethod));
      }
    }
  }
}
