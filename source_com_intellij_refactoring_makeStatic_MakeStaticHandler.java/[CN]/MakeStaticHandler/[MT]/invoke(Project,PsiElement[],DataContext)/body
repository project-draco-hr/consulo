{
  if (elements.length != 1 || !(elements[0] instanceof PsiTypeParameterListOwner))   return;
  myProject=project;
  myMember=(PsiTypeParameterListOwner)elements[0];
  if (!myMember.isWritable()) {
    if (!RefactoringMessageUtil.checkReadOnlyStatus(project,myMember))     return;
  }
  final PsiClass containingClass;
  if (myMember instanceof PsiMethod && ((PsiMethod)myMember).isConstructor()) {
    String message="Cannot perform the refactoring.\n" + "Constructor cannot be made static.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.MAKE_METHOD_STATIC,myProject);
    return;
  }
  if (myMember.getContainingClass() == null) {
    String message="Cannot perform the refactoring.\n" + "This member does not seem to belong to any class.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.MAKE_METHOD_STATIC,myProject);
    return;
  }
  containingClass=myMember.getContainingClass();
  if (myMember.hasModifierProperty(PsiModifier.STATIC)) {
    String message="Cannot perform the refactoring.\n" + "Member is already static.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.MAKE_METHOD_STATIC,myProject);
    return;
  }
  if (myMember.hasModifierProperty(PsiModifier.ABSTRACT)) {
    String message="Cannot perfrom the refactoring.\n" + "Cannot make abstract method static.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.MAKE_METHOD_STATIC,myProject);
    return;
  }
  if (containingClass.getContainingClass() != null && !containingClass.hasModifierProperty(PsiModifier.STATIC)) {
    String message="Cannot perform the refactoring.\n" + "Inner classes cannot have static members.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.MAKE_METHOD_STATIC,myProject);
    return;
  }
  final InternalUsageInfo[] classRefsInMember=MakeStaticUtil.findClassRefsInMember(myMember,false);
  AbstractMakeStaticDialog dialog;
  if (!ApplicationManager.getApplication().isUnitTestMode()) {
    if (classRefsInMember.length > 0) {
      final PsiType type=containingClass.getManager().getElementFactory().createType(containingClass);
      String[] nameSuggestions=CodeStyleManager.getInstance(myProject).suggestVariableName(VariableKind.PARAMETER,null,null,type).names;
      dialog=new MakeParametrizedStaticDialog(myProject,myMember,nameSuggestions,classRefsInMember);
    }
 else {
      dialog=new SimpleMakeStaticDialog(myProject,myMember);
    }
    dialog.show();
    return;
  }
}
