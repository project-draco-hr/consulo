def apply(self, repo, source, revmap, merges, opts={}):
    'apply the revisions in revmap one by one in revision order'
    revs = sorted(revmap)
    (p1, p2) = repo.dirstate.parents()
    pulls = []
    diffopts = patch.diffopts(self.ui, opts)
    diffopts.git = True
    lock = wlock = None
    try:
        wlock = repo.wlock()
        lock = repo.lock()
        for rev in revs:
            node = revmap[rev]
            revstr = ('%s:%s' % (rev, revlog.short(node)))
            if self.applied(repo, node, p1):
                self.ui.warn((_('skipping already applied revision %s\n') % revstr))
                continue
            parents = source.changelog.parents(node)
            if (not opts.get('filter')):
                if (parents[0] == p1):
                    pulls.append(node)
                    p1 = node
                    continue
                if pulls:
                    if (source != repo):
                        repo.pull(source, heads=pulls)
                    merge.update(repo, pulls[(-1)], False, False, None)
                    (p1, p2) = repo.dirstate.parents()
                    pulls = []
            domerge = False
            if (node in merges):
                domerge = True
                if (not hasnode(repo, node)):
                    repo.pull(source, heads=[node])
            if (parents[1] != revlog.nullid):
                self.ui.note((_('skipping merge changeset %s:%s\n') % (rev, revlog.short(node))))
                patchfile = None
            else:
                (fd, patchfile) = tempfile.mkstemp(prefix='hg-transplant-')
                fp = os.fdopen(fd, 'w')
                gen = patch.diff(source, parents[0], node, opts=diffopts)
                for chunk in gen:
                    fp.write(chunk)
                fp.close()
            del revmap[rev]
            if (patchfile or domerge):
                try:
                    n = self.applyone(repo, node, source.changelog.read(node), patchfile, merge=domerge, log=opts.get('log'), filter=opts.get('filter'))
                    if (n and domerge):
                        self.ui.status((_('%s merged at %s\n') % (revstr, revlog.short(n))))
                    elif n:
                        self.ui.status((_('%s transplanted to %s\n') % (revlog.short(node), revlog.short(n))))
                finally:
                    if patchfile:
                        os.unlink(patchfile)
        if pulls:
            repo.pull(source, heads=pulls)
            merge.update(repo, pulls[(-1)], False, False, None)
    finally:
        self.saveseries(revmap, merges)
        self.transplants.write()
        lock.release()
        wlock.release()
