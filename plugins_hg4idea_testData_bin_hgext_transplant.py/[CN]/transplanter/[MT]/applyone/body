def applyone(self, repo, node, cl, patchfile, merge=False, log=False, filter=None):
    'apply the patch in patchfile to the repository as a transplant'
    (manifest, user, (time, timezone), files, message) = cl[:5]
    date = ('%d %d' % (time, timezone))
    extra = {'transplant_source': node, }
    if filter:
        (user, date, message) = self.filter(filter, cl, patchfile)
    if log:
        message += ('\n(transplanted from %s)' % revlog.hex(node))
    self.ui.status((_('applying %s\n') % revlog.short(node)))
    self.ui.note(('%s %s\n%s\n' % (user, date, message)))
    if ((not patchfile) and (not merge)):
        raise util.Abort(_('can only omit patchfile if merging'))
    if patchfile:
        try:
            files = {}
            try:
                patch.patch(patchfile, self.ui, cwd=repo.root, files=files, eolmode=None)
                if (not files):
                    self.ui.warn((_('%s: empty changeset') % revlog.hex(node)))
                    return None
            finally:
                files = patch.updatedir(self.ui, repo, files)
        except Exception as inst:
            seriespath = os.path.join(self.path, 'series')
            if os.path.exists(seriespath):
                os.unlink(seriespath)
            p1 = repo.dirstate.parents()[0]
            p2 = node
            self.log(user, date, message, p1, p2, merge=merge)
            self.ui.write((str(inst) + '\n'))
            raise util.Abort(_('Fix up the merge and run hg transplant --continue'))
    else:
        files = None
    if merge:
        (p1, p2) = repo.dirstate.parents()
        repo.dirstate.setparents(p1, node)
        m = match.always(repo.root, '')
    else:
        m = match.exact(repo.root, '', files)
    n = repo.commit(message, user, date, extra=extra, match=m)
    if (not merge):
        self.transplants.set(n, node)
    return n
