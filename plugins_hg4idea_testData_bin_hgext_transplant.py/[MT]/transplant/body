def transplant(ui, repo, *revs, **opts):
    'transplant changesets from another branch\n\n    Selected changesets will be applied on top of the current working\n    directory with the log of the original changeset. If --log is\n    specified, log messages will have a comment appended of the form::\n\n      (transplanted from CHANGESETHASH)\n\n    You can rewrite the changelog message with the --filter option.\n    Its argument will be invoked with the current changelog message as\n    $1 and the patch as $2.\n\n    If --source/-s is specified, selects changesets from the named\n    repository. If --branch/-b is specified, selects changesets from\n    the branch holding the named revision, up to that revision. If\n    --all/-a is specified, all changesets on the branch will be\n    transplanted, otherwise you will be prompted to select the\n    changesets you want.\n\n    hg transplant --branch REVISION --all will rebase the selected\n    branch (up to the named revision) onto your current working\n    directory.\n\n    You can optionally mark selected transplanted changesets as merge\n    changesets. You will not be prompted to transplant any ancestors\n    of a merged transplant, and you can merge descendants of them\n    normally instead of transplanting them.\n\n    If no merges or revisions are provided, hg transplant will start\n    an interactive changeset browser.\n\n    If a changeset application fails, you can fix the merge by hand\n    and then resume where you left off by calling hg transplant\n    --continue/-c.\n    '

    def getremotechanges(repo, url):
        sourcerepo = ui.expandpath(url)
        source = hg.repository(ui, sourcerepo)
        (common, incoming, rheads) = repo.findcommonincoming(source, force=True)
        if (not incoming):
            return (source, None, None)
        bundle = None
        if (not source.local()):
            if source.capable('changegroupsubset'):
                cg = source.changegroupsubset(incoming, rheads, 'incoming')
            else:
                cg = source.changegroup(incoming, 'incoming')
            bundle = changegroup.writebundle(cg, None, 'HG10UN')
            source = bundlerepo.bundlerepository(ui, repo.root, bundle)
        return (source, incoming, bundle)

    def incwalk(repo, incoming, branches, match=util.always):
        if (not branches):
            branches = None
        for node in repo.changelog.nodesbetween(incoming, branches)[0]:
            if match(node):
                yield node

    def transplantwalk(repo, root, branches, match=util.always):
        if (not branches):
            branches = repo.heads()
        ancestors = []
        for branch in branches:
            ancestors.append(repo.changelog.ancestor(root, branch))
        for node in repo.changelog.nodesbetween(ancestors, branches)[0]:
            if match(node):
                yield node

    def checkopts(opts, revs):
        if opts.get('continue'):
            if (opts.get('branch') or opts.get('all') or opts.get('merge')):
                raise util.Abort(_('--continue is incompatible with branch, all or merge'))
            return
        if (not (opts.get('source') or revs or opts.get('merge') or opts.get('branch'))):
            raise util.Abort(_('no source URL, branch tag or revision list provided'))
        if opts.get('all'):
            if (not opts.get('branch')):
                raise util.Abort(_('--all requires a branch revision'))
            if revs:
                raise util.Abort(_('--all is incompatible with a revision list'))
    checkopts(opts, revs)
    if (not opts.get('log')):
        opts['log'] = ui.config('transplant', 'log')
    if (not opts.get('filter')):
        opts['filter'] = ui.config('transplant', 'filter')
    tp = transplanter(ui, repo)
    (p1, p2) = repo.dirstate.parents()
    if ((len(repo) > 0) and (p1 == revlog.nullid)):
        raise util.Abort(_('no revision checked out'))
    if (not opts.get('continue')):
        if (p2 != revlog.nullid):
            raise util.Abort(_('outstanding uncommitted merges'))
        (m, a, r, d) = repo.status()[:4]
        if (m or a or r or d):
            raise util.Abort(_('outstanding local changes'))
    bundle = None
    source = opts.get('source')
    if source:
        (source, incoming, bundle) = getremotechanges(repo, source)
    else:
        source = repo
    try:
        if opts.get('continue'):
            tp.resume(repo, source, opts)
            return
        tf = tp.transplantfilter(repo, source, p1)
        if opts.get('prune'):
            prune = [source.lookup(r) for r in cmdutil.revrange(source, opts.get('prune'))]
            matchfn = (lambda x: (tf(x) and (x not in prune)))
        else:
            matchfn = tf
        branches = map(source.lookup, opts.get('branch', ()))
        merges = map(source.lookup, opts.get('merge', ()))
        revmap = {}
        if revs:
            for r in cmdutil.revrange(source, revs):
                revmap[int(r)] = source.lookup(r)
        elif (opts.get('all') or (not merges)):
            if (source != repo):
                alltransplants = incwalk(source, incoming, branches, match=matchfn)
            else:
                alltransplants = transplantwalk(source, p1, branches, match=matchfn)
            if opts.get('all'):
                revs = alltransplants
            else:
                (revs, newmerges) = browserevs(ui, source, alltransplants, opts)
                merges.extend(newmerges)
            for r in revs:
                revmap[source.changelog.rev(r)] = r
        for r in merges:
            revmap[source.changelog.rev(r)] = r
        tp.apply(repo, source, revmap, merges, opts)
    finally:
        if bundle:
            source.close()
            os.unlink(bundle)
