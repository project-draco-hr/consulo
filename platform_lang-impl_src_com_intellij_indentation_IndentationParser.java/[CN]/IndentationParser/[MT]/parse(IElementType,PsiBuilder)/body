{
  final PsiBuilder.Marker fileMarker=builder.mark();
  final PsiBuilder.Marker documentMarker=builder.mark();
  final Stack<BlockInfo> stack=new Stack<BlockInfo>();
  stack.push(new BlockInfo(0,builder.mark()));
  PsiBuilder.Marker startLineMarker=null;
  int currentIndent=0;
  boolean eolSeen=false;
  while (!builder.eof()) {
    final IElementType type=builder.getTokenType();
    if (type == myEolTokenType) {
      if (startLineMarker == null) {
        startLineMarker=builder.mark();
      }
      eolSeen=true;
    }
 else {
      if (type == myIndentTokenType) {
        currentIndent=builder.getTokenText().length();
      }
 else {
        if (!eolSeen && !stack.isEmpty() && currentIndent > 0 && currentIndent < stack.peek().getIndent()) {
          eolSeen=true;
        }
        if (eolSeen) {
          if (startLineMarker != null) {
            startLineMarker.rollbackTo();
            startLineMarker=null;
          }
          while (!stack.isEmpty() && currentIndent < stack.peek().getIndent()) {
            closeBlock(builder,stack.pop().getMarker());
          }
          if (!stack.isEmpty()) {
            final BlockInfo blockInfo=stack.peek();
            if (currentIndent >= blockInfo.getIndent()) {
              if (currentIndent == blockInfo.getIndent()) {
                closeBlock(builder,stack.pop().getMarker());
              }
              passEOLsAndIndents(builder);
              stack.push(new BlockInfo(currentIndent,builder.mark()));
            }
          }
          eolSeen=false;
          currentIndent=0;
        }
      }
    }
    advanceLexer(builder);
  }
  if (startLineMarker != null) {
    startLineMarker.drop();
  }
  while (!stack.isEmpty()) {
    closeBlock(builder,stack.pop().getMarker());
  }
  documentMarker.done(myDocumentType);
  fileMarker.done(root);
  return builder.getTreeBuilt();
}
