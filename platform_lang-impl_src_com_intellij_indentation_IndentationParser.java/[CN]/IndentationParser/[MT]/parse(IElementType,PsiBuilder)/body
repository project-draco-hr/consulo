{
  final PsiBuilder.Marker fileMarker=builder.mark();
  final Stack<Pair<Integer,PsiBuilder.Marker>> stack=new Stack<Pair<Integer,PsiBuilder.Marker>>();
  stack.push(Pair.create(0,builder.mark()));
  PsiBuilder.Marker startLineMarker=null;
  int currentIndent=0;
  boolean eolSeen=false;
  while (!builder.eof()) {
    final IElementType type=builder.getTokenType();
    if (type == myEolTokenType) {
      if (startLineMarker == null) {
        startLineMarker=builder.mark();
      }
      eolSeen=true;
    }
 else {
      if (type == myIndentTokenType) {
        currentIndent=builder.getTokenText().length();
      }
 else       if (eolSeen) {
        if (startLineMarker != null) {
          startLineMarker.rollbackTo();
          startLineMarker=null;
        }
        while (!stack.isEmpty() && currentIndent < stack.peek().first) {
          stack.pop().second.done(myBlockElementType);
        }
        if (!stack.isEmpty()) {
          final Pair<Integer,PsiBuilder.Marker> pair=stack.peek();
          if (currentIndent == pair.first) {
            stack.pop().second.done(myBlockElementType);
            passEOLsAndIndents(builder);
            stack.push(Pair.create(currentIndent,builder.mark()));
          }
          if (currentIndent > pair.first) {
            passEOLsAndIndents(builder);
            stack.push(Pair.create(currentIndent,builder.mark()));
          }
        }
        eolSeen=false;
        currentIndent=0;
      }
    }
    advanceLexer(builder);
  }
  if (startLineMarker != null) {
    startLineMarker.drop();
  }
  while (!stack.isEmpty()) {
    stack.pop().second.done(myBlockElementType);
  }
  return buildTree(fileMarker,builder,root);
}
