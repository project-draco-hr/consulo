{
  boolean allNull=true;
  if (keyOff % 16 != 0 || foundOff % 16 != 0 || keyLength % 16 != 0 || foundKeyLength % 16 != 0) {
    throw new IllegalArgumentException("offsets & lengths must be at character boundaries");
  }
  int off1=keyOff / 16;
  int off2=foundOff / 16;
  int len1=keyLength / 16 + off1;
  int len2=foundKeyLength / 16 + off2;
  int length=Math.max(len1,len2);
  char k=0, f=0;
  for (int i=0; i < length; i++) {
    int kOff=i + off1;
    int fOff=i + off2;
    if (kOff >= len1) {
      k=0;
    }
 else {
      k=key.charAt(kOff);
    }
    if (found == null || fOff >= len2) {
      f=0;
    }
 else {
      f=found.charAt(fOff);
    }
    if (k != f) {
      int x=k ^ f;
      return i * 16 + (Integer.numberOfLeadingZeros(x) - 16);
    }
    if (k != 0)     allNull=false;
  }
  if (allNull) {
    return PatriciaTrie.KeyAnalyzer.NULL_BIT_KEY;
  }
  return PatriciaTrie.KeyAnalyzer.EQUAL_BIT_KEY;
}
