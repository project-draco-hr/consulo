{
  myProject=project;
  myLock=new Object();
  myRemoteRevisionsNumbersCache=new RemoteRevisionsNumbersCache(myProject);
  myRemoteRevisionsStateCache=new RemoteRevisionsStateCache(myProject);
  myChangeDecorator=new RemoteStatusChangeNodeDecorator(this);
  myVcsManager=ProjectLevelVcsManager.getInstance(project);
  myVcsManager.addVcsListener(this);
  myKinds=new HashMap<String,RemoteDifferenceStrategy>();
  Disposer.register(project,new Disposable(){
    public void dispose(){
      myVcsManager.removeVcsListener(RemoteRevisionsCache.this);
    }
  }
);
  myControlledCycle=new ControlledCycle(project,new ControlledCycle.MyCallback(){
    public boolean call(    final AtomicSectionsAware atomicSectionsAware){
      atomicSectionsAware.checkShouldExit();
      final boolean shouldBeDone=VcsConfiguration.getInstance(myProject).CHECK_LOCALLY_CHANGED_CONFLICTS_IN_BACKGROUND && myVcsManager.hasActiveVcss();
      if (shouldBeDone) {
        boolean somethingChanged=myRemoteRevisionsNumbersCache.updateStep(atomicSectionsAware);
        atomicSectionsAware.checkShouldExit();
        somethingChanged|=myRemoteRevisionsStateCache.updateStep(atomicSectionsAware);
        if (somethingChanged) {
          myProject.getMessageBus().syncPublisher(REMOTE_VERSION_CHANGED).run();
        }
      }
      return shouldBeDone;
    }
  }
,"Finishing \"changed on server\" update",DEFAULT_REFRESH_INTERVAL);
  updateRoots();
  if ((!myProject.isDefault()) && VcsConfiguration.getInstance(myProject).CHECK_LOCALLY_CHANGED_CONFLICTS_IN_BACKGROUND) {
    if (!myVcsManager.hasActiveVcss())     return;
    ((ProjectLevelVcsManagerImpl)myVcsManager).addInitializationRequest(VcsInitObject.REMOTE_REVISIONS_CACHE,new Runnable(){
      public void run(){
        myControlledCycle.startIfNotStarted(-1);
      }
    }
);
  }
}
