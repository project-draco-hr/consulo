{
  myProject=project;
  myLock=new Object();
  myRemoteRevisionsNumbersCache=new RemoteRevisionsNumbersCache(myProject);
  myRemoteRevisionsStateCache=new RemoteRevisionsStateCache(myProject);
  myChangeDecorator=new RemoteStatusChangeNodeDecorator(this);
  myVcsManager=ProjectLevelVcsManager.getInstance(project);
  myVcsManager.addVcsListener(this);
  myKinds=new HashMap<String,RemoteDifferenceStrategy>();
  Disposer.register(project,new Disposable(){
    public void dispose(){
      myVcsManager.removeVcsListener(RemoteRevisionsCache.this);
    }
  }
);
  updateKinds();
  myControlledCycle=new ControlledCycle(project,new ControlledCycle.MyCallback(){
    public boolean call(    final AtomicSectionsAware atomicSectionsAware){
      atomicSectionsAware.checkShouldExit();
      final boolean shouldBeDone=VcsConfiguration.getInstance(myProject).CHECK_LOCALLY_CHANGED_CONFLICTS_IN_BACKGROUND;
      if (shouldBeDone) {
        boolean somethingChanged=myRemoteRevisionsNumbersCache.updateStep(atomicSectionsAware);
        atomicSectionsAware.checkShouldExit();
        somethingChanged|=myRemoteRevisionsStateCache.updateStep(atomicSectionsAware);
        if (somethingChanged) {
          myProject.getMessageBus().syncPublisher(REMOTE_VERSION_CHANGED).run();
        }
      }
      return shouldBeDone;
    }
  }
,"Finishing \"changed on server\" update",3 * 60 * 1000);
  if ((!myProject.isDefault()) && VcsConfiguration.getInstance(myProject).CHECK_LOCALLY_CHANGED_CONFLICTS_IN_BACKGROUND) {
    ((ProjectLevelVcsManagerImpl)myVcsManager).addInitializationRequest(VcsInitObject.REMOTE_REVISIONS_CACHE,new Runnable(){
      public void run(){
        myControlledCycle.start();
      }
    }
);
  }
}
