{
  final TextRange contentsRange=new TextRange(prefixLength,parsedNode.getTextLength() - suffixLength);
  final Map<LeafElement,String> newTexts=new THashMap<LeafElement,String>();
  ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementVisitor(){
    int currentSourceOffset=rangeInsideHost.getStartOffset();
    LeafElement prevElement;
    String prevElementTail;
    protected boolean visitNode(    TreeElement element){
      return true;
    }
    public void visitLeaf(    LeafElement leaf){
      TextRange range=leaf.getTextRange();
      if (prefixLength > range.getStartOffset() && prefixLength < range.getEndOffset()) {
        LOG.error("Prefix must not contain text that will be glued with the element body after parsing. " + "However, parsed element of " + leaf.getClass() + " contains "+ (prefixLength - range.getStartOffset())+ " characters from the prefix. "+ "Parsed text is '"+ leaf.getText()+ "'");
      }
      if (range.getStartOffset() < contentsRange.getEndOffset() && contentsRange.getEndOffset() < range.getEndOffset()) {
        LOG.error("Suffix must not contain text that will be glued with the element body after parsing. " + "However, parsed element of " + leaf.getClass() + " contains "+ (range.getEndOffset() - contentsRange.getEndOffset())+ " characters from the suffix. "+ "Parsed text is '"+ leaf.getText()+ "'");
      }
      if (!contentsRange.contains(range))       return;
      int offsetInSource=currentSourceOffset;
      int endOffsetInSource=literalTextEscaper.getOffsetInHost(range.getEndOffset() - prefixLength,rangeInsideHost);
      String hostSubText=hostText.substring(offsetInSource,endOffsetInSource);
      if (leaf.getElementType() == TokenType.WHITE_SPACE && prevElementTail != null) {
        hostSubText=prevElementTail + hostSubText;
        newTexts.remove(prevElement);
      }
      String leafText=leaf.getText();
      if (!Comparing.strEqual(leafText,hostSubText)) {
        newTexts.put(leaf,hostSubText);
      }
      if (hostSubText.startsWith(leafText) && hostSubText.length() != leafText.length()) {
        prevElementTail=hostSubText.substring(leafText.length());
      }
 else {
        prevElementTail=null;
      }
      currentSourceOffset+=endOffsetInSource - offsetInSource;
      prevElement=leaf;
    }
  }
);
  for (  LeafElement leaf : newTexts.keySet()) {
    String newText=newTexts.get(leaf);
    leaf.setText(newText);
  }
  ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementVisitor(){
    protected boolean visitNode(    TreeElement element){
      element.clearCaches();
      return true;
    }
  }
);
}
