{
  final Map<LeafElement,String> newTexts=new THashMap<LeafElement,String>();
  ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementVisitor(){
    int currentHostNum=0;
    int currentInHostOffset=shreds.get(0).rangeInsideHost.getStartOffset();
    LeafElement prevElement;
    String prevElementTail;
    int prevHostsCombinedLength=0;
    TextRange contentsRange=TextRange.from(shreds.get(0).prefix.length(),shreds.get(0).rangeInsideHost.getLength());
    protected boolean visitNode(    TreeElement element){
      return true;
    }
    public void visitLeaf(    LeafElement leaf){
      TextRange range=leaf.getTextRange();
      int prefixLength=contentsRange.getStartOffset();
      if (prefixLength > range.getStartOffset() && prefixLength < range.getEndOffset()) {
        LOG.error("Prefix must not contain text that will be glued with the element body after parsing. " + "However, parsed element of " + leaf.getClass() + " contains "+ (prefixLength - range.getStartOffset())+ " characters from the prefix. "+ "Parsed text is '"+ leaf.getText()+ "'");
      }
      if (range.getStartOffset() < contentsRange.getEndOffset() && contentsRange.getEndOffset() < range.getEndOffset()) {
        LOG.error("Suffix must not contain text that will be glued with the element body after parsing. " + "However, parsed element of " + leaf.getClass() + " contains "+ (range.getEndOffset() - contentsRange.getEndOffset())+ " characters from the suffix. "+ "Parsed text is '"+ leaf.getText()+ "'");
      }
      if (!contentsRange.contains(range))       return;
      int startOffsetInHost=currentInHostOffset;
      int endOffsetInHost;
      String leafEncodedText="";
      while (true) {
        TextRange rangeInsideHost=shreds.get(currentHostNum).rangeInsideHost;
        int end=range.getEndOffset() - prefixLength - prevHostsCombinedLength;
        endOffsetInHost=escapers.get(currentHostNum).getOffsetInHost(end,rangeInsideHost);
        String hostText=shreds.get(currentHostNum).host.getText();
        if (endOffsetInHost != -1) {
          leafEncodedText+=hostText.substring(startOffsetInHost,endOffsetInHost);
          break;
        }
        String rest=hostText.substring(startOffsetInHost,rangeInsideHost.getEndOffset());
        leafEncodedText+=rest;
        prevHostsCombinedLength+=escapers.get(currentHostNum).getOffsetInHost(rangeInsideHost.getLength(),rangeInsideHost) - escapers.get(currentHostNum).getOffsetInHost(0,rangeInsideHost);
        currentHostNum++;
        currentInHostOffset=startOffsetInHost=rangeInsideHost.getStartOffset();
        contentsRange=TextRange.from(shreds.get(currentHostNum).prefix.length(),shreds.get(currentHostNum).rangeInsideHost.getLength());
      }
      if (leaf.getElementType() == TokenType.WHITE_SPACE && prevElementTail != null) {
        leafEncodedText=prevElementTail + leafEncodedText;
        newTexts.remove(prevElement);
      }
      String leafText=leaf.getText();
      if (!Comparing.strEqual(leafText,leafEncodedText)) {
        newTexts.put(leaf,leafEncodedText);
      }
      if (leafEncodedText.startsWith(leafText) && leafEncodedText.length() != leafText.length()) {
        prevElementTail=leafEncodedText.substring(leafText.length());
      }
 else {
        prevElementTail=null;
      }
      currentInHostOffset+=endOffsetInHost - startOffsetInHost;
      prevElement=leaf;
    }
  }
);
  for (  LeafElement leaf : newTexts.keySet()) {
    String newText=newTexts.get(leaf);
    leaf.setText(newText);
  }
  ((TreeElement)parsedNode).acceptTree(new RecursiveTreeElementVisitor(){
    protected boolean visitNode(    TreeElement element){
      element.clearCaches();
      return true;
    }
  }
);
}
