{
  final Collection<FieldRepr> added=diff.fields().added();
  if (added.isEmpty()) {
    return true;
  }
  debug("Processing added fields");
  for (  final FieldRepr f : added) {
    debug("Field: ",f.name);
    if (!f.isPrivate()) {
      final TIntHashSet subClasses=getAllSubclasses(classRepr.name);
      subClasses.forEach(new TIntProcedure(){
        @Override public boolean execute(        int subClass){
          final ClassRepr r=myFuture.reprByName(subClass);
          if (r != null) {
            final File sourceFileName=myClassToSourceFile.get(subClass);
            if (sourceFileName != null) {
              if (r.isLocal()) {
                debug("Affecting local subclass (introduced field can potentially hide surrounding method parameters/local variables): ",sourceFileName);
                myAffectedFiles.add(sourceFileName);
              }
 else {
                final int outerClass=r.getOuterClassName();
                if (!isEmpty(outerClass) && myFuture.isFieldVisible(outerClass,f)) {
                  debug("Affecting inner subclass (introduced field can potentially hide surrounding class fields): ",sourceFileName);
                  myAffectedFiles.add(sourceFileName);
                }
              }
            }
          }
          debug("Affecting field usages referenced from subclass ",subClass);
          final TIntHashSet propagated=myFuture.propagateFieldAccess(f.name,subClass);
          myFuture.affectFieldUsages(f,propagated,f.createUsage(myContext,subClass),state.myAffectedUsages,state.myDependants);
          final TIntHashSet deps=myClassToClassDependency.get(subClass);
          if (deps != null) {
            addAll(state.myDependants,deps);
          }
          return true;
        }
      }
);
    }
    final Collection<Pair<FieldRepr,ClassRepr>> overriddenFields=new HashSet<Pair<FieldRepr,ClassRepr>>();
    myFuture.addOverriddenFields(f,classRepr,overriddenFields);
    for (    final Pair<FieldRepr,ClassRepr> p : overriddenFields) {
      final FieldRepr ff=p.first;
      final ClassRepr cc=p.second;
      if (!ff.isPrivate()) {
        final TIntHashSet propagated=myPresent.propagateFieldAccess(ff.name,cc.name);
        final Set<UsageRepr.Usage> localUsages=new HashSet<UsageRepr.Usage>();
        debug("Affecting usages of overridden field in class ",cc.name);
        myFuture.affectFieldUsages(ff,propagated,ff.createUsage(myContext,cc.name),localUsages,state.myDependants);
        if (f.isPrivate() || (f.isPublic() && (ff.isPublic() || ff.isPackageLocal())) || (f.isProtected() && ff.isProtected())|| (f.isPackageLocal() && ff.isPackageLocal())) {
        }
 else {
          Util.UsageConstraint constaint;
          if ((ff.isProtected() && f.isPublic()) || (f.isProtected() && ff.isPublic()) || (ff.isPackageLocal() && f.isProtected())) {
            constaint=myFuture.new NegationConstraint(myFuture.new InheritanceConstraint(cc.name));
          }
 else           if (ff.isPublic() && ff.isPackageLocal()) {
            constaint=myFuture.new NegationConstraint(myFuture.new PackageConstraint(cc.getPackageName()));
          }
 else {
            constaint=myFuture.new IntersectionConstraint(myFuture.new NegationConstraint(myFuture.new InheritanceConstraint(cc.name)),myFuture.new NegationConstraint(myFuture.new PackageConstraint(cc.getPackageName())));
          }
          for (          final UsageRepr.Usage usage : localUsages) {
            state.myUsageConstraints.put(usage,constaint);
          }
        }
        state.myAffectedUsages.addAll(localUsages);
      }
    }
  }
  debug("End of added fields processing");
  return true;
}
