{
  final Collection<MethodRepr> added=diff.methods().added();
  if (added.isEmpty()) {
    return;
  }
  debug("Processing added methods: ");
  if (it.isAnnotation()) {
    debug("Class is annotation, skipping method analysis");
    return;
  }
  Ref<ClassRepr> oldItRef=null;
  for (  final MethodRepr m : added) {
    debug("Method: ",m.name);
    if (it.isInterface() || it.isAbstract() || m.isAbstract()) {
      debug("Class is abstract, or is interface, or added method in abstract => affecting all subclasses");
      myFuture.affectSubclasses(it.name,myAffectedFiles,state.myAffectedUsages,state.myDependants,false);
    }
    TIntHashSet propagated=null;
    if (!m.isPrivate() && m.name != myInitName) {
      if (oldItRef == null) {
        oldItRef=new Ref<ClassRepr>(getReprByName(null,it.name));
      }
      final ClassRepr oldIt=oldItRef.get();
      if (oldIt != null && myPresent.hasOverriddenMethods(oldIt,MethodRepr.equalByJavaRules(m))) {
      }
 else {
        if (m.myArgumentTypes.length > 0) {
          propagated=myFuture.propagateMethodAccess(m,it.name);
          debug("Conservative case on overriding methods, affecting method usages");
          myFuture.affectMethodUsages(m,propagated,m.createMetaUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
    }
    if (!m.isPrivate()) {
      final Collection<Pair<MethodRepr,ClassRepr>> affectedMethods=myFuture.findAllMethodsBySpecificity(m,it);
      final MethodRepr.Predicate overrides=MethodRepr.equalByJavaRules(m);
      if (propagated == null) {
        propagated=myFuture.propagateMethodAccess(m,it.name);
      }
      final Collection<MethodRepr> lessSpecific=it.findMethods(myFuture.lessSpecific(m));
      for (      final MethodRepr mm : lessSpecific) {
        if (!mm.equals(m)) {
          debug("Found less specific method, affecting method usages");
          myFuture.affectMethodUsages(mm,propagated,mm.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
      debug("Processing affected by specificity methods");
      for (      final Pair<MethodRepr,ClassRepr> pair : affectedMethods) {
        final MethodRepr method=pair.first;
        final ClassRepr methodClass=pair.second;
        if (methodClass == MOCK_CLASS) {
          continue;
        }
        final Boolean inheritorOf=myPresent.isInheritorOf(methodClass.name,it.name);
        final boolean isInheritor=inheritorOf != null && inheritorOf;
        debug("Method: ",method.name);
        debug("Class : ",methodClass.name);
        if (overrides.satisfy(method) && isInheritor) {
          debug("Current method overrides that found");
          final File file=myClassToSourceFile.get(methodClass.name);
          if (file != null) {
            myAffectedFiles.add(file);
            debug("Affecting file ",file);
          }
        }
 else {
          debug("Current method does not override that found");
          final TIntHashSet yetPropagated=myPresent.propagateMethodAccess(method,it.name);
          if (isInheritor) {
            final TIntHashSet deps=myClassToClassDependency.get(methodClass.name);
            if (deps != null) {
              addAll(state.myDependants,deps);
            }
            myFuture.affectMethodUsages(method,yetPropagated,method.createUsage(myContext,methodClass.name),state.myAffectedUsages,state.myDependants);
          }
          debug("Affecting method usages for that found");
          myFuture.affectMethodUsages(method,yetPropagated,method.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
      final TIntHashSet subClasses=getAllSubclasses(it.name);
      if (subClasses != null) {
        subClasses.forEach(new TIntProcedure(){
          @Override public boolean execute(          int subClass){
            final ClassRepr r=myFuture.reprByName(subClass);
            if (r != null) {
              final File sourceFileName=myClassToSourceFile.get(subClass);
              if (sourceFileName != null) {
                final int outerClass=r.getOuterClassName();
                if (!isEmpty(outerClass) && myFuture.isMethodVisible(outerClass,m)) {
                  myAffectedFiles.add(sourceFileName);
                  debug("Affecting file due to local overriding: ",sourceFileName);
                }
              }
            }
            return true;
          }
        }
);
      }
    }
  }
  debug("End of added methods processing");
}
