{
  final MultiMap<VcsRoot,FilePath> map=sortByVcsRoots.sort(myDeleted);
  myPreparedDeletion=new MultiMap<VcsRoot,FilePath>();
  for (  VcsRoot vcsRoot : map.keySet()) {
    if (vcsRoot != null && vcsRoot.getVcs() != null) {
      final CheckinEnvironment localChangesProvider=vcsRoot.getVcs().getCheckinEnvironment();
      if (localChangesProvider == null)       continue;
      final boolean takeDirs=vcsRoot.getVcs().areDirectoriesVersionedItems();
      final Collection<FilePath> files=map.get(vcsRoot);
      final List<FilePath> toBeDeleted=new LinkedList<FilePath>();
      for (      FilePath file : files) {
        final FilePath parent=file.getParentPath();
        if ((takeDirs || (!file.isDirectory())) && parent != null && parent.getIOFile().exists()) {
          toBeDeleted.add(file);
        }
      }
      if (toBeDeleted.isEmpty())       return;
      if (!vcsRoot.getVcs().fileListenerIsSynchronous()) {
        for (        FilePath filePath : toBeDeleted) {
          myVcsFileListenerContextHelper.ignoreDeleted(filePath);
        }
      }
      myPreparedDeletion.put(vcsRoot,toBeDeleted);
    }
  }
}
