{
  final String message;
  final Intersection intersection;
  final ChangeListManager listManager=ChangeListManager.getInstance(myProject);
  final List<LocalChangeList> localChangeLists=listManager.getChangeListsCopy();
  if (myMergeAll) {
    intersection=getMergeAllIntersection(localChangeLists);
    message="There are local changes that can potentially intersect with merge changes.\nDo you want to continue?";
  }
 else {
    intersection=checkIntersection(myLists,localChangeLists);
    message="There are local changes that will intersect with merge changes.\nDo you want to continue?";
  }
  if (intersection == null || intersection.getChangesSubset().isEmpty())   return;
  final int result=Messages.showDialog(message,myTitle,new String[]{"Shelve local changes","Continue merge","Cancel"},0,Messages.getQuestionIcon());
switch (result) {
case 2:
    context.cancelEverything();
  return;
case 1:
return;
case 0:
default :
context.next(new ShelveLocalChanges(intersection));
}
}
