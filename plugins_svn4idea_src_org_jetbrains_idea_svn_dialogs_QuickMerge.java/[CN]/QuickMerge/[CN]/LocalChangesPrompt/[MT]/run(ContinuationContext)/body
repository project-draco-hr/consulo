{
  final Intersection intersection;
  final ChangeListManager listManager=ChangeListManager.getInstance(myProject);
  final List<LocalChangeList> localChangeLists=listManager.getChangeListsCopy();
  if (myMergeAll) {
    intersection=getMergeAllIntersection(localChangeLists);
  }
 else {
    intersection=checkIntersection(myLists,localChangeLists);
  }
  if (intersection == null || intersection.getChangesSubset().isEmpty())   return;
  final LocalChangesAction action=myInteraction.selectLocalChangesAction(myMergeAll);
switch (action) {
case shelve:
    context.next(new ShelveLocalChanges(intersection));
  return;
case cancel:
context.cancelEverything();
return;
case continueMerge:
return;
case inspect:
@SuppressWarnings("unchecked") final Collection<Change> changes=(Collection<Change>)intersection.getChangesSubset().values();
final List<FilePath> paths=ChangesUtil.getPaths(changes);
Collections.sort(paths,FilePathByPathComparator.getInstance());
myInteraction.showIntersectedLocalPaths(paths);
context.cancelEverything();
return;
default :
}
}
