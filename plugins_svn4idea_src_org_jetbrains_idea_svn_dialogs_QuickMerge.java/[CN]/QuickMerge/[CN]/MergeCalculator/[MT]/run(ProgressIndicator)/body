{
  final Consumer<CopyData> revisionsLoader=new Consumer<CopyData>(){
    public void consume(    CopyData copyData){
      if (copyData == null) {
        showErrorBalloon("Merge start wasn't found");
        return;
      }
      myIsReintegrate=!copyData.isTrunkSupposedCorrect();
      if (!myWcInfo.getFormat().supportsMergeInfo())       return;
      final long localLatest=!copyData.isTrunkSupposedCorrect() ? copyData.getCopyTargetRevision() : copyData.getCopySourceRevision();
      final SvnCommittedChangesProvider committedChangesProvider=(SvnCommittedChangesProvider)myVcs.getCommittedChangesProvider();
      final ChangeBrowserSettings settings=new ChangeBrowserSettings();
      settings.CHANGE_AFTER=Long.toString(localLatest);
      settings.USE_CHANGE_AFTER_FILTER=true;
      String local=SVNPathUtil.getRelativePath(myWcInfo.getRepositoryRoot(),myWcInfo.getRootUrl());
      final String relativeLocal=(local.startsWith("/") ? local : "/" + local);
      final LinkedList<Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>> list=new LinkedList<Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>>();
      try {
        myMergeInfoHelper=new OneShotMergeInfoHelper(myProject,myWcInfo,mySourceUrl);
        myMergeInfoHelper.prepare();
        committedChangesProvider.getCommittedChangesWithMergedRevisons(settings,new SvnRepositoryLocation(mySourceUrl),0,new PairConsumer<SvnChangeList,TreeStructureNode<SVNLogEntry>>(){
          public void consume(          SvnChangeList svnList,          TreeStructureNode<SVNLogEntry> tree){
            indicator.checkCanceled();
            if (localLatest >= svnList.getNumber())             return;
            list.add(new Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>(svnList,tree));
          }
        }
);
      }
 catch (      VcsException e) {
        AbstractVcsHelper.getInstance(myProject).showErrors(Collections.singletonList(e),"Checking revisions for merge fault");
      }
catch (      SVNException e) {
        AbstractVcsHelper.getInstance(myProject).showErrors(Collections.singletonList(new VcsException(e)),"Checking revisions for merge fault");
      }
      for (      Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>> pair : list) {
        final SvnChangeList svnList=pair.getFirst();
        final Pair<SvnMergeInfoCache.MergeCheckResult,Set<String>> result=myMergeInfoHelper.checkList(svnList);
        final SvnMergeInfoCache.MergeCheckResult checkResult=result.getFirst();
        final Set<String> notMergedSet=result.getSecond();
        if (notMergedSet != null & (!notMergedSet.isEmpty())) {
          myPartiallyMerged.put(svnList.getNumber(),notMergedSet);
        }
        if (SvnMergeInfoCache.MergeCheckResult.NOT_MERGED.equals(checkResult)) {
          final List<TreeStructureNode<SVNLogEntry>> children=pair.getSecond().getChildren();
          boolean localChange=false;
          for (          TreeStructureNode<SVNLogEntry> child : children) {
            if (isLocalRevisionMergeIteration(child,relativeLocal,indicator)) {
              localChange=true;
              break;
            }
          }
          if (!localChange) {
            myNotMerged.add(svnList);
          }
        }
      }
    }
  }
;
  new FirstInBranch(myVcs,myWcInfo.getRepositoryRoot(),myWcInfo.getRootUrl(),mySourceUrl,revisionsLoader).run();
}
