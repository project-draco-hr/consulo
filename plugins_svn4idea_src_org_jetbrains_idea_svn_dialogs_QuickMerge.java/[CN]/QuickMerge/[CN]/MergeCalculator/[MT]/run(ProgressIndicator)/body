{
  new FirstInBranch(myVcs,myWcInfo.getRepositoryRoot(),myWcInfo.getRootUrl(),mySourceUrl,new Consumer<CopyData>(){
    public void consume(    CopyData copyData){
      if (copyData == null) {
        showErrorBalloon("Merge start wasn't found");
        return;
      }
      myIsReintegrate=!copyData.isTrunkSupposedCorrect();
      if (!myWcInfo.getFormat().supportsMergeInfo())       return;
      final long localLatest=!copyData.isTrunkSupposedCorrect() ? copyData.getCopyTargetRevision() : copyData.getCopySourceRevision();
      myBranchInfo=new BranchInfo(myVcs,myWcInfo.getRepositoryRoot(),myWcInfo.getRootUrl(),mySourceUrl,mySourceUrl,myVcs.createWCClient());
      final CommittedChangesProvider<SvnChangeList,ChangeBrowserSettings> committedChangesProvider=myVcs.getCommittedChangesProvider();
      final ChangeBrowserSettings settings=new ChangeBrowserSettings();
      settings.CHANGE_AFTER=Long.toString(localLatest);
      settings.USE_CHANGE_AFTER_FILTER=true;
      try {
        committedChangesProvider.loadCommittedChanges(settings,new SvnRepositoryLocation(mySourceUrl),committedChangesProvider.getUnlimitedCountValue(),new AsynchConsumer<CommittedChangeList>(){
          public void finished(){
          }
          public void consume(          CommittedChangeList committedChangeList){
            final SvnChangeList svnList=(SvnChangeList)committedChangeList;
            if (localLatest >= svnList.getNumber())             return;
            final SvnMergeInfoCache.MergeCheckResult checkResult=myBranchInfo.checkList(svnList,myWcInfo.getPath());
            if (SvnMergeInfoCache.MergeCheckResult.NOT_MERGED.equals(checkResult)) {
              myNotMerged.add(svnList);
            }
          }
        }
);
      }
 catch (      VcsException e) {
        AbstractVcsHelper.getInstance(myProject).showErrors(Collections.singletonList(e),"Checking revisions for merge fault");
      }
    }
  }
).run();
}
