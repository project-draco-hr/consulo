{
  SvnBranchPointsCalculator.WrapperInvertor<SvnBranchPointsCalculator.BranchCopyData> copyDataValue=null;
  try {
    copyDataValue=myCopyData.get().get();
  }
 catch (  SVNException e) {
    finishWithError(context,"Merge start wasn't found",Collections.singletonList(new VcsException(e)));
    return;
  }
  if (copyDataValue == null) {
    finishWithError(context,"Merge start wasn't found",true);
    return;
  }
  final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
  myIsReintegrate=copyDataValue.isInvertedSense();
  if (!myWcInfo.getFormat().supportsMergeInfo())   return;
  final SvnBranchPointsCalculator.BranchCopyData data=copyDataValue.getTrue();
  final long sourceLatest=data.getTargetRevision();
  final SvnCommittedChangesProvider committedChangesProvider=(SvnCommittedChangesProvider)myVcs.getCommittedChangesProvider();
  final ChangeBrowserSettings settings=new ChangeBrowserSettings();
  settings.CHANGE_AFTER=Long.toString(sourceLatest);
  settings.USE_CHANGE_AFTER_FILTER=true;
  String local=SVNPathUtil.getRelativePath(myWcInfo.getRepositoryRoot(),myWcInfo.getRootUrl());
  final String relativeLocal=(local.startsWith("/") ? local : "/" + local);
  String relativeBranch=SVNPathUtil.getRelativePath(myWcInfo.getRepositoryRoot(),mySourceUrl);
  relativeBranch=(relativeBranch.startsWith("/") ? relativeBranch : "/" + relativeBranch);
  final LinkedList<Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>> list=new LinkedList<Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>>();
  try {
    committedChangesProvider.getCommittedChangesWithMergedRevisons(settings,new SvnRepositoryLocation(mySourceUrl),0,new PairConsumer<SvnChangeList,TreeStructureNode<SVNLogEntry>>(){
      public void consume(      SvnChangeList svnList,      TreeStructureNode<SVNLogEntry> tree){
        indicator.checkCanceled();
        if (sourceLatest >= svnList.getNumber())         return;
        list.add(new Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>>(svnList,tree));
      }
    }
);
  }
 catch (  VcsException e) {
    finishWithError(context,"Checking revisions for merge fault",Collections.singletonList(e));
  }
  indicator.setText("Checking merge information...");
  for (  Pair<SvnChangeList,TreeStructureNode<SVNLogEntry>> pair : list) {
    final SvnChangeList svnList=pair.getFirst();
    final SvnMergeInfoCache.MergeCheckResult checkResult=myMergeChecker.checkList(svnList);
    indicator.setText2("Processing revision " + svnList.getNumber());
    if (SvnMergeInfoCache.MergeCheckResult.NOT_MERGED.equals(checkResult)) {
      boolean localChange=checkListForPaths(relativeLocal,relativeBranch,pair);
      if (!localChange) {
        myNotMerged.add(svnList);
      }
    }
  }
  if (myNotMerged.isEmpty()) {
    finishWithError(context,"Everything is up-to-date",false);
    return;
  }
  context.next(new ShowRevisionSelector(copyDataValue));
}
