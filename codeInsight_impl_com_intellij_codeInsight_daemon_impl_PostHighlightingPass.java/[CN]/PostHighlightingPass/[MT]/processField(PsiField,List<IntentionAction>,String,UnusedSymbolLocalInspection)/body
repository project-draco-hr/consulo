{
  final PsiIdentifier identifier=field.getNameIdentifier();
  if (field.hasModifierProperty(PsiModifier.PRIVATE)) {
    if (!myRefCountHolder.isReferenced(field) && !isImplicitUsage(field)) {
      if (HighlightUtil.isSerializationImplicitlyUsedField(field)) {
        return null;
      }
      String message=MessageFormat.format(JavaErrorMessages.message("private.field.is.not.used"),identifier.getText());
      HighlightInfo highlightInfo=createUnusedSymbolInfo(identifier,message);
      QuickFixAction.registerQuickFixAction(highlightInfo,new RemoveUnusedVariableFix(field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(true,false,field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(false,true,field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(true,true,field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateConstructorParameterFromFieldFix(field),options,displayName);
      return highlightInfo;
    }
    final boolean readReferenced=myRefCountHolder.isReferencedForRead(field);
    if (!readReferenced && !isImplicitRead(field)) {
      String message=MessageFormat.format(JavaErrorMessages.message("private.field.is.not.used.for.reading"),identifier.getText());
      HighlightInfo highlightInfo=createUnusedSymbolInfo(identifier,message);
      QuickFixAction.registerQuickFixAction(highlightInfo,new RemoveUnusedVariableFix(field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(true,false,field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(false,true,field),options,displayName);
      QuickFixAction.registerQuickFixAction(highlightInfo,new CreateGetterOrSetterAction(true,true,field),options,displayName);
      return highlightInfo;
    }
    if (!field.hasInitializer()) {
      final boolean injected=isFieldInjected(field,unusedSymbolInspection.INJECTION_ANNOS);
      final boolean writeReferenced=myRefCountHolder.isReferencedForWrite(field);
      if (!writeReferenced && !injected && !isImplicitWrite(field)) {
        String message=MessageFormat.format(JavaErrorMessages.message("private.field.is.not.assigned"),identifier.getText());
        HighlightInfo info=createUnusedSymbolInfo(identifier,message);
        QuickFixAction.registerQuickFixAction(info,new CreateGetterOrSetterAction(false,true,field),options,displayName);
        QuickFixAction.registerQuickFixAction(info,new CreateConstructorParameterFromFieldFix(field),options,displayName);
        final PsiAnnotation[] psiAnnotations=field.getModifierList().getAnnotations();
        if (psiAnnotations.length > 0) {
          for (          PsiAnnotation psiAnnotation : psiAnnotations) {
            @NonNls final String name=psiAnnotation.getQualifiedName();
            if (name == null)             continue;
            if (name.startsWith("java.") || name.startsWith("javax.") || name.startsWith("org.jetbrains."))             continue;
            QuickFixAction.registerQuickFixAction(info,unusedSymbolInspection.createAddToInjectionAnnotationsIntentionAction(name,field));
          }
        }
        return info;
      }
    }
  }
  return null;
}
