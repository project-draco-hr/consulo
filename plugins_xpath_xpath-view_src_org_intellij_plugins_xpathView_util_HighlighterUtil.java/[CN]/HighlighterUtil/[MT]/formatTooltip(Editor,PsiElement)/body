{
  if (!(element instanceof XmlTag)) {
    final String text=element.getText();
    if ((text == null || text.length() == 0) && MyPsiUtil.isNameElement(element)) {
      final XmlTag tag=PsiTreeUtil.getParentOfType(element,XmlTag.class,true);
      if (tag != null) {
        return tag.getName();
      }
    }
    return text;
  }
  final CodeStyleSettingsManager instance=CodeStyleSettingsManager.getInstance(element.getProject());
  final int tabSize=instance.getCurrentSettings().getTabSize(FileTypeManager.getInstance().getFileTypeByExtension("xml"));
  final char[] spaces=new char[tabSize];
  for (int i=0; i < spaces.length; i++) {
    spaces[i]=' ';
  }
  final int textOffset=element.getTextOffset();
  final int lineStartOffset=e.logicalPositionToOffset(new LogicalPosition(e.offsetToLogicalPosition(textOffset).line,0));
  final CharSequence chars=e.getDocument().getCharsSequence();
  int indent=0;
  for (int i=lineStartOffset; i < textOffset; i++) {
    if (chars.charAt(i) == ' ') {
      indent++;
    }
 else     if (chars.charAt(i) == '\t') {
      indent+=((indent + tabSize) / tabSize) * tabSize - indent;
    }
 else {
      break;
    }
  }
  final String text=element.getText().replaceAll("\\t",new String(spaces)).replaceAll("&","&amp;").replaceAll("<","&lt;");
  final Pattern indentPattern=Pattern.compile("^(\\s*).+");
  final StringBuilder sb=new StringBuilder("<html><pre>");
  final String[] lines=text.split("\\n");
  for (  String line : lines) {
    final Matcher matcher=indentPattern.matcher(line);
    if (matcher.matches()) {
      line=line.substring(Math.min(matcher.group(1).length(),indent));
    }
    sb.append(line).append("\n");
  }
  return sb.append("</pre></html>").toString();
}
