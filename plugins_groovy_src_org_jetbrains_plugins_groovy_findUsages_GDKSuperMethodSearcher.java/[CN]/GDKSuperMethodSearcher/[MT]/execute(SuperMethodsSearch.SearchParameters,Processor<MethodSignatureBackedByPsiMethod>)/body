{
  final PsiMethod method=queryParameters.getMethod();
  if (!(method instanceof GrMethod)) {
    return true;
  }
  final PsiClass psiClass=method.getContainingClass();
  if (psiClass == null)   return true;
  final HierarchicalMethodSignature hierarchicalSignature=method.getHierarchicalMethodSignature();
  if (hierarchicalSignature.getSuperSignatures().size() != 0)   return true;
  final Project project=method.getProject();
  final String name=method.getName();
  final MethodResolverProcessor processor=new MethodResolverProcessor(name,((GrMethod)method),false,null,null,PsiType.EMPTY_ARRAY);
  ResolveUtil.processNonCodeMethods(JavaPsiFacade.getElementFactory(project).createType(psiClass),processor,method,false);
  final GroovyResolveResult[] candidates=processor.getCandidates();
  final List<PsiMethod> allMethods=new ArrayList<PsiMethod>();
  for (  GroovyResolveResult candidate : candidates) {
    final PsiElement element=candidate.getElement();
    if (element instanceof PsiMethod) {
      allMethods.add((PsiMethod)element);
    }
  }
  final MethodSignature signature=method.getHierarchicalMethodSignature();
  List<PsiMethod> goodSupers=new ArrayList<PsiMethod>();
  for (  PsiMethod m : allMethods) {
    if (PsiImplUtil.isExtendsSignature(m.getHierarchicalMethodSignature(),signature)) {
      goodSupers.add(m);
    }
  }
  if (goodSupers.size() == 0)   return true;
  final PsiManager psiManager=PsiManager.getInstance(project);
  final GlobalSearchScope searchScope=GlobalSearchScope.allScope(project);
  List<PsiMethod> result=new ArrayList<PsiMethod>(goodSupers.size());
  result.add(goodSupers.get(0));
  final Comparator<PsiMethod> comparator=new Comparator<PsiMethod>(){
    public int compare(    PsiMethod o1,    PsiMethod o2){
      o1=getRealMethod(o1);
      o2=getRealMethod(o2);
      final PsiType type1=TypeConversionUtil.erasure(o1.getParameterList().getParameters()[0].getType());
      final PsiType type2=TypeConversionUtil.erasure(o2.getParameterList().getParameters()[0].getType());
      if (TypesUtil.isAssignable(type1,type2,psiManager,searchScope)) {
        return -1;
      }
 else       if (TypesUtil.isAssignable(type2,type1,psiManager,searchScope)) {
        return 1;
      }
      return 0;
    }
  }
;
  Outer:   for (  PsiMethod current : goodSupers) {
    for (Iterator<PsiMethod> i=result.iterator(); i.hasNext(); ) {
      PsiMethod m=i.next();
      final int res=comparator.compare(m,current);
      if (res > 0) {
        continue Outer;
      }
 else       if (res < 0) {
        i.remove();
      }
    }
    result.add(current);
  }
  for (  PsiMethod psiMethod : result) {
    if (!consumer.process(getRealMethod(psiMethod).getHierarchicalMethodSignature())) {
      return false;
    }
  }
  return true;
}
