{
  final PsiMethod method=queryParameters.getMethod();
  if (!(method instanceof GrMethod)) {
    return true;
  }
  if (method.hasModifierProperty(PsiModifier.STATIC))   return true;
  final PsiClass psiClass=method.getContainingClass();
  if (psiClass == null)   return true;
  final HierarchicalMethodSignature hierarchicalSignature=method.getHierarchicalMethodSignature();
  if (hierarchicalSignature.getSuperSignatures().size() != 0)   return true;
  final Project project=method.getProject();
  final String name=method.getName();
  final MethodResolverProcessor processor=new MethodResolverProcessor(name,((GrMethod)method),false,null,null,PsiType.EMPTY_ARRAY);
  ResolveUtil.processNonCodeMembers(JavaPsiFacade.getElementFactory(project).createType(psiClass),processor,(GrMethod)method,ResolveState.initial());
  final GroovyResolveResult[] candidates=processor.getCandidates();
  final PsiManager psiManager=PsiManager.getInstance(project);
  final MethodSignature signature=method.getHierarchicalMethodSignature();
  List<PsiMethod> goodSupers=new ArrayList<PsiMethod>();
  for (  GroovyResolveResult candidate : candidates) {
    final PsiElement element=candidate.getElement();
    if (element instanceof PsiMethod) {
      final PsiMethod m=(PsiMethod)element;
      if (!isTheSameMethod(method,psiManager,m) && PsiImplUtil.isExtendsSignature(m.getHierarchicalMethodSignature(),signature)) {
        goodSupers.add(m);
      }
    }
  }
  if (goodSupers.size() == 0)   return true;
  final GlobalSearchScope searchScope=GlobalSearchScope.allScope(project);
  List<PsiMethod> result=new ArrayList<PsiMethod>(goodSupers.size());
  result.add(goodSupers.get(0));
  final Comparator<PsiMethod> comparator=new Comparator<PsiMethod>(){
    public int compare(    PsiMethod o1,    PsiMethod o2){
      final PsiType type1=getRealType(o1);
      final PsiType type2=getRealType(o2);
      if (TypesUtil.isAssignable(type1,type2,o1,true)) {
        return -1;
      }
 else       if (TypesUtil.isAssignable(type2,type1,o1,true)) {
        return 1;
      }
      return 0;
    }
  }
;
  Outer:   for (  PsiMethod current : goodSupers) {
    for (Iterator<PsiMethod> i=result.iterator(); i.hasNext(); ) {
      PsiMethod m=i.next();
      final int res=comparator.compare(m,current);
      if (res > 0) {
        continue Outer;
      }
 else       if (res < 0) {
        i.remove();
      }
    }
    result.add(current);
  }
  for (  PsiMethod psiMethod : result) {
    if (!consumer.process(getRealMethod(psiMethod).getHierarchicalMethodSignature())) {
      return false;
    }
  }
  return true;
}
