{
  int zzInput;
  int zzAction;
  int zzCurrentPosL;
  int zzMarkedPosL;
  int zzEndReadL=zzEndRead;
  CharSequence zzBufferL=zzBuffer;
  char[] zzBufferArrayL=zzBufferArray;
  char[] zzCMapL=ZZ_CMAP;
  int[] zzTransL=ZZ_TRANS;
  int[] zzRowMapL=ZZ_ROWMAP;
  int[] zzAttrL=ZZ_ATTRIBUTE;
  while (true) {
    zzMarkedPosL=zzMarkedPos;
    zzAction=-1;
    zzCurrentPosL=zzCurrentPos=zzStartRead=zzMarkedPosL;
    zzState=ZZ_LEXSTATE[zzLexicalState];
    zzForAction: {
      while (true) {
        if (zzCurrentPosL < zzEndReadL)         zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++);
 else         if (zzAtEOF) {
          zzInput=YYEOF;
          break zzForAction;
        }
 else {
          zzCurrentPos=zzCurrentPosL;
          zzMarkedPos=zzMarkedPosL;
          boolean eof=zzRefill();
          zzCurrentPosL=zzCurrentPos;
          zzMarkedPosL=zzMarkedPos;
          zzBufferL=zzBuffer;
          zzEndReadL=zzEndRead;
          if (eof) {
            zzInput=YYEOF;
            break zzForAction;
          }
 else {
            zzInput=zzBufferArrayL != null ? zzBufferArrayL[zzCurrentPosL++] : zzBufferL.charAt(zzCurrentPosL++);
          }
        }
        int zzNext=zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
        if (zzNext == -1)         break zzForAction;
        zzState=zzNext;
        int zzAttributes=zzAttrL[zzState];
        if ((zzAttributes & 1) == 1) {
          zzAction=zzState;
          zzMarkedPosL=zzCurrentPosL;
          if ((zzAttributes & 8) == 8)           break zzForAction;
        }
      }
    }
    zzMarkedPos=zzMarkedPosL;
switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
case 70:
{
        yybegin(WAIT_FOR_REGEX);
        return (mSPREAD_DOT);
      }
case 173:
    break;
case 27:
{
    yybegin(WAIT_FOR_REGEX);
    return (mMOD);
  }
case 174:
break;
case 46:
{
yybegin(NLS_AFTER_NLS);
afterComment=IN_TRIPLE_IDENT;
return mNLS;
}
case 175:
break;
case 112:
{
yybegin(WAIT_FOR_REGEX);
return (mSTAR_STAR_ASSIGN);
}
case 176:
break;
case 133:
{
return (kTRUE);
}
case 177:
break;
case 122:
{
yybegin(WAIT_FOR_REGEX);
return (mREGEX_MATCH);
}
case 178:
break;
case 69:
{
yybegin(WAIT_FOR_REGEX);
return (mSTAR_STAR);
}
case 179:
break;
case 135:
{
return (kNULL);
}
case 180:
break;
case 129:
{
return (kENUM);
}
case 181:
break;
case 53:
{
blockStack.push(mDIV);
braceCount.push(mLCURLY);
yybegin(NLS_AFTER_LBRACE);
return mLCURLY;
}
case 182:
break;
case 55:
{
if (!gStringStack.isEmpty()) {
gStringStack.pop();
}
if (blockStack.isEmpty()) {
yybegin(YYINITIAL);
}
 else {
yybegin(IN_INNER_BLOCK);
}
return mREGEX_END;
}
case 183:
break;
case 62:
{
yypushback(1);
yybegin(IN_DOLLAR_SLASH_REGEX);
}
case 184:
break;
case 80:
{
return (kDO);
}
case 185:
break;
case 65:
{
yypushback(1);
yybegin(NLS_AFTER_COMMENT);
}
case 186:
break;
case 72:
{
return mSH_COMMENT;
}
case 187:
break;
case 42:
{
if (!gStringStack.isEmpty()) {
gStringStack.pop();
}
if (blockStack.isEmpty()) {
yybegin(YYINITIAL);
}
 else {
yybegin(IN_INNER_BLOCK);
}
return mGSTRING_END;
}
case 188:
break;
case 7:
{
return mIDENT;
}
case 189:
break;
case 144:
{
return (kSUPER);
}
case 190:
break;
case 94:
{
yybegin(WAIT_FOR_REGEX);
return (mREGEX_FIND);
}
case 191:
break;
case 99:
{
yybegin(WAIT_FOR_REGEX);
return (mBOR_ASSIGN);
}
case 192:
break;
case 171:
{
return (kINSTANCEOF);
}
case 193:
break;
case 35:
{
blockStack.push(mLPAREN);
braceCount.push(mLCURLY);
yybegin(NLS_AFTER_LBRACE);
return mLCURLY;
}
case 194:
break;
case 108:
{
if (!gStringStack.isEmpty()) {
gStringStack.pop();
}
if (blockStack.isEmpty()) {
yybegin(YYINITIAL);
}
 else {
yybegin(IN_INNER_BLOCK);
}
return mDOLLAR_SLASH_REGEX_END;
}
case 195:
break;
case 73:
{
yybegin(WAIT_FOR_REGEX);
return (mNOT_EQUAL);
}
case 196:
break;
case 103:
zzMarkedPos=zzStartRead + 1;
{
yybegin(IN_SINGLE_IDENT);
return mDOT;
}
case 197:
break;
case 152:
{
return (kSTATIC);
}
case 198:
break;
case 100:
{
yybegin(WAIT_FOR_REGEX);
return (mLOR);
}
case 199:
break;
case 57:
{
yypushback(1);
yybegin(IN_REGEX);
}
case 200:
break;
case 143:
{
return (kCATCH);
}
case 201:
break;
case 54:
{
return mREGEX_CONTENT;
}
case 202:
break;
case 106:
yypushback(1);
{
return mREGEX_CONTENT;
}
case 203:
break;
case 97:
{
yybegin(WAIT_FOR_REGEX);
return (mMOD_ASSIGN);
}
case 204:
break;
case 168:
{
return (kPROTECTED);
}
case 205:
break;
case 86:
{
yybegin(WAIT_FOR_REGEX);
return (mRANGE_INCLUSIVE);
}
case 206:
break;
case 113:
{
return mNUM_BIG_DECIMAL;
}
case 207:
break;
case 58:
{
yybegin(IN_DOLLAR_SLASH_REGEX_DOT);
return mIDENT;
}
case 208:
break;
case 25:
{
yybegin(WAIT_FOR_REGEX);
return (mGT);
}
case 209:
break;
case 33:
{
yypushback(1);
yybegin(IN_SINGLE_GSTRING);
}
case 210:
break;
case 125:
{
yybegin(WAIT_FOR_REGEX);
return (mSR_ASSIGN);
}
case 211:
break;
case 149:
{
return (kDOUBLE);
}
case 212:
break;
case 119:
{
yybegin(IN_TRIPLE_GSTRING);
gStringStack.push(mLBRACK);
return mGSTRING_BEGIN;
}
case 213:
break;
case 121:
{
return (kNEW);
}
case 214:
break;
case 36:
{
yypushback(1);
yybegin(IN_TRIPLE_GSTRING);
}
case 215:
break;
case 17:
{
yybegin(WAIT_FOR_REGEX);
return (mASSIGN);
}
case 216:
break;
case 50:
{
afterComment=YYINITIAL;
return (WHITE_SPACE);
}
case 217:
break;
case 156:
{
return (kNATIVE);
}
case 218:
break;
case 114:
{
return (kFOR);
}
case 219:
break;
case 98:
{
yybegin(WAIT_FOR_REGEX);
return (mBXOR_ASSIGN);
}
case 220:
break;
case 132:
{
return (kCHAR);
}
case 221:
break;
case 91:
{
yybegin(WAIT_FOR_REGEX);
return (mOPTIONAL_DOT);
}
case 222:
break;
case 24:
{
yybegin(WAIT_FOR_REGEX);
return (mLT);
}
case 223:
break;
case 148:
{
return (kIMPORT);
}
case 224:
break;
case 159:
{
return (kEXTENDS);
}
case 225:
break;
case 2:
{
yybegin(NLS_AFTER_NLS);
afterComment=WAIT_FOR_REGEX;
return !braceCount.isEmpty() && mLPAREN == braceCount.peek() ? WHITE_SPACE : mNLS;
}
case 226:
break;
case 60:
{
return mDOLLAR_SLASH_REGEX_CONTENT;
}
case 227:
break;
case 109:
yypushback(1);
{
return mDOLLAR_SLASH_REGEX_CONTENT;
}
case 228:
break;
case 63:
{
yypushback(1);
yybegin(afterComment);
}
case 229:
break;
case 157:
{
return (kFINALLY);
}
case 230:
break;
case 82:
{
yybegin(WAIT_FOR_REGEX);
return (mPLUS_ASSIGN);
}
case 231:
break;
case 136:
{
return (kVOID);
}
case 232:
break;
case 150:
{
return (kPUBLIC);
}
case 233:
break;
case 128:
{
return (kELSE);
}
case 234:
break;
case 12:
{
return mSTRING_LITERAL;
}
case 235:
break;
case 6:
{
yybegin(WAIT_FOR_REGEX);
return (mLNOT);
}
case 236:
break;
case 10:
{
yybegin(WAIT_FOR_REGEX);
return (mMINUS);
}
case 237:
break;
case 64:
{
yypushback(1);
yybegin(WAIT_FOR_REGEX);
}
case 238:
break;
case 59:
{
blockStack.push(mDOLLAR);
braceCount.push(mLCURLY);
yybegin(NLS_AFTER_LBRACE);
return mLCURLY;
}
case 239:
break;
case 30:
{
yybegin(WAIT_FOR_REGEX);
return (mBAND);
}
case 240:
break;
case 170:
{
return (kIMPLEMENTS);
}
case 241:
break;
case 5:
{
yybegin(WAIT_FOR_REGEX);
return (mSTAR);
}
case 242:
break;
case 11:
{
yybegin(WAIT_FOR_REGEX);
return (mDOT);
}
case 243:
break;
case 8:
{
return mNUM_INT;
}
case 244:
break;
case 167:
{
return (kINTERFACE);
}
case 245:
break;
case 81:
{
yybegin(WAIT_FOR_REGEX);
return (mINC);
}
case 246:
break;
case 161:
{
return (kPACKAGE);
}
case 247:
break;
case 146:
{
return (kTHROW);
}
case 248:
break;
case 92:
{
yybegin(WAIT_FOR_REGEX);
return (mELVIS);
}
case 249:
break;
case 79:
{
return (kIN);
}
case 250:
break;
case 84:
{
yybegin(WAIT_FOR_REGEX);
return (mMINUS_ASSIGN);
}
case 251:
break;
case 66:
{
return mSL_COMMENT;
}
case 252:
break;
case 37:
{
yybegin(IN_TRIPLE_DOT);
return mIDENT;
}
case 253:
break;
case 20:
{
yybegin(WAIT_FOR_REGEX);
braceCount.push(mLPAREN);
return (mLBRACK);
}
case 254:
break;
case 130:
{
return (kBYTE);
}
case 255:
break;
case 137:
{
yybegin(WAIT_FOR_REGEX);
return (mBSR_ASSIGN);
}
case 256:
break;
case 52:
{
yybegin(IN_REGEX_DOT);
return mIDENT;
}
case 257:
break;
case 44:
{
yybegin(IN_TRIPLE_GSTRING_DOLLAR);
return mDOLLAR;
}
case 258:
break;
case 49:
{
yypushback(1);
if (blockStack.isEmpty()) {
yybegin(YYINITIAL);
}
 else {
yybegin(IN_INNER_BLOCK);
}
}
case 259:
break;
case 172:
{
return (kSYNCHRONIZED);
}
case 260:
break;
case 117:
{
yybegin(WAIT_FOR_REGEX);
return (mTRIPLE_DOT);
}
case 261:
break;
case 85:
{
yybegin(WAIT_FOR_REGEX);
return (mCLOSABLE_BLOCK_OP);
}
case 262:
break;
case 87:
{
yybegin(WAIT_FOR_REGEX);
return (mMEMBER_POINTER);
}
case 263:
break;
case 120:
{
return (kTRY);
}
case 264:
break;
case 21:
{
if (!braceCount.isEmpty() && mLPAREN == braceCount.peek()) {
braceCount.pop();
}
return (mRBRACK);
}
case 265:
break;
case 48:
{
if (!blockStack.isEmpty()) {
IElementType br=blockStack.pop();
if (br.equals(mLPAREN)) yybegin(IN_SINGLE_GSTRING);
if (br.equals(mLBRACK)) yybegin(IN_TRIPLE_GSTRING);
if (br.equals(mDIV)) yybegin(IN_REGEX);
if (br.equals(mDOLLAR)) yybegin(IN_DOLLAR_SLASH_REGEX);
}
while (!braceCount.isEmpty() && mLCURLY != braceCount.peek()) {
braceCount.pop();
}
if (!braceCount.isEmpty() && mLCURLY == braceCount.peek()) {
braceCount.pop();
}
return mRCURLY;
}
case 266:
break;
case 131:
{
return (kCASE);
}
case 267:
break;
case 77:
{
return mNUM_DOUBLE;
}
case 268:
break;
case 158:
{
return (kDEFAULT);
}
case 269:
break;
case 126:
{
if (!gStringStack.isEmpty()) {
gStringStack.pop();
}
if (blockStack.isEmpty()) {
yybegin(YYINITIAL);
}
 else {
yybegin(IN_INNER_BLOCK);
}
return mGSTRING_END;
}
case 270:
break;
case 169:
{
return (kTRANSIENT);
}
case 271:
break;
case 111:
{
return GROOVY_DOC_COMMENT;
}
case 272:
break;
case 16:
{
yybegin(WAIT_FOR_REGEX);
return (mQUESTION);
}
case 273:
break;
case 153:
{
return (kSWITCH);
}
case 274:
break;
case 4:
{
if (zzStartRead == 0 || zzBuffer.subSequence(0,zzStartRead).toString().trim().length() == 0) {
yypushback(1);
yybegin(WAIT_FOR_REGEX);
}
 else {
return (mDIV);
}
}
case 275:
break;
case 110:
zzMarkedPos=zzStartRead + 1;
{
yybegin(IN_DOLLAR_SLASH_REGEX_IDENT);
return mDOT;
}
case 276:
break;
case 89:
{
return mGSTRING_LITERAL;
}
case 277:
break;
case 124:
{
yybegin(WAIT_FOR_REGEX);
return (mSL_ASSIGN);
}
case 278:
break;
case 138:
{
return (kFLOAT);
}
case 279:
break;
case 105:
{
yybegin(IN_DOLLAR_SLASH_REGEX);
gStringStack.push(mDOLLAR);
return mDOLLAR_SLASH_REGEX_BEGIN;
}
case 280:
break;
case 45:
{
yypushback(1);
yybegin(IN_TRIPLE_IDENT);
}
case 281:
break;
case 34:
{
yybegin(IN_SINGLE_DOT);
return mIDENT;
}
case 282:
break;
case 123:
{
yybegin(WAIT_FOR_REGEX);
return (mCOMPARE_TO);
}
case 283:
break;
case 88:
{
yypushback(2);
yybegin(WAIT_FOR_REGEX);
}
case 284:
break;
case 78:
{
return (kIF);
}
case 285:
break;
case 139:
{
return (kFINAL);
}
case 286:
break;
case 101:
{
yybegin(WAIT_FOR_REGEX);
return (mBAND_ASSIGN);
}
case 287:
break;
case 154:
{
return (kTHROWS);
}
case 288:
break;
case 75:
{
return mNUM_FLOAT;
}
case 289:
break;
case 38:
{
blockStack.push(mLBRACK);
braceCount.push(mLCURLY);
yybegin(NLS_AFTER_LBRACE);
return mLCURLY;
}
case 290:
break;
case 47:
{
blockStack.push(mLCURLY);
braceCount.push(mLCURLY);
yybegin(NLS_AFTER_LBRACE);
return (mLCURLY);
}
case 291:
break;
case 115:
{
return (kINT);
}
case 292:
break;
case 165:
{
return (kSTRICTFP);
}
case 293:
break;
case 9:
{
yybegin(WAIT_FOR_REGEX);
return (mPLUS);
}
case 294:
break;
case 163:
{
return (kABSTRACT);
}
case 295:
break;
case 140:
{
return (kFALSE);
}
case 296:
break;
case 41:
{
yybegin(IN_SINGLE_GSTRING_DOLLAR);
return mDOLLAR;
}
case 297:
break;
case 26:
{
yybegin(WAIT_FOR_REGEX);
return (mBNOT);
}
case 298:
break;
case 13:
{
yybegin(IN_SINGLE_GSTRING);
gStringStack.push(mLPAREN);
return mGSTRING_BEGIN;
}
case 299:
break;
case 90:
{
return (kAS);
}
case 300:
break;
case 71:
{
yybegin(WAIT_FOR_REGEX);
return (mSTAR_ASSIGN);
}
case 301:
break;
case 164:
{
return (kCONTINUE);
}
case 302:
break;
case 40:
{
clearStacks();
yybegin(NLS_AFTER_NLS);
afterComment=YYINITIAL;
return mNLS;
}
case 303:
break;
case 127:
{
return (kLONG);
}
case 304:
break;
case 76:
{
return mNUM_LONG;
}
case 305:
break;
case 141:
{
return (kBREAK);
}
case 306:
break;
case 160:
{
return (kBOOLEAN);
}
case 307:
break;
case 151:
{
return (kASSERT);
}
case 308:
break;
case 96:
{
yybegin(WAIT_FOR_REGEX);
return (mGE);
}
case 309:
break;
case 23:
{
yybegin(WAIT_FOR_REGEX);
return (mCOMMA);
}
case 310:
break;
case 93:
{
yybegin(WAIT_FOR_REGEX);
return (mEQUAL);
}
case 311:
break;
case 3:
{
return WHITE_SPACE;
}
case 312:
break;
case 134:
{
return (kTHIS);
}
case 313:
break;
case 162:
{
return (kPRIVATE);
}
case 314:
break;
case 18:
{
yybegin(WAIT_FOR_REGEX);
braceCount.push(mLPAREN);
return (mLPAREN);
}
case 315:
break;
case 104:
zzMarkedPos=zzStartRead + 1;
{
yybegin(IN_TRIPLE_NLS);
return mDOT;
}
case 316:
break;
case 51:
{
yybegin(IN_REGEX);
gStringStack.push(mDIV);
return mREGEX_BEGIN;
}
case 317:
break;
case 145:
{
return (kSHORT);
}
case 318:
break;
case 83:
{
yybegin(WAIT_FOR_REGEX);
return (mDEC);
}
case 319:
break;
case 31:
{
yybegin(WAIT_FOR_REGEX);
return (mSEMI);
}
case 320:
break;
case 61:
{
yybegin(IN_DOLLAR_SLASH_REGEX_DOLLAR);
return mDOLLAR;
}
case 321:
break;
case 166:
{
return (kVOLATILE);
}
case 322:
break;
case 14:
{
yybegin(NLS_AFTER_LBRACE);
braceCount.push(mLCURLY);
return (mLCURLY);
}
case 323:
break;
case 32:
{
yybegin(WAIT_FOR_REGEX);
return (mAT);
}
case 324:
break;
case 74:
{
return mNUM_BIG_INT;
}
case 325:
break;
case 118:
{
yybegin(WAIT_FOR_REGEX);
return (mRANGE_EXCLUSIVE);
}
case 326:
break;
case 142:
{
return (kCLASS);
}
case 327:
break;
case 68:
{
yybegin(WAIT_FOR_REGEX);
return (mDIV_ASSIGN);
}
case 328:
break;
case 95:
{
yybegin(WAIT_FOR_REGEX);
return (mLE);
}
case 329:
break;
case 155:
{
return (kRETURN);
}
case 330:
break;
case 22:
{
yybegin(WAIT_FOR_REGEX);
return (mCOLON);
}
case 331:
break;
case 107:
zzMarkedPos=zzStartRead + 1;
{
yybegin(IN_REGEX_IDENT);
return mDOT;
}
case 332:
break;
case 56:
{
yybegin(IN_REGEX_DOLLAR);
return mDOLLAR;
}
case 333:
break;
case 19:
{
if (!braceCount.isEmpty() && mLPAREN == braceCount.peek()) {
braceCount.pop();
}
return (mRPAREN);
}
case 334:
break;
case 43:
{
int zzFState=24;
int zzFPos=zzStartRead;
if (zzFin.length <= zzBufferL.length()) {
zzFin=new boolean[zzBufferL.length() + 1];
}
boolean zzFinL[]=zzFin;
while (zzFState != -1 && zzFPos < zzMarkedPos) {
if ((zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzInput=zzBufferL.charAt(zzFPos++);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) {
zzFinL[zzFPos]=true;
}
zzFState=25;
zzFPos=zzMarkedPos;
while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {
zzInput=zzBufferL.charAt(--zzFPos);
zzFState=zzTransL[zzRowMapL[zzFState] + zzCMapL[zzInput]];
}
;
zzMarkedPos=zzFPos;
}
{
return mGSTRING_CONTENT;
}
case 335:
break;
case 39:
{
return mGSTRING_CONTENT;
}
case 336:
break;
case 102:
{
yybegin(WAIT_FOR_REGEX);
return (mLAND);
}
case 337:
break;
case 29:
{
yybegin(WAIT_FOR_REGEX);
return (mBOR);
}
case 338:
break;
case 116:
{
return (kDEF);
}
case 339:
break;
case 28:
{
yybegin(WAIT_FOR_REGEX);
return (mBXOR);
}
case 340:
break;
case 15:
{
while (!braceCount.isEmpty() && mLCURLY != braceCount.peek()) {
braceCount.pop();
}
if (!braceCount.isEmpty() && mLCURLY == braceCount.peek()) {
braceCount.pop();
}
return mRCURLY;
}
case 341:
break;
case 147:
{
return (kWHILE);
}
case 342:
break;
case 1:
{
return mWRONG;
}
case 343:
break;
case 67:
{
return mML_COMMENT;
}
case 344:
break;
default :
if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
zzAtEOF=true;
zzDoEOF();
return null;
}
 else {
zzScanError(ZZ_NO_MATCH);
}
}
}
}
