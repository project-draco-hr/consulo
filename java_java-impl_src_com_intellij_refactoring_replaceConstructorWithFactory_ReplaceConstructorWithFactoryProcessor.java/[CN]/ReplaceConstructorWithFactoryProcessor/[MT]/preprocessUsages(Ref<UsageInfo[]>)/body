{
  UsageInfo[] usages=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final PsiResolveHelper helper=JavaPsiFacade.getInstance(myProject).getResolveHelper();
  final PsiClass constructorContainingClass=getConstructorContainingClass();
  if (!helper.isAccessible(constructorContainingClass,myTargetClass,null)) {
    String message=RefactoringBundle.message("class.0.is.not.accessible.from.target.1",RefactoringUIUtil.getDescription(constructorContainingClass,true),RefactoringUIUtil.getDescription(myTargetClass,true));
    conflicts.putValue(constructorContainingClass,message);
  }
  HashSet<PsiElement> reportedContainers=new HashSet<PsiElement>();
  final String targetClassDescription=RefactoringUIUtil.getDescription(myTargetClass,true);
  for (  UsageInfo usage : usages) {
    final PsiElement container=ConflictsUtil.getContainer(usage.getElement());
    if (!reportedContainers.contains(container)) {
      reportedContainers.add(container);
      if (!helper.isAccessible(myTargetClass,usage.getElement(),null)) {
        String message=RefactoringBundle.message("target.0.is.not.accessible.from.1",targetClassDescription,RefactoringUIUtil.getDescription(container,true));
        conflicts.putValue(myTargetClass,message);
      }
    }
  }
  if (myIsInner) {
    for (    UsageInfo usage : usages) {
      final PsiField field=PsiTreeUtil.getParentOfType(usage.getElement(),PsiField.class);
      if (field != null) {
        final PsiClass containingClass=field.getContainingClass();
        if (PsiTreeUtil.isAncestor(containingClass,myTargetClass,true)) {
          String message=RefactoringBundle.message("constructor.being.refactored.is.used.in.initializer.of.0",RefactoringUIUtil.getDescription(field,true),RefactoringUIUtil.getDescription(constructorContainingClass,false));
          conflicts.putValue(field,message);
        }
      }
    }
  }
  return showConflicts(conflicts);
}
