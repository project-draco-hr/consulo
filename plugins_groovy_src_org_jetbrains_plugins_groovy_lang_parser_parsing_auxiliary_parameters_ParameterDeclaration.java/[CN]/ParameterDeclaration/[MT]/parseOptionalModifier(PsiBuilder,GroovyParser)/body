{
  Set<IElementType> modSet=new HashSet<IElementType>();
  PsiBuilder.Marker marker=builder.mark();
  boolean hasModifiers=false;
  while (builder.getTokenType() == kFINAL || builder.getTokenType() == kDEF || builder.getTokenType() == mAT) {
    hasModifiers=true;
    if (kFINAL.equals(builder.getTokenType())) {
      if (modSet.contains(kFINAL)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("duplicate.modifier",PsiModifier.FINAL));
      }
 else {
        builder.advanceLexer();
        modSet.add(kFINAL);
      }
      ParserUtils.getToken(builder,mNLS);
    }
 else     if (kDEF.equals(builder.getTokenType())) {
      if (modSet.contains(kDEF)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("duplicate.modifier",GrModifier.DEF));
      }
 else {
        builder.advanceLexer();
        modSet.add(kDEF);
      }
      ParserUtils.getToken(builder,mNLS);
    }
 else {
      if (!Annotation.parse(builder,parser)) {
        ParserUtils.wrapError(builder,GroovyBundle.message("annotation.expected"));
      }
      ParserUtils.getToken(builder,mNLS);
    }
  }
  marker.done(MODIFIERS);
  return hasModifiers;
}
