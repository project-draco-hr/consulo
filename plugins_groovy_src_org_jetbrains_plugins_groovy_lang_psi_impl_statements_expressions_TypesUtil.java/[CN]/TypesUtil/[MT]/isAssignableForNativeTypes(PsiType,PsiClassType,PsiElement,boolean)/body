{
  if (!(lType instanceof PsiClassType))   return null;
  final PsiClassType.ClassResolveResult leftResult=((PsiClassType)lType).resolveGenerics();
  final PsiClassType.ClassResolveResult rightResult=rType.resolveGenerics();
  final PsiClass leftClass=leftResult.getElement();
  PsiClass rightClass=rightResult.getElement();
  if (rightClass == null || leftClass == null)   return null;
  if (!InheritanceUtil.isInheritorOrSelf(rightClass,leftClass,true))   return Boolean.FALSE;
  PsiSubstitutor rightSubstitutor=rightResult.getSubstitutor();
  if (!leftClass.hasTypeParameters())   return Boolean.TRUE;
  PsiSubstitutor leftSubstitutor=leftResult.getSubstitutor();
  if (!leftClass.getManager().areElementsEquivalent(leftClass,rightClass)) {
    rightSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(leftClass,rightClass,rightSubstitutor);
    rightClass=leftClass;
  }
 else   if (!rightClass.hasTypeParameters())   return Boolean.TRUE;
  Iterator<PsiTypeParameter> li=PsiUtil.typeParametersIterator(leftClass);
  Iterator<PsiTypeParameter> ri=PsiUtil.typeParametersIterator(rightClass);
  while (li.hasNext()) {
    if (!ri.hasNext())     return Boolean.FALSE;
    PsiTypeParameter lp=li.next();
    PsiTypeParameter rp=ri.next();
    final PsiType typeLeft=leftSubstitutor.substitute(lp);
    if (typeLeft == null)     continue;
    final PsiType typeRight=rightSubstitutor.substituteWithBoundsPromotion(rp);
    if (typeRight == null) {
      return Boolean.TRUE;
    }
    if (!isAssignableByMethodCallConversion(typeLeft,typeRight,context,allowConversion))     return Boolean.FALSE;
  }
  return Boolean.TRUE;
}
