{
  PsiReturnStatement[] returns=RefactoringUtil.findReturnStatements(method);
  if (returns.length == 0)   return false;
  PsiCodeBlock body=method.getBody();
  ControlFlow controlFlow;
  try {
    controlFlow=ControlFlowFactory.getControlFlow(body,new LocalsControlFlowPolicy(body),false);
  }
 catch (  AnalysisCanceledException e) {
    return false;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("Control flow:");
    LOG.debug(controlFlow.toString());
  }
  List<Instruction> instructions=new ArrayList<Instruction>(controlFlow.getInstructions());
  for (  PsiReturnStatement aReturn : returns) {
    int offset=controlFlow.getStartOffset(aReturn);
    int endOffset=controlFlow.getEndOffset(aReturn);
    while (offset <= endOffset && !(instructions.get(offset) instanceof GoToInstruction)) {
      offset++;
    }
    LOG.assertTrue(instructions.get(offset) instanceof GoToInstruction);
    instructions.set(offset,EmptyInstruction.INSTANCE);
  }
  for (  PsiReturnStatement aReturn : returns) {
    int offset=controlFlow.getEndOffset(aReturn);
    while (true) {
      if (offset == instructions.size())       break;
      Instruction instruction=instructions.get(offset);
      if (instruction instanceof GoToInstruction) {
        offset=((GoToInstruction)instruction).offset;
      }
 else       if (instruction instanceof ThrowToInstruction) {
        offset=((ThrowToInstruction)instruction).offset;
      }
 else       if (instruction instanceof ConditionalThrowToInstruction) {
        offset++;
      }
 else {
        return true;
      }
    }
  }
  return false;
}
