{
  final JpsAndroidModuleExtension extension=AndroidJpsUtil.getExtension(module);
  if (extension == null || extension.isLibrary()) {
    return true;
  }
  final String[] sourceRoots=AndroidJpsUtil.toPaths(AndroidJpsUtil.getSourceRootsForModuleAndDependencies(module));
  final ProjectPaths paths=context.getProjectPaths();
  final File intArtifactsDir=AndroidJpsUtil.getDirectoryForIntermediateArtifacts(context,module);
  final File moduleOutputDir=paths.getModuleOutputDir(module,false);
  if (moduleOutputDir == null) {
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,AndroidJpsBundle.message("android.jps.errors.output.dir.not.specified",module.getName())));
    return false;
  }
  final AndroidPlatform platform=AndroidJpsUtil.getAndroidPlatform(module,context,BUILDER_NAME);
  if (platform == null) {
    return false;
  }
  final Set<String> externalJarsSet=AndroidJpsUtil.getExternalLibraries(context,module,platform);
  final File resPackage=getPackagedResourcesFile(module,intArtifactsDir);
  final File classesDexFile=new File(intArtifactsDir.getPath(),AndroidCommonUtils.CLASSES_FILE_NAME);
  final String sdkPath=platform.getSdk().getHomePath();
  final String outputPath=AndroidJpsUtil.getApkPath(extension,moduleOutputDir);
  if (outputPath == null) {
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,AndroidJpsBundle.message("android.jps.errors.cannot.compute.output.apk",module.getName())));
    return false;
  }
  final String customKeyStorePath=FileUtil.toSystemDependentName(extension.getCustomDebugKeyStorePath());
  final String[] nativeLibDirs=collectNativeLibsFolders(extension);
  final String resPackagePath=release ? resPackage.getPath() + RELEASE_SUFFIX : resPackage.getPath();
  final String outputApkPath=release ? AndroidCommonUtils.addSuffixToFileName(outputPath,UNSIGNED_SUFFIX) : outputPath;
  final String classesDexFilePath=classesDexFile.getPath();
  final String[] externalJars=ArrayUtil.toStringArray(externalJarsSet);
  final List<AndroidNativeLibData> additionalNativeLibs=extension.getAdditionalNativeLibs();
  final AndroidFileSetState currentFileSetState=buildCurrentApkBuilderState(context.getProjectDescriptor().getProject(),resPackagePath,classesDexFilePath,nativeLibDirs,sourceRoots,externalJars,release);
  final AndroidApkBuilderConfigState currentApkBuilderConfigState=new AndroidApkBuilderConfigState(outputApkPath,customKeyStorePath,additionalNativeLibs);
  if (context.isMake()) {
    final AndroidFileSetState savedApkFileSetState=apkFileSetStorage.getState(module.getName());
    final AndroidApkBuilderConfigState savedApkBuilderConfigState=apkBuilderConfigStateStorage.getState(module.getName());
    if (currentFileSetState.equalsTo(savedApkFileSetState) && currentApkBuilderConfigState.equalsTo(savedApkBuilderConfigState)) {
      return true;
    }
  }
  context.processMessage(new ProgressMessage(AndroidJpsBundle.message("android.jps.progress.packaging",AndroidJpsUtil.getApkName(module))));
  final Map<AndroidCompilerMessageKind,List<String>> messages=AndroidApkBuilder.execute(resPackagePath,classesDexFilePath,sourceRoots,externalJars,nativeLibDirs,additionalNativeLibs,outputApkPath,release,sdkPath,customKeyStorePath,new MyExcludedSourcesFilter(context.getProjectDescriptor().getProject()));
  if (messages.get(AndroidCompilerMessageKind.ERROR).size() == 0) {
    final File dst=new File(AndroidCommonUtils.addSuffixToFileName(outputPath,AndroidCommonUtils.ANDROID_FINAL_PACKAGE_FOR_ARTIFACT_SUFFIX));
    FileUtil.copy(new File(outputApkPath),dst);
    outputConsumer.registerOutputFile(dst,Collections.<String>emptyList());
  }
  AndroidJpsUtil.addMessages(context,messages,BUILDER_NAME,module.getName());
  final boolean success=messages.get(AndroidCompilerMessageKind.ERROR).isEmpty();
  apkFileSetStorage.update(module.getName(),success ? currentFileSetState : null);
  apkBuilderConfigStateStorage.update(module.getName(),success ? currentApkBuilderConfigState : null);
  return success;
}
