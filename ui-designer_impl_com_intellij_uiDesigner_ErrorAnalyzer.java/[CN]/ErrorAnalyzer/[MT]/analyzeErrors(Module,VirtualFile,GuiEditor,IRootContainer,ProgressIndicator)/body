{
  final String classToBind=rootContainer.getClassToBind();
  final PsiClass psiClass;
  if (classToBind != null) {
    psiClass=FormEditingUtil.findClassToBind(module,classToBind);
    if (psiClass == null) {
      final QuickFix[] fixes=editor != null ? new QuickFix[]{new CreateClassToBindFix(editor,classToBind)} : QuickFix.EMPTY_ARRAY;
      final ErrorInfo errorInfo=new ErrorInfo(null,UIDesignerBundle.message("error.class.does.not.exist",classToBind),fixes);
      rootContainer.putClientProperty(CLIENT_PROP_CLASS_TO_BIND_ERROR,errorInfo);
    }
 else {
      rootContainer.putClientProperty(CLIENT_PROP_CLASS_TO_BIND_ERROR,null);
    }
  }
 else {
    psiClass=null;
  }
  final ArrayList<String> usedBindings=new ArrayList<String>();
  final HashMap<String,PsiType> className2Type=new HashMap<String,PsiType>();
  FormEditingUtil.iterate(rootContainer,new FormEditingUtil.ComponentVisitor<IComponent>(){
    public boolean visit(    final IComponent component){
      if (progress != null && progress.isCanceled())       return false;
      component.putClientProperty(CLIENT_PROP_BINDING_ERROR,null);
      final String binding=component.getBinding();
      if (binding == null) {
        return true;
      }
      if (psiClass != null) {
        final PsiField[] fields=psiClass.getFields();
        PsiField field=null;
        for (int i=fields.length - 1; i >= 0; i--) {
          if (binding.equals(fields[i].getName())) {
            field=fields[i];
            break;
          }
        }
        if (field == null) {
          final QuickFix[] fixes=editor != null ? new QuickFix[]{new CreateFieldFix(editor,psiClass,component.getComponentClassName(),binding)} : QuickFix.EMPTY_ARRAY;
          component.putClientProperty(CLIENT_PROP_BINDING_ERROR,new ErrorInfo(null,UIDesignerBundle.message("error.no.field.in.class",binding,classToBind),fixes));
          return true;
        }
 else         if (field.hasModifierProperty(PsiModifier.STATIC)) {
          component.putClientProperty(CLIENT_PROP_BINDING_ERROR,new ErrorInfo(null,UIDesignerBundle.message("error.cant.bind.to.static",binding),QuickFix.EMPTY_ARRAY));
          return true;
        }
        try {
          final PsiType componentType;
          final String className=component.getComponentClassName().replace('$','.');
          if (className2Type.containsKey(className)) {
            componentType=className2Type.get(className);
          }
 else {
            componentType=PsiManager.getInstance(module.getProject()).getElementFactory().createTypeFromText(className,null);
          }
          final PsiType fieldType=field.getType();
          if (fieldType != null && componentType != null && !fieldType.isAssignableFrom(componentType)) {
            final QuickFix[] fixes=editor != null ? new QuickFix[]{new ChangeFieldTypeFix(editor,field,componentType)} : QuickFix.EMPTY_ARRAY;
            component.putClientProperty(CLIENT_PROP_BINDING_ERROR,new ErrorInfo(null,UIDesignerBundle.message("error.bind.incompatible.types",fieldType.getPresentableText(),className),fixes));
          }
        }
 catch (        IncorrectOperationException e) {
        }
      }
      if (usedBindings.contains(binding)) {
        component.putClientProperty(CLIENT_PROP_BINDING_ERROR,new ErrorInfo(null,UIDesignerBundle.message("error.binding.already.exists",binding),QuickFix.EMPTY_ARRAY));
        return true;
      }
      usedBindings.add(binding);
      return true;
    }
  }
);
  if (progress != null)   progress.checkCanceled();
  FormEditingUtil.iterate(rootContainer,new FormEditingUtil.ComponentVisitor<IComponent>(){
    public boolean visit(    final IComponent component){
      if (progress != null && progress.isCanceled())       return false;
      component.putClientProperty(CLIENT_PROP_ERROR_ARRAY,null);
      if (!(component instanceof IContainer)) {
        return true;
      }
      final IContainer container=(IContainer)component;
      if (container instanceof IRootContainer) {
        final IRootContainer rootContainer=(IRootContainer)container;
        if (rootContainer.getComponentCount() > 1) {
          putError(component,new ErrorInfo(null,UIDesignerBundle.message("error.multiple.toplevel.components"),QuickFix.EMPTY_ARRAY));
        }
      }
 else       if (container.isXY() && container.getComponentCount() > 0) {
        putError(component,new ErrorInfo(null,UIDesignerBundle.message("error.panel.not.laid.out"),QuickFix.EMPTY_ARRAY));
      }
      return true;
    }
  }
);
  if (progress != null)   progress.checkCanceled();
  try {
    final PsiFile formPsiFile=PsiManager.getInstance(module.getProject()).findFile(formFile);
    if (formPsiFile != null && rootContainer instanceof RadRootContainer) {
      final List<FormInspectionTool> formInspectionTools=new ArrayList<FormInspectionTool>();
      for (      Object object : Extensions.getRootArea().getExtensionPoint(ExtensionPoints.FORM_INSPECTION_TOOL).getExtensions()) {
        final FormInspectionTool formInspectionTool=(FormInspectionTool)object;
        if (formInspectionTool.isActive(formPsiFile)) {
          formInspectionTools.add(formInspectionTool);
        }
      }
      if (formInspectionTools.size() > 0 && editor != null) {
        for (        FormInspectionTool tool : formInspectionTools) {
          tool.startCheckForm(rootContainer);
        }
        FormEditingUtil.iterate(rootContainer,new FormEditingUtil.ComponentVisitor<RadComponent>(){
          public boolean visit(          final RadComponent component){
            if (progress != null && progress.isCanceled())             return false;
            for (            FormInspectionTool tool : formInspectionTools) {
              ErrorInfo[] errorInfos=tool.checkComponent(editor,component);
              if (errorInfos != null) {
                ArrayList<ErrorInfo> errorList=(ArrayList<ErrorInfo>)component.getClientProperty(CLIENT_PROP_ERROR_ARRAY);
                if (errorList == null) {
                  errorList=new ArrayList<ErrorInfo>();
                  component.putClientProperty(CLIENT_PROP_ERROR_ARRAY,errorList);
                }
                Collections.addAll(errorList,errorInfos);
              }
            }
            return true;
          }
        }
);
        for (        FormInspectionTool tool : formInspectionTools) {
          tool.doneCheckForm(rootContainer);
        }
      }
    }
  }
 catch (  Exception e) {
    LOG.error(e);
  }
}
