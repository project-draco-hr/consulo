{
  final boolean isStatic=prototype.hasModifierProperty(PsiModifier.STATIC);
  final String name=prototype.getName();
  if (!GroovyPropertyUtils.isProperty(clazz,name,isStatic))   return;
  final PsiMethod getter=GroovyPropertyUtils.findPropertyGetter(clazz,name,isStatic,true);
  final PsiType returnType;
  if (getter instanceof GrMethod) {
    returnType=((GrMethod)getter).getInferredReturnType();
  }
 else   if (getter instanceof GrAccessorMethod) {
    returnType=((GrAccessorMethod)getter).getInferredReturnType();
  }
 else {
    return;
  }
  if (!(returnType instanceof GrClosureType))   return;
  final GrSignature signature=((GrClosureType)returnType).getSignature();
  signature.accept(new GrRecursiveSignatureVisitor(){
    @Override public void visitClosureSignature(    GrClosureSignature signature){
      NextSignature:       for (      MethodSignature prototypeSignature : prototypeSignatures) {
        final GrClosureParameter[] params=signature.getParameters();
        final PsiType[] types=prototypeSignature.getParameterTypes();
        if (types.length != params.length)         continue;
        for (int i=0; i < types.length; i++) {
          if (!TypesUtil.isAssignableByMethodCallConversion(types[i],params[i].getType(),refactoredMethod.getParameterList())) {
            continue NextSignature;
          }
        }
        conflicts.putValue(getter,GroovyRefactoringBundle.message("refactored.method.will.cover.closure.property",name,RefactoringUIUtil.getDescription(getter.getContainingClass(),false)));
      }
    }
  }
);
}
