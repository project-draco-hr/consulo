{
  for (  String value : valueToFiles.keySet()) {
    if (progress != null) {
      progress.setText2(InspectionsBundle.message("duplicate.property.value.progress.indicator.text",value));
      progress.checkCanceled();
    }
    if (value.length() == 0)     continue;
    StringSearcher searcher=new StringSearcher(value,true,true);
    StringBuffer message=new StringBuffer();
    int duplicatesCount=0;
    Set<PsiFile> psiFilesWithDuplicates=valueToFiles.get(value);
    for (    PsiFile file : psiFilesWithDuplicates) {
      CharSequence text=file.getViewProvider().getContents();
      final char[] textArray=CharArrayUtil.fromSequenceWithoutCopying(text);
      for (int offset=LowLevelSearchUtil.searchWord(text,textArray,0,text.length(),searcher,progress); offset >= 0; offset=LowLevelSearchUtil.searchWord(text,textArray,offset + searcher.getPattern().length(),text.length(),searcher,progress)) {
        PsiElement element=file.findElementAt(offset);
        if (element != null && element.getParent() instanceof Property) {
          final Property property=(Property)element.getParent();
          if (Comparing.equal(property.getValue(),value) && element.getStartOffsetInParent() != 0) {
            if (duplicatesCount == 0) {
              message.append(InspectionsBundle.message("duplicate.property.value.problem.descriptor",property.getValue()));
            }
            surroundWithHref(message,element,true);
            duplicatesCount++;
          }
        }
      }
    }
    if (duplicatesCount > 1) {
      problemDescriptors.add(manager.createProblemDescriptor(psiFile,message.toString(),false,null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
  }
}
