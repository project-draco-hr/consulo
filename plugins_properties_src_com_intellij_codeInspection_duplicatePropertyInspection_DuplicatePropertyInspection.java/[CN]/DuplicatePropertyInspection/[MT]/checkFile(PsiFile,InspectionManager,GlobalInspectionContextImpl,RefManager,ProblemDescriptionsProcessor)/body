{
  if (!(file instanceof PropertiesFile))   return;
  if (!context.isToCheckFile(file,this))   return;
  final PsiSearchHelper searchHelper=PsiSearchHelper.SERVICE.getInstance(file.getProject());
  final PropertiesFile propertiesFile=(PropertiesFile)file;
  final List<IProperty> properties=propertiesFile.getProperties();
  Module module=ModuleUtil.findModuleForPsiElement(file);
  if (module == null)   return;
  final GlobalSearchScope scope=CURRENT_FILE ? GlobalSearchScope.fileScope(file) : MODULE_WITH_DEPENDENCIES ? GlobalSearchScope.moduleWithDependenciesScope(module) : GlobalSearchScope.projectScope(file.getProject());
  final Map<String,Set<PsiFile>> processedValueToFiles=Collections.synchronizedMap(new HashMap<String,Set<PsiFile>>());
  final Map<String,Set<PsiFile>> processedKeyToFiles=Collections.synchronizedMap(new HashMap<String,Set<PsiFile>>());
  final ProgressIndicator original=ProgressManager.getInstance().getProgressIndicator();
  final ProgressIndicator progress=ProgressWrapper.wrap(original);
  ProgressManager.getInstance().runProcess(new Runnable(){
    public void run(){
      if (!JobUtil.invokeConcurrentlyUnderProgress(properties,progress,false,new Processor<IProperty>(){
        public boolean process(        final IProperty property){
          if (original != null) {
            if (original.isCanceled())             return false;
            original.setText2(PropertiesBundle.message("searching.for.property.key.progress.text",property.getUnescapedKey()));
          }
          processTextUsages(processedValueToFiles,property.getValue(),processedKeyToFiles,searchHelper,scope);
          processTextUsages(processedKeyToFiles,property.getUnescapedKey(),processedValueToFiles,searchHelper,scope);
          return true;
        }
      }
))       throw new ProcessCanceledException();
      List<ProblemDescriptor> problemDescriptors=new ArrayList<ProblemDescriptor>();
      Map<String,Set<String>> keyToDifferentValues=new HashMap<String,Set<String>>();
      if (CHECK_DUPLICATE_KEYS || CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) {
        prepareDuplicateKeysByFile(processedKeyToFiles,manager,keyToDifferentValues,problemDescriptors,file,original);
      }
      if (CHECK_DUPLICATE_VALUES)       prepareDuplicateValuesByFile(processedValueToFiles,manager,problemDescriptors,file,original);
      if (CHECK_DUPLICATE_KEYS_WITH_DIFFERENT_VALUES) {
        processDuplicateKeysWithDifferentValues(keyToDifferentValues,processedKeyToFiles,problemDescriptors,manager,file,original);
      }
      if (!problemDescriptors.isEmpty()) {
        processor.addProblemElement(refManager.getReference(file),problemDescriptors.toArray(new ProblemDescriptor[problemDescriptors.size()]));
      }
    }
  }
,progress);
}
