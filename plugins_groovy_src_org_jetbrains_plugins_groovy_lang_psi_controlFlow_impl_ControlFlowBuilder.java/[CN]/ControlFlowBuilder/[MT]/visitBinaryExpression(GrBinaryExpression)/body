{
  final GrExpression left=expression.getLeftOperand();
  final GrExpression right=expression.getRightOperand();
  final IElementType opType=expression.getOperationTokenType();
  if (ControlFlowBuilderUtil.isInstanceOfBinary(expression)) {
    expression.getLeftOperand().accept(this);
    processInstanceOf(expression);
    return;
  }
  if (opType != mLOR && opType != mLAND && opType != kIN) {
    left.accept(this);
    if (right != null) {
      right.accept(this);
    }
    visitCall(expression);
    return;
  }
  ConditionInstruction condition=new ConditionInstruction(expression);
  addNodeAndCheckPending(condition);
  registerCondition(condition);
  left.accept(this);
  if (right == null)   return;
  final List<GotoInstruction> negations=collectAndRemoveAllPendingNegations(expression);
  visitCall(expression);
  if (opType == mLAND) {
    for (    GotoInstruction negation : negations) {
      addPendingEdge(expression,negation);
    }
    if (negations.isEmpty()) {
      InstructionImpl head=myHead;
      addNode(new NegatingGotoInstruction(expression,condition));
      handlePossibleReturn(expression);
      addPendingEdge(expression,myHead);
      myHead=head;
    }
  }
 else {
    final InstructionImpl instruction=addNodeAndCheckPending(new InstructionImpl(expression));
    handlePossibleReturn(expression);
    addPendingEdge(expression,myHead);
    myHead=instruction;
    InstructionImpl head=reduceAllNegationsIntoInstruction(expression,negations);
    if (head != null)     myHead=head;
  }
  myConditions.removeFirstOccurrence(condition);
  right.accept(this);
}
