{
  final GrExpression left=expression.getLeftOperand();
  final GrExpression right=expression.getRightOperand();
  final IElementType opType=expression.getOperationTokenType();
  if (opType != mLOR && opType != mLAND) {
    left.accept(this);
    if (right != null) {
      right.accept(this);
    }
    visitCall(expression);
    return;
  }
  ConditionInstruction condition=new ConditionInstruction(expression,myInstructionNumber++);
  addNodeAndCheckPending(condition);
  registerCondition(condition);
  left.accept(this);
  if (right == null)   return;
  final List<GotoInstruction> negations=collectAndRemoveAllPendingNegations(expression);
  visitCall(expression);
  if (opType == mLAND) {
    for (    GotoInstruction negation : negations) {
      addPendingEdge(expression,negation);
    }
    if (negations.isEmpty()) {
      InstructionImpl head=myHead;
      NegatingGotoInstruction negation=addNode(new NegatingGotoInstruction(expression,myInstructionNumber++,condition));
      addPendingEdge(expression,negation);
      myHead=head;
    }
  }
 else {
    addNodeAndCheckPending(new InstructionImpl(expression,myInstructionNumber++));
    addPendingEdge(expression,myHead);
    myHead=reduceAllNegationsIntoInstruction(expression,negations);
  }
  myConditions.removeFirstOccurrence(condition);
  right.accept(this);
}
