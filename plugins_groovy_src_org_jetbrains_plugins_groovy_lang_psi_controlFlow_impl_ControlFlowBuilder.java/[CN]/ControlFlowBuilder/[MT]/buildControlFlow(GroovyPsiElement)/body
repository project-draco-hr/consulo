{
  myInstructions=new ArrayList<InstructionImpl>();
  myProcessingStack=new ArrayDeque<InstructionImpl>();
  myCaughtExceptionInfos=new ArrayDeque<ExceptionInfo>();
  myConditions=new ArrayDeque<ConditionInstruction>();
  myNegatingStack=new ArrayDeque<NegatingGotoInstruction>();
  myFinallyCount=0;
  myPending=new ArrayList<Pair<InstructionImpl,GroovyPsiElement>>();
  myInstructionNumber=0;
  myLastInScope=null;
  if (scope instanceof GrStatementOwner) {
    GrStatement[] statements=((GrStatementOwner)scope).getStatements();
    if (statements.length > 0) {
      myLastInScope=statements[statements.length - 1];
    }
  }
  startNode(null);
  if (scope instanceof GrClosableBlock) {
    buildFlowForClosure((GrClosableBlock)scope);
  }
 else {
    scope.accept(this);
  }
  final InstructionImpl end=startNode(null);
  checkPending(end);
  return assertValidPsi(myInstructions.toArray(new Instruction[myInstructions.size()]));
}
