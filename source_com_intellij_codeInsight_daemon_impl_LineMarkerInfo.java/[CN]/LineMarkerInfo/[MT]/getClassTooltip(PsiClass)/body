{
  PsiManager manager=aClass.getManager();
  PsiSearchHelper helper=manager.getSearchHelper();
  if (type == SUBCLASSED_CLASS) {
    PsiElementProcessor.CollectElementsWithLimit<PsiClass> processor=new PsiElementProcessor.CollectElementsWithLimit<PsiClass>(5);
    GlobalSearchScope scope=GlobalSearchScope.allScope(manager.getProject());
    helper.processInheritors(processor,aClass,scope,false);
    if (processor.isOverflow()) {
      return aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.too.many") : DaemonBundle.message("class.is.subclassed.too.many");
    }
    PsiClass[] subclasses=processor.toArray(new PsiClass[processor.getCollection().size()]);
    if (subclasses.length == 0)     return null;
    Comparator<PsiClass> comparator=new PsiClassListCellRenderer().getComparator();
    Arrays.sort(subclasses,comparator);
    String start=aClass.isInterface() ? DaemonBundle.message("interface.is.implemented.by.header") : DaemonBundle.message("class.is.subclassed.by.header");
    @NonNls String pattern="&nbsp;&nbsp;&nbsp;&nbsp;{0}";
    return composeText(subclasses,start,pattern);
  }
 else   if (type == BOUND_CLASS_OR_FIELD) {
    if (aClass.getQualifiedName() != null) {
      PsiFile[] formFiles=helper.findFormsBoundToClass(aClass.getQualifiedName());
      @NonNls final String pattern="&nbsp;&nbsp;&nbsp;&nbsp;{0}";
      return composeText(formFiles,DaemonBundle.message("ui.is.bound.header"),pattern);
    }
  }
  return null;
}
