{
  final Project project=context.getProject();
  final int projectId=getProjectId(project);
  final CompilerConfiguration configuration=CompilerConfiguration.getInstance(project);
  final boolean _forceCompile=forceCompile || isRebuild;
synchronized (mySourcesToRecompile) {
    final TIntHashSet pathsToRecompile=mySourcesToRecompile.get(projectId);
    if (_forceCompile || pathsToRecompile != null && !pathsToRecompile.isEmpty()) {
      while (scopeSrcIterator.hasNext()) {
        final VirtualFile file=scopeSrcIterator.next();
        if (!file.isValid() || configuration.isExcludedFromCompilation(file) || !compiler.isCompilableFile(file,context)) {
          continue;
        }
        final int fileId=getFileId(file);
        if (_forceCompile) {
          toCompile.add(file);
          if (pathsToRecompile == null || !pathsToRecompile.contains(fileId)) {
            addSourceForRecompilation(projectId,file,null);
          }
        }
 else         if (pathsToRecompile.contains(fileId)) {
          toCompile.add(file);
        }
      }
    }
  }
  if (!isRebuild) {
    final CompileScope compileScope=context.getCompileScope();
synchronized (myOutputsToDelete) {
      final Map<String,SourceUrlClassNamePair> outputsToDelete=myOutputsToDelete.get(projectId);
      if (outputsToDelete != null) {
        final VirtualFileManager vfm=VirtualFileManager.getInstance();
        final LocalFileSystem lfs=LocalFileSystem.getInstance();
        final List<String> zombieEntries=new ArrayList<String>();
        for (        String outputPath : outputsToDelete.keySet()) {
          final SourceUrlClassNamePair classNamePair=outputsToDelete.get(outputPath);
          final String sourceUrl=classNamePair.getSourceUrl();
          final VirtualFile srcFile=vfm.findFileByUrl(sourceUrl);
          final boolean sourcePresent=srcFile != null;
          if (sourcePresent) {
            if (!compiler.isCompilableFile(srcFile,context)) {
              continue;
            }
            if (!compileScope.belongs(sourceUrl) && ((CompileContextEx)context).isInSourceContent(srcFile)) {
              continue;
            }
          }
          if (lfs.findFileByPath(outputPath) != null) {
            final File file=new File(outputPath);
            toDelete.add(new Trinity<File,String,Boolean>(file,classNamePair.getClassName(),Boolean.valueOf(sourcePresent)));
            if (LOG.isDebugEnabled()) {
              LOG.debug("Found file to delete: " + file);
            }
          }
 else {
            zombieEntries.add(outputPath);
          }
        }
        for (        String path : zombieEntries) {
          unmarkOutputPathForDeletion(path);
        }
      }
    }
  }
}
