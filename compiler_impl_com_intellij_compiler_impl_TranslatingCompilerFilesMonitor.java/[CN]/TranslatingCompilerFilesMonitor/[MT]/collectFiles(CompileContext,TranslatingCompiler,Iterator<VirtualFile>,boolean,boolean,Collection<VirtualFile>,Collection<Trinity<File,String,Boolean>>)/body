{
  final Project project=context.getProject();
  final int projectId=getProjectId(project);
  final CompilerConfiguration configuration=CompilerConfiguration.getInstance(project);
  final boolean _forceCompile=forceCompile || isRebuild;
synchronized (mySourcesToRecompile) {
    final TIntHashSet pathsToRecompile=mySourcesToRecompile.get(projectId);
    if (_forceCompile || (pathsToRecompile != null && pathsToRecompile.size() > 0)) {
      while (scopeSrcIterator.hasNext()) {
        final VirtualFile file=scopeSrcIterator.next();
        if (configuration.isExcludedFromCompilation(file) || !compiler.isCompilableFile(file,context)) {
          continue;
        }
        final int fileId=getFileId(file);
        if (_forceCompile) {
          toCompile.add(file);
          if (pathsToRecompile == null || !pathsToRecompile.contains(fileId)) {
            addSourceForRecompilation(projectId,file,null);
          }
        }
 else         if (pathsToRecompile.contains(fileId)) {
          toCompile.add(file);
        }
      }
    }
  }
  if (!isRebuild) {
    final CompileScope compileScope=context.getCompileScope();
synchronized (myOutputsToDelete) {
      for (      String outputPath : myOutputsToDelete.keySet()) {
        final SourceUrlClassNamePair classNamePair=myOutputsToDelete.get(outputPath);
        final String sourceUrl=classNamePair.getSourceUrl();
        if (compileScope.belongs(sourceUrl)) {
          final VirtualFile srcFile=VirtualFileManager.getInstance().findFileByUrl(sourceUrl);
          final boolean sourcePresent=srcFile != null;
          if (sourcePresent && !compiler.isCompilableFile(srcFile,context)) {
            continue;
          }
          toDelete.add(new Trinity<File,String,Boolean>(new File(outputPath),classNamePair.getClassName(),Boolean.valueOf(sourcePresent)));
        }
      }
    }
  }
}
