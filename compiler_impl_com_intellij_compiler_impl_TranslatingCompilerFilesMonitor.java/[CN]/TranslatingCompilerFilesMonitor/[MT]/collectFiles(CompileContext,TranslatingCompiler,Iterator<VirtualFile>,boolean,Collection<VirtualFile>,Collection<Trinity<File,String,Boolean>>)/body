{
  final String projectId=getProjectId(context.getProject());
synchronized (mySourcesToRecompile) {
    final TIntHashSet pathsToRecompile=mySourcesToRecompile.get(projectId);
    if (forceCompile || (pathsToRecompile != null && pathsToRecompile.size() > 0)) {
      while (scopeSrcIterator.hasNext()) {
        final VirtualFile file=scopeSrcIterator.next();
        if (!compiler.isCompilableFile(file,context)) {
          continue;
        }
        final int fileId=getFileId(file);
        if (forceCompile) {
          toCompile.add(file);
          if (pathsToRecompile == null || !pathsToRecompile.contains(fileId)) {
            addSourceForRecompilation(Collections.singletonList(projectId),file,null);
          }
        }
 else         if (pathsToRecompile.contains(fileId)) {
          toCompile.add(file);
        }
      }
    }
  }
  final CompileScope compileScope=context.getCompileScope();
synchronized (myOutputsToDelete) {
    for (    String outputPath : myOutputsToDelete.keySet()) {
      final SourceUrlClassNamePair classNamePair=myOutputsToDelete.get(outputPath);
      final String sourceUrl=classNamePair.getSourceUrl();
      if (compileScope.belongs(sourceUrl)) {
        final boolean sourcePresent=VirtualFileManager.getInstance().findFileByUrl(sourceUrl) != null;
        toDelete.add(new Trinity<File,String,Boolean>(new File(outputPath),classNamePair.getClassName(),Boolean.valueOf(sourcePresent)));
      }
    }
  }
}
