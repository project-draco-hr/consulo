{
  final List<BeforeAfter<AirContentRevision>> result=new ArrayList<BeforeAfter<AirContentRevision>>(changes.size());
  final Convertor<Change,FilePath> beforePrefferingConvertor=new Convertor<Change,FilePath>(){
    @Override public FilePath convert(    Change o){
      final FilePath before=ChangesUtil.getBeforePath(o);
      return before == null ? ChangesUtil.getAfterPath(o) : before;
    }
  }
;
  final MultiMap<VcsRoot,Change> byRoots=new SortByVcsRoots<Change>(project,beforePrefferingConvertor).sort(changes);
  for (  VcsRoot root : byRoots.keySet()) {
    final Collection<Change> rootChanges=byRoots.get(root);
    if (root.getVcs() == null || root.getVcs().getOutgoingChangesProvider() == null) {
      addConvertChanges(rootChanges,result);
      continue;
    }
    final VcsOutgoingChangesProvider<?> provider=root.getVcs().getOutgoingChangesProvider();
    final Collection<Change> basedOnLocal=provider.filterLocalChangesBasedOnLocalCommits(rootChanges,root.getPath());
    rootChanges.removeAll(basedOnLocal);
    addConvertChanges(rootChanges,result);
    for (    Change change : basedOnLocal) {
      result.add(new BeforeAfter<AirContentRevision>(convertRevision(change.getBeforeRevision(),provider),convertRevision(change.getAfterRevision(),provider)));
    }
  }
  return result;
}
