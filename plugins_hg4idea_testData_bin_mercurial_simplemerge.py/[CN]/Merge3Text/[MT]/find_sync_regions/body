def find_sync_regions(self):
    'Return a list of sync regions, where both descendents match the base.\n\n        Generates a list of (base1, base2, a1, a2, b1, b2).  There is\n        always a zero-length sync region at the end of all the files.\n        '
    ia = ib = 0
    amatches = mdiff.get_matching_blocks(self.basetext, self.atext)
    bmatches = mdiff.get_matching_blocks(self.basetext, self.btext)
    len_a = len(amatches)
    len_b = len(bmatches)
    sl = []
    while ((ia < len_a) and (ib < len_b)):
        (abase, amatch, alen) = amatches[ia]
        (bbase, bmatch, blen) = bmatches[ib]
        i = intersect((abase, (abase + alen)), (bbase, (bbase + blen)))
        if i:
            intbase = i[0]
            intend = i[1]
            intlen = (intend - intbase)
            assert (intlen <= alen)
            assert (intlen <= blen)
            assert (abase <= intbase)
            assert (bbase <= intbase)
            asub = (amatch + (intbase - abase))
            bsub = (bmatch + (intbase - bbase))
            aend = (asub + intlen)
            bend = (bsub + intlen)
            assert (self.base[intbase:intend] == self.a[asub:aend]), (self.base[intbase:intend], self.a[asub:aend])
            assert (self.base[intbase:intend] == self.b[bsub:bend])
            sl.append((intbase, intend, asub, aend, bsub, bend))
        if ((abase + alen) < (bbase + blen)):
            ia += 1
        else:
            ib += 1
    intbase = len(self.base)
    abase = len(self.a)
    bbase = len(self.b)
    sl.append((intbase, intbase, abase, abase, bbase, bbase))
    return sl
