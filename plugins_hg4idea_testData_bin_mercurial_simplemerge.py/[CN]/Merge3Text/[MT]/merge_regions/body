def merge_regions(self):
    'Return sequences of matching and conflicting regions.\n\n        This returns tuples, where the first value says what kind we\n        have:\n\n        \'unchanged\', start, end\n             Take a region of base[start:end]\n\n        \'same\', astart, aend\n             b and a are different from base but give the same result\n\n        \'a\', start, end\n             Non-clashing insertion from a[start:end]\n\n        Method is as follows:\n\n        The two sequences align only on regions which match the base\n        and both descendents.  These are found by doing a two-way diff\n        of each one against the base, and then finding the\n        intersections between those regions.  These "sync regions"\n        are by definition unchanged in both and easily dealt with.\n\n        The regions in between can be in any of three cases:\n        conflicted, or changed on only one side.\n        '
    iz = ia = ib = 0
    for (zmatch, zend, amatch, aend, bmatch, bend) in self.find_sync_regions():
        matchlen = (zend - zmatch)
        assert (matchlen >= 0)
        assert (matchlen == (aend - amatch))
        assert (matchlen == (bend - bmatch))
        len_a = (amatch - ia)
        len_b = (bmatch - ib)
        len_base = (zmatch - iz)
        assert (len_a >= 0)
        assert (len_b >= 0)
        assert (len_base >= 0)
        if (len_a or len_b):
            equal_a = compare_range(self.a, ia, amatch, self.base, iz, zmatch)
            equal_b = compare_range(self.b, ib, bmatch, self.base, iz, zmatch)
            same = compare_range(self.a, ia, amatch, self.b, ib, bmatch)
            if same:
                yield ('same', ia, amatch)
            elif (equal_a and (not equal_b)):
                yield ('b', ib, bmatch)
            elif (equal_b and (not equal_a)):
                yield ('a', ia, amatch)
            elif ((not equal_a) and (not equal_b)):
                yield ('conflict', iz, zmatch, ia, amatch, ib, bmatch)
            else:
                raise AssertionError("can't handle a=b=base but unmatched")
            ia = amatch
            ib = bmatch
        iz = zmatch
        if (matchlen > 0):
            assert (ia == amatch)
            assert (ib == bmatch)
            assert (iz == zmatch)
            yield ('unchanged', zmatch, zend)
            iz = zend
            ia = aend
            ib = bend
