def simplemerge(ui, local, base, other, **opts):

    def readfile(filename):
        f = open(filename, 'rb')
        text = f.read()
        f.close()
        if util.binary(text):
            msg = (_('%s looks like a binary file.') % filename)
            if (not opts.get('text')):
                raise util.Abort(msg)
            elif (not opts.get('quiet')):
                ui.warn((_('warning: %s\n') % msg))
        return text
    name_a = local
    name_b = other
    labels = opts.get('label', [])
    if labels:
        name_a = labels.pop(0)
    if labels:
        name_b = labels.pop(0)
    if labels:
        raise util.Abort(_('can only specify two labels.'))
    localtext = readfile(local)
    basetext = readfile(base)
    othertext = readfile(other)
    local = os.path.realpath(local)
    if (not opts.get('print')):
        opener = util.opener(os.path.dirname(local))
        out = opener(os.path.basename(local), 'w', atomictemp=True)
    else:
        out = sys.stdout
    reprocess = (not opts.get('no_minimal'))
    m3 = Merge3Text(basetext, localtext, othertext)
    for line in m3.merge_lines(name_a=name_a, name_b=name_b, reprocess=reprocess):
        out.write(line)
    if (not opts.get('print')):
        out.rename()
    if m3.conflicts:
        if (not opts.get('quiet')):
            ui.warn(_('warning: conflicts during merge.\n'))
        return 1
