{
  ParserUtils.getToken(builder,mLCURLY);
  ParserUtils.getToken(builder,mNLS);
  if (ParserUtils.getToken(builder,mRCURLY)) {
    return;
  }
  if (!kCASE.equals(builder.getTokenType()) && !kDEFAULT.equals(builder.getTokenType())) {
    builder.error(GroovyBundle.message("case.expected"));
    while (!builder.eof() && !(kCASE.equals(builder.getTokenType()) || kDEFAULT.equals(builder.getTokenType()) || mRCURLY.equals(builder.getTokenType()))) {
      builder.error(GroovyBundle.message("case.expected"));
      builder.advanceLexer();
    }
  }
  while (kCASE.equals(builder.getTokenType()) || kDEFAULT.equals(builder.getTokenType())) {
    PsiBuilder.Marker sectionMarker=builder.mark();
    parseCaseLabel(builder,parser);
    if (builder.getTokenType() == mRCURLY || ParserUtils.lookAhead(builder,mNLS,mRCURLY)) {
      builder.error(GroovyBundle.message("expression.expected"));
    }
 else {
      parser.parseSwitchCaseList(builder);
    }
    sectionMarker.done(CASE_SECTION);
    if (builder.getTokenType() != kCASE && builder.getTokenType() != kDEFAULT && builder.getTokenType() != mRCURLY) {
      builder.error("case, default or } expected");
      while (!builder.eof() && builder.getTokenType() != kCASE && builder.getTokenType() != kDEFAULT && builder.getTokenType() != mRCURLY) {
        builder.advanceLexer();
      }
    }
  }
  ParserUtils.getToken(builder,mRCURLY,GroovyBundle.message("rcurly.expected"));
}
