{
  Pair<Set<Instruction>,Set<Instruction>> constConditions=runner.getConstConditionalExpressions();
  Set<Instruction> trueSet=constConditions.getFirst();
  Set<Instruction> falseSet=constConditions.getSecond();
  ArrayList<Instruction> allProblems=new ArrayList<Instruction>();
  allProblems.addAll(trueSet);
  allProblems.addAll(falseSet);
  allProblems.addAll(runner.getNPEInstructions());
  allProblems.addAll(runner.getCCEInstructions());
  allProblems.addAll(StandardDataFlowRunner.getRedundantInstanceofs(runner,visitor));
  Collections.sort(allProblems,new Comparator<Instruction>(){
    @Override public int compare(    Instruction i1,    Instruction i2){
      return i1.getIndex() - i2.getIndex();
    }
  }
);
  HashSet<PsiElement> reportedAnchors=new HashSet<PsiElement>();
  for (  Instruction instruction : allProblems) {
    if (instruction instanceof MethodCallInstruction) {
      reportCallMayProduceNpe(holder,(MethodCallInstruction)instruction);
    }
 else     if (instruction instanceof FieldReferenceInstruction) {
      reportFieldAccessMayProduceNpe(holder,(FieldReferenceInstruction)instruction);
    }
 else     if (instruction instanceof TypeCastInstruction) {
      reportCastMayFail(holder,(TypeCastInstruction)instruction);
    }
 else     if (instruction instanceof BranchingInstruction) {
      handleBranchingInstruction(holder,visitor,trueSet,falseSet,reportedAnchors,(BranchingInstruction)instruction);
    }
  }
  reportNullableArguments(runner,holder);
  reportNullableAssignments(runner,holder);
  reportUnboxedNullables(runner,holder);
  reportNullableReturns(runner,holder);
  reportNullableArgumentsPassedToNonAnnotated(runner,holder);
}
