{
  final PreparedStatement statement=myConnection.getOrCreatePreparedStatement(SqliteTables.PREPARED_INSERT_REVISION,new ThrowableConvertor<Connection,PreparedStatement,SQLException>(){
    @Override public PreparedStatement convert(    Connection connection) throws SQLException {
      return connection.prepareStatement("INSERT INTO " + SqliteTables.REVISION.TABLE_NAME + " ( "+ StringUtil.join(Arrays.asList(SqliteTables.REVISION.ROOT_FK,SqliteTables.REVISION.AUTHOR_FK,SqliteTables.REVISION.DATE,SqliteTables.REVISION.NUMBER_INT,SqliteTables.REVISION.NUMBER_STR,SqliteTables.REVISION.COMMENT),", ")+ ") VALUES (?,?,?,?,?,?)",Statement.RETURN_GENERATED_KEYS);
    }
  }
);
  final Map<Long,CommittedChangeList> result=new HashMap<Long,CommittedChangeList>();
  try {
    statement.setLong(1,locationId);
    final Long lastRevision=myKnownRepositoryLocations.getLastRevision(locationId);
    final Long firstRevision=myKnownRepositoryLocations.getFirstRevision(locationId);
    for (    CommittedChangeList list : lists) {
      if (lastRevision != null && list.getNumber() <= lastRevision && list.getNumber() >= firstRevision)       continue;
      statement.setLong(2,authors.get(list.getCommitterName()));
      statement.setLong(3,list.getCommitDate().getTime());
      statement.setLong(4,list.getNumber());
      statement.setString(5,String.valueOf(list.getNumber()));
      statement.setString(6,list.getComment());
      final long id=SqliteUtil.insert(statement);
      result.put(id,list);
      insertPathsChanges(knowPaths,list,id);
    }
    myConnection.commit();
  }
 catch (  SQLException e) {
    throw new VcsException(e);
  }
  return result;
}
