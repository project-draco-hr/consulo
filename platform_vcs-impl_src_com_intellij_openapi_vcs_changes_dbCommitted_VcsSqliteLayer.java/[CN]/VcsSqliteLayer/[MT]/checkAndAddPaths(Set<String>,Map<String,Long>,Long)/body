{
  final PreparedStatement select=myConnection.getOrCreatePreparedStatement(SqliteTables.PREPARED_READ_PATH,new ThrowableConvertor<Connection,PreparedStatement,SQLException>(){
    @Override public PreparedStatement convert(    Connection connection) throws SQLException {
      return connection.prepareStatement("SELECT " + SqliteTables.PATHS.ID + " FROM "+ SqliteTables.PATHS.TABLE_NAME+ " WHERE "+ SqliteTables.PATHS.ROOT_FK+ " = ? AND "+ SqliteTables.PATHS.PATH+ " = ?");
    }
  }
);
  try {
    select.setLong(1,locationId);
    for (    final String path : paths) {
      select.setString(2,path);
      final ResultSet set=select.executeQuery();
      SqliteUtil.readSelectResults(set,new ThrowableRunnable<SQLException>(){
        @Override public void run() throws SQLException {
          known.put(path,set.getLong(1));
        }
      }
);
    }
    paths.removeAll(known.keySet());
    if (paths.isEmpty())     return;
    final PreparedStatement insert=myConnection.getOrCreatePreparedStatement(SqliteTables.PREPARED_INSERT_PATH,new ThrowableConvertor<Connection,PreparedStatement,SQLException>(){
      @Override public PreparedStatement convert(      Connection connection) throws SQLException {
        return connection.prepareStatement("INSERT INTO " + SqliteTables.PATHS.TABLE_NAME + " ( "+ SqliteTables.PATHS.ROOT_FK+ " , "+ SqliteTables.PATHS.PATH+ " ) VALUES (?,?)",Statement.RETURN_GENERATED_KEYS);
      }
    }
);
    insert.setLong(1,locationId);
    for (    String path : paths) {
      insert.setString(2,path);
      final long id=SqliteUtil.insert(insert);
      known.put(path,id);
    }
  }
 catch (  SQLException e) {
    throw new VcsException(e);
  }
}
