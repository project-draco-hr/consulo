{
  ApplicationManager.getApplication().assertReadAccessAllowed();
  final Set<PsiElement> skipParentsSet=new THashSet<PsiElement>();
  final Set<HighlightInfo> gotHighlights=new THashSet<HighlightInfo>();
  final List<HighlightVisitor> visitors=new ArrayList<HighlightVisitor>(highlightVisitors.length);
  for (  HighlightVisitor visitor : highlightVisitors) {
    if (visitor.suitableForFile(myFile))     visitors.add(visitor);
  }
  HighlightVisitor[] visitorArray=visitors.toArray(new HighlightVisitor[visitors.size()]);
  Arrays.sort(visitorArray,VISITOR_ORDER_COMPARATOR);
  final boolean forceHighlightParents=forceHighlightParents();
  final HighlightInfoHolder holder=createInfoHolder();
  holder.setWritable(true);
  final ProgressManager progressManager=ProgressManager.getInstance();
  setProgressLimit((long)elements.size() * visitorArray.length);
  final int chunkSize=Math.max(1,elements.size() / 100);
  for (  final HighlightVisitor visitor : visitorArray) {
    Runnable action=new Runnable(){
      public void run(){
        int nextLimit=chunkSize;
        for (int i=0; i < elements.size(); i++) {
          PsiElement element=elements.get(i);
          progressManager.checkCanceled();
          if (element != myFile && !skipParentsSet.isEmpty() && element.getFirstChild() != null && skipParentsSet.contains(element)) {
            skipParentsSet.add(element.getParent());
            continue;
          }
          if (element instanceof PsiErrorElement) {
            myHasErrorElement=true;
          }
          holder.clear();
          visitor.visit(element,holder);
          if (i == nextLimit) {
            advanceProgress(chunkSize);
            nextLimit=i + chunkSize;
          }
          for (int j=0; j < holder.size(); j++) {
            HighlightInfo info=holder.get(j);
            if (!gotHighlights.add(info))             continue;
            boolean isError=info.getSeverity() == HighlightSeverity.ERROR;
            if (isError) {
              if (!forceHighlightParents) {
                skipParentsSet.add(element.getParent());
              }
              myErrorFound=true;
            }
          }
        }
      }
    }
;
    if (!visitor.analyze(action,myUpdateAll,myFile)) {
      progress.cancel();
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        public void run(){
          try {
            Thread.sleep(new Random().nextInt(100));
          }
 catch (          InterruptedException e) {
            LOG.error(e);
          }
          DaemonCodeAnalyzer.getInstance(myProject).restart();
        }
      }
,myProject.getDisposed());
      throw new ProcessCanceledException();
    }
  }
  return gotHighlights;
}
