{
  List<DocumentWindow> injected=InjectedLanguageUtil.getCachedInjectedDocuments(myFile);
  Collection<PsiElement> hosts=new THashSet<PsiElement>(elements.size() + injected.size());
  for (  DocumentWindow documentRange : injected) {
    PsiFile file=PsiDocumentManager.getInstance(myProject).getPsiFile(documentRange);
    if (file == null)     continue;
    PsiElement context=file.getContext();
    if (context != null && context.isValid() && !file.getProject().isDisposed() && (myUpdateAll || new TextRange(myStartOffset,myEndOffset).intersects(context.getTextRange()))) {
      hosts.add(context);
    }
  }
  hosts.addAll(elements);
  final Collection<PsiFile> injectedFiles=new THashSet<PsiFile>();
  for (  PsiElement element : hosts) {
    InjectedLanguageUtil.enumerate(element,myFile,new PsiLanguageInjectionHost.InjectedPsiVisitor(){
      public void visit(      @NotNull PsiFile injectedPsi,      @NotNull List<PsiLanguageInjectionHost.Shred> places){
        injectedFiles.add(injectedPsi);
      }
    }
,false);
  }
  if (injectedFiles.isEmpty())   return;
  JobUtil.invokeConcurrentlyForAll(injectedFiles,new Processor<PsiFile>(){
    public boolean process(    final PsiFile injectedPsi){
      AnnotationHolderImpl annotationHolder=createAnnotationHolder();
      highlightInjectedIn(injectedPsi,annotationHolder,errorFilters);
      DocumentWindow documentWindow=(DocumentWindow)PsiDocumentManager.getInstance(myProject).getCachedDocument(injectedPsi);
      for (      Annotation annotation : annotationHolder) {
        final TextRange fixedTextRange;
        final int startOffset=annotation.getStartOffset();
        TextRange textRange=documentWindow.getHostRange(startOffset);
        if (textRange == null) {
          textRange=findNearestTextRange(documentWindow,startOffset);
          final boolean isBefore=startOffset < textRange.getStartOffset();
          fixedTextRange=new TextRange(isBefore ? textRange.getStartOffset() - 1 : textRange.getEndOffset(),isBefore ? textRange.getStartOffset() : textRange.getEndOffset() + 1);
        }
 else {
          fixedTextRange=null;
        }
        final HighlightInfo highlightInfo=HighlightInfo.fromAnnotation(annotation,fixedTextRange);
        addHighlightInfo(textRange,highlightInfo);
      }
      Collection<HighlightInfo> todos=highlightTodos(injectedPsi,injectedPsi.getText(),0,injectedPsi.getTextLength());
      for (      HighlightInfo info : todos) {
        TextRange editable=documentWindow.intersectWithEditable(new TextRange(info.startOffset,info.endOffset));
        if (editable == null)         continue;
        TextRange hostRange=documentWindow.injectedToHost(editable);
        HighlightInfo patched=HighlightInfo.createHighlightInfo(info.type,hostRange,info.description,info.forcedTextAttributes);
        patched.toolTip=info.toolTip;
        addHighlightInfo(hostRange,patched);
      }
      return true;
    }
  }
,"Highlight injected language fragments");
}
