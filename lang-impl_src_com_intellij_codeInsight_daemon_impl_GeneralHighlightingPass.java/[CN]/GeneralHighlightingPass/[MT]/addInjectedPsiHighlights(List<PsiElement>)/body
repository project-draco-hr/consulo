{
  List<DocumentWindow> injected=InjectedLanguageUtil.getCachedInjectedDocuments(myFile);
  Collection<PsiElement> hosts=new THashSet<PsiElement>(elements.size() + injected.size());
  for (  DocumentWindow documentRange : injected) {
    PsiFile file=PsiDocumentManager.getInstance(myProject).getPsiFile(documentRange);
    if (file == null)     continue;
    PsiElement context=file.getContext();
    if (context != null && context.isValid() && !file.getProject().isDisposed() && (myUpdateAll || new TextRange(myStartOffset,myEndOffset).intersects(context.getTextRange()))) {
      hosts.add(context);
    }
  }
  hosts.addAll(elements);
  final Collection<PsiFile> injectedFiles=new THashSet<PsiFile>();
  for (  PsiElement element : hosts) {
    InjectedLanguageUtil.enumerate(element,myFile,new PsiLanguageInjectionHost.InjectedPsiVisitor(){
      public void visit(      @NotNull PsiFile injectedPsi,      @NotNull List<PsiLanguageInjectionHost.Shred> places){
        injectedFiles.add(injectedPsi);
      }
    }
,false);
  }
  if (injectedFiles.isEmpty())   return;
  JobUtil.invokeConcurrentlyForAll(injectedFiles,new Processor<PsiFile>(){
    public boolean process(    final PsiFile injectedPsi){
      AnnotationHolderImpl annotationHolder=createAnnotationHolder();
      highlightInjectedIn(injectedPsi,annotationHolder);
      DocumentWindow documentWindow=(DocumentWindow)PsiDocumentManager.getInstance(myProject).getCachedDocument(injectedPsi);
      for (      Annotation annotation : annotationHolder) {
        final TextRange fixedTextRange;
        final int startOffset=annotation.getStartOffset();
        TextRange textRange=documentWindow.getHostRange(startOffset);
        if (textRange == null) {
          textRange=findNearestTextRange(documentWindow,startOffset);
          final boolean isBefore=startOffset < textRange.getStartOffset();
          fixedTextRange=new TextRange(isBefore ? textRange.getStartOffset() - 1 : textRange.getEndOffset(),isBefore ? textRange.getStartOffset() : textRange.getEndOffset() + 1);
        }
 else {
          fixedTextRange=null;
        }
        final HighlightInfo highlightInfo=HighlightInfo.fromAnnotation(annotation,fixedTextRange);
synchronized (myInjectedPsiHighlights) {
          Collection<HighlightInfo> infos=myInjectedPsiHighlights.get(textRange);
          if (infos == null) {
            infos=new SmartList<HighlightInfo>();
            myInjectedPsiHighlights.put(textRange,infos);
          }
          infos.add(highlightInfo);
        }
      }
      return true;
    }
  }
,"Highlight injected language fragments");
}
