{
  final JobImpl<String> job=new JobImpl<String>(Job.DEFAULT_PRIORITY,failFastOnAcquireReadAction);
  final int chunkSize=Math.max(1,things.size() / Math.max(1,JobSchedulerImpl.CORES_COUNT / 2));
  for (int i=0; i < things.size(); i+=chunkSize) {
    final int finalI=i;
    job.addTask(new Runnable(){
      @Override public void run(){
        ProgressManager.getInstance().executeProcessUnderProgress(new Runnable(){
          @Override public void run(){
            try {
              for (int k=finalI; k < finalI + chunkSize && k < things.size(); k++) {
                T thing=things.get(k);
                if (!thingProcessor.process(thing)) {
                  job.cancel();
                  break;
                }
              }
            }
 catch (            ProcessCanceledException e) {
              job.cancel();
              throw e;
            }
          }
        }
,wrapper);
      }
    }
);
  }
  try {
    job.scheduleAndWaitForResults(runInReadAction);
  }
 catch (  RuntimeException e) {
    job.cancel();
    throw e;
  }
catch (  Throwable throwable) {
    job.cancel();
    throw new ProcessCanceledException(throwable);
  }
  return !job.isCanceled();
}
