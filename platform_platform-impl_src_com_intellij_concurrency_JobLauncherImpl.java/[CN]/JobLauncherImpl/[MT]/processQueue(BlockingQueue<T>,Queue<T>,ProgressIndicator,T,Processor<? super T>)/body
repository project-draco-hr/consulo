{
class MyTask implements Callable<Boolean> {
    private final int mySeq;
    private boolean result;
    private MyTask(    int seq){
      mySeq=seq;
    }
    @Override public Boolean call() throws Exception {
      ProgressManager.getInstance().executeProcessUnderProgress(new Runnable(){
        @Override public void run(){
          try {
            while (true) {
              progress.checkCanceled();
              T element=failedToProcess.poll();
              if (element == null)               element=things.take();
              if (element == tombStone) {
                things.offer(element);
                result=true;
                break;
              }
              try {
                if (!thingProcessor.process(element)) {
                  result=false;
                  break;
                }
              }
 catch (              RuntimeException e) {
                failedToProcess.add(element);
                throw e;
              }
            }
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
,progress);
      return result;
    }
    @Override public String toString(){
      return super.toString() + " seq=" + mySeq;
    }
  }
  boolean isSmallEnough=things.contains(tombStone);
  if (isSmallEnough) {
    try {
      return new MyTask(0).call();
    }
 catch (    RuntimeException e) {
      throw e;
    }
catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
  List<ForkJoinTask<Boolean>> tasks=new ArrayList<ForkJoinTask<Boolean>>();
  for (int i=0; i < JobSchedulerImpl.CORES_COUNT; i++) {
    tasks.add(pool.submit(new MyTask(i)));
  }
  boolean result=true;
  RuntimeException exception=null;
  for (  ForkJoinTask<Boolean> task : tasks) {
    try {
      result&=task.join();
    }
 catch (    RuntimeException e) {
      exception=e;
    }
  }
  if (exception != null) {
    throw exception;
  }
  return result;
}
