{
  PsiClass containingClass=method.getContainingClass();
  if (containingClass == null)   return null;
  Map<String,List<Pair<GrMethodReturnTypeDescriptor.Param[],String>>> methodMap=getMap().get(containingClass.getQualifiedName());
  if (methodMap == null)   return null;
  List<Pair<GrMethodReturnTypeDescriptor.Param[],String>> pairs=methodMap.get(method.getName());
  if (pairs == null)   return null;
  String typeName=null;
  mainLoop:   for (  Pair<GrMethodReturnTypeDescriptor.Param[],String> pair : pairs) {
    if (pair.first == null) {
      typeName=pair.second;
      break;
    }
 else {
      GrMethodReturnTypeDescriptor.Param[] params=pair.first;
      PsiParameterList parameterList=method.getParameterList();
      if (parameterList.getParametersCount() == params.length) {
        PsiParameter[] parameters=parameterList.getParameters();
        for (int i=0; i < parameters.length; i++) {
          if (!TypesUtil.isClassType(parameters[i].getType(),params[i].type)) {
            continue mainLoop;
          }
        }
        typeName=pair.second;
        break;
      }
    }
  }
  if (typeName == null)   return null;
  if (typeName.equals("!closure")) {
    GrExpression[] allArguments=PsiUtil.getAllArguments(callExpression);
    GrClosableBlock closure=null;
    for (    GrExpression argument : allArguments) {
      if (argument instanceof GrClosableBlock) {
        closure=(GrClosableBlock)argument;
        break;
      }
    }
    if (closure == null)     return null;
    final GrClosableBlock finalClosure=closure;
    return ourGuard.doPreventingRecursion(callExpression,true,new Computable<PsiType>(){
      @Override public PsiType compute(){
        PsiType returnType=finalClosure.getReturnType();
        if (returnType == PsiType.VOID)         return null;
        return returnType;
      }
    }
);
  }
  return JavaPsiFacade.getElementFactory(containingClass.getProject()).createTypeFromText(typeName,callExpression);
}
