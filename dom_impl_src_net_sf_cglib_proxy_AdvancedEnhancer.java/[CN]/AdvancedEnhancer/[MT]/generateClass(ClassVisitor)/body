{
  Class sc=(superclass == null) ? Object.class : superclass;
  if (TypeUtils.isFinal(sc.getModifiers())) {
    throw new IllegalArgumentException("Cannot subclass final class " + sc);
  }
  List<Constructor> constructors=new ArrayList<Constructor>(Arrays.asList(sc.getDeclaredConstructors()));
  filterConstructors(sc,constructors);
  final Set forcePublic=new HashSet();
  List<Method> actualMethods=new ArrayList<Method>();
  final Map<Method,Method> covariantMethods=new HashMap<Method,Method>();
  getMethods(sc,interfaces,actualMethods,new ArrayList<Method>(),forcePublic);
  final Set<JavaMethodSignature> finalMethods=new HashSet<JavaMethodSignature>();
  for (Class aClass=sc; aClass != null; aClass=aClass.getSuperclass()) {
    for (    final Method method : aClass.getDeclaredMethods()) {
      final int modifiers=method.getModifiers();
      final JavaMethodSignature signature=JavaMethodSignature.getSignature(method);
      if ((modifiers & Constants.ACC_FINAL) != 0) {
        finalMethods.add(signature);
        removeAllCovariantMethods(actualMethods,method,covariantMethods);
      }
 else       if ((modifiers & Constants.ACC_ABSTRACT) == 0 || finalMethods.contains(signature)) {
        removeAllCovariantMethods(actualMethods,method,covariantMethods);
      }
    }
  }
  ClassEmitter e=new ClassEmitter(v);
  e.begin_class(Constants.V1_2,Constants.ACC_PUBLIC,getClassName(),Type.getType(sc),(useFactory ? TypeUtils.add(TypeUtils.getTypes(interfaces),FACTORY) : TypeUtils.getTypes(interfaces)),Constants.SOURCE_FILE);
  List constructorInfo=CollectionUtils.transform(constructors,MethodInfoTransformer.getInstance());
  e.declare_field(Constants.ACC_PRIVATE,BOUND_FIELD,Type.BOOLEAN_TYPE,null,null);
  if (!interceptDuringConstruction) {
    e.declare_field(Constants.ACC_PRIVATE,CONSTRUCTED_FIELD,Type.BOOLEAN_TYPE,null,null);
  }
  e.declare_field(Constants.PRIVATE_FINAL_STATIC,THREAD_CALLBACKS_FIELD,THREAD_LOCAL,null,null);
  e.declare_field(Constants.PRIVATE_FINAL_STATIC,STATIC_CALLBACKS_FIELD,CALLBACK_ARRAY,null,null);
  if (serialVersionUID != null) {
    e.declare_field(Constants.PRIVATE_FINAL_STATIC,Constants.SUID_FIELD_NAME,Type.LONG_TYPE,serialVersionUID,null);
  }
  for (int i=0; i < callbackTypes.length; i++) {
    e.declare_field(Constants.ACC_PRIVATE,getCallbackField(i),callbackTypes[i],null,null);
  }
  final Map<Method,MethodInfo> methodInfoMap=new HashMap<Method,MethodInfo>();
  for (  Method method : actualMethods) {
    int modifiers=Constants.ACC_FINAL | (method.getModifiers() & ~Constants.ACC_ABSTRACT & ~Constants.ACC_NATIVE& ~Constants.ACC_SYNCHRONIZED);
    if (forcePublic.contains(MethodWrapper.create(method))) {
      modifiers=(modifiers & ~Constants.ACC_PROTECTED) | Constants.ACC_PUBLIC;
    }
    if (covariantMethods.containsKey(method)) {
      modifiers=modifiers | Constants.ACC_BRIDGE;
    }
    methodInfoMap.put(method,ReflectUtils.getMethodInfo(method,modifiers));
  }
  emitMethods(e,methodInfoMap,covariantMethods);
  emitConstructors(e,constructorInfo);
  emitSetThreadCallbacks(e);
  emitSetStaticCallbacks(e);
  emitBindCallbacks(e);
  if (useFactory) {
    int[] keys=getCallbackKeys();
    emitNewInstanceCallbacks(e);
    emitNewInstanceCallback(e);
    emitNewInstanceMultiarg(e,constructorInfo);
    emitGetCallback(e,keys);
    emitSetCallback(e,keys);
    emitGetCallbacks(e);
    emitSetCallbacks(e);
  }
  e.end_class();
}
