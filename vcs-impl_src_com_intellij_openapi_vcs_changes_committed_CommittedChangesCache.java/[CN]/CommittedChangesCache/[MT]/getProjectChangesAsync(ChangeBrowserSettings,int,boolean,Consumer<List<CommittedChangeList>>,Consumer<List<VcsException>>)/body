{
  final Task.Backgroundable task=new Task.Backgroundable(myProject,VcsBundle.message("committed.changes.refresh.progress")){
    private final LinkedHashSet<CommittedChangeList> myResult=new LinkedHashSet<CommittedChangeList>();
    private final List<VcsException> myExceptions=new ArrayList<VcsException>();
    private boolean myDisposed=false;
    public void run(    @NotNull final ProgressIndicator indicator){
      for (      AbstractVcs vcs : myVcsManager.getAllActiveVcss()) {
        final CommittedChangesProvider provider=vcs.getCommittedChangesProvider();
        if (provider == null)         continue;
        final VirtualFile[] roots=myVcsManager.getRootsUnderVcs(vcs);
        final VcsCommittedListsZipper vcsZipper=provider.getZipper();
        CommittedListsSequencesZipper zipper=null;
        if (vcsZipper != null) {
          zipper=new CommittedListsSequencesZipper(vcsZipper);
        }
        boolean zipSupported=zipper != null;
        for (        VirtualFile root : roots) {
          if (myProject.isDisposed())           return;
          final RepositoryLocation location=provider.getLocationFor(new FilePathImpl(root));
          if (location == null)           continue;
          try {
            final List<CommittedChangeList> lists=getChanges(settings,root,vcs,maxCount,cacheOnly,provider,location);
            if (lists != null) {
              if (zipSupported) {
                zipper.add(location,lists);
              }
 else {
                myResult.addAll(lists);
              }
            }
          }
 catch (          VcsException e) {
            myExceptions.add(e);
          }
catch (          ProcessCanceledException e) {
            myDisposed=true;
          }
        }
        if (zipSupported) {
          myResult.addAll(zipper.execute());
        }
      }
    }
    public void onSuccess(){
      if (myProject.isDisposed()) {
        return;
      }
      if (myExceptions.size() > 0) {
        errorConsumer.consume(myExceptions);
      }
 else       if (!myDisposed) {
        consumer.consume(new ArrayList<CommittedChangeList>(myResult));
      }
    }
  }
;
  myTaskQueue.run(task);
}
