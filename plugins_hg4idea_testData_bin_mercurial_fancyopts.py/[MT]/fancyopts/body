def fancyopts(args, options, state, gnu=False):
    "\n    read args, parse options, and store options in state\n\n    each option is a tuple of:\n\n      short option or ''\n      long option\n      default value\n      description\n\n    option types include:\n\n      boolean or none - option sets variable in state to true\n      string - parameter string is stored in state\n      list - parameter string is added to a list\n      integer - parameter strings is stored as int\n      function - call function with parameter\n\n    non-option args are returned\n    "
    namelist = []
    shortlist = ''
    argmap = {}
    defmap = {}
    for (short, name, default, comment) in options:
        oname = name
        name = name.replace('-', '_')
        argmap[('-' + short)] = argmap[('--' + oname)] = name
        defmap[name] = default
        if isinstance(default, list):
            state[name] = default[:]
        elif hasattr(default, '__call__'):
            state[name] = None
        else:
            state[name] = default
        if (not ((default is None) or (default is True) or (default is False))):
            if short:
                short += ':'
            if oname:
                oname += '='
        if short:
            shortlist += short
        if name:
            namelist.append(oname)
    if gnu:
        parse = gnugetopt
    else:
        parse = getopt.getopt
    (opts, args) = parse(args, shortlist, namelist)
    for (opt, val) in opts:
        name = argmap[opt]
        t = type(defmap[name])
        if (t is type(fancyopts)):
            state[name] = defmap[name](val)
        elif (t is type(1)):
            state[name] = int(val)
        elif (t is type('')):
            state[name] = val
        elif (t is type([])):
            state[name].append(val)
        elif ((t is type(None)) or (t is type(False))):
            state[name] = True
    return args
