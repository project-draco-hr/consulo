{
  final StringCharacterIterator it=new StringCharacterIterator(methodSignature);
  final StringBuffer formals=new StringBuffer();
  if (it.current() == '<') {
    SignatureParser.INSTANCE.parseFormalTypeParameters(it,formals);
  }
  if (it.current() != '(') {
    throw new SignatureParsingException("'(' expected");
  }
  it.next();
  final String[] paramSignatures;
  if (it.current() != ')') {
    final List<String> params=new ArrayList<String>();
    while (it.current() != ')') {
      final StringBuffer typeSignature=new StringBuffer();
      SignatureParser.INSTANCE.parseTypeSignature(it,typeSignature);
      params.add(typeSignature.toString());
    }
    paramSignatures=params.toArray(new String[params.size()]);
  }
 else {
    paramSignatures=ArrayUtil.EMPTY_STRING_ARRAY;
  }
  it.next();
  final StringBuffer returnTypeSignature=new StringBuffer();
  SignatureParser.INSTANCE.parseReturnType(it,returnTypeSignature);
  final StringBuffer throwsSignature=new StringBuffer();
  if (it.current() != CharacterIterator.DONE) {
    SignatureParser.INSTANCE.parseThrowsSignature(it,throwsSignature);
  }
  return new GenericMethodSignature(formals.toString(),paramSignatures,returnTypeSignature.toString(),throwsSignature.toString());
}
