{
  DnDSupport.createBuilder(component).setBeanProvider(new Function<DnDActionInfo,DnDDragStartBean>(){
    @Override public DnDDragStartBean fun(    DnDActionInfo info){
      final Point p=info.getPoint();
      return new DnDDragStartBean(new RowDragInfo(component,Integer.valueOf(getRow(component,p))));
    }
  }
).setTargetChecker(new DnDTargetChecker(){
    @Override public boolean update(    DnDEvent event){
      final Object o=event.getAttachedObject();
      event.setDropPossible(o instanceof RowDragInfo && ((RowDragInfo)o).component == component);
      int oldIndex=((RowDragInfo)o).row;
      int newIndex=getRow(component,event.getPoint());
      if (oldIndex != newIndex && newIndex != -1 && model.canExchangeRows(oldIndex,newIndex)) {
        Rectangle cellBounds=getCellBounds(component,newIndex);
        if (oldIndex < newIndex) {
          cellBounds.y+=cellBounds.height - 2;
        }
        RelativeRectangle rectangle=new RelativeRectangle(component,cellBounds);
        rectangle.getDimension().height=2;
        event.setHighlighting(rectangle,2);
      }
 else {
        event.setDropPossible(false);
        event.hideHighlighter();
      }
      return false;
    }
  }
).setDropHandler(new DnDDropHandler(){
    @Override public void drop(    DnDEvent event){
      final Object o=event.getAttachedObject();
      final Point p=event.getPoint();
      if (o instanceof RowDragInfo && ((RowDragInfo)o).component == component) {
        int oldIndex=((RowDragInfo)o).row;
        if (oldIndex == -1)         return;
        int newIndex=getRow(component,p);
        if (newIndex == -1) {
          newIndex=getRowCount(component) - 1;
        }
        if (model.canExchangeRows(oldIndex,newIndex)) {
          int min=Math.min(oldIndex,newIndex);
          int max=Math.max(oldIndex,newIndex);
          if (newIndex > oldIndex) {
            while (min < max) {
              model.exchangeRows(min,min + 1);
              min++;
            }
            setSelectedRow(component,min);
          }
 else {
            while (max > min) {
              model.exchangeRows(max,max - 1);
              max--;
            }
            setSelectedRow(component,max);
          }
        }
      }
      event.hideHighlighter();
    }
  }
).install();
}
