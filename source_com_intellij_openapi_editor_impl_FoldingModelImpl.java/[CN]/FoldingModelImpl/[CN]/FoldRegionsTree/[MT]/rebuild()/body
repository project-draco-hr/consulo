{
  ArrayList<FoldRegion> topLevels=new ArrayList<FoldRegion>(myRegions.size() / 2);
  ArrayList<FoldRegion> visible=new ArrayList<FoldRegion>(myRegions.size());
  FoldRegion[] regions=myRegions.toArray(new FoldRegion[myRegions.size()]);
  FoldRegion currentToplevel=null;
  for (  FoldRegion region : regions) {
    if (region.isValid()) {
      visible.add(region);
      if (!region.isExpanded()) {
        if (currentToplevel == null || currentToplevel.getEndOffset() < region.getStartOffset()) {
          currentToplevel=region;
          topLevels.add(region);
        }
      }
    }
  }
  myCachedTopLevelRegions=topLevels.isEmpty() ? FoldRegion.EMPTY_ARRAY : topLevels.toArray(new FoldRegion[topLevels.size()]);
  Arrays.sort(myCachedTopLevelRegions,new Comparator<FoldRegion>(){
    public int compare(    FoldRegion r1,    FoldRegion r2){
      int end1=r1.getEndOffset();
      int end2=r2.getEndOffset();
      if (end1 < end2)       return -1;
      if (end1 > end2)       return 1;
      return 0;
    }
  }
);
  FoldRegion[] visibleArrayed=visible.toArray(new FoldRegion[visible.size()]);
  for (  FoldRegion visibleRegion : visibleArrayed) {
    for (    FoldRegion topLevelRegion : myCachedTopLevelRegions) {
      if (contains(topLevelRegion,visibleRegion)) {
        visible.remove(visibleRegion);
        break;
      }
    }
  }
  myCachedVisible=visible.toArray(new FoldRegion[visible.size()]);
  Arrays.sort(myCachedVisible,new Comparator<FoldRegion>(){
    public int compare(    FoldRegion r1,    FoldRegion r2){
      int end1=r1.getEndOffset();
      int end2=r2.getEndOffset();
      if (end1 < end2)       return 1;
      if (end1 > end2)       return -1;
      return 0;
    }
  }
);
  updateCachedOffsets();
}
