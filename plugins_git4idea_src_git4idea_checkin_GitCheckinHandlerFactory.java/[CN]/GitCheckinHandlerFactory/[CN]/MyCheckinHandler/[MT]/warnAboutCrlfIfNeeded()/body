{
  GitVcsSettings settings=GitVcsSettings.getInstance(myProject);
  if (!settings.warnAboutCrlf()) {
    return ReturnResult.COMMIT;
  }
  final GitPlatformFacade platformFacade=ServiceManager.getService(myProject,GitPlatformFacade.class);
  final Git git=ServiceManager.getService(Git.class);
  final Collection<VirtualFile> files=myPanel.getVirtualFiles();
  final AtomicReference<GitCrlfProblemsDetector> crlfHelper=new AtomicReference<GitCrlfProblemsDetector>();
  ProgressManager.getInstance().run(new Task.Modal(myProject,"Checking for line separator issues...",true){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      crlfHelper.set(GitCrlfProblemsDetector.detect(GitCheckinHandlerFactory.MyCheckinHandler.this.myProject,platformFacade,git,files));
    }
  }
);
  if (crlfHelper.get() == null) {
    return ReturnResult.CANCEL;
  }
  if (crlfHelper.get().shouldWarn()) {
    final GitCrlfDialog dialog=new GitCrlfDialog(myProject);
    UIUtil.invokeAndWaitIfNeeded(new Runnable(){
      @Override public void run(){
        dialog.show();
      }
    }
);
    int decision=dialog.getExitCode();
    if (decision == GitCrlfDialog.CANCEL) {
      return ReturnResult.CANCEL;
    }
 else {
      if (decision == GitCrlfDialog.SET) {
        VirtualFile anyRoot=myPanel.getRoots().iterator().next();
        setCoreAutoCrlfAttribute(anyRoot);
      }
 else {
        if (dialog.dontWarnAgain()) {
          settings.setWarnAboutCrlf(false);
        }
      }
      return ReturnResult.COMMIT;
    }
  }
  return ReturnResult.COMMIT;
}
