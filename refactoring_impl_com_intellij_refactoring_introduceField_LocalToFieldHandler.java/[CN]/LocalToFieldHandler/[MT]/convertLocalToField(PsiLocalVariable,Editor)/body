{
  PsiClass aClass;
  boolean tempIsStatic=myIsConstant;
  PsiElement parent=local.getParent();
  while (true) {
    if (parent instanceof PsiClass && !(parent instanceof PsiAnonymousClass)) {
      aClass=(PsiClass)parent;
      break;
    }
    if (parent instanceof PsiFile && PsiUtil.isInJspFile(parent)) {
      String message=RefactoringBundle.message("error.not.supported.for.jsp",REFACTORING_NAME);
      CommonRefactoringUtil.showErrorHint(myProject,editor,message,REFACTORING_NAME,HelpID.LOCAL_TO_FIELD);
      return false;
    }
    if (parent instanceof PsiModifierListOwner && ((PsiModifierListOwner)parent).hasModifierProperty(PsiModifier.STATIC)) {
      tempIsStatic=true;
    }
    parent=parent.getParent();
  }
  final boolean isStatic=tempIsStatic;
  PsiExpression[] occurences=CodeInsightUtil.findReferenceExpressions(RefactoringUtil.getVariableScope(local),local);
  if (editor != null) {
    RefactoringUtil.highlightAllOccurences(myProject,occurences,editor);
  }
  final BaseExpressionToFieldHandler.Settings settings=showRefactoringDialog(aClass,local,occurences,isStatic);
  if (settings == null)   return false;
  final String variableName=local.getName();
  final String fieldName=settings.getFieldName();
  final BaseExpressionToFieldHandler.InitializationPlace initializerPlace=settings.getInitializerPlace();
  final boolean declareFinal=settings.isDeclareFinal();
  @Modifier final String fieldVisibility=settings.getFieldVisibility();
  final PsiClass destinationClass=settings.getDestinationClass();
  boolean rebindNeeded=false;
  if (destinationClass != null) {
    aClass=destinationClass;
    rebindNeeded=true;
  }
  final boolean annotateAsNonNls=settings.isAnnotateAsNonNls();
  final PsiClass aaClass=aClass;
  final boolean rebindNeeded1=rebindNeeded;
  final Runnable runnable=new Runnable(){
    public void run(){
      try {
        final boolean rebindNeeded2=!variableName.equals(fieldName) || rebindNeeded1;
        final PsiReference[] refs;
        if (rebindNeeded2) {
          refs=ReferencesSearch.search(local,GlobalSearchScope.projectScope(myProject),false).toArray(new PsiReference[0]);
        }
 else {
          refs=null;
        }
        final PsiMethod enclosingConstructor=BaseExpressionToFieldHandler.getEnclosingConstructor(aaClass,local);
        PsiField field=settings.isIntroduceEnumConstant() ? EnumConstantsUtil.createEnumConstant(aaClass,local,fieldName) : createField(local,fieldName,initializerPlace == IN_FIELD_DECLARATION);
        if (!settings.isIntroduceEnumConstant()) {
          if (isStatic) {
            field.getModifierList().setModifierProperty(PsiModifier.STATIC,true);
          }
          if (declareFinal) {
            field.getModifierList().setModifierProperty(PsiModifier.FINAL,true);
          }
          if (annotateAsNonNls) {
            PsiAnnotation annotation=JavaPsiFacade.getInstance(local.getProject()).getElementFactory().createAnnotationFromText("@" + AnnotationUtil.NON_NLS,field);
            field.getModifierList().addAfter(annotation,null);
          }
          field.getModifierList().setModifierProperty(fieldVisibility,true);
        }
        field=(PsiField)aaClass.add(field);
        JavaCodeStyleManager.getInstance(myProject).shortenClassReferences(field);
        local.normalizeDeclaration();
        PsiDeclarationStatement declarationStatement=(PsiDeclarationStatement)local.getParent();
        final BaseExpressionToFieldHandler.InitializationPlace finalInitializerPlace;
        if (local.getInitializer() == null) {
          finalInitializerPlace=IN_FIELD_DECLARATION;
        }
 else {
          finalInitializerPlace=initializerPlace;
        }
        final PsiElementFactory factory=JavaPsiFacade.getInstance(myManager.getProject()).getElementFactory();
switch (finalInitializerPlace) {
case IN_FIELD_DECLARATION:
          declarationStatement.delete();
        break;
case IN_CURRENT_METHOD:
      PsiStatement statement=createAssignment(local,fieldName,factory);
    declarationStatement.replace(statement);
  break;
case IN_CONSTRUCTOR:
addInitializationToConstructors(local,field,enclosingConstructor,factory);
break;
case IN_SETUP_METHOD:
addInitializationToSetUp(local,field,factory);
}
if (enclosingConstructor != null && initializerPlace == IN_CONSTRUCTOR) {
PsiStatement statement=createAssignment(local,fieldName,factory);
declarationStatement.replace(statement);
}
if (rebindNeeded2) {
for (final PsiReference reference : refs) {
if (reference != null) {
RefactoringUtil.replaceOccurenceWithFieldRef((PsiExpression)reference,field,aaClass,editor,field.getContainingFile());
}
}
}
}
 catch (IncorrectOperationException e) {
LOG.error(e);
}
}
}
;
CommandProcessor.getInstance().executeCommand(myProject,new Runnable(){
public void run(){
ApplicationManager.getApplication().runWriteAction(runnable);
}
}
,REFACTORING_NAME,null);
return true;
}
