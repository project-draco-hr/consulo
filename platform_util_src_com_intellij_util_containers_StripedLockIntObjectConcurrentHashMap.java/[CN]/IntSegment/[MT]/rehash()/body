{
  IntHashEntry[] oldTable=table;
  int oldCapacity=oldTable.length;
  if (oldCapacity >= StripedLockConcurrentHashMap.MAXIMUM_CAPACITY) {
    return;
  }
  IntHashEntry[] newTable=new IntHashEntry[oldCapacity << 1];
  int sizeMask=newTable.length - 1;
  for (int i=0; i < oldCapacity; i++) {
    IntHashEntry<V> e=oldTable[i];
    if (e != null) {
      IntHashEntry<V> next=e.next;
      int idx=e.key & sizeMask;
      if (next == null) {
        newTable[idx]=e;
      }
 else {
        IntHashEntry<V> lastRun=e;
        int lastIdx=idx;
        for (IntHashEntry<V> last=next; last != null; last=last.next) {
          int k=last.key & sizeMask;
          if (k != lastIdx) {
            lastIdx=k;
            lastRun=last;
          }
        }
        newTable[lastIdx]=lastRun;
        for (IntHashEntry<V> p=e; p != lastRun; p=p.next) {
          int k=p.key & sizeMask;
          IntHashEntry<V> n=newTable[k];
          newTable[k]=new IntHashEntry<V>(p.key,n,p.value);
        }
      }
    }
  }
  setTable(newTable);
}
