{
  final AtomicInteger tooManyUsages=new AtomicInteger();
  final CountDownLatch waitWhileUserClick=new CountDownLatch(1);
  final AtomicInteger usageCountWithoutDefinition=new AtomicInteger(0);
  ProgressManager.getInstance().run(new Task.Backgroundable(myProject,UsageViewManagerImpl.getProgressTitle(myPresentation)){
    public void run(    @NotNull final ProgressIndicator indicator){
      setSearchInProgress(true);
      final com.intellij.usages.UsageViewManager usageViewManager=com.intellij.usages.UsageViewManager.getInstance(myProject);
      usageViewManager.setCurrentSearchCancelled(false);
      myChangesDetected=false;
      UsageSearcher usageSearcher=myUsageSearcherFactory.create();
      usageSearcher.generate(new Processor<Usage>(){
        public boolean process(        final Usage usage){
          if (usageViewManager.searchHasBeenCancelled())           return false;
          ((UsageViewManagerImpl)usageViewManager).appendUsageWhenNotTooMany(usage,myTargets,UsageViewImpl.this,indicator,tooManyUsages,waitWhileUserClick,usageCountWithoutDefinition);
          ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
          return indicator == null || !indicator.isCanceled();
        }
      }
);
      drainQueuedUsageNodes();
      setSearchInProgress(false);
    }
  }
);
}
