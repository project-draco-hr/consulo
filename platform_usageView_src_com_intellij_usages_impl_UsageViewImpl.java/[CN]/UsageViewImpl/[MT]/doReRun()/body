{
  final AtomicInteger tooManyUsages=new AtomicInteger();
  final CountDownLatch waitWhileUserClick=new CountDownLatch(1);
  final AtomicInteger usageCountWithoutDefinition=new AtomicInteger(0);
  ProgressManager.getInstance().run(new Task.Backgroundable(myProject,UsageViewManagerImpl.getProgressTitle(myPresentation)){
    @Override public void run(    @NotNull final ProgressIndicator indicator){
      setSearchInProgress(true);
      final com.intellij.usages.UsageViewManager usageViewManager=com.intellij.usages.UsageViewManager.getInstance(myProject);
      setCurrentSearchCancelled(false);
      myChangesDetected=false;
      UsageSearcher usageSearcher=myUsageSearcherFactory.create();
      usageSearcher.generate(new Processor<Usage>(){
        @Override public boolean process(        final Usage usage){
          if (searchHasBeenCancelled())           return false;
          if (tooManyUsages.get() == 1) {
            try {
              waitWhileUserClick.await(1,TimeUnit.SECONDS);
            }
 catch (            InterruptedException ignored) {
            }
          }
          boolean incrementCounter=!com.intellij.usages.UsageViewManager.isSelfUsage(usage,myTargets);
          if (incrementCounter) {
            final int usageCount=usageCountWithoutDefinition.incrementAndGet();
            if (usageCount > UsageLimitUtil.USAGES_LIMIT && tooManyUsages.get() == 0 && tooManyUsages.compareAndSet(0,1)) {
              ((UsageViewManagerImpl)usageViewManager).showTooManyUsagesWarning(indicator,waitWhileUserClick,usageCountWithoutDefinition.get(),UsageViewImpl.this);
            }
            appendUsage(usage);
          }
          ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
          return indicator == null || !indicator.isCanceled();
        }
      }
);
      drainQueuedUsageNodes();
      setSearchInProgress(false);
    }
  }
);
}
