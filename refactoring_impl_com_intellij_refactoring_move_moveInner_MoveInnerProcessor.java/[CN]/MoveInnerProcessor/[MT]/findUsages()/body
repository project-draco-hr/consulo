{
  LOG.assertTrue(myTargetContainer != null);
  Collection<PsiReference> innerClassRefs=ReferencesSearch.search(myInnerClass).findAll();
  ArrayList<UsageInfo> usageInfos=new ArrayList<UsageInfo>(innerClassRefs.size());
  for (  PsiReference innerClassRef : innerClassRefs) {
    PsiElement ref=innerClassRef.getElement();
    if (!PsiTreeUtil.isAncestor(myInnerClass,ref,true)) {
      usageInfos.add(new UsageInfo(ref));
    }
  }
  final String newQName;
  if (myTargetContainer instanceof PsiDirectory) {
    final PsiDirectory targetDirectory=(PsiDirectory)myTargetContainer;
    final PsiPackage aPackage=targetDirectory.getPackage();
    LOG.assertTrue(aPackage != null);
    newQName=aPackage.getQualifiedName() + "." + myNewClassName;
  }
 else   if (myTargetContainer instanceof PsiClass) {
    final String qName=((PsiClass)myTargetContainer).getQualifiedName();
    if (qName != null) {
      newQName=qName + "." + myNewClassName;
    }
 else {
      newQName=myNewClassName;
    }
  }
 else {
    newQName=myNewClassName;
  }
  MoveClassesOrPackagesUtil.findNonCodeUsages(mySearchInComments,mySearchInNonJavaFiles,myInnerClass,newQName,usageInfos);
  return usageInfos.toArray(new UsageInfo[usageInfos.size()]);
}
