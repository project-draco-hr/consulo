{
  PsiManager manager=PsiManager.getInstance(myProject);
  final PsiElementFactory factory=JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();
  final RefactoringElementListener elementListener=getTransaction().getElementListener(myInnerClass);
  String newClassName=myNewClassName;
  try {
    PsiField field=null;
    if (myParameterNameOuterClass != null) {
      field=factory.createField(myFieldNameOuterClass,factory.createType(myOuterClass));
      field=(PsiField)myInnerClass.add(field);
      myInnerClass=field.getContainingClass();
      addFieldInitializationToConstructors(myInnerClass,field,myParameterNameOuterClass);
    }
    ChangeContextUtil.encodeContextInfo(myInnerClass,false);
    PsiClass newClass;
    if (myTargetContainer instanceof PsiDirectory) {
      myInnerClass=CodeInsightUtilBase.forcePsiPostprocessAndRestoreElement(myInnerClass);
      newClass=JavaDirectoryService.getInstance().createClass((PsiDirectory)myTargetContainer,newClassName);
      PsiDocComment defaultDocComment=newClass.getDocComment();
      if (defaultDocComment != null && myInnerClass.getDocComment() == null) {
        myInnerClass=(PsiClass)myInnerClass.addAfter(defaultDocComment,null).getParent();
      }
      newClass=(PsiClass)newClass.replace(myInnerClass);
      newClass.getModifierList().setModifierProperty(PsiModifier.STATIC,false);
      newClass.getModifierList().setModifierProperty(PsiModifier.PRIVATE,false);
      newClass.getModifierList().setModifierProperty(PsiModifier.PROTECTED,false);
      final boolean makePublic=needPublicAccess();
      if (makePublic) {
        newClass.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true);
      }
      final PsiMethod[] constructors=newClass.getConstructors();
      for (      PsiMethod constructor : constructors) {
        final PsiModifierList modifierList=constructor.getModifierList();
        modifierList.setModifierProperty(PsiModifier.PRIVATE,false);
        modifierList.setModifierProperty(PsiModifier.PROTECTED,false);
        if (makePublic) {
          modifierList.setModifierProperty(PsiModifier.PUBLIC,true);
        }
      }
    }
 else {
      newClass=(PsiClass)myTargetContainer.add(myInnerClass);
    }
    newClass.setName(newClassName);
    for (    PsiReference ref : ReferencesSearch.search(myInnerClass,new LocalSearchScope(newClass),true)) {
      PsiElement element=ref.getElement();
      if (element.getParent() instanceof PsiJavaCodeReferenceElement) {
        PsiJavaCodeReferenceElement parentRef=(PsiJavaCodeReferenceElement)element.getParent();
        PsiElement parentRefElement=parentRef.resolve();
        if (parentRefElement instanceof PsiClass) {
          parentRef.getQualifier().delete();
          continue;
        }
      }
      ref.bindToElement(newClass);
    }
    List<PsiReference> referencesToRebind=new ArrayList<PsiReference>();
    for (    UsageInfo usage : usages) {
      if (usage.isNonCodeUsage)       continue;
      PsiElement refElement=usage.getElement();
      PsiReference[] references=refElement.getReferences();
      for (      PsiReference reference : references) {
        if (reference.isReferenceTo(myInnerClass)) {
          referencesToRebind.add(reference);
        }
      }
    }
    myInnerClass.delete();
    for (    UsageInfo usage : usages) {
      if (usage.isNonCodeUsage)       continue;
      PsiElement refElement=usage.getElement();
      if (myParameterNameOuterClass != null) {
        PsiElement refParent=refElement.getParent();
        if (refParent instanceof PsiNewExpression || refParent instanceof PsiAnonymousClass) {
          PsiNewExpression newExpr=refParent instanceof PsiNewExpression ? (PsiNewExpression)refParent : (PsiNewExpression)refParent.getParent();
          PsiExpressionList argList=newExpr.getArgumentList();
          if (argList != null) {
            if (newExpr.getQualifier() == null) {
              PsiThisExpression thisExpr;
              PsiClass parentClass=RefactoringUtil.getThisClass(newExpr);
              if (myOuterClass.equals(parentClass)) {
                thisExpr=RefactoringUtil.createThisExpression(manager,null);
              }
 else {
                thisExpr=RefactoringUtil.createThisExpression(manager,myOuterClass);
              }
              argList.addAfter(thisExpr,null);
            }
 else {
              argList.addAfter(newExpr.getQualifier(),null);
              newExpr.getQualifier().delete();
            }
          }
        }
      }
    }
    for (    PsiReference reference : referencesToRebind) {
      reference.bindToElement(newClass);
    }
    if (field != null) {
      PsiExpression accessExpression=factory.createExpressionFromText(myFieldNameOuterClass,null);
      ChangeContextUtil.decodeContextInfo(newClass,myOuterClass,accessExpression);
    }
 else {
      ChangeContextUtil.decodeContextInfo(newClass,null,null);
    }
    PsiFile targetFile=newClass.getContainingFile();
    OpenFileDescriptor descriptor=new OpenFileDescriptor(myProject,targetFile.getVirtualFile(),newClass.getTextOffset());
    FileEditorManager.getInstance(myProject).openTextEditor(descriptor,true);
    if (myMoveCallback != null) {
      myMoveCallback.refactoringCompleted();
    }
    elementListener.elementMoved(newClass);
    List<NonCodeUsageInfo> nonCodeUsages=new ArrayList<NonCodeUsageInfo>();
    for (    UsageInfo usage : usages) {
      if (usage instanceof NonCodeUsageInfo) {
        nonCodeUsages.add((NonCodeUsageInfo)usage);
      }
    }
    myNonCodeUsages=nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
