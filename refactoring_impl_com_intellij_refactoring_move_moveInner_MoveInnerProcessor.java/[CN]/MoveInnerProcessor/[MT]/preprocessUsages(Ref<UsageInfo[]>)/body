{
  final ArrayList<String> conflicts=new ArrayList<String>();
class Visitor extends PsiRecursiveElementVisitor {
    private final HashMap<PsiElement,HashSet<PsiElement>> reported=new HashMap<PsiElement,HashSet<PsiElement>>();
    @Override public void visitReferenceElement(    PsiJavaCodeReferenceElement reference){
      PsiElement resolved=reference.resolve();
      if (resolved instanceof PsiMember && PsiTreeUtil.isAncestor(myInnerClass,resolved,true) && becomesInaccessible(((PsiMember)resolved))) {
        final PsiElement container=ConflictsUtil.getContainer(reference);
        HashSet<PsiElement> containerSet=reported.get(resolved);
        if (containerSet == null) {
          containerSet=new HashSet<PsiElement>();
          reported.put(resolved,containerSet);
        }
        if (!containerSet.contains(container)) {
          containerSet.add(container);
          String message=RefactoringBundle.message("0.will.become.inaccessible.from.1",ConflictsUtil.getDescription(resolved,true),ConflictsUtil.getDescription(container,true));
          conflicts.add(message);
        }
      }
    }
    private boolean becomesInaccessible(    PsiMember element){
      final String visibilityModifier=VisibilityUtil.getVisibilityModifier(element.getModifierList());
      if (PsiModifier.PRIVATE.equals(visibilityModifier))       return true;
      if (PsiModifier.PUBLIC.equals(visibilityModifier))       return false;
      final PsiFile containingFile=myOuterClass.getContainingFile();
      if (myTargetContainer instanceof PsiDirectory) {
        final PsiPackage aPackage=JavaDirectoryService.getInstance().getPackage(((PsiDirectory)myTargetContainer));
        return !isInPackage(containingFile,aPackage);
      }
      PsiFile targetFile=myTargetContainer.getContainingFile();
      if (targetFile != null) {
        final PsiDirectory containingDirectory=targetFile.getContainingDirectory();
        if (containingDirectory != null) {
          final PsiPackage targetPackage=JavaDirectoryService.getInstance().getPackage(containingDirectory);
          return isInPackage(containingFile,targetPackage);
        }
      }
      return false;
    }
    @Override public void visitClass(    PsiClass aClass){
      if (aClass == myInnerClass)       return;
      super.visitClass(aClass);
    }
  }
  myOuterClass.accept(new Visitor());
  return showConflicts(conflicts);
}
