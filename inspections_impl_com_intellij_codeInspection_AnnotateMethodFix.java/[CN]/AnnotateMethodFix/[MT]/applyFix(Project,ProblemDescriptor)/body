{
  final PsiElement psiElement=descriptor.getPsiElement();
  PsiMethod method=PsiTreeUtil.getParentOfType(psiElement,PsiMethod.class);
  if (method == null)   return;
  final List<PsiMethod> toAnnotate=new ArrayList<PsiMethod>();
  toAnnotate.add(method);
  List<MethodSignatureBackedByPsiMethod> superMethodSignatures=method.findSuperMethodSignaturesIncludingStatic(true);
  for (  MethodSignatureBackedByPsiMethod superMethodSignature : superMethodSignatures) {
    PsiMethod superMethod=superMethodSignature.getMethod();
    if (!AnnotationUtil.isAnnotated(superMethod,myAnnotation,false) && superMethod.getManager().isInProject(superMethod)) {
      int ret=annotateBaseMethod(method,superMethod,project);
      if (ret != 0 && ret != 1)       return;
      if (ret == 0) {
        toAnnotate.add(superMethod);
      }
    }
  }
  if (annotateOverriddenMethods()) {
    PsiMethod[] methods=method.getManager().getSearchHelper().findOverridingMethods(method,GlobalSearchScope.allScope(project),true);
    for (    PsiMethod psiMethod : methods) {
      if (!AnnotationUtil.isAnnotated(psiMethod,myAnnotation,false) && psiMethod.getManager().isInProject(psiMethod)) {
        toAnnotate.add(psiMethod);
      }
    }
  }
  CodeInsightUtil.preparePsiElementsForWrite(toAnnotate);
  for (  PsiMethod psiMethod : toAnnotate) {
    annotateMethod(psiMethod);
  }
  UndoManager.getInstance(project).markDocumentForUndo(method.getContainingFile());
}
