{
  String name=refExpr.getReferenceName();
  if (name == null)   return GroovyResolveResult.EMPTY_ARRAY;
  Kind kind=refExpr.getKind();
  if (incompleteCode) {
    ResolverProcessor processor=CompletionProcessor.createRefSameNameProcessor(refExpr,name);
    resolveImpl(refExpr,processor);
    GroovyResolveResult[] propertyCandidates=processor.getCandidates();
    if (propertyCandidates.length > 0)     return propertyCandidates;
  }
  if (kind == Kind.METHOD_OR_PROPERTY) {
    final PsiType[] argTypes=PsiUtil.getArgumentTypes(refExpr,false,false);
    PsiType thisType=getThisType(refExpr);
    MethodResolverProcessor methodResolver=new MethodResolverProcessor(name,refExpr,false,thisType,argTypes,refExpr.getTypeArguments());
    resolveImpl(refExpr,methodResolver);
    if (methodResolver.hasApplicableCandidates())     return methodResolver.getCandidates();
    ClosurePropertyResolverProcessor closureResolver=new ClosurePropertyResolverProcessor(name,refExpr,argTypes,true);
    resolveImpl(refExpr,closureResolver);
    if (closureResolver.hasApplicableCandidates())     return closureResolver.getCandidates();
    final String[] names=GroovyPropertyUtils.suggestGettersName(name);
    List<GroovyResolveResult> list=new ArrayList<GroovyResolveResult>();
    for (    String getterName : names) {
      closureResolver=new ClosurePropertyResolverProcessor(getterName,refExpr,argTypes,false);
      resolveImpl(refExpr,closureResolver);
      if (closureResolver.hasApplicableCandidates())       list.addAll(Arrays.asList(closureResolver.getCandidates()));
    }
    if (list.size() > 0)     return list.toArray(new GroovyResolveResult[list.size()]);
    if (methodResolver.hasCandidates())     return methodResolver.getCandidates();
    return closureResolver.getCandidates();
  }
 else   if (kind == Kind.TYPE_OR_PROPERTY) {
    ResolverProcessor processor=new PropertyResolverProcessor(name,refExpr);
    resolveImpl(refExpr,processor);
    GroovyResolveResult[] candidates=processor.getCandidates();
    if (candidates.length > 0)     return candidates;
    final boolean isLValue=PsiUtil.isLValue(refExpr);
    String[] names;
    PsiType[] argTypes;
    if (isLValue) {
      names=GroovyPropertyUtils.suggestSettersName(name);
      argTypes=new PsiType[]{PsiType.NULL};
    }
 else {
      names=GroovyPropertyUtils.suggestGettersName(name);
      argTypes=PsiType.EMPTY_ARRAY;
    }
    List<GroovyResolveResult> list=new ArrayList<GroovyResolveResult>();
    for (    String getterName : names) {
      PsiType thisType=getThisType(refExpr);
      MethodResolverProcessor accessorResolver=new MethodResolverProcessor(getterName,refExpr,false,thisType,argTypes,PsiType.EMPTY_ARRAY);
      resolveImpl(refExpr,accessorResolver);
      if (accessorResolver.hasApplicableCandidates()) {
        list.addAll(Arrays.asList(accessorResolver.getCandidates()));
      }
    }
    if (list.size() > 0)     return list.toArray(new GroovyResolveResult[list.size()]);
    EnumSet<ClassHint.ResolveKind> kinds=refExpr.getParent() instanceof GrReferenceExpression ? EnumSet.of(ClassHint.ResolveKind.CLASS,ClassHint.ResolveKind.PACKAGE) : EnumSet.of(ClassHint.ResolveKind.CLASS);
    ResolverProcessor classProcessor=new ClassResolverProcessor(refExpr.getReferenceName(),refExpr,kinds);
    resolveImpl(refExpr,classProcessor);
    return classProcessor.getCandidates();
  }
  return GroovyResolveResult.EMPTY_ARRAY;
}
