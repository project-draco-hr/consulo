{
class Node {
    int myComponent=-1;
    Constraint myConstraint;
    HashSet<Node> myNeighbours=new HashSet<Node>();
    public Node(){
      myConstraint=null;
    }
    public Node(    final Constraint c){
      myConstraint=c;
    }
    public Constraint getConstraint(){
      return myConstraint;
    }
    public void addEdge(    final Node n){
      if (!myNeighbours.contains(n)) {
        myNeighbours.add(n);
        n.addEdge(this);
      }
    }
  }
  final Node[] typeVariableNodes=new Node[myTypeVariableFactory.getNumber()];
  final Node[] constraintNodes=new Node[myConstraints.size()];
  final HashMap<Constraint,HashSet<PsiTypeVariable>> boundVariables=new HashMap<Constraint,HashSet<PsiTypeVariable>>();
  for (int i=0; i < typeVariableNodes.length; i++) {
    typeVariableNodes[i]=new Node();
  }
{
    int j=0;
    for (Iterator<Constraint> c=myConstraints.iterator(); c.hasNext(); ) {
      constraintNodes[j++]=new Node(c.next());
    }
  }
{
    int l=0;
    for (Iterator<Constraint> i=myConstraints.iterator(); i.hasNext(); ) {
      final HashSet<PsiTypeVariable> boundVars=new HashSet<PsiTypeVariable>();
      final Constraint constraint=i.next();
      final Node constraintNode=constraintNodes[l++];
      new Object(){
        void visit(        final Constraint c){
          visit(c.getLeft());
          visit(c.getRight());
        }
        private void visit(        final PsiType t){
          if (t instanceof PsiTypeVariable) {
            boundVars.add((PsiTypeVariable)t);
          }
 else           if (t instanceof PsiArrayType) {
            visit(t.getDeepComponentType());
          }
 else           if (t instanceof PsiClassType) {
            final PsiSubstitutor subst=Util.resolveType(t).getSubstitutor();
            for (Iterator<PsiType> j=subst.getSubstitutionMap().values().iterator(); j.hasNext(); ) {
              visit(j.next());
            }
          }
 else           if (t instanceof PsiIntersectionType) {
            final PsiType[] conjuncts=((PsiIntersectionType)t).getConjuncts();
            for (int j=0; j < conjuncts.length; j++) {
              visit(conjuncts[j]);
            }
          }
        }
      }
.visit(constraint);
      final PsiTypeVariable[] bound=boundVars.toArray(new PsiTypeVariable[]{});
      for (int j=0; j < bound.length; j++) {
        final int x=bound[j].getIndex();
        final Node typeVariableNode=typeVariableNodes[x];
        typeVariableNode.addEdge(constraintNode);
        for (int k=j + 1; k < bound.length; k++) {
          final int y=bound[k].getIndex();
          typeVariableNode.addEdge(typeVariableNodes[y]);
        }
      }
      boundVariables.put(constraint,boundVars);
    }
  }
  final LinkedList<HashSet<PsiTypeVariable>> clusters=myTypeVariableFactory.getClusters();
  for (final Iterator<HashSet<PsiTypeVariable>> c=clusters.iterator(); c.hasNext(); ) {
    final HashSet<PsiTypeVariable> cluster=c.next();
    Node prev=null;
    for (final Iterator<PsiTypeVariable> v=cluster.iterator(); v.hasNext(); ) {
      final Node curr=typeVariableNodes[v.next().getIndex()];
      if (prev != null) {
        prev.addEdge(curr);
      }
      prev=curr;
    }
  }
  int currComponent=0;
  for (int i=0; i < typeVariableNodes.length; i++) {
    final Node node=typeVariableNodes[i];
    if (node.myComponent == -1) {
      final int component=currComponent;
      new Object(){
        void selectComponent(        final Node n){
          final LinkedList<Node> frontier=new LinkedList<Node>();
          frontier.addFirst(n);
          while (frontier.size() > 0) {
            final Node curr=frontier.removeFirst();
            curr.myComponent=component;
            for (Iterator<Node> i=curr.myNeighbours.iterator(); i.hasNext(); ) {
              final Node p=i.next();
              if (p.myComponent == -1) {
                frontier.addFirst(p);
              }
            }
          }
        }
      }
.selectComponent(node);
      currComponent++;
    }
  }
  final System[] systems=new System[currComponent];
  for (int i=0; i < constraintNodes.length; i++) {
    final Node node=constraintNodes[i];
    final Constraint constraint=node.getConstraint();
    final int index=node.myComponent;
    if (systems[index] == null) {
      systems[index]=new System(myProject,myElements,myTypes,myTypeVariableFactory,mySettings);
    }
    systems[index].addConstraint(constraint,boundVariables.get(constraint));
  }
  return systems;
}
