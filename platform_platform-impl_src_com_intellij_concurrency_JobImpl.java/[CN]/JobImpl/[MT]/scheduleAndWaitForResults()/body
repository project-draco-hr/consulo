{
  checkCanSchedule();
  final Application application=ApplicationManager.getApplication();
  boolean callerHasReadAccess=application != null && application.isReadAccessAllowed();
  boolean reallySchedule;
  PrioritizedFutureTask[] tasks=getTasks();
synchronized (myFutures) {
    reallySchedule=JobSchedulerImpl.CORES_COUNT >= 2 && myFutures.size() >= 2;
  }
  scheduled=true;
  if (!reallySchedule) {
    for (    PrioritizedFutureTask future : tasks) {
      future.run();
    }
    return null;
  }
  submitTasks(tasks,callerHasReadAccess,false);
  while (!isDone()) {
    Runnable task=JobSchedulerImpl.stealTask();
    if (task == null)     break;
    boolean wasMarked=ApplicationImpl.setExceptionalThreadWithReadAccessFlag(false);
    try {
      task.run();
    }
  finally {
      if (wasMarked)       ApplicationImpl.setExceptionalThreadWithReadAccessFlag(true);
    }
  }
  waitForTermination();
  return null;
}
