{
  super.visitModifierList(list);
  final PsiElement parent=list.getParent();
  if (!myHolder.hasErrorResults() && parent instanceof PsiMethod) {
    myHolder.add(HighlightMethodUtil.checkMethodCanHaveBody((PsiMethod)parent));
  }
  if (parent instanceof PsiMethod) {
    final PsiMethod method=(PsiMethod)parent;
    final MethodSignatureBackedByPsiMethod methodSignature=MethodSignatureBackedByPsiMethod.create(method,PsiSubstitutor.EMPTY);
    if (!method.isConstructor()) {
      final List<MethodSignatureBackedByPsiMethod> superMethodSignatures=PsiSuperMethodUtil.findSuperMethodSignaturesIncludingStatic(method,true);
      final List<MethodSignatureBackedByPsiMethod> superMethodCandidateSignatures=PsiSuperMethodUtil.findSuperMethodSignaturesIncludingStatic(method,false);
      if (!myHolder.hasErrorResults()) {
        myHolder.add(HighlightMethodUtil.checkMethodWeakerPrivileges(methodSignature,superMethodCandidateSignatures,true));
      }
      if (!myHolder.hasErrorResults()) {
        myHolder.add(HighlightMethodUtil.checkMethodIncompatibleReturnType(methodSignature,superMethodSignatures,true));
      }
      if (!myHolder.hasErrorResults()) {
        myHolder.add(HighlightMethodUtil.checkMethodIncompatibleThrows(methodSignature,superMethodSignatures,true));
      }
      if (!myHolder.hasErrorResults()) {
        myHolder.add(HighlightMethodUtil.checkMethodOverridesFinal(methodSignature,superMethodSignatures));
      }
      if (!myHolder.hasErrorResults()) {
        myHolder.add(HighlightMethodUtil.checkMethodOverridesDeprecated(methodSignature,superMethodSignatures,mySettings));
      }
    }
    final PsiClass aClass=method.getContainingClass();
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightMethodUtil.checkMethodMustHaveBody(method,aClass));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightMethodUtil.checkDuplicateMethod(aClass,method));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightMethodUtil.checkConstructorCallBaseclassConstructor(method,myRefCountHolder));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightMethodUtil.checkStaticMethodOverride(method));
  }
 else   if (parent instanceof PsiClass) {
    PsiClass aClass=(PsiClass)parent;
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightClassUtil.checkDuplicateNestedClass(aClass));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightClassUtil.checkClassMustBeAbstract(aClass));
    if (!myHolder.hasErrorResults()) {
      myHolder.add(HighlightClassUtil.checkClassDoesNotCallSuperConstructorOrHandleExceptions(aClass,myRefCountHolder));
    }
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightMethodUtil.checkInheritedMethodsWithSameSignature(aClass));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightClassUtil.checkCyclicInheritance(aClass));
  }
 else   if (parent instanceof PsiPointcutDef) {
    PsiPointcutDef pointcutDef=(PsiPointcutDef)parent;
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightAspectUtil.checkAbstractPointcutBody(pointcutDef));
    if (!myHolder.hasErrorResults())     myHolder.add(HighlightAspectUtil.checkPointcutOverridesFinal(pointcutDef));
  }
 else   if (parent instanceof PsiEnumConstant) {
    if (!myHolder.hasErrorResults())     myHolder.addAll(GenericsHighlightUtil.checkEnumConstantModifierList(list));
  }
  if (!myHolder.hasErrorResults()) {
    HighlightInfo[] duplicateResults=AnnotationsHighlightUtil.checkDuplicatedAnnotations(list);
    for (int i=0; i < duplicateResults.length; i++) {
      myHolder.add(duplicateResults[i]);
    }
  }
}
