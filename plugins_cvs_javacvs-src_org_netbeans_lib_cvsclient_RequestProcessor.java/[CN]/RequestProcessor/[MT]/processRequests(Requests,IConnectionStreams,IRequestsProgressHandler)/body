{
  BugLog.getInstance().assertNotNull(requests);
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  final Ref<IOException> ioExceptionRef=new Ref<IOException>();
  final Ref<CommandException> commandExceptionRef=new Ref<CommandException>();
  final Ref<Boolean> result=new Ref<Boolean>();
  final Future<?> future=Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      try {
        sendRequests(requests,connectionStreams,communicationProgressHandler);
        sendRequest(requests.getResponseExpectingRequest(),connectionStreams);
        connectionStreams.flushForReading();
        result.set(handleResponses(connectionStreams,new DefaultResponseHandler()));
      }
 catch (      IOException e) {
        ioExceptionRef.set(e);
      }
catch (      CommandException e) {
        commandExceptionRef.set(e);
      }
 finally {
        semaphore.up();
      }
    }
  }
);
  semaphore.waitFor((long)(1.2 * myTimeout));
  if (!ioExceptionRef.isNull())   throw new IOCommandException(ioExceptionRef.get());
  if (!commandExceptionRef.isNull())   throw commandExceptionRef.get();
  if ((!future.isDone() && (!future.isCancelled()))) {
    future.cancel(true);
    throw new CommandException(new CommandAbortedException(),"Command execution timed out");
  }
  return result.isNull() ? false : result.get();
}
