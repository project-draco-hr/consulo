{
  BugLog.getInstance().assertNotNull(requests);
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  final Ref<IOException> ioExceptionRef=new Ref<IOException>();
  final Ref<CommandException> commandExceptionRef=new Ref<CommandException>();
  final Ref<Boolean> result=new Ref<Boolean>();
  final Future<?> future=Executors.newSingleThreadExecutor().submit(new Runnable(){
    public void run(){
      try {
        checkCanceled();
        sendRequests(requests,connectionStreams,communicationProgressHandler);
        checkCanceled();
        sendRequest(requests.getResponseExpectingRequest(),connectionStreams);
        connectionStreams.flushForReading();
        result.set(handleResponses(connectionStreams,new DefaultResponseHandler()));
      }
 catch (      IOException e) {
        ioExceptionRef.set(e);
      }
catch (      CommandException e) {
        commandExceptionRef.set(e);
      }
 finally {
        semaphore.up();
      }
    }
  }
);
  final long tOut=(myTimeout < 20000) ? 20000 : myTimeout;
  while (true) {
    semaphore.waitFor(tOut);
    if (future.isDone() || future.isCancelled())     break;
    if (!commandStopper.isAlive())     break;
    commandStopper.resetAlive();
  }
  if (!ioExceptionRef.isNull())   throw new IOCommandException(ioExceptionRef.get());
  if (!commandExceptionRef.isNull())   throw commandExceptionRef.get();
  if ((!future.isDone() && (!future.isCancelled()) && (!commandStopper.isAlive()))) {
    future.cancel(true);
    throw new CommandException(new CommandAbortedException(),"Command execution timed out");
  }
  return result.isNull() ? false : result.get();
}
