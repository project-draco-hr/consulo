{
  final BuildDataManager dataManager=context.getProjectDescriptor().dataManager;
  try {
    final Map<T,Set<File>> cleanedSources=new java.util.HashMap<T,Set<File>>();
    ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
    final Collection<String> outputsToLog=logger.isEnabled() ? new LinkedList<String>() : null;
    final THashSet<File> dirsToDelete=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
    final THashSet<String> deletedPaths=new THashSet<String>();
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<R,T>(){
      private final Map<T,SourceToOutputMapping> mappingsCache=new java.util.HashMap<T,SourceToOutputMapping>();
      @Override public boolean apply(      T target,      File file,      R sourceRoot) throws IOException {
        SourceToOutputMapping srcToOut=mappingsCache.get(target);
        if (srcToOut == null) {
          srcToOut=dataManager.getSourceToOutputMap(target);
          mappingsCache.put(target,srcToOut);
        }
        final String srcPath=file.getPath();
        final Collection<String> outputs=srcToOut.getOutputs(srcPath);
        if (outputs != null) {
          final boolean shouldPruneOutputDirs=target instanceof ModuleBasedTarget;
          for (          String output : outputs) {
            if (outputsToLog != null) {
              outputsToLog.add(output);
            }
            final File outFile=new File(output);
            final boolean deleted=outFile.delete();
            if (deleted) {
              deletedPaths.add(output);
              if (shouldPruneOutputDirs) {
                final File parent=outFile.getParentFile();
                if (parent != null) {
                  dirsToDelete.add(parent);
                }
              }
            }
          }
          Set<File> cleaned=cleanedSources.get(target);
          if (cleaned == null) {
            cleaned=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
            cleanedSources.put(target,cleaned);
          }
          cleaned.add(file);
        }
        return true;
      }
    }
);
    if (outputsToLog != null && context.isMake()) {
      logger.logDeletedFiles(outputsToLog);
    }
    if (!deletedPaths.isEmpty()) {
      context.processMessage(new FileDeletedEvent(deletedPaths));
    }
    FSOperations.pruneEmptyDirs(context,dirsToDelete);
    return cleanedSources;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
