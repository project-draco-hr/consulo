{
  final MethodSignatureUtil.MethodSignatureToMethods methods=MethodSignatureUtil.getOverrideEquivalentMethods(aClass);
  final Collection<List<MethodSignatureBackedByPsiMethod>> lists=methods.values();
  Map<MethodSignature,List<MethodSignatureBackedByPsiMethod>> components=new THashMap<MethodSignature,List<MethodSignatureBackedByPsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  Map<List<MethodSignatureBackedByPsiMethod>,PsiMethod> inverse=new HashMap<List<MethodSignatureBackedByPsiMethod>,PsiMethod>();
  PsiManager manager=aClass.getManager();
  for (  List<MethodSignatureBackedByPsiMethod> overrideEquivalents : lists) {
    for (    MethodSignatureBackedByPsiMethod signature : overrideEquivalents) {
      final PsiMethod method=signature.getMethod();
      if (!manager.getResolveHelper().isAccessible(method,aClass,null))       continue;
      final MethodSignature originalSignature=method.getSignature(PsiSubstitutor.EMPTY);
      final List<MethodSignatureBackedByPsiMethod> component=components.get(originalSignature);
      if (component != null && component != overrideEquivalents) {
        final String pattern="{0}; both methods have same erasure, yet neither overrides the other";
        String description=MessageFormat.format(pattern,new Object[]{HighlightMethodUtil.createClashMethodMessage(method,inverse.get(component),true)});
        TextRange textRange=ClassUtil.getClassDeclarationTextRange(aClass);
        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,textRange,description);
      }
      components.put(originalSignature,overrideEquivalents);
      inverse.put(overrideEquivalents,method);
    }
  }
  return null;
}
