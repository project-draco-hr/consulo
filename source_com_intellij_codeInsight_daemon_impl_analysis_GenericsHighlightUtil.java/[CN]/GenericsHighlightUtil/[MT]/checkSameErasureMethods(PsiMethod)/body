{
  final PsiClass aClass=method.getContainingClass();
  if (aClass == null)   return null;
  final MethodSignatureUtil.MethodSignatureToMethods sameSignatureMethods=MethodSignatureUtil.getOverrideEquivalentMethods(aClass);
  MethodSignature originalMethodSignature=method.getSignature(PsiSubstitutor.EMPTY);
  final List<MethodSignatureBackedByPsiMethod> overrideEquivalentList=sameSignatureMethods.get(originalMethodSignature);
  if (overrideEquivalentList == null)   return null;
  for (  MethodSignatureBackedByPsiMethod superSignature : overrideEquivalentList) {
    PsiMethod superMethod=superSignature.getMethod();
    final boolean sameClass=method.getManager().areElementsEquivalent(method.getContainingClass(),superMethod.getContainingClass());
    if (superMethod == method || (method.isConstructor() && !sameClass))     continue;
    if (!MethodSignatureUtil.isSubsignature(superSignature,originalMethodSignature)) {
      final String pattern=sameClass ? "{0}; both methods have same erasure." : "{0}; both methods have same erasure, yet neither overrides the other";
      String description=MessageFormat.format(pattern,new Object[]{HighlightMethodUtil.createClashMethodMessage(method,superMethod,!sameClass)});
      TextRange textRange=HighlightUtil.getMethodDeclarationTextRange(method);
      return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,textRange,description);
    }
  }
  return null;
}
