{
  Map<PsiElement,Pair<PsiMethod,PsiSubstitutor>> map=CURRENT_CANDIDATE.get();
  if (map == null) {
    map=new ConcurrentWeakHashMap<PsiElement,Pair<PsiMethod,PsiSubstitutor>>();
    CURRENT_CANDIDATE.set(map);
  }
  final PsiMethod method=getElement();
  final Pair<PsiMethod,PsiSubstitutor> alreadyThere=includeReturnConstraint ? map.put(getMarkerList(),Pair.create(method,super.getSubstitutor())) : null;
  try {
    PsiTypeParameter[] typeParameters=method.getTypeParameters();
    if (!method.hasModifierProperty(PsiModifier.STATIC)) {
      final PsiClass containingClass=method.getContainingClass();
      if (containingClass != null && PsiUtil.isRawSubstitutor(containingClass,mySubstitutor)) {
        Project project=containingClass.getProject();
        JavaPsiFacade javaPsiFacade=JavaPsiFacade.getInstance(project);
        return javaPsiFacade.getElementFactory().createRawSubstitutor(mySubstitutor,typeParameters);
      }
    }
    final PsiElement parent=getParent();
    if (parent == null)     return PsiSubstitutor.EMPTY;
    Project project=method.getProject();
    JavaPsiFacade javaPsiFacade=JavaPsiFacade.getInstance(project);
    return javaPsiFacade.getResolveHelper().inferTypeArguments(typeParameters,method.getParameterList().getParameters(),arguments,mySubstitutor,parent,policy,myLanguageLevel);
  }
  finally {
    if (alreadyThere == null)     map.remove(getMarkerList());
  }
}
