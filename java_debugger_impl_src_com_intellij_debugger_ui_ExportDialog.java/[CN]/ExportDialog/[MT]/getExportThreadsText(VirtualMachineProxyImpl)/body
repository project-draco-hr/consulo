{
  final StringBuffer buffer=new StringBuffer(512);
  List<ThreadReference> threads=vmProxy.getVirtualMachine().allThreads();
  for (  ThreadReference threadReference : threads) {
    final String name=threadName(threadReference);
    if (name == null) {
      continue;
    }
    buffer.append(name);
    ReferenceType referenceType=threadReference.referenceType();
    if (referenceType != null) {
      Field daemon=referenceType.fieldByName("daemon");
      if (daemon != null) {
        Value value=threadReference.getValue(daemon);
        if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {
          buffer.append(" ").append(DebuggerBundle.message("threads.export.attribute.label.daemon"));
        }
      }
      Field priority=referenceType.fieldByName("priority");
      if (priority != null) {
        Value value=threadReference.getValue(priority);
        if (value instanceof IntegerValue) {
          buffer.append(", ").append(DebuggerBundle.message("threads.export.attribute.label.priority",((IntegerValue)value).intValue()));
        }
      }
    }
    ThreadGroupReference groupReference=threadReference.threadGroup();
    if (groupReference != null) {
      buffer.append(", ").append(DebuggerBundle.message("threads.export.attribute.label.group",groupReference.name()));
    }
    buffer.append(", ").append(DebuggerBundle.message("threads.export.attribute.label.status",DebuggerUtilsEx.getThreadStatusText(threadReference.status())));
    try {
      if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {
        List<ObjectReference> list=threadReference.ownedMonitors();
        for (        ObjectReference reference : list) {
          final List<ThreadReference> waiting=reference.waitingThreads();
          for (          ThreadReference thread : waiting) {
            final String waitingThreadName=threadName(thread);
            if (waitingThreadName != null) {
              buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.label.blocks.thread",waitingThreadName));
            }
          }
        }
      }
      ObjectReference waitedMonitor=vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;
      if (waitedMonitor != null) {
        if (vmProxy.canGetMonitorInfo()) {
          ThreadReference waitedThread=waitedMonitor.owningThread();
          if (waitedThread != null) {
            final String waitedThreadName=threadName(waitedThread);
            if (waitedThreadName != null) {
              buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.label.waiting.for.thread",waitedThreadName,ThreadDumpAction.renderObject(waitedMonitor)));
            }
          }
        }
      }
      final List<StackFrame> frames=threadReference.frames();
      for (      StackFrame stackFrame : frames) {
        final Location location=stackFrame.location();
        buffer.append("\n\t  ").append(renderLocation(location));
      }
    }
 catch (    IncompatibleThreadStateException e) {
      buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.error.incompatible.state"));
    }
    buffer.append("\n\n");
  }
  return buffer.toString();
}
