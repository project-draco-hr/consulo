{
  super(new BorderLayout());
  myInternalTable=t;
  final JBListTableModel model=new JBListTableModel(t){
    @Override public JBTableRow getRow(    int index){
      return getRowAt(index);
    }
    @Override public boolean isCellEditable(    int rowIndex,    int columnIndex){
      return isRowEditable(rowIndex);
    }
  }
;
  mainTable=new JBTable(model){
    @Override protected void processKeyEvent(    KeyEvent e){
      if (e.getKeyCode() == KeyEvent.VK_ENTER) {
        editCellAt(getSelectedRow(),getSelectedColumn());
      }
 else {
        super.processKeyEvent(e);
      }
    }
    @Override public TableCellRenderer getCellRenderer(    int row,    int column){
      return new DefaultTableCellRenderer(){
        @Override public Component getTableCellRendererComponent(        JTable table,        Object value,        boolean selected,        boolean hasFocus,        int row,        int col){
          return getRowRenderer(t,row,selected,hasFocus);
        }
      }
;
    }
    @Override protected boolean processKeyBinding(    KeyStroke ks,    KeyEvent e,    int condition,    boolean pressed){
      if (isEditing() && e.getKeyCode() == KeyEvent.VK_TAB) {
        if (pressed) {
          final KeyboardFocusManager mgr=KeyboardFocusManager.getCurrentKeyboardFocusManager();
          if (e.isShiftDown()) {
            mgr.focusPreviousComponent();
          }
 else {
            mgr.focusNextComponent();
          }
        }
        return true;
      }
      return super.processKeyBinding(ks,e,condition,pressed);
    }
    @Override public TableCellEditor getCellEditor(    final int row,    int column){
      final JBTableRowEditor editor=getRowEditor(row);
      if (editor != null) {
        editor.prepareEditor(t,row);
        editor.setFocusCycleRoot(true);
        final List<Component> focusableComponents=Arrays.<Component>asList(editor.getFocusableComponents());
        editor.setFocusTraversalPolicy(new FocusTraversalPolicy(){
          @Override public Component getComponentAfter(          Container aContainer,          Component aComponent){
            int i=focusableComponents.indexOf(aComponent);
            if (i != -1) {
              i++;
              if (i >= focusableComponents.size()) {
                i=0;
              }
              return focusableComponents.get(i);
            }
            return null;
          }
          @Override public Component getComponentBefore(          Container aContainer,          Component aComponent){
            int i=focusableComponents.indexOf(aComponent);
            if (i != -1) {
              i--;
              if (i == -1) {
                i=focusableComponents.size() - 1;
              }
              return focusableComponents.get(i);
            }
            return null;
          }
          @Override public Component getFirstComponent(          Container aContainer){
            return focusableComponents.get(0);
          }
          @Override public Component getLastComponent(          Container aContainer){
            return focusableComponents.get(focusableComponents.size() - 1);
          }
          @Override public Component getDefaultComponent(          Container aContainer){
            return editor.getPreferredFocusedComponent();
          }
        }
);
        return new AbstractTableCellEditor(){
          JTable curTable=null;
          @Override public Component getTableCellEditorComponent(          final JTable table,          Object value,          boolean isSelected,          final int row,          int column){
            curTable=table;
            final JPanel p=new JPanel(new BorderLayout()){
              @Override public void addNotify(){
                super.addNotify();
                final int height=(int)getPreferredSize().getHeight();
                if (height > table.getRowHeight(row)) {
                  new RowResizeAnimator(table,row,height).start();
                }
              }
              public void removeNotify(){
                super.removeNotify();
                new RowResizeAnimator(table,row,table.getRowHeight()).start();
              }
            }
;
            p.add(editor,BorderLayout.CENTER);
            return p;
          }
          @Override public Object getCellEditorValue(){
            final JBTableRow value=editor.getValue();
            for (int i=0; i < t.getColumnCount(); i++) {
              t.setValueAt(value.getValueAt(i),row,i);
            }
            return value;
          }
          @Override public boolean stopCellEditing(){
            return super.stopCellEditing();
          }
          @Override public void cancelCellEditing(){
            super.cancelCellEditing();
          }
        }
;
      }
      return null;
    }
    @Override public Component prepareEditor(    TableCellEditor editor,    int row,    int column){
      Object value=getValueAt(row,column);
      boolean isSelected=isCellSelected(row,column);
      return editor.getTableCellEditorComponent(this,value,isSelected,row,column);
    }
  }
;
  mainTable.setStriped(true);
}
