{
  final PsiElement root=getRootElement(psi);
  if (root == null) {
    return Collections.emptyList();
  }
  List<T> cached=_getCachedSemElements(key,true,psi,root);
  if (cached != null) {
    return cached;
  }
  final Collection<SemKey> inheritors=myInheritors.get(key);
  final RecursionGuard.Cacheable<Map<SemKey,List<SemElement>>> cacheable=RecursionManager.createGuard("sem").doCacheable(new Computable<Map<SemKey,List<SemElement>>>(){
    @Override public Map<SemKey,List<SemElement>> compute(){
      final Map<SemKey,List<SemElement>> map=new THashMap<SemKey,List<SemElement>>();
      for (      final SemKey each : inheritors) {
        map.put(each,createSemElements(each,psi));
      }
      return map;
    }
  }
);
  Map<SemKey,List<SemElement>> map=cacheable.result;
  if (cacheable.mayCache) {
    final ConcurrentMap<SemKey,List<SemElement>> persistent=cacheOrGetMap(psi,root);
    for (    SemKey semKey : map.keySet()) {
      persistent.putIfAbsent(semKey,map.get(semKey));
    }
  }
  LinkedHashSet<T> result=new LinkedHashSet<T>();
  for (  final SemKey each : inheritors) {
    result.addAll((List<T>)map.get(each));
  }
  return new ArrayList<T>(result);
}
