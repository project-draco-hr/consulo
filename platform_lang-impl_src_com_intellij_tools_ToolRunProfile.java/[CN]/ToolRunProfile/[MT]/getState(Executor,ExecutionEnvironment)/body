{
  final Project project=env.getProject();
  if (project == null || myCommandLine == null) {
    return null;
  }
  final CommandLineState commandLineState=new CommandLineState(env){
    GeneralCommandLine createCommandLine(){
      return myCommandLine;
    }
    @Override @NotNull protected OSProcessHandler startProcess() throws ExecutionException {
      final GeneralCommandLine commandLine=createCommandLine();
      final OSProcessHandler processHandler=new ColoredProcessHandler(commandLine.createProcess(),commandLine.getCommandLineString());
      ProcessTerminatedListener.attach(processHandler);
      return processHandler;
    }
    @Override @NotNull public ExecutionResult execute(    @NotNull final Executor executor,    @NotNull ProgramRunner runner) throws ExecutionException {
      final ExecutionResult result=super.execute(executor,runner);
      final ProcessHandler processHandler=result.getProcessHandler();
      if (processHandler != null) {
        processHandler.addProcessListener(new ToolProcessAdapter(project,myTool.synchronizeAfterExecution(),getName()));
        processHandler.addProcessListener(new ProcessAdapter(){
          @Override public void onTextAvailable(          ProcessEvent event,          Key outputType){
            if ((outputType == ProcessOutputTypes.STDOUT && myTool.isShowConsoleOnStdOut()) || (outputType == ProcessOutputTypes.STDERR && myTool.isShowConsoleOnStdErr())) {
              ExecutionManager.getInstance(project).getContentManager().toFrontRunContent(executor,processHandler);
            }
          }
        }
);
      }
      return result;
    }
  }
;
  TextConsoleBuilder builder=TextConsoleBuilderFactory.getInstance().createBuilder(project);
  final FilterInfo[] outputFilters=myTool.getOutputFilters();
  for (int i=0; i < outputFilters.length; i++) {
    builder.addFilter(new RegexpFilter(project,outputFilters[i].getRegExp()));
  }
  commandLineState.setConsoleBuilder(builder);
  return commandLineState;
}
