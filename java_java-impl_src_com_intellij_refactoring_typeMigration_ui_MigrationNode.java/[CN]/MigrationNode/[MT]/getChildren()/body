{
  if (myCachedChildren == null) {
    myCachedChildren=new ArrayList<MigrationNode>();
    final PsiElement element=myInfo.getElement();
    if (element != null) {
      myLabeler.setCurrentRoot(myInfo);
      myLabeler.migrateRoot(element,myMigrationType,myLabeler.markRootUsages(element,myMigrationType));
      final HashSet<Pair<TypeMigrationUsageInfo,PsiType>> roots=myLabeler.getRootsTree().get(myInfo);
      if (roots != null) {
        for (        Pair<TypeMigrationUsageInfo,PsiType> root : roots) {
          final TypeMigrationUsageInfo info=root.getFirst();
          if (myParents.contains(info))           continue;
          final HashSet<TypeMigrationUsageInfo> parents=new HashSet<TypeMigrationUsageInfo>(myParents);
          parents.add(info);
          final MigrationNode migrationNode=new MigrationNode(getProject(),info,root.getSecond(),myLabeler,myBuilder,parents,myProcessed);
          if (myInfo.isExcluded()) {
            info.setExcluded(true);
          }
          myCachedChildren.add(migrationNode);
        }
      }
    }
  }
  return myCachedChildren;
}
