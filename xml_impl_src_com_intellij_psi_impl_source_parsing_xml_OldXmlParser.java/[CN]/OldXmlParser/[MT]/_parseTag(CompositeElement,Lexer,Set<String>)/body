{
  if (lexer.getTokenType() != XML_START_TAG_START) {
    return false;
  }
  CompositeElement tag=ASTFactory.composite(XML_TAG);
  parent.rawAddChildren(tag);
  addToken(tag,lexer);
  if (lexer.getTokenType() != XML_TAG_NAME) {
    return true;
  }
  final String openedName=lexer.getTokenText();
  addToken(tag,lexer);
  parseAttributeList(tag,lexer);
  while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {
    addToken(tag,lexer);
    parseAttributeList(tag,lexer);
  }
  TreeElement tagEnd;
  if (lexer.getTokenType() == XML_TAG_END) {
    tagEnd=addToken(tag,lexer);
    boolean setFlag=false;
    if (!names.contains(openedName)) {
      names.add(openedName);
      setFlag=true;
    }
    CompositeElement text=null;
    while (true) {
      if (parseProcessingInstruction(tag,lexer)) {
      }
 else       if (_parseTag(tag,lexer,names)) {
      }
 else       if (lexer.getTokenType() == XML_DATA_CHARACTERS) {
        if (text == null) {
          text=ASTFactory.composite(XML_TEXT);
          tag.rawAddChildren(text);
        }
        addToken(text,lexer);
      }
 else       if (lexer.getTokenType() == XML_CDATA_START) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_CDATA_END) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {
        tag.rawAddChildren(parseEntityRef(lexer));
      }
 else {
        break;
      }
    }
    if (setFlag) {
      names.remove(openedName);
    }
    final int pos=lexer.getTokenStart();
    if (lexer.getTokenType() != XML_END_TAG_START) {
      tagEnd.rawInsertAfterMe(Factory.createErrorElement(XmlErrorMessages.message("element.is.not.closed")));
      return false;
    }
    TreeElement endTagStart=createTokenElement(lexer,myCharTable);
    lexer.advance();
    if (lexer.getTokenType() != XML_TAG_NAME) {
      tag.rawAddChildren(endTagStart);
      return true;
    }
    final String closingName=lexer.getBufferSequence().subSequence(lexer.getTokenStart(),lexer.getTokenEnd()).toString();
    if (!closingName.equals(openedName) && names.contains(closingName)) {
      lexer.start(lexer.getBufferSequence(),pos,lexer.getBufferEnd());
      if (tagEnd != null) {
        final TreeElement start=tagEnd.getTreeNext();
        if (start != null) {
          start.rawRemoveUpToLast();
          parent.rawAddChildren(start);
        }
      }
      tagEnd.rawInsertAfterMe(Factory.createErrorElement(XmlErrorMessages.message("element.is.not.closed")));
      return true;
    }
    tag.rawAddChildren(endTagStart);
    addToken(tag,lexer);
    if (lexer.getTokenType() != XML_TAG_END) {
      return true;
    }
    addToken(tag,lexer);
  }
 else   if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {
    addToken(tag,lexer);
  }
 else {
    tag.getLastChildNode().rawInsertAfterMe(Factory.createErrorElement(XmlErrorMessages.message("element.is.not.closed")));
  }
  return true;
}
