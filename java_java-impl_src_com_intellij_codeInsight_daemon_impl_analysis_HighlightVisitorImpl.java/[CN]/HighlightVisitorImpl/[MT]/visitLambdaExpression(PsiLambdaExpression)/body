{
  myHolder.add(HighlightUtil.checkLambdaFeature(expression));
  if (!myHolder.hasErrorResults()) {
    if (LambdaUtil.isValidLambdaContext(expression.getParent())) {
      final PsiType functionalInterfaceType=expression.getFunctionalInterfaceType();
      if (functionalInterfaceType != null) {
        final String notFunctionalMessage=LambdaUtil.checkInterfaceFunctional(functionalInterfaceType);
        if (notFunctionalMessage != null) {
          myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,notFunctionalMessage));
        }
 else {
          if (!LambdaUtil.isLambdaFullyInferred(expression,functionalInterfaceType)) {
            myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,"Cyclic inference"));
          }
 else {
            final String incompatibleReturnTypesMessage=LambdaUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
            if (incompatibleReturnTypesMessage != null) {
              myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,incompatibleReturnTypesMessage));
            }
          }
        }
      }
    }
 else {
      myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,"Lambda expression not expected here"));
    }
  }
}
