{
  myHolder.add(HighlightUtil.checkLambdaFeature(expression));
  if (!myHolder.hasErrorResults()) {
    if (LambdaUtil.isValidLambdaContext(expression.getParent())) {
      final PsiType functionalInterfaceType=expression.getFunctionalInterfaceType();
      if (functionalInterfaceType != null) {
        final String notFunctionalMessage=LambdaHighlightingUtil.checkInterfaceFunctional(functionalInterfaceType);
        if (notFunctionalMessage != null) {
          myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,notFunctionalMessage));
        }
 else {
          if (!LambdaUtil.isLambdaFullyInferred(expression,functionalInterfaceType) && !expression.hasFormalParameterTypes()) {
            myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,"Cyclic inference"));
          }
 else {
            final String incompatibleReturnTypesMessage=LambdaHighlightingUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
            if (incompatibleReturnTypesMessage != null) {
              myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,incompatibleReturnTypesMessage));
            }
 else {
              final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);
              if (interfaceMethod != null) {
                final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
                final PsiParameter[] lambdaParameters=expression.getParameterList().getParameters();
                final String incompatibleTypesMessage="Incompatible parameter types in lambda expression";
                if (lambdaParameters.length != parameters.length) {
                  myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,incompatibleTypesMessage));
                }
 else {
                  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
                  for (int i=0; i < lambdaParameters.length; i++) {
                    PsiParameter lambdaParameter=lambdaParameters[i];
                    if (!TypeConversionUtil.isAssignable(lambdaParameter.getType(),GenericsUtil.eliminateWildcards(LambdaUtil.getSubstitutor(interfaceMethod,resolveResult).substitute(parameters[i].getType())))) {
                      myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,lambdaParameter,incompatibleTypesMessage));
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else {
      myHolder.add(HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,expression,"Lambda expression not expected here"));
    }
    if (!myHolder.hasErrorResults()) {
      final PsiElement body=expression.getBody();
      if (body instanceof PsiCodeBlock) {
        myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement((PsiCodeBlock)body));
      }
    }
  }
}
