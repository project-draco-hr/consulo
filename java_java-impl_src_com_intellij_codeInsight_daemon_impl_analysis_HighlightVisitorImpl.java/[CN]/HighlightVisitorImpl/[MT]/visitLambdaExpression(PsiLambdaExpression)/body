{
  myHolder.add(HighlightUtil.checkLambdaFeature(expression));
  if (!myHolder.hasErrorResults()) {
    if (LambdaUtil.isValidLambdaContext(expression.getParent())) {
      final PsiType functionalInterfaceType=expression.getFunctionalInterfaceType();
      if (functionalInterfaceType != null) {
        final String notFunctionalMessage=LambdaHighlightingUtil.checkInterfaceFunctional(functionalInterfaceType);
        if (notFunctionalMessage != null) {
          HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(notFunctionalMessage).create();
          myHolder.add(result);
        }
 else {
          if (!LambdaUtil.isLambdaFullyInferred(expression,functionalInterfaceType) && !expression.hasFormalParameterTypes()) {
            HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Cyclic inference").create();
            myHolder.add(result);
          }
 else {
            final String incompatibleReturnTypesMessage=LambdaHighlightingUtil.checkReturnTypeCompatible(expression,LambdaUtil.getFunctionalInterfaceReturnType(functionalInterfaceType));
            if (incompatibleReturnTypesMessage != null) {
              HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(incompatibleReturnTypesMessage).create();
              myHolder.add(result);
            }
 else {
              final PsiMethod interfaceMethod=LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);
              if (interfaceMethod != null) {
                final PsiParameter[] parameters=interfaceMethod.getParameterList().getParameters();
                final PsiParameter[] lambdaParameters=expression.getParameterList().getParameters();
                final String incompatibleTypesMessage="Incompatible parameter types in lambda expression";
                if (lambdaParameters.length != parameters.length) {
                  HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(incompatibleTypesMessage).create();
                  myHolder.add(result);
                }
 else {
                  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
                  for (int i=0; i < lambdaParameters.length; i++) {
                    PsiParameter lambdaParameter=lambdaParameters[i];
                    if (!TypeConversionUtil.isAssignable(lambdaParameter.getType(),GenericsUtil.eliminateWildcards(LambdaUtil.getSubstitutor(interfaceMethod,resolveResult).substitute(parameters[i].getType())))) {
                      HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(lambdaParameter).descriptionAndTooltip(incompatibleTypesMessage).create();
                      myHolder.add(result);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
 else {
      HighlightInfo result=HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip("Lambda expression not expected here").create();
      myHolder.add(result);
    }
    if (!myHolder.hasErrorResults()) {
      final PsiElement body=expression.getBody();
      if (body instanceof PsiCodeBlock) {
        myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement((PsiCodeBlock)body));
      }
    }
  }
}
