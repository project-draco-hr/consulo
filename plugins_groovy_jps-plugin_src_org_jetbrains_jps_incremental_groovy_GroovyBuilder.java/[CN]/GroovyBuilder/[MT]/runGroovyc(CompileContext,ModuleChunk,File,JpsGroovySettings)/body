{
  ArrayList<String> classpath=new ArrayList<String>(generateClasspath(context,chunk));
  if (LOG.isDebugEnabled()) {
    LOG.debug("Groovyc classpath: " + classpath);
  }
  List<String> programParams=ContainerUtilRt.newArrayList(myForStubs ? "stubs" : "groovyc",tempFile.getPath());
  if (settings.invokeDynamic) {
    programParams.add("--indy");
  }
  List<String> vmParams=ContainerUtilRt.newArrayList();
  vmParams.add("-Xmx" + settings.heapSize + "m");
  vmParams.add("-Dfile.encoding=" + System.getProperty("file.encoding"));
  String grapeRoot=System.getProperty(GroovycOSProcessHandler.GRAPE_ROOT);
  if (grapeRoot != null) {
    vmParams.add("-D" + GroovycOSProcessHandler.GRAPE_ROOT + "="+ grapeRoot);
  }
  final List<String> cmd=ExternalProcessUtil.buildJavaCommandLine(getJavaExecutable(chunk),"org.jetbrains.groovy.compiler.rt.GroovycRunner",Collections.<String>emptyList(),classpath,vmParams,programParams);
  final Process process=Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmd));
  final Consumer<String> updater=new Consumer<String>(){
    public void consume(    String s){
      context.processMessage(new ProgressMessage(s));
    }
  }
;
  final GroovycOSProcessHandler handler=new GroovycOSProcessHandler(process,updater){
    @Override protected Future<?> executeOnPooledThread(    Runnable task){
      return SharedThreadPool.getInstance().executeOnPooledThread(task);
    }
  }
;
  handler.startNotify();
  handler.waitFor();
  return handler;
}
