{
  try {
    final List<File> toCompile=collectChangedFiles(context,chunk);
    if (toCompile.isEmpty()) {
      return ExitCode.NOTHING_DONE;
    }
    Map<JpsModule,String> finalOutputs=getCanonicalModuleOutputs(context,chunk);
    if (finalOutputs == null) {
      return ExitCode.ABORT;
    }
    Map<JpsModule,String> generationOutputs=getGenerationOutputs(chunk,finalOutputs);
    final Set<String> toCompilePaths=new LinkedHashSet<String>();
    for (    File file : toCompile) {
      toCompilePaths.add(FileUtil.toSystemIndependentName(file.getPath()));
    }
    Map<String,String> class2Src=buildClassToSourceMap(chunk,context,toCompilePaths,finalOutputs);
    final String encoding=context.getProjectDescriptor().getEncodingConfiguration().getPreferredModuleChunkEncoding(chunk);
    List<String> patchers=Collections.emptyList();
    String compilerOutput=generationOutputs.get(chunk.representativeModule());
    final File tempFile=GroovycOSProcessHandler.fillFileWithGroovycParameters(compilerOutput,toCompilePaths,FileUtil.toSystemDependentName(finalOutputs.get(chunk.representativeModule())),class2Src,encoding,patchers);
    final List<String> cmd=ExternalProcessUtil.buildJavaCommandLine(getJavaExecutable(chunk),"org.jetbrains.groovy.compiler.rt.GroovycRunner",Collections.<String>emptyList(),new ArrayList<String>(generateClasspath(context,chunk)),Arrays.asList("-Xmx384m","-Dfile.encoding=" + System.getProperty("file.encoding")),Arrays.<String>asList(myForStubs ? "stubs" : "groovyc",tempFile.getPath()));
    final Process process=Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmd));
    final Consumer<String> updater=new Consumer<String>(){
      public void consume(      String s){
        context.processMessage(new ProgressMessage(s));
      }
    }
;
    final GroovycOSProcessHandler handler=new GroovycOSProcessHandler(process,updater){
      @Override protected Future<?> executeOnPooledThread(      Runnable task){
        return SharedThreadPool.getInstance().executeOnPooledThread(task);
      }
    }
;
    handler.startNotify();
    handler.waitFor();
    if (!context.isProjectRebuild() && handler.shouldRetry()) {
      if (CHUNK_REBUILD_ORDERED.get(context) != null) {
        CHUNK_REBUILD_ORDERED.set(context,null);
      }
 else {
        CHUNK_REBUILD_ORDERED.set(context,Boolean.TRUE);
        LOG.info("Order chunk rebuild");
        return ExitCode.CHUNK_REBUILD_REQUIRED;
      }
    }
    if (myForStubs) {
      final ModuleRootsIndex rootsIndex=context.getProjectDescriptor().rootsIndex;
      for (      JpsModule module : generationOutputs.keySet()) {
        File root=new File(generationOutputs.get(module));
        rootsIndex.associateRoot(context,root,module,chunk.isTests());
      }
    }
    for (    CompilerMessage message : handler.getCompilerMessages()) {
      context.processMessage(message);
    }
    List<GroovycOSProcessHandler.OutputItem> compiled=new ArrayList<GroovycOSProcessHandler.OutputItem>();
    for (    GroovycOSProcessHandler.OutputItem item : handler.getSuccessfullyCompiled()) {
      compiled.add(ensureCorrectOutput(context,chunk,item,generationOutputs,compilerOutput));
    }
    if (myForStubs) {
      Map<String,String> stubToSrc=STUB_TO_SRC.get(context);
      if (stubToSrc == null) {
        STUB_TO_SRC.set(context,stubToSrc=new ConcurrentHashMap<String,String>());
      }
      for (      GroovycOSProcessHandler.OutputItem item : handler.getSuccessfullyCompiled()) {
        stubToSrc.put(FileUtil.toSystemIndependentName(item.outputPath),item.sourcePath);
      }
    }
    if (!myForStubs && updateDependencies(context,chunk,toCompile,generationOutputs,compiled)) {
      return ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
    return ExitCode.OK;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
