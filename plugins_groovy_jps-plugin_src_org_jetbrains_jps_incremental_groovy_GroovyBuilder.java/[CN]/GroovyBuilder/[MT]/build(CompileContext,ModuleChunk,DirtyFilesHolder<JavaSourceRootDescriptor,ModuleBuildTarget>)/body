{
  try {
    final List<File> toCompile=collectChangedFiles(context,dirtyFilesHolder);
    if (toCompile.isEmpty()) {
      return ExitCode.NOTHING_DONE;
    }
    if (Utils.IS_TEST_MODE || LOG.isDebugEnabled()) {
      LOG.info("forStubs=" + myForStubs);
    }
    Map<ModuleBuildTarget,String> finalOutputs=getCanonicalModuleOutputs(context,chunk);
    if (finalOutputs == null) {
      return ExitCode.ABORT;
    }
    final Set<String> toCompilePaths=getPathsToCompile(toCompile);
    Map<String,String> class2Src=buildClassToSourceMap(chunk,context,toCompilePaths,finalOutputs);
    final String encoding=context.getProjectDescriptor().getEncodingConfiguration().getPreferredModuleChunkEncoding(chunk);
    List<String> patchers=Collections.emptyList();
    Map<ModuleBuildTarget,String> generationOutputs=myForStubs ? getStubGenerationOutputs(chunk,context) : finalOutputs;
    String compilerOutput=generationOutputs.get(chunk.representativeTarget());
    String finalOutput=FileUtil.toSystemDependentName(finalOutputs.get(chunk.representativeTarget()));
    final File tempFile=GroovycOSProcessHandler.fillFileWithGroovycParameters(compilerOutput,toCompilePaths,finalOutput,class2Src,encoding,patchers);
    final GroovycOSProcessHandler handler=runGroovyc(context,chunk,tempFile);
    List<GroovycOSProcessHandler.OutputItem> compiled=processCompiledFiles(context,chunk,generationOutputs,compilerOutput,handler);
    if (checkChunkRebuildNeeded(context,handler)) {
      return ExitCode.CHUNK_REBUILD_REQUIRED;
    }
    if (myForStubs) {
      addStubRootsToJavacSourcePath(context,generationOutputs);
      rememberStubSources(context,compiled);
    }
    for (    CompilerMessage message : handler.getCompilerMessages()) {
      context.processMessage(message);
    }
    if (!myForStubs && updateDependencies(context,chunk,toCompile,generationOutputs,compiled)) {
      return ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
    return ExitCode.OK;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
