{
  if (!CodeInsightUtil.prepareFileForWrite(file))   return;
  PsiDocumentManager.getInstance(project).commitAllDocuments();
  final PsiMethod targetMethod=PsiTreeUtil.getParentOfType(myWrongElement,PsiMethod.class);
  PsiElement element=findElement(myWrongElement,targetMethod);
  LOG.assertTrue(element != null);
  final PsiClassType[] unhandledExceptions=filterInProjectExceptions(ExceptionUtil.getUnhandledExceptions(element),targetMethod);
  boolean processSuperMethods=false;
  final PsiMethod[] superMethods=getSuperMethods(targetMethod);
  boolean hasSuperMethodsWithoutExceptions=hasSuperMethodsWithoutExceptions(superMethods,unhandledExceptions);
  if (hasSuperMethodsWithoutExceptions && superMethods.length > 0) {
    int result=Messages.showYesNoCancelDialog("Method '" + targetMethod.getName() + "' is inherited.\n"+ "Do you want to add exceptions to method signatures in the whole method hierarchy?","Method Is Inherited",Messages.getQuestionIcon());
    if (result == 0)     processSuperMethods=true;
 else     if (result == 1)     processSuperMethods=false;
 else     return;
  }
  final boolean processSuperMethods1=processSuperMethods;
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    public void run(){
      if (!CodeInsightUtil.prepareFileForWrite(targetMethod.getContainingFile()))       return;
      if (processSuperMethods1) {
        for (int i=0; i < superMethods.length; i++) {
          PsiMethod superMethod=superMethods[i];
          if (!CodeInsightUtil.prepareFileForWrite(superMethod.getContainingFile()))           return;
        }
      }
      try {
        processMethod(targetMethod,unhandledExceptions,project);
        if (processSuperMethods1) {
          for (int i=0; i < superMethods.length; i++) {
            PsiMethod superMethod=superMethods[i];
            processMethod(superMethod,unhandledExceptions,project);
          }
        }
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
  }
);
}
