{
  if (!(node.getUserObject() instanceof NodeDescriptor))   return;
  NodeDescriptor descriptor=(NodeDescriptor)node.getUserObject();
  if (getElementFromDescriptor(descriptor) == null)   return;
  DefaultMutableTreeNode parentNode=(DefaultMutableTreeNode)node.getParent();
  if (parentNode != null) {
    int oldIndex=parentNode.getIndex(node);
    int newIndex=oldIndex;
    if (isLoadingChildrenFor(node.getParent()) || getBuilder().isChildrenResortingNeeded(descriptor)) {
      final ArrayList<TreeNode> children=new ArrayList<TreeNode>(parentNode.getChildCount());
      for (int i=0; i < parentNode.getChildCount(); i++) {
        children.add(parentNode.getChildAt(i));
      }
      Collections.sort(children,myNodeComparator);
      newIndex=children.indexOf(node);
    }
    if (oldIndex != newIndex) {
      List<Object> pathsToExpand=new ArrayList<Object>();
      List<Object> selectionPaths=new ArrayList<Object>();
      TreeBuilderUtil.storePaths(getBuilder(),node,pathsToExpand,selectionPaths,false);
      removeNodeFromParent(node,false);
      myTreeModel.insertNodeInto(node,parentNode,newIndex);
      TreeBuilderUtil.restorePaths(getBuilder(),pathsToExpand,selectionPaths,false);
    }
 else {
      myTreeModel.nodeChanged(node);
    }
  }
 else {
    myTreeModel.nodeChanged(node);
  }
}
