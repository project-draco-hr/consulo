{
  removeFromCancelled(node);
  execute(new Runnable(){
    public void run(){
      try {
        AbstractTreeStructure treeStructure=getTreeStructure();
        if (treeStructure.hasSomethingToCommit())         treeStructure.commit();
        final NodeDescriptor descriptor=getDescriptorFrom(node);
        if (descriptor == null) {
          removeFromUnbuilt(node);
          removeLoading(node,true);
          return;
        }
        boolean descriptorIsReady=descriptorIsUpToDate || pass.isUpdated(descriptor);
        final boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath())) || isAutoExpand(node);
        final boolean wasLeaf=node.getChildCount() == 0;
        boolean bgBuild=isToBuildInBackground(descriptor);
        boolean notRequiredToUpdateChildren=!forcedNow && !wasExpanded;
        if (notRequiredToUpdateChildren && forceUpdate && !wasExpanded) {
          boolean alwaysPlus=getBuilder().isAlwaysShowPlus(descriptor);
          if (alwaysPlus && wasLeaf) {
            notRequiredToUpdateChildren=false;
          }
 else {
            notRequiredToUpdateChildren=alwaysPlus;
            if (notRequiredToUpdateChildren && !wasExpanded && !myUnbuiltNodes.contains(node)) {
              removeChildren(node);
            }
          }
        }
        final Ref<LoadedChildren> preloaded=new Ref<LoadedChildren>(loadedChildren);
        if (notRequiredToUpdateChildren) {
          if (myUnbuiltNodes.contains(node) && node.getChildCount() == 0) {
            insertLoadingNode(node,true);
          }
          if (!descriptorIsReady) {
            update(descriptor,false);
          }
          return;
        }
        if (!forcedNow) {
          if (!bgBuild) {
            if (myUnbuiltNodes.contains(node)) {
              if (!descriptorIsReady) {
                update(descriptor,true);
                descriptorIsReady=true;
              }
              if (processAlwaysLeaf(node) || !updateChildren)               return;
              Pair<Boolean,LoadedChildren> unbuilt=processUnbuilt(node,descriptor,pass,wasExpanded,null);
              if (unbuilt.getFirst())               return;
              preloaded.set(unbuilt.getSecond());
            }
          }
        }
        final boolean childForceUpdate=isChildNodeForceUpdate(node,forceUpdate,wasExpanded);
        if (!forcedNow && isToBuildInBackground(descriptor)) {
          boolean alwaysLeaf=processAlwaysLeaf(node);
          queueBackgroundUpdate(new UpdateInfo(descriptor,pass,canSmartExpand(node,toSmartExpand),wasExpanded,childForceUpdate,descriptorIsReady,!alwaysLeaf && updateChildren),node);
          return;
        }
 else {
          if (!descriptorIsReady) {
            update(descriptor,false).doWhenDone(new Runnable(){
              public void run(){
                if (processAlwaysLeaf(node) || !updateChildren)                 return;
                updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
              }
            }
);
          }
 else {
            if (processAlwaysLeaf(node) || !updateChildren)             return;
            updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
          }
        }
      }
  finally {
        if (!isReleased()) {
          processNodeActionsIfReady(node);
        }
      }
    }
  }
,node);
}
