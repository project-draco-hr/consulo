{
  final ActionCallback result=new ActionCallback();
  if (pass.isExpired()) {
    return new ActionCallback.Rejected();
  }
  final Ref<NodeDescriptor> childDesc=new Ref<NodeDescriptor>(childDescriptor);
  if (childDesc.get() == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  final Object oldElement=getElementFromDescriptor(childDesc.get());
  if (oldElement == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  AsyncResult<Boolean> update=new AsyncResult<Boolean>();
  if (parentPreloadedChildren != null && parentPreloadedChildren.getDescriptor(oldElement) != null) {
    update.setDone(parentPreloadedChildren.isUpdated(oldElement));
  }
 else {
    update=update(childDesc.get());
  }
  update.doWhenDone(new AsyncResult.Handler<Boolean>(){
    public void run(    Boolean isChanged){
      boolean changes=isChanged;
      boolean forceRemapping=false;
      Object newElement=getElementFromDescriptor(childDesc.get());
      Integer index=newElement != null ? elementToIndexMap.getValue(getBuilder().getTreeStructureElement(childDesc.get())) : null;
      if (index != null) {
        final Object elementFromMap=elementToIndexMap.getKey(index);
        if (elementFromMap != newElement && elementFromMap.equals(newElement)) {
          if (isInStructure(elementFromMap) && isInStructure(newElement)) {
            if (parentNode.getUserObject() instanceof NodeDescriptor) {
              final NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
              childDesc.set(getTreeStructure().createDescriptor(elementFromMap,parentDescriptor));
              childNode.setUserObject(childDesc.get());
              newElement=elementFromMap;
              forceRemapping=true;
              update(childDesc.get());
              changes=true;
            }
          }
        }
        if (childDesc.get().getIndex() != index.intValue()) {
          changes=true;
        }
        childDesc.get().setIndex(index.intValue());
      }
      if (index != null && changes) {
        updateNodeImageAndPosition(childNode,false);
      }
      if (!oldElement.equals(newElement) | forceRemapping) {
        removeMapping(oldElement,childNode,newElement);
        if (newElement != null) {
          createMapping(newElement,childNode);
        }
      }
      if (index == null) {
        int selectedIndex=-1;
        if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
          selectedIndex=parentNode.getIndex(childNode);
        }
        if (childNode.getParent() instanceof DefaultMutableTreeNode) {
          final DefaultMutableTreeNode parent=(DefaultMutableTreeNode)childNode.getParent();
          if (myTree.isExpanded(new TreePath(parent.getPath()))) {
            if (parent.getChildCount() == 1 && parent.getChildAt(0) == childNode) {
              insertLoadingNode(parent,false);
            }
          }
        }
        Object disposedElement=getElementFor(childNode);
        removeNodeFromParent(childNode,selectedIndex >= 0);
        disposeNode(childNode);
        adjustSelectionOnChildRemove(parentNode,selectedIndex,disposedElement);
      }
 else {
        elementToIndexMap.remove(getBuilder().getTreeStructureElement(childDesc.get()));
        updateNodeChildren(childNode,pass,null,false,canSmartExpand,forceUpdate,true);
      }
      if (parentNode.equals(getRootNode())) {
        myTreeModel.nodeChanged(getRootNode());
      }
      result.setDone();
    }
  }
);
  return result;
}
