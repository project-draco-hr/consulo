{
  final ActionCallback result=new ActionCallback();
  if (pass.isExpired()) {
    return new ActionCallback.Rejected();
  }
  final Ref<NodeDescriptor> childDesc=new Ref<NodeDescriptor>(childDescriptor);
  if (childDesc.get() == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  final Object oldElement=getElementFromDescriptor(childDesc.get());
  if (oldElement == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  AsyncResult<Boolean> update=new AsyncResult<Boolean>();
  if (parentPreloadedChildren != null && parentPreloadedChildren.getDescriptor(oldElement) != null) {
    update.setDone(parentPreloadedChildren.isUpdated(oldElement));
  }
 else {
    update=update(childDesc.get(),false);
  }
  update.doWhenDone(new AsyncResult.Handler<Boolean>(){
    public void run(    Boolean isChanged){
      final Ref<Boolean> changes=new Ref<Boolean>(isChanged);
      final Ref<Boolean> forceRemapping=new Ref<Boolean>(false);
      final Ref<Object> newElement=new Ref<Object>(getElementFromDescriptor(childDesc.get()));
      final Integer index=newElement.get() != null ? elementToIndexMap.getValue(getBuilder().getTreeStructureElement(childDesc.get())) : null;
      final AsyncResult<Boolean> updateIndexDone=new AsyncResult<Boolean>();
      final ActionCallback indexReady=new ActionCallback();
      if (index != null) {
        final Object elementFromMap=elementToIndexMap.getKey(index);
        if (elementFromMap != newElement.get() && elementFromMap.equals(newElement.get())) {
          if (isInStructure(elementFromMap) && isInStructure(newElement.get())) {
            if (parentNode.getUserObject() instanceof NodeDescriptor) {
              final NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
              childDesc.set(getTreeStructure().createDescriptor(elementFromMap,parentDescriptor));
              childNode.setUserObject(childDesc.get());
              newElement.set(elementFromMap);
              forceRemapping.set(true);
              update(childDesc.get(),false).doWhenDone(new AsyncResult.Handler<Boolean>(){
                public void run(                Boolean isChanged){
                  changes.set(isChanged);
                  updateIndexDone.setDone(isChanged);
                }
              }
);
            }
          }
 else {
            updateIndexDone.setDone(changes.get());
          }
        }
 else {
          updateIndexDone.setDone(changes.get());
        }
        updateIndexDone.doWhenDone(new Runnable(){
          public void run(){
            if (childDesc.get().getIndex() != index.intValue()) {
              changes.set(true);
            }
            childDesc.get().setIndex(index.intValue());
            indexReady.setDone();
          }
        }
);
      }
 else {
        updateIndexDone.setDone();
      }
      updateIndexDone.doWhenDone(new Runnable(){
        public void run(){
          if (index != null && changes.get()) {
            updateNodeImageAndPosition(childNode,false);
          }
          if (!oldElement.equals(newElement.get()) | forceRemapping.get()) {
            removeMapping(oldElement,childNode,newElement.get());
            if (newElement.get() != null) {
              createMapping(newElement.get(),childNode);
            }
            NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
            if (parentDescriptor != null) {
              parentDescriptor.setChildrenSortingStamp(-1);
            }
          }
          if (index == null) {
            int selectedIndex=-1;
            if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
              selectedIndex=parentNode.getIndex(childNode);
            }
            if (childNode.getParent() instanceof DefaultMutableTreeNode) {
              final DefaultMutableTreeNode parent=(DefaultMutableTreeNode)childNode.getParent();
              if (myTree.isExpanded(new TreePath(parent.getPath()))) {
                if (parent.getChildCount() == 1 && parent.getChildAt(0) == childNode) {
                  insertLoadingNode(parent,false);
                }
              }
            }
            Object disposedElement=getElementFor(childNode);
            removeNodeFromParent(childNode,selectedIndex >= 0);
            disposeNode(childNode);
            adjustSelectionOnChildRemove(parentNode,selectedIndex,disposedElement);
          }
 else {
            elementToIndexMap.remove(getBuilder().getTreeStructureElement(childDesc.get()));
            updateNodeChildren(childNode,pass,null,false,canSmartExpand,forceUpdate,true);
          }
          if (parentNode.equals(getRootNode())) {
            myTreeModel.nodeChanged(getRootNode());
          }
          result.setDone();
        }
      }
);
    }
  }
);
  return result;
}
