{
  if (pass.isExpired()) {
    return new ActionCallback.Rejected();
  }
  if (childDescriptor == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  final Object oldElement=getElementFromDescriptor(childDescriptor);
  if (oldElement == null) {
    pass.expire();
    return new ActionCallback.Rejected();
  }
  AsyncResult<Boolean> update=new AsyncResult<Boolean>();
  if (parentPreloadedChildren != null && parentPreloadedChildren.getDescriptor(oldElement) != null) {
    update.setDone(parentPreloadedChildren.isUpdated(oldElement));
  }
 else {
    update=update(childDescriptor,false);
  }
  final ActionCallback result=new ActionCallback();
  final Ref<NodeDescriptor> childDesc=new Ref<NodeDescriptor>(childDescriptor);
  update.doWhenDone(new AsyncResult.Handler<Boolean>(){
    @Override public void run(    Boolean isChanged){
      final AtomicBoolean changes=new AtomicBoolean(isChanged);
      final AtomicBoolean forceRemapping=new AtomicBoolean();
      final Ref<Object> newElement=new Ref<Object>(getElementFromDescriptor(childDesc.get()));
      final Integer index=newElement.get() == null ? null : elementToIndexMap.getValue(getBuilder().getTreeStructureElement(childDesc.get()));
      final AsyncResult<Boolean> updateIndexDone=new AsyncResult<Boolean>();
      if (index == null) {
        updateIndexDone.setDone();
      }
 else {
        final Object elementFromMap=elementToIndexMap.getKey(index);
        if (elementFromMap != newElement.get() && elementFromMap.equals(newElement.get())) {
          if (isInStructure(elementFromMap) && isInStructure(newElement.get())) {
            if (parentNode.getUserObject() instanceof NodeDescriptor) {
              final NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
              childDesc.set(getTreeStructure().createDescriptor(elementFromMap,parentDescriptor));
              NodeDescriptor oldDesc=getDescriptorFrom(childNode);
              if (oldDesc != null) {
                childDesc.get().applyFrom(oldDesc);
              }
              childNode.setUserObject(childDesc.get());
              newElement.set(elementFromMap);
              forceRemapping.set(true);
              update(childDesc.get(),false).doWhenDone(new AsyncResult.Handler<Boolean>(){
                @Override public void run(                Boolean isChanged){
                  changes.set(isChanged);
                  updateIndexDone.setDone(isChanged);
                }
              }
);
            }
          }
 else {
            updateIndexDone.setDone(changes.get());
          }
        }
 else {
          updateIndexDone.setDone(changes.get());
        }
        updateIndexDone.doWhenDone(new Runnable(){
          @Override public void run(){
            if (childDesc.get().getIndex() != index.intValue()) {
              changes.set(true);
            }
            childDesc.get().setIndex(index.intValue());
          }
        }
);
      }
      updateIndexDone.doWhenDone(new Runnable(){
        @Override public void run(){
          if (!oldElement.equals(newElement.get()) || forceRemapping.get()) {
            removeMapping(oldElement,childNode,newElement.get());
            if (newElement.get() != null) {
              createMapping(newElement.get(),childNode);
            }
            NodeDescriptor parentDescriptor=getDescriptorFrom(parentNode);
            if (parentDescriptor != null) {
              parentDescriptor.setChildrenSortingStamp(-1);
            }
          }
          if (index == null) {
            int selectedIndex=-1;
            if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
              selectedIndex=parentNode.getIndex(childNode);
            }
            if (childNode.getParent() instanceof DefaultMutableTreeNode) {
              final DefaultMutableTreeNode parent=(DefaultMutableTreeNode)childNode.getParent();
              if (myTree.isExpanded(new TreePath(parent.getPath()))) {
                if (parent.getChildCount() == 1 && parent.getChildAt(0) == childNode) {
                  insertLoadingNode(parent,false);
                }
              }
            }
            Object disposedElement=getElementFor(childNode);
            removeNodeFromParent(childNode,selectedIndex >= 0);
            disposeNode(childNode);
            adjustSelectionOnChildRemove(parentNode,selectedIndex,disposedElement);
            result.setDone();
          }
 else {
            elementToIndexMap.remove(getBuilder().getTreeStructureElement(childDesc.get()));
            ActionCallback callback=updateNodeChildren(childNode,pass,null,false,canSmartExpand,forceUpdate,true,true);
            callback.doWhenDone(result.createSetDoneRunnable());
          }
        }
      }
);
    }
  }
);
  return result;
}
