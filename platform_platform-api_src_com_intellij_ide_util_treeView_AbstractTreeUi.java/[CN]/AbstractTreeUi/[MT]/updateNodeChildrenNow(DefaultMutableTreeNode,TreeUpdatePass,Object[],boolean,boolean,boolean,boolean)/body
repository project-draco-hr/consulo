{
  final NodeDescriptor descriptor=getDescriptorFrom(node);
  final MutualMap<Object,Integer> elementToIndexMap=loadElementsFromStructure(descriptor,preloadedChildren);
  myUpdatingChildren.add(node);
  pass.setCurrentNode(node);
  final boolean canSmartExpand=canSmartExpand(node,toSmartExpand);
  processExistingNodes(node,elementToIndexMap,pass,canSmartExpand(node,toSmartExpand),forceUpdate,wasExpanded).doWhenDone(new Runnable(){
    public void run(){
      if (isDisposed(node)) {
        return;
      }
      removeLoading(node,false);
      final boolean expanded=isExpanded(node,wasExpanded);
      ArrayList<TreeNode> nodesToInsert=collectNodesToInsert(descriptor,elementToIndexMap,node,expanded);
      insertNodesInto(nodesToInsert,node);
      updateNodesToInsert(nodesToInsert,pass,canSmartExpand,isChildNodeForceUpdate(node,forceUpdate,expanded));
      removeLoading(node,true);
      if (node.getChildCount() > 0) {
        if (expanded) {
          expand(node,canSmartExpand);
        }
        if (expanded || wasLeaf) {
          expand(node,descriptor,wasLeaf,canSmartExpand);
        }
      }
      myUpdatingChildren.remove(node);
      final Object element=getElementFor(node);
      addNodeAction(element,new NodeAction(){
        public void onReady(        final DefaultMutableTreeNode node){
          removeLoading(node,false);
        }
      }
,false);
      processNodeActionsIfReady(node);
    }
  }
);
}
