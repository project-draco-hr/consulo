{
  AbstractTreeUpdater updater=getUpdater();
  if (mayQueue && updater != null) {
    updater.queueSelection(new SelectionRequest(elements,onDone,addToSelection,checkCurrentSelection,checkIfInStructure,scrollToVisible,deferred,canSmartExpand));
    return;
  }
  boolean willAffectSelection=elements.length > 0 || (elements.length == 0 && addToSelection);
  if (!willAffectSelection) {
    runDone(onDone);
    return;
  }
  final boolean oldCanProcessDeferredSelection=myCanProcessDeferredSelections;
  if (!deferred && wasRootNodeInitialized() && willAffectSelection) {
    myCanProcessDeferredSelections=false;
  }
  if (!checkDeferred(deferred,onDone))   return;
  if (!deferred && oldCanProcessDeferredSelection && !myCanProcessDeferredSelections) {
    getTree().clearSelection();
  }
  runDone(new Runnable(){
    public void run(){
      if (!checkDeferred(deferred,onDone))       return;
      final Set<Object> currentElements=getSelectedElements();
      if (checkCurrentSelection && currentElements.size() > 0 && elements.length == currentElements.size()) {
        boolean runSelection=false;
        for (        Object eachToSelect : elements) {
          if (!currentElements.contains(eachToSelect)) {
            runSelection=true;
            break;
          }
        }
        if (!runSelection) {
          if (elements.length > 0) {
            selectVisible(elements[0],onDone,true,true,scrollToVisible);
          }
          return;
        }
      }
      Set<Object> toSelect=new HashSet<Object>();
      myTree.clearSelection();
      toSelect.addAll(Arrays.asList(elements));
      if (addToSelection) {
        toSelect.addAll(currentElements);
      }
      if (checkIfInStructure) {
        final Iterator<Object> allToSelect=toSelect.iterator();
        while (allToSelect.hasNext()) {
          Object each=allToSelect.next();
          if (!isInStructure(each)) {
            allToSelect.remove();
          }
        }
      }
      final Object[] elementsToSelect=ArrayUtil.toObjectArray(toSelect);
      if (wasRootNodeInitialized()) {
        final int[] originalRows=myTree.getSelectionRows();
        if (!addToSelection) {
          myTree.clearSelection();
        }
        addNext(elementsToSelect,0,new Runnable(){
          public void run(){
            if (getTree().isSelectionEmpty()) {
              processInnerChange(new Runnable(){
                public void run(){
                  restoreSelection(currentElements);
                }
              }
);
            }
            runDone(onDone);
          }
        }
,originalRows,deferred,scrollToVisible,canSmartExpand);
      }
 else {
        addToDeferred(elementsToSelect,onDone);
      }
    }
  }
);
}
