{
  assertIsDispatchThread();
  AbstractTreeUpdater updater=getUpdater();
  if (mayQueue && updater != null) {
    updater.queueSelection(new SelectionRequest(elements,onDone,addToSelection,checkCurrentSelection,checkIfInStructure,scrollToVisible,deferred,canSmartExpand));
    return;
  }
  boolean willAffectSelection=elements.length > 0 || elements.length == 0 && addToSelection;
  if (!willAffectSelection) {
    runDone(onDone);
    maybeReady();
    return;
  }
  final boolean oldCanProcessDeferredSelection=myCanProcessDeferredSelections;
  if (!deferred && wasRootNodeInitialized() && willAffectSelection) {
    _getReady().doWhenDone(new Runnable(){
      @Override public void run(){
        myCanProcessDeferredSelections=false;
      }
    }
);
  }
  if (!checkDeferred(deferred,onDone))   return;
  if (!deferred && oldCanProcessDeferredSelection && !myCanProcessDeferredSelections) {
    if (!addToSelection) {
      getTree().clearSelection();
    }
  }
  runDone(new Runnable(){
    public void run(){
      try {
        if (!checkDeferred(deferred,onDone))         return;
        final Set<Object> currentElements=getSelectedElements();
        if (checkCurrentSelection && !currentElements.isEmpty() && elements.length == currentElements.size()) {
          boolean runSelection=false;
          for (          Object eachToSelect : elements) {
            if (!currentElements.contains(eachToSelect)) {
              runSelection=true;
              break;
            }
          }
          if (!runSelection) {
            if (elements.length > 0) {
              selectVisible(elements[0],onDone,true,true,scrollToVisible);
            }
            return;
          }
        }
        Set<Object> toSelect=new HashSet<Object>();
        clearSelection();
        ContainerUtil.addAll(toSelect,elements);
        if (addToSelection) {
          toSelect.addAll(currentElements);
        }
        if (checkIfInStructure) {
          final Iterator<Object> allToSelect=toSelect.iterator();
          while (allToSelect.hasNext()) {
            Object each=allToSelect.next();
            if (!isInStructure(each)) {
              allToSelect.remove();
            }
          }
        }
        final Object[] elementsToSelect=ArrayUtil.toObjectArray(toSelect);
        if (wasRootNodeInitialized()) {
          final int[] originalRows=myTree.getSelectionRows();
          if (!addToSelection) {
            clearSelection();
          }
          addNext(elementsToSelect,0,new Runnable(){
            public void run(){
              if (getTree().isSelectionEmpty()) {
                processInnerChange(new Runnable(){
                  public void run(){
                    restoreSelection(currentElements);
                  }
                }
);
              }
              runDone(onDone);
            }
          }
,originalRows,deferred,scrollToVisible,canSmartExpand);
        }
 else {
          addToDeferred(elementsToSelect,onDone,addToSelection);
        }
      }
  finally {
        maybeReady();
      }
    }
  }
);
}
