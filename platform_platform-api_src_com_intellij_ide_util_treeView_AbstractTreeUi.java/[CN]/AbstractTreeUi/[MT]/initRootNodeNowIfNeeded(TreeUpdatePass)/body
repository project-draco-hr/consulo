{
  boolean wasCleanedUp=false;
  if (myRootNodeWasInitialized) {
    Object root=getTreeStructure().getRootElement();
    Object currentRoot=getElementFor(myRootNode);
    if (Comparing.equal(root,currentRoot))     return false;
    cleanUpNow();
    wasCleanedUp=true;
  }
  myRootNodeWasInitialized=true;
  final Object rootElement=getTreeStructure().getRootElement();
  addNodeAction(rootElement,new NodeAction(){
    public void onReady(    final DefaultMutableTreeNode node){
      processDeferredActions();
    }
  }
,false);
  final Ref<NodeDescriptor> rootDescriptor=new Ref<NodeDescriptor>(null);
  final boolean bgLoading=getTreeStructure().isToBuildChildrenInBackground(rootElement);
  Runnable build=new Runnable(){
    public void run(){
      rootDescriptor.set(getTreeStructure().createDescriptor(rootElement,null));
      getRootNode().setUserObject(rootDescriptor.get());
      update(rootDescriptor.get(),true);
    }
  }
;
  Runnable update=new Runnable(){
    public void run(){
      if (getElementFromDescriptor(rootDescriptor.get()) != null) {
        createMapping(getElementFromDescriptor(rootDescriptor.get()),getRootNode());
      }
      insertLoadingNode(getRootNode(),true);
      boolean willUpdate=false;
      if (isAutoExpand(rootDescriptor.get())) {
        willUpdate=myUnbuiltNodes.contains(getRootNode());
        expand(getRootNode(),true);
      }
      if (!willUpdate) {
        updateNodeChildren(getRootNode(),pass,null,false,false,false,true);
      }
      if (getRootNode().getChildCount() == 0) {
        myTreeModel.nodeChanged(getRootNode());
      }
    }
  }
;
  if (bgLoading) {
    queueToBackground(build,update,null);
  }
 else {
    build.run();
    update.run();
  }
  return wasCleanedUp;
}
