{
  maybeSetBusyAndScheduleWaiterForReady(true,getElementFor(pass.getNode()));
  setHoldSize(true);
  boolean consumed=initRootNodeNowIfNeeded(pass);
  if (consumed)   return;
  final DefaultMutableTreeNode node=pass.getNode();
  if (!(node.getUserObject() instanceof NodeDescriptor))   return;
  if (pass.isUpdateStructure()) {
    setUpdaterState(new UpdaterTreeState(this)).beforeSubtreeUpdate();
    boolean forceUpdate=true;
    TreePath path=getPathFor(node);
    boolean invisible=!myTree.isExpanded(path) && (path.getParentPath() == null || !myTree.isExpanded(path.getParentPath()));
    if (invisible && myUnbuiltNodes.contains(node)) {
      forceUpdate=false;
    }
    updateNodeChildren(node,pass,null,false,canSmartExpand,forceUpdate,false,pass.isUpdateChildren());
  }
 else {
    updateRow(0,pass);
  }
}
