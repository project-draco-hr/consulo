{
  final NodeDescriptor descriptor=getDescriptorFrom(node);
  final MutualMap<Object,Integer> elementToIndexMap=loadElementsFromStructure(descriptor,preloadedChildren);
  final LoadedChildren loadedChildren=preloadedChildren != null ? preloadedChildren : new LoadedChildren(elementToIndexMap.getKeys().toArray());
  addToUpdating(node);
  pass.setCurrentNode(node);
  final boolean canSmartExpand=canSmartExpand(node,toSmartExpand);
  processExistingNodes(node,elementToIndexMap,pass,canSmartExpand(node,toSmartExpand),forceUpdate,wasExpanded,preloadedChildren).doWhenDone(new Runnable(){
    public void run(){
      if (isDisposed(node)) {
        return;
      }
      removeLoading(node,false);
      final boolean expanded=isExpanded(node,wasExpanded);
      if (expanded) {
        myWillBeExpaned.add(node);
      }
 else {
        myWillBeExpaned.remove(node);
      }
      collectNodesToInsert(descriptor,elementToIndexMap,node,expanded,loadedChildren).doWhenDone(new AsyncResult.Handler<ArrayList<TreeNode>>(){
        public void run(        ArrayList<TreeNode> nodesToInsert){
          insertNodesInto(nodesToInsert,node);
          updateNodesToInsert(nodesToInsert,pass,canSmartExpand,isChildNodeForceUpdate(node,forceUpdate,expanded));
          removeLoading(node,true);
          removeFromUpdating(node);
          if (node.getChildCount() > 0) {
            if (expanded) {
              expand(node,canSmartExpand);
            }
          }
          final Object element=getElementFor(node);
          addNodeAction(element,new NodeAction(){
            public void onReady(            final DefaultMutableTreeNode node){
              removeLoading(node,false);
            }
          }
,false);
          processNodeActionsIfReady(node);
        }
      }
).doWhenProcessed(new Runnable(){
        public void run(){
          myWillBeExpaned.remove(node);
        }
      }
);
    }
  }
);
}
