{
  ApplicationManager.getApplication().assertIsDispatchThread();
  if (!(node.getUserObject() instanceof NodeDescriptor))   return;
  NodeDescriptor descriptor=getDescriptorFrom(node);
  if (getElementFromDescriptor(descriptor) == null)   return;
  if (updatePosition) {
    DefaultMutableTreeNode parentNode=(DefaultMutableTreeNode)node.getParent();
    if (parentNode != null) {
      int oldIndex=parentNode.getIndex(node);
      int newIndex=oldIndex;
      if (isLoadingChildrenFor(node.getParent()) || getBuilder().isChildrenResortingNeeded(descriptor)) {
        final List<TreeNode> children=new ArrayList<TreeNode>(parentNode.getChildCount());
        for (int i=0; i < parentNode.getChildCount(); i++) {
          TreeNode child=parentNode.getChildAt(i);
          LOG.assertTrue(child != null);
          children.add(child);
        }
        sortChildren(node,children,true,false);
        newIndex=children.indexOf(node);
      }
      if (oldIndex != newIndex) {
        List<Object> pathsToExpand=new ArrayList<Object>();
        List<Object> selectionPaths=new ArrayList<Object>();
        TreeBuilderUtil.storePaths(getBuilder(),node,pathsToExpand,selectionPaths,false);
        removeNodeFromParent(node,false);
        myTreeModel.insertNodeInto(node,parentNode,newIndex);
        TreeBuilderUtil.restorePaths(getBuilder(),pathsToExpand,selectionPaths,false);
      }
 else {
        nodeChanged(node);
      }
    }
 else {
      nodeChanged(node);
    }
  }
 else   if (nodeChanged) {
    nodeChanged(node);
  }
}
