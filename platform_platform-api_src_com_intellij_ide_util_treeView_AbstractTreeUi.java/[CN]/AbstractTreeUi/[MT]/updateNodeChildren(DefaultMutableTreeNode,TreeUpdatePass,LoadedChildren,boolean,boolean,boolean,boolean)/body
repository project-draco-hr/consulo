{
  removeFromCancelled(node);
  execute(new Runnable(){
    public void run(){
      try {
        getTreeStructure().commit();
        final NodeDescriptor descriptor=getDescriptorFrom(node);
        if (descriptor == null) {
          removeFromUnbuilt(node);
          removeLoading(node,true);
          return;
        }
        final boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath())) || isAutoExpand(node);
        final boolean wasLeaf=node.getChildCount() == 0;
        boolean bgBuild=isToBuildInBackground(descriptor);
        boolean notRequiredToUpdateChildren=!forcedNow && !wasExpanded;
        if (notRequiredToUpdateChildren && forceUpdate && !wasExpanded) {
          boolean alwaysPlus=getBuilder().isAlwaysShowPlus(descriptor);
          if (alwaysPlus && wasLeaf) {
            notRequiredToUpdateChildren=false;
          }
 else {
            notRequiredToUpdateChildren=alwaysPlus;
          }
        }
        final Ref<LoadedChildren> preloaded=new Ref<LoadedChildren>(loadedChildren);
        boolean descriptorWasUpdated=descriptorIsUpToDate;
        if (notRequiredToUpdateChildren) {
          if (myUnbuiltNodes.contains(node) && node.getChildCount() == 0) {
            insertLoadingNode(node,true);
          }
          return;
        }
        if (!forcedNow) {
          if (!bgBuild) {
            if (myUnbuiltNodes.contains(node)) {
              if (!descriptorWasUpdated) {
                update(descriptor,true);
                descriptorWasUpdated=true;
              }
              if (processAlwaysLeaf(node))               return;
              Pair<Boolean,LoadedChildren> unbuilt=processUnbuilt(node,descriptor,pass,wasExpanded,null);
              if (unbuilt.getFirst())               return;
              preloaded.set(unbuilt.getSecond());
            }
          }
        }
        final boolean childForceUpdate=isChildNodeForceUpdate(node,forceUpdate,wasExpanded);
        if (!forcedNow && isToBuildInBackground(descriptor)) {
          if (processAlwaysLeaf(node))           return;
          queueBackgroundUpdate(new UpdateInfo(descriptor,pass,canSmartExpand(node,toSmartExpand),wasExpanded,childForceUpdate,descriptorWasUpdated),node);
          return;
        }
 else {
          if (!descriptorWasUpdated) {
            update(descriptor,false).doWhenDone(new Runnable(){
              public void run(){
                if (processAlwaysLeaf(node))                 return;
                updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
              }
            }
);
          }
 else {
            if (processAlwaysLeaf(node))             return;
            updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
          }
        }
      }
  finally {
        if (isReleased())         return;
        processNodeActionsIfReady(node);
      }
    }
  }
,node);
}
