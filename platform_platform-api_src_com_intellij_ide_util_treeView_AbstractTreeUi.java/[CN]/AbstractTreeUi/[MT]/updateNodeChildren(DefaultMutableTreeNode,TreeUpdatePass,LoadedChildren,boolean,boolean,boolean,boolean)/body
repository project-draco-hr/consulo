{
  getTreeStructure().commit();
  final boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath())) || isAutoExpand(node);
  final boolean wasLeaf=node.getChildCount() == 0;
  try {
    final NodeDescriptor descriptor=getDescriptorFrom(node);
    if (descriptor == null) {
      removeLoading(node,true);
      return;
    }
    boolean bgBuild=isToBuildInBackground(descriptor);
    boolean notRequiredToUpdateChildren=!forcedNow && !wasExpanded;
    if (notRequiredToUpdateChildren && forceUpdate && !wasExpanded) {
      boolean alwaysPlus=getBuilder().isAlwaysShowPlus(descriptor);
      if (alwaysPlus && wasLeaf) {
        notRequiredToUpdateChildren=false;
      }
 else {
        notRequiredToUpdateChildren=alwaysPlus;
      }
    }
    final Ref<LoadedChildren> preloaded=new Ref<LoadedChildren>(loadedChildren);
    boolean descriptorWasUpdated=descriptorIsUpToDate;
    if (notRequiredToUpdateChildren) {
      if (myUnbuiltNodes.contains(node) && node.getChildCount() == 0) {
        insertLoadingNode(node,true);
      }
      return;
    }
    if (!forcedNow) {
      if (!bgBuild) {
        if (myUnbuiltNodes.contains(node)) {
          if (!descriptorWasUpdated) {
            update(descriptor,true);
            descriptorWasUpdated=true;
          }
          if (processAlwaysLeaf(node))           return;
          Pair<Boolean,LoadedChildren> unbuilt=processUnbuilt(node,descriptor,pass,wasExpanded,null);
          if (unbuilt.getFirst())           return;
          preloaded.set(unbuilt.getSecond());
        }
      }
    }
    final boolean childForceUpdate=isChildNodeForceUpdate(node,forceUpdate,wasExpanded);
    if (!forcedNow && isToBuildInBackground(descriptor)) {
      if (processAlwaysLeaf(node))       return;
      queueBackgroundUpdate(new UpdateInfo(descriptor,pass,canSmartExpand(node,toSmartExpand),wasExpanded,childForceUpdate,descriptorWasUpdated),node);
      return;
    }
 else {
      if (!descriptorWasUpdated) {
        update(descriptor,false).doWhenDone(new Runnable(){
          public void run(){
            if (processAlwaysLeaf(node))             return;
            updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
          }
        }
);
      }
 else {
        if (processAlwaysLeaf(node))         return;
        updateNodeChildrenNow(node,pass,preloaded.get(),toSmartExpand,wasExpanded,wasLeaf,childForceUpdate);
      }
    }
  }
  finally {
    processNodeActionsIfReady(node);
  }
}
