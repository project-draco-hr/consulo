{
  if (!(node.getUserObject() instanceof NodeDescriptor))   return;
  NodeDescriptor descriptor=getDescriptorFrom(node);
  if (getElementFromDescriptor(descriptor) == null)   return;
  boolean notified=false;
  if (updatePosition) {
    DefaultMutableTreeNode parentNode=(DefaultMutableTreeNode)node.getParent();
    if (parentNode != null) {
      int oldIndex=parentNode.getIndex(node);
      int newIndex=oldIndex;
      if (isLoadingChildrenFor(node.getParent()) || getBuilder().isChildrenResortingNeeded(descriptor)) {
        final ArrayList<TreeNode> children=new ArrayList<TreeNode>(parentNode.getChildCount());
        for (int i=0; i < parentNode.getChildCount(); i++) {
          children.add(parentNode.getChildAt(i));
        }
        sortChildren(node,children,true,false);
        newIndex=children.indexOf(node);
      }
      if (oldIndex != newIndex) {
        List<Object> pathsToExpand=new ArrayList<Object>();
        List<Object> selectionPaths=new ArrayList<Object>();
        TreeBuilderUtil.storePaths(getBuilder(),node,pathsToExpand,selectionPaths,false);
        removeNodeFromParent(node,false);
        myTreeModel.insertNodeInto(node,parentNode,newIndex);
        TreeBuilderUtil.restorePaths(getBuilder(),pathsToExpand,selectionPaths,false);
        notified=true;
      }
 else {
        myTreeModel.nodeChanged(node);
        notified=true;
      }
    }
 else {
      myTreeModel.nodeChanged(node);
      notified=true;
    }
  }
}
