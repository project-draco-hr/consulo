{
  final AsyncResult<ArrayList<TreeNode>> result=new AsyncResult<ArrayList<TreeNode>>();
  final ArrayList<TreeNode> nodesToInsert=new ArrayList<TreeNode>();
  final Collection<Object> allElements=elementToIndexMap.getKeys();
  final ActionCallback processingDone=new ActionCallback(allElements.size());
  for (  final Object child : allElements) {
    Integer index=elementToIndexMap.getValue(child);
    final Ref<NodeDescriptor> childDescr=new Ref<NodeDescriptor>(loadedChildren.getDescriptor(child));
    boolean needToUpdate=false;
    if (childDescr.get() == null) {
      childDescr.set(getTreeStructure().createDescriptor(child,descriptor));
      needToUpdate=true;
    }
    if (childDescr.get() == null) {
      processingDone.setDone();
      continue;
    }
    if (index == null) {
      index=Integer.MAX_VALUE;
      needToUpdate=true;
    }
    childDescr.get().setIndex(index.intValue());
    final ActionCallback update=new ActionCallback();
    if (needToUpdate) {
      update(childDescr.get(),false).doWhenDone(new AsyncResult.Handler<Boolean>(){
        public void run(        Boolean changes){
          loadedChildren.putDescriptor(child,childDescr.get(),changes);
          update.setDone();
        }
      }
);
    }
 else {
      update.setDone();
    }
    update.doWhenDone(new Runnable(){
      public void run(){
        Object element=getElementFromDescriptor(childDescr.get());
        if (element == null) {
          processingDone.setDone();
        }
 else {
          DefaultMutableTreeNode node=getNodeForElement(element,false);
          if (node == null || node.getParent() != parent) {
            final DefaultMutableTreeNode childNode=createChildNode(childDescr.get());
            if (addLoadingNode || getBuilder().isAlwaysShowPlus(childDescr.get())) {
              insertLoadingNode(childNode,true);
            }
 else {
              addToUnbuilt(childNode);
            }
            nodesToInsert.add(childNode);
            createMapping(element,childNode);
          }
          processingDone.setDone();
        }
      }
    }
);
  }
  processingDone.doWhenDone(new Runnable(){
    public void run(){
      result.setDone(nodesToInsert);
    }
  }
);
  return result;
}
