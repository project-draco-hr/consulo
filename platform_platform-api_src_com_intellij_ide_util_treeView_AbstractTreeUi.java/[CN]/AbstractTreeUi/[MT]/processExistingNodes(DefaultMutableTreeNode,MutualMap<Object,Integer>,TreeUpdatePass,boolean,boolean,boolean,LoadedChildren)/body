{
  final List<TreeNode> childNodes=TreeUtil.childrenToArray(node);
  return maybeYeild(new ActiveRunnable(){
    @NotNull @Override public ActionCallback run(){
      if (pass.isExpired())       return new ActionCallback.Rejected();
      if (childNodes.isEmpty())       return new ActionCallback.Done();
      final ActionCallback result=new ActionCallback(childNodes.size());
      for (      TreeNode each : childNodes) {
        final DefaultMutableTreeNode eachChild=(DefaultMutableTreeNode)each;
        if (isLoadingNode(eachChild)) {
          result.setDone();
          continue;
        }
        final boolean childForceUpdate=isChildNodeForceUpdate(eachChild,forceUpdate,wasExpaned);
        maybeYeild(new ActiveRunnable(){
          @NotNull @Override public ActionCallback run(){
            NodeDescriptor descriptor=preloaded != null ? preloaded.getDescriptor(getElementFor(eachChild)) : null;
            NodeDescriptor descriptorFromNode=getDescriptorFrom(eachChild);
            if (descriptor != null) {
              eachChild.setUserObject(descriptor);
              if (descriptorFromNode != null) {
                descriptor.setChildrenSortingStamp(descriptorFromNode.getChildrenSortingStamp());
              }
            }
 else {
              descriptor=descriptorFromNode;
            }
            return processExistingNode(eachChild,descriptor,node,elementToIndexMap,pass,canSmartExpand,childForceUpdate,preloaded);
          }
        }
,pass,node).notify(result);
        if (result.isRejected()) {
          break;
        }
      }
      return result;
    }
  }
,pass,node);
}
