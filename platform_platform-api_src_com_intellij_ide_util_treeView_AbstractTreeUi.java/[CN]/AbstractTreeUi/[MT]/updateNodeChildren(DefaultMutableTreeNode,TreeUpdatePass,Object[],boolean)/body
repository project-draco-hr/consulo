{
  getTreeStructure().commit();
  final boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath()));
  final boolean wasLeaf=node.getChildCount() == 0;
  final NodeDescriptor descriptor=(NodeDescriptor)node.getUserObject();
  if (descriptor == null)   return;
  if (myUnbuiltNodes.contains(node)) {
    processUnbuilt(node,descriptor,pass);
    processNodeActionsIfReady(node);
    return;
  }
  if (!forcedNow && istToBuildInBackground(descriptor)) {
    queueBackgroundUpdate(node,descriptor,pass);
    return;
  }
  final MutualMap<Object,Integer> elementToIndexMap=collectElementToIndexMap(descriptor,preloadedChildren);
  myUpdatingChildren.add(node);
  pass.setCurrentNode(node);
  processAllChildren(node,elementToIndexMap,pass).doWhenDone(new Runnable(){
    public void run(){
      if (isDisposed(node)) {
        return;
      }
      if (canYield()) {
        removeLoading(node,false);
      }
      ArrayList<TreeNode> nodesToInsert=collectNodesToInsert(descriptor,elementToIndexMap);
      insertNodesInto(nodesToInsert,node);
      updateNodesToInsert(nodesToInsert,pass);
      if (wasExpanded) {
        expand(node);
      }
      if (wasExpanded || wasLeaf) {
        expand(node,descriptor,wasLeaf);
      }
      myUpdatingChildren.remove(node);
      final Object element=getElementFor(node);
      addNodeAction(element,new NodeAction(){
        public void onReady(        final DefaultMutableTreeNode node){
          removeLoading(node,false);
        }
      }
);
      processNodeActionsIfReady(node);
    }
  }
);
}
