{
  final Ref<Object[]> passOne=new Ref<Object[]>();
  try {
    myStateLock.readLock().acquire();
    execute(new Runnable(){
      public void run(){
        passOne.set(getTreeStructure().getChildElements(element));
      }
    }
);
  }
 catch (  IndexNotReadyException e) {
    warnOnIndexNotReady();
    return ArrayUtil.EMPTY_OBJECT_ARRAY;
  }
catch (  InterruptedException e) {
    throw new ProcessCanceledException();
  }
 finally {
    myStateLock.readLock().release();
  }
  if (!Registry.is("ide.tree.checkStructure"))   return passOne.get();
  final Object[] passTwo=getTreeStructure().getChildElements(element);
  final HashSet two=new HashSet(Arrays.asList(passTwo));
  if (passOne.get().length != passTwo.length) {
    LOG.error("AbstractTreeStructure.getChildren() must either provide same objects or new objects but with correct hashCode() and equals() methods. Wrong parent element=" + element);
  }
 else {
    for (    Object eachInOne : passOne.get()) {
      if (!two.contains(eachInOne)) {
        LOG.error("AbstractTreeStructure.getChildren() must either provide same objects or new objects but with correct hashCode() and equals() methods. Wrong parent element=" + element);
        break;
      }
    }
  }
  return passOne.get();
}
