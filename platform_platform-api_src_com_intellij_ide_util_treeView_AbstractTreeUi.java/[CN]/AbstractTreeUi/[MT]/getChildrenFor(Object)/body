{
  final Object[] passOne;
  try {
    passOne=getTreeStructure().getChildElements(element);
  }
 catch (  IndexNotReadyException e) {
    warnOnIndexNotReady();
    return ArrayUtil.EMPTY_OBJECT_ARRAY;
  }
  if (!myCheckStructure)   return passOne;
  final Object[] passTwo=getTreeStructure().getChildElements(element);
  final HashSet two=new HashSet(Arrays.asList(passTwo));
  if (passOne.length != passTwo.length) {
    LOG.error("AbstractTreeStructure.getChildren() must either provide same objects or new objects but with correct hashCode() and equals() methods. Wrong parent element=" + element);
  }
 else {
    for (    Object eachInOne : passOne) {
      if (!two.contains(eachInOne)) {
        LOG.error("AbstractTreeStructure.getChildren() must either provide same objects or new objects but with correct hashCode() and equals() methods. Wrong parent element=" + element);
        break;
      }
    }
  }
  return passOne;
}
