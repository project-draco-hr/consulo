{
  if (!canInitiateNewActivity())   return new ActionCallback.Rejected();
  final ActionCallback result=new ActionCallback();
  final AtomicBoolean fail=new AtomicBoolean();
  final Runnable finalizer=new Runnable(){
    @Override public void run(){
      if (fail.get()) {
        result.setRejected();
      }
 else {
        result.setDone();
      }
    }
  }
;
  registerWorkerTask(bgBuildAction);
  final Runnable pooledThreadWithProgressRunnable=new Runnable(){
    @Override public void run(){
      try {
        final AbstractTreeBuilder builder=getBuilder();
        if (!canInitiateNewActivity()) {
          throw new ProcessCanceledException();
        }
        builder.runBackgroundLoading(new Runnable(){
          @Override public void run(){
            assertNotDispatchThread();
            try {
              if (!canInitiateNewActivity()) {
                throw new ProcessCanceledException();
              }
              execute(bgBuildAction);
              if (edtPostRunnable != null) {
                builder.updateAfterLoadedInBackground(new Runnable(){
                  @Override public void run(){
                    try {
                      assertIsDispatchThread();
                      if (!canInitiateNewActivity()) {
                        throw new ProcessCanceledException();
                      }
                      execute(edtPostRunnable);
                    }
 catch (                    ProcessCanceledException e) {
                      fail.set(true);
                      cancelUpdate();
                    }
 finally {
                      unregisterWorkerTask(bgBuildAction,finalizer);
                    }
                  }
                }
);
              }
 else {
                unregisterWorkerTask(bgBuildAction,finalizer);
              }
            }
 catch (            ProcessCanceledException e) {
              fail.set(true);
              unregisterWorkerTask(bgBuildAction,finalizer);
              cancelUpdate();
            }
catch (            Throwable t) {
              unregisterWorkerTask(bgBuildAction,finalizer);
              throw new RuntimeException(t);
            }
          }
        }
);
      }
 catch (      ProcessCanceledException e) {
        unregisterWorkerTask(bgBuildAction,finalizer);
        cancelUpdate();
      }
    }
  }
;
  Runnable pooledThreadRunnable=new Runnable(){
    @Override public void run(){
      try {
        if (myProgress != null) {
          ProgressManager.getInstance().runProcess(pooledThreadWithProgressRunnable,myProgress);
        }
 else {
          execute(pooledThreadWithProgressRunnable);
        }
      }
 catch (      ProcessCanceledException e) {
        fail.set(true);
        unregisterWorkerTask(bgBuildAction,finalizer);
        cancelUpdate();
      }
    }
  }
;
  if (isPassthroughMode()) {
    execute(pooledThreadRunnable);
  }
 else {
    if (myWorker == null || myWorker.isDisposed()) {
      myWorker=new WorkerThread("AbstractTreeBuilder.Worker",1);
      myWorker.start();
      myWorker.addTaskFirst(pooledThreadRunnable);
      myWorker.dispose(false);
    }
 else {
      myWorker.addTaskFirst(pooledThreadRunnable);
    }
  }
  return result;
}
