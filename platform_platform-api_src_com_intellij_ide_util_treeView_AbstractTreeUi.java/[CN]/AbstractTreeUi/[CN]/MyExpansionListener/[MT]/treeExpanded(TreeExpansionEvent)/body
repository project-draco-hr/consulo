{
  final TreePath path=event.getPath();
  if (mySilentExpand != null && mySilentExpand.equals(path))   return;
  dropUpdaterStateIfExternalChange();
  if (myRequestedExpand != null && !myRequestedExpand.equals(path)) {
    _getReady().doWhenDone(new Runnable(){
      @Override public void run(){
        Object element=getElementFor(path.getLastPathComponent());
        expand(element,null);
      }
    }
);
    return;
  }
  final DefaultMutableTreeNode node=(DefaultMutableTreeNode)path.getLastPathComponent();
  if (!myUnbuiltNodes.contains(node)) {
    removeLoading(node,false);
    Set<DefaultMutableTreeNode> childrenToUpdate=new HashSet<DefaultMutableTreeNode>();
    for (int i=0; i < node.getChildCount(); i++) {
      DefaultMutableTreeNode each=(DefaultMutableTreeNode)node.getChildAt(i);
      if (myUnbuiltNodes.contains(each)) {
        makeLoadingOrLeafIfNoChildren(each);
        childrenToUpdate.add(each);
      }
    }
    if (!childrenToUpdate.isEmpty()) {
      for (      DefaultMutableTreeNode each : childrenToUpdate) {
        maybeUpdateSubtreeToUpdate(each);
      }
    }
  }
 else {
    getBuilder().expandNodeChildren(node);
  }
  processSmartExpand(node,canSmartExpand(node,true),false);
  processNodeActionsIfReady(node);
}
