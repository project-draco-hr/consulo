{
  if (psiClass instanceof PsiAnonymousClass)   return null;
  if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {
    return null;
  }
  PsiDocComment docComment=psiClass.getDocComment();
  final PsiIdentifier nameIdentifier=psiClass.getNameIdentifier();
  final PsiElement elementToHighlight=nameIdentifier != null ? nameIdentifier : psiClass;
  if (docComment == null) {
    return isJavaDocRequired(psiClass) ? new ProblemDescriptor[]{createDescriptor(elementToHighlight,JavaDocLocalInspection.REQUIRED_JAVADOC_IS_ABSENT)} : null;
  }
  PsiDocTag[] tags=docComment.getTags();
  boolean isAuthorRequired=isTagRequired(psiClass,"author");
  boolean isVersionRequired=isTagRequired(psiClass,"version");
  boolean isSinceRequired=isTagRequired(psiClass,"since");
  boolean isAuthorAbsent=true;
  boolean isVersionAbsent=true;
  boolean isSinceAbsent=true;
  if (isAuthorRequired || isVersionRequired) {
    for (int i=0; i < tags.length && (isAuthorAbsent || isVersionAbsent || isSinceAbsent); i++) {
      PsiDocTag tag=tags[i];
      if ("author".equals(tag.getName()))       isAuthorAbsent=false;
      if ("version".equals(tag.getName()))       isVersionAbsent=false;
      if ("since".equals(tag.getName()))       isSinceAbsent=false;
    }
  }
  ArrayList<ProblemDescriptor> problems=null;
  if (isAuthorRequired && isAuthorAbsent) {
    problems=new ArrayList<ProblemDescriptor>();
    problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor2","<code>@author</code>")));
  }
  if (isVersionRequired && isVersionAbsent) {
    if (problems == null)     problems=new ArrayList<ProblemDescriptor>();
    problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor2","<code>@version</code>")));
  }
  if (isSinceRequired && isSinceAbsent) {
    if (problems == null)     problems=new ArrayList<ProblemDescriptor>();
    problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor2","<code>@since</code>")));
  }
  problems=checkForPeriodInDoc(docComment,docComment,problems);
  for (  PsiDocTag tag : tags) {
    if ("author".equals(tag.getName())) {
      if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {
        if (problems == null)         problems=new ArrayList<ProblemDescriptor>();
        problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor5")));
      }
    }
 else     if ("version".equals(tag.getName())) {
      if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {
        if (problems == null)         problems=new ArrayList<ProblemDescriptor>();
        problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor6")));
      }
    }
 else     if ("since".equals(tag.getName())) {
      if (JavaDocLocalInspection.extractTagDescription(tag).length() == 0) {
        if (problems == null)         problems=new ArrayList<ProblemDescriptor>();
        problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message("inspection.javadoc.problem.descriptor7")));
      }
    }
  }
  problems=checkDuplicateTags(tags,problems);
  return problems == null ? null : problems.toArray(new ProblemDescriptorImpl[problems.size()]);
}
