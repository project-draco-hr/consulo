{
  @NonNls final String namespacePrefix=tag.getNamespacePrefix();
  if (namespacePrefix.length() > 0) {
    final String namespaceByPrefix=tag.getNamespaceByPrefix(namespacePrefix);
    if (namespaceByPrefix.length() == 0) {
      final PsiFile containingFile=tag.getContainingFile();
      if (!HighlightUtil.isRootInspected(containingFile))       return;
      if (!"xml".equals(namespacePrefix)) {
        boolean taglibDeclaration=containingFile.getFileType() == StdFileTypes.JSP;
        if (taglibDeclaration) {
          final XmlTag[] directiveTags=PsiUtil.getJspFile(containingFile).getDirectiveTags(JspDirectiveKind.TAGLIB,false);
          for (          XmlTag t : directiveTags) {
            if (namespacePrefix.equals(t.getAttributeValue("prefix")))             return;
          }
        }
 else {
          String nsDeclarationAttrName=null;
          for (XmlTag t=tag; t != null; t=t.getParentTag()) {
            if (t.hasNamespaceDeclarations()) {
              if (nsDeclarationAttrName == null)               nsDeclarationAttrName="xmlns:" + namespacePrefix;
              if (t.getAttributeValue(nsDeclarationAttrName) != null)               return;
            }
          }
        }
        final boolean error=containingFile.getFileType() == StdFileTypes.JSPX || containingFile.getFileType() == StdFileTypes.XHTML || containingFile.getFileType() == StdFileTypes.XML;
        final String localizedMessage=XmlErrorMessages.message("unbound.namespace",namespacePrefix);
        final int messageLength=namespacePrefix.length();
        final HighlightInfoType infoType=error ? HighlightInfoType.ERROR : HighlightInfoType.WARNING;
        bindMessageToTag(tag,infoType,0,messageLength,localizedMessage,new CreateNSDeclarationIntentionAction(tag,namespacePrefix,taglibDeclaration));
      }
    }
  }
}
