{
  for (Iterator<List<MethodSignatureBackedByPsiMethod>> iterator=allMethodsCollection.values().iterator(); iterator.hasNext(); ) {
    List<MethodSignatureBackedByPsiMethod> sameSignatureMethods=new ArrayList<MethodSignatureBackedByPsiMethod>(iterator.next());
    PsiSuperMethodUtil.removeOverriddenMethods(sameSignatureMethods,aClass,aClass);
    if (sameSignatureMethods.size() != 0) {
      final MethodSignatureBackedByPsiMethod methodSignature=sameSignatureMethods.get(0);
      final PsiMethod method=methodSignature.getMethod();
      final PsiClass containingClass=method.getContainingClass();
      if (containingClass == null || aClass.equals(containingClass)) {
        continue;
      }
      if (method.hasModifierProperty(PsiModifier.ABSTRACT) && !method.hasModifierProperty(PsiModifier.STATIC) && !method.hasModifierProperty(PsiModifier.PRIVATE)&& aClass.getManager().getResolveHelper().isAccessible(method,aClass,aClass)) {
        return method;
      }
    }
  }
  return null;
}
