{
  final Semaphore written=new Semaphore(0);
  final Semaphore read=new Semaphore(0);
  final AtomicBoolean isFinished=new AtomicBoolean();
  List<Future<?>> futures=new ArrayList<Future<?>>();
  for (  final Key each : ALL_TYPES) {
    futures.add(execute(new Runnable(){
      public void run(){
        int i=0;
        while (!isFinished.get()) {
          mySplitter.process(StringUtil.repeat("A",100),each);
          i++;
          if (i % 10 == 0) {
            written.release();
            try {
              if (!read.tryAcquire(1,TimeUnit.SECONDS))               throw new TimeoutException();
            }
 catch (            Exception e) {
              throw new RuntimeException(e);
            }
          }
        }
      }
    }
));
  }
  try {
    boolean hadOutput=false;
    for (int i=0; i < 100; i++) {
      written.acquire(ALL_TYPES.size());
      mySplitter.flush();
synchronized (myOutput) {
        for (        Key each : ALL_TYPES) {
          List<String> out=myOutput.get(each);
          if (!out.isEmpty()) {
            assertSize(1,out);
            out.clear();
            hadOutput=true;
          }
        }
      }
      read.release(ALL_TYPES.size());
    }
    assertTrue(hadOutput);
  }
  finally {
    isFinished.set(true);
    for (    Future<?> each : futures) {
      each.get(1,TimeUnit.SECONDS);
    }
  }
}
