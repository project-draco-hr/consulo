{
  final List<SmartPsiElementPointer> toInvert=new ArrayList<SmartPsiElementPointer>();
  addRefsToInvert(toInvert,myElement);
  if (myElement instanceof PsiMethod) {
    final Collection<PsiMethod> overriders=OverridingMethodsSearch.search((PsiMethod)myElement).findAll();
    for (    PsiMethod overrider : overriders) {
      myRenameProcessor.addElement(overrider,myNewName);
    }
    Collection<PsiMethod> allMethods=new HashSet<PsiMethod>(overriders);
    allMethods.add((PsiMethod)myElement);
    for (    PsiMethod method : allMethods) {
      method.accept(new PsiRecursiveElementVisitor(){
        public void visitReturnStatement(        PsiReturnStatement statement){
          final PsiExpression returnValue=statement.getReturnValue();
          if (returnValue != null && PsiType.BOOLEAN.equals(returnValue.getType())) {
            toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(returnValue));
          }
        }
      }
);
    }
  }
 else   if (myElement instanceof PsiParameter && ((PsiParameter)myElement).getDeclarationScope() instanceof PsiMethod) {
    final PsiMethod method=(PsiMethod)((PsiParameter)myElement).getDeclarationScope();
    int index=method.getParameterList().getParameterIndex((PsiParameter)myElement);
    LOG.assertTrue(index >= 0);
    final Query<PsiReference> methodQuery=MethodReferencesSearch.search(method);
    final Collection<PsiReference> methodRefs=methodQuery.findAll();
    for (    PsiReference ref : methodRefs) {
      if (ref.getElement().getParent() instanceof PsiMethodCallExpression) {
        final PsiMethodCallExpression call=(PsiMethodCallExpression)ref.getElement().getParent();
        final PsiReferenceExpression methodExpression=call.getMethodExpression();
        final PsiExpression[] args=call.getArgumentList().getExpressions();
        if (index < args.length) {
          if (methodExpression.getQualifier() == null || !"super".equals(methodExpression.getQualifierExpression().getText())) {
            toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(args[index]));
          }
        }
      }
    }
    final Collection<PsiMethod> overriders=OverridingMethodsSearch.search(method).findAll();
    for (    PsiMethod overrider : overriders) {
      final PsiParameter overriderParameter=overrider.getParameterList().getParameters()[index];
      myRenameProcessor.addElement(overriderParameter,myNewName);
      addRefsToInvert(toInvert,overriderParameter);
    }
  }
  final UsageInfo[] renameUsages=myRenameProcessor.findUsages();
  myUsagesToInvert=toInvert.toArray(new SmartPsiElementPointer[toInvert.size()]);
  Set<PsiElement> elements=new HashSet<PsiElement>();
  List<UsageInfo> result=new ArrayList<UsageInfo>();
  for (  UsageInfo renameUsage : renameUsages) {
    elements.add(renameUsage.getElement());
    result.add(renameUsage);
  }
  for (  SmartPsiElementPointer pointer : myUsagesToInvert) {
    final PsiExpression expression=(PsiExpression)pointer.getElement();
    if (!elements.contains(expression)) {
      elements.add(expression);
      result.add(new UsageInfo(expression));
    }
  }
  return result.toArray(new UsageInfo[result.size()]);
}
