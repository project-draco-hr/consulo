{
  try {
    final Map<PsiClass,Boolean> allClasses=new HashMap<PsiClass,Boolean>();
    for (    PsiElement element : myElementsToMove) {
      if (element instanceof PsiClass) {
        final PsiClass psiClass=(PsiClass)element;
        if (allClasses.containsKey(psiClass)) {
          continue;
        }
        final PsiClassOwner containingFile=(PsiClassOwner)element.getContainingFile();
        final PsiClass[] classes=containingFile.getClasses();
        boolean all=true;
        for (        PsiClass aClass : classes) {
          if (ArrayUtil.find(myElementsToMove,aClass) == -1) {
            all=false;
            break;
          }
        }
        for (        PsiClass aClass : classes) {
          allClasses.put(aClass,all);
        }
      }
    }
    final Map<PsiElement,PsiElement> oldToNewElementsMapping=new HashMap<PsiElement,PsiElement>();
    for (int idx=0; idx < myElementsToMove.length; idx++) {
      PsiElement element=myElementsToMove[idx];
      final RefactoringElementListener elementListener=getTransaction().getElementListener(element);
      if (element instanceof PsiPackage) {
        final PsiDirectory[] directories=((PsiPackage)element).getDirectories();
        final PsiPackage newElement=MoveClassesOrPackagesUtil.doMovePackage((PsiPackage)element,myMoveDestination);
        LOG.assertTrue(newElement != null);
        oldToNewElementsMapping.put(element,newElement);
        int i=0;
        final PsiDirectory[] newDirectories=newElement.getDirectories();
        if (newDirectories.length == 1) {
          for (          PsiDirectory directory : directories) {
            oldToNewElementsMapping.put(directory,newDirectories[0]);
          }
        }
 else {
          for (          PsiDirectory directory : directories) {
            oldToNewElementsMapping.put(directory,newDirectories[i++]);
          }
        }
        element=newElement;
      }
 else       if (element instanceof PsiClass) {
        final PsiClass psiClass=(PsiClass)element;
        MoveClassesOrPackagesUtil.prepareMoveClass(psiClass);
        final PsiClass newElement=MoveClassesOrPackagesUtil.doMoveClass(psiClass,myMoveDestination.getTargetDirectory(element.getContainingFile()),allClasses.get(psiClass));
        oldToNewElementsMapping.put(element,newElement);
        element=newElement;
      }
 else {
        LOG.error("Unexpected element to move: " + element);
      }
      elementListener.elementMoved(element);
      myElementsToMove[idx]=element;
    }
    for (    PsiElement element : myElementsToMove) {
      if (element instanceof PsiClass) {
        MoveClassesOrPackagesUtil.finishMoveClass((PsiClass)element);
      }
    }
    myNonCodeUsages=CommonMoveUtil.retargetUsages(usages,oldToNewElementsMapping);
  }
 catch (  IncorrectOperationException e) {
    myNonCodeUsages=new NonCodeUsageInfo[0];
    RefactoringUIUtil.processIncorrectOperation(myProject,e);
  }
}
