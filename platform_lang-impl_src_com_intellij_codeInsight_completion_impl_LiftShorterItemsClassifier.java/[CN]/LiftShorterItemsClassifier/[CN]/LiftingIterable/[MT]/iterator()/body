{
  final Set<LookupElement> processed=newIdentityTroveSet(mySrcSet.size());
  final Set<FList<LookupElement>> arraysProcessed=newIdentityTroveSet();
  final Iterable<LookupElement> next=myNext.classify(mySource,myContext);
  Iterator<LookupElement> base=FilteringIterator.create(next.iterator(),new Condition<LookupElement>(){
    @Override public boolean value(    LookupElement element){
      return processed.add(element);
    }
  }
);
  return new FlatteningIterator<LookupElement,LookupElement>(base){
    @Override protected Iterator<LookupElement> createValueIterator(    LookupElement element){
      List<LookupElement> shorter=addShorterElements(null,myToLift.get(element));
      List<LookupElement> singleton=Collections.singletonList(element);
      if (shorter != null) {
        if (myLifted != null) {
          myLifted.addAll(shorter);
        }
        Iterable<LookupElement> lifted=myNext.classify(shorter,myContext);
        return (myLiftBefore ? ContainerUtil.concat(lifted,singleton) : ContainerUtil.concat(singleton,lifted)).iterator();
      }
      return singleton.iterator();
    }
    @Nullable private List<LookupElement> addShorterElements(    @Nullable List<LookupElement> toLift,    @Nullable FList<LookupElement> from){
      if (from == null) {
        return toLift;
      }
      FList<LookupElement> each=from;
      while (!each.isEmpty() && arraysProcessed.add(each)) {
        LookupElement shorterElement=each.getHead();
        if (mySrcSet.contains(shorterElement) && processed.add(shorterElement)) {
          if (toLift == null) {
            toLift=new ArrayList<LookupElement>();
          }
          toLift.add(shorterElement);
        }
        each=each.getTail();
      }
      return toLift;
    }
  }
;
}
