{
  final Set<LookupElement> processed=identityTroveSet(mySrcSet.size());
  final Set<FList<LookupElement>> arraysProcessed=identityTroveSet();
  final boolean forSorting=myContext.get(CompletionLookupArranger.PURE_RELEVANCE) != Boolean.TRUE;
  final Iterable<LookupElement> next=myNext.classify(mySource,myContext);
  Iterator<LookupElement> base=FilteringIterator.create(next.iterator(),new Condition<LookupElement>(){
    @Override public boolean value(    LookupElement element){
      return processed.add(element);
    }
  }
);
  return new FlatteningIterator<LookupElement,LookupElement>(base){
    @Override protected Iterator<LookupElement> createValueIterator(    LookupElement element){
      List<LookupElement> shorter=addShorterElements(null,myToLiftForPreselection.get(element));
      if (forSorting) {
        shorter=addShorterElements(shorter,myToLiftForSorting.get(element));
      }
      if (shorter != null) {
        if (myLifted != null) {
          myLifted.addAll(shorter);
        }
        return ContainerUtil.concat(myNext.classify(shorter,myContext),Collections.singletonList(element)).iterator();
      }
      return Collections.singletonList(element).iterator();
    }
    @Nullable private List<LookupElement> addShorterElements(    @Nullable List<LookupElement> toLift,    @Nullable FList<LookupElement> from){
      if (from == null) {
        return toLift;
      }
      FList<LookupElement> each=from;
      while (!each.isEmpty() && arraysProcessed.add(each)) {
        LookupElement shorterElement=each.getHead();
        if (mySrcSet.contains(shorterElement) && processed.add(shorterElement)) {
          if (toLift == null) {
            toLift=new ArrayList<LookupElement>();
          }
          toLift.add(shorterElement);
        }
        each=each.getTail();
      }
      return toLift;
    }
  }
;
}
