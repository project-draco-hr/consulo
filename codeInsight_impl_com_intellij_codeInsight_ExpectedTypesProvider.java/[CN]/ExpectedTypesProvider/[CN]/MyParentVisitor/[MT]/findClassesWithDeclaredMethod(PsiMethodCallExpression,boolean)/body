{
  final PsiReferenceExpression reference=methodCallExpr.getMethodExpression();
  final PsiManager manager=methodCallExpr.getManager();
  final JavaPsiFacade facade=JavaPsiFacade.getInstance(manager.getProject());
  final PsiMethod[] methods=myClassProvider.findDeclaredMethods(reference.getManager(),reference.getReferenceName());
  Set<ExpectedTypeInfo> types=new THashSet<ExpectedTypeInfo>();
  for (  PsiMethod method : methods) {
    final PsiClass aClass=method.getContainingClass();
    if (!facade.getResolveHelper().isAccessible(method,reference,aClass))     continue;
    final PsiSubstitutor substitutor=ExpectedTypeUtil.inferSubstitutor(method,methodCallExpr,forCompletion);
    final PsiClassType type;
    if (substitutor != null) {
      type=facade.getElementFactory().createType(aClass,substitutor);
    }
 else {
      type=facade.getElementFactory().createType(aClass);
    }
    if (method.hasModifierProperty(PsiModifier.STATIC) || method.hasModifierProperty(PsiModifier.FINAL) || method.hasModifierProperty(PsiModifier.PRIVATE)) {
      types.add(createInfoImpl(type,ExpectedTypeInfo.TYPE_STRICTLY,type,TailType.DOT));
    }
 else {
      addBaseType(types,type,method);
    }
  }
  return types.toArray(new ExpectedTypeInfo[types.size()]);
}
