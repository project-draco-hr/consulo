{
  clazz=_clazz;
  assertCanRunWriteAction();
  ActivityTracker.getInstance().inc();
  fireBeforeWriteActionStart(_clazz);
  final AtomicBoolean stopped=new AtomicBoolean(false);
  LOG.assertTrue(isWriteAccessAllowed() || !Thread.holdsLock(PsiLock.LOCK),"Thread must not hold PsiLock while performing writeAction");
  try {
    if (!myLock.writeLock().tryLock()) {
      if (ourDumpThreadsOnLongWriteActionWaiting > 0) {
        executeOnPooledThread(new Runnable(){
          @Override public void run(){
            while (!stopped.get()) {
              try {
                Thread.sleep(ourDumpThreadsOnLongWriteActionWaiting);
                if (!stopped.get()) {
                  PerformanceWatcher.getInstance().dumpThreads(true);
                }
              }
 catch (              InterruptedException ignored) {
              }
            }
          }
        }
);
      }
      myLock.writeLock().lockInterruptibly();
    }
    acquired();
  }
 catch (  InterruptedException e) {
    throw new RuntimeInterruptedException(e);
  }
  stopped.set(true);
  myWriteActionsStack.push(_clazz);
  fireWriteActionStarted(_clazz);
}
