{
  assertIsDispatchThread();
  boolean writeAccessAllowed=isInsideWriteActionEDTOnly();
  if (writeAccessAllowed || isHeadlessEnvironment() && !isUnitTestMode()) {
    LOG.debug("Starting process with progress from within write action makes no sense");
    try {
      ProgressManager.getInstance().runProcess(process,new EmptyProgressIndicator());
    }
 catch (    ProcessCanceledException e) {
      return false;
    }
    return true;
  }
  final ProgressWindow progress=new ProgressWindow(canBeCanceled,false,project,parentComponent,cancelText);
  Disposer.register(this,progress);
  progress.setTitle(progressTitle);
  final AtomicBoolean threadStarted=new AtomicBoolean();
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      executeOnPooledThread(new Runnable(){
        @Override public void run(){
          try {
            ProgressManager.getInstance().runProcess(process,progress);
          }
 catch (          ProcessCanceledException e) {
            progress.cancel();
          }
catch (          RuntimeException e) {
            progress.cancel();
            throw e;
          }
        }
      }
);
      threadStarted.set(true);
    }
  }
);
  progress.startBlocking();
  LOG.assertTrue(threadStarted.get());
  LOG.assertTrue(!progress.isRunning());
  return !progress.isCanceled();
}
