{
  final boolean available=super.checkAvailable(editor,file);
  if (!available)   return false;
  LineRange range=toMove;
  if (editor == null)   return false;
  final Document document=editor.getDocument();
  range=expandLineRangeToCoverPsiElements(range,editor,file);
  if (range == null)   return false;
  final int startOffset=editor.logicalPositionToOffset(new LogicalPosition(range.startLine,0));
  final int endOffset=editor.logicalPositionToOffset(new LogicalPosition(range.endLine,0));
  final PsiElement[] statements=GroovyRefactoringUtil.findStatementsInRange(file,startOffset,endOffset,false);
  if (statements.length == 0)   return false;
  for (  final PsiElement statement : statements) {
    if (statement instanceof GrMembersDeclaration) {
      final GrMembersDeclaration declaration=(GrMembersDeclaration)statement;
      if (declaration.getMembers().length > 0) {
        return false;
      }
    }
  }
  range=toMove=new LineRange(statements[0],statements[statements.length - 1],document);
  updateComplementaryRange();
  final PsiElement commonParent=PsiTreeUtil.findCommonParent(range.firstElement,range.lastElement);
  Class<? extends PsiElement>[] classes=new Class[]{GrMethod.class,GrTypeDefinition.class,PsiComment.class,GroovyFile.class};
  PsiElement guard=PsiTreeUtil.getParentOfType(commonParent,classes);
  if (!calcInsertOffset(file,editor,range))   return false;
  int insertOffset=isDown ? getLineStartSafeOffset(document,toMove2.endLine) - 1 : document.getLineStartOffset(toMove2.startLine);
  PsiElement newGuard=file.getViewProvider().findElementAt(insertOffset);
  newGuard=PsiTreeUtil.getParentOfType(newGuard,classes);
  if (newGuard != null && newGuard != guard && isInside(insertOffset,newGuard) != PsiTreeUtil.isAncestor(newGuard,range.lastElement,false)) {
    if (!PsiTreeUtil.isAncestor(guard,newGuard,false)) {
      return false;
    }
    while (true) {
      PsiElement candidate=PsiTreeUtil.getParentOfType(newGuard,classes);
      if (candidate == null || candidate == guard || !PsiTreeUtil.isAncestor(guard,candidate,false)) {
        break;
      }
      newGuard=candidate;
    }
    toMove2=new LineRange(newGuard,newGuard,document);
  }
  return true;
}
