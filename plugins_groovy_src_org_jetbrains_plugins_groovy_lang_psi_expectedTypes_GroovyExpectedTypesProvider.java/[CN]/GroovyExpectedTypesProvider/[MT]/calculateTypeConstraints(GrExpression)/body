{
  return TypeInferenceHelper.getCurrentContext().getCachedValue(expression,new Computable<TypeConstraint[]>(){
    @Override public TypeConstraint[] compute(){
      MyCalculator calculator=new MyCalculator(expression);
      final PsiElement parent=expression.getParent();
      if (parent instanceof GroovyPsiElement) {
        ((GroovyPsiElement)parent).accept(calculator);
      }
 else {
        parent.accept(new GroovyPsiElementVisitor(calculator));
      }
      final TypeConstraint[] result=calculator.getResult();
      List<TypeConstraint> custom=new ArrayList<TypeConstraint>();
      for (      GroovyExpectedTypesContributor contributor : GroovyExpectedTypesContributor.EP_NAME.getExtensions()) {
        custom.addAll(contributor.calculateTypeConstraints(expression));
      }
      if (!custom.isEmpty()) {
        custom.addAll(0,Arrays.asList(result));
        return custom.toArray(new TypeConstraint[custom.size()]);
      }
      return result;
    }
  }
);
}
