{
  final GrExpression invokedExpression=methodCall.getInvokedExpression();
  if (myExpression.equals(invokedExpression)) {
    myResult=new TypeConstraint[]{SubtypeConstraint.create(GroovyCommonClassNames.GROOVY_LANG_CLOSURE,methodCall)};
    return;
  }
  final GrClosableBlock[] closureArgs=methodCall.getClosureArguments();
  final int closureIndex=Arrays.asList(closureArgs).indexOf(myExpression);
  if (closureIndex >= 0) {
    List<TypeConstraint> constraints=new ArrayList<TypeConstraint>();
    for (    GroovyResolveResult variant : ResolveUtil.getCallVariants(myExpression)) {
      final GrArgumentList argumentList=methodCall.getArgumentList();
      final GrNamedArgument[] namedArgs=argumentList == null ? GrNamedArgument.EMPTY_ARRAY : argumentList.getNamedArguments();
      final GrExpression[] expressionArgs=argumentList == null ? GrExpression.EMPTY_ARRAY : argumentList.getExpressionArguments();
      try {
        final Map<GrExpression,Pair<PsiParameter,PsiType>> map=GrClosureSignatureUtil.mapArgumentsToParameters(variant,methodCall,true,true,namedArgs,expressionArgs,closureArgs);
        addConstraintsFromMap(constraints,map);
      }
 catch (      RuntimeException e) {
        LOG.error("call: " + methodCall.getText() + "\nsymbol: "+ variant.getElement().getText(),e);
      }
    }
    if (!constraints.isEmpty()) {
      myResult=constraints.toArray(new TypeConstraint[constraints.size()]);
    }
  }
}
