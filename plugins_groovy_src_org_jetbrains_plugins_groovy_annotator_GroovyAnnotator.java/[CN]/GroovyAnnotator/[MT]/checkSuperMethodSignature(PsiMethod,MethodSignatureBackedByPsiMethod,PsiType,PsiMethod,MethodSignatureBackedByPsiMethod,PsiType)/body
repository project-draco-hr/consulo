{
  PsiType substitutedSuperReturnType=substituteSuperReturnType(superMethodSignature,methodSignature,superReturnType);
  if (returnType.equals(substitutedSuperReturnType))   return null;
  final PsiType rawReturnType=TypeConversionUtil.erasure(returnType);
  final PsiType rawSuperReturnType=TypeConversionUtil.erasure(substitutedSuperReturnType);
  if (returnType instanceof PsiClassType && substitutedSuperReturnType instanceof PsiClassType) {
    if (TypeConversionUtil.isAssignable(rawSuperReturnType,rawReturnType)) {
      return null;
    }
  }
 else   if (returnType instanceof PsiArrayType && superReturnType instanceof PsiArrayType) {
    if (rawReturnType.equals(rawSuperReturnType)) {
      return null;
    }
  }
  String qName=getQNameOfMember(method);
  String baseQName=getQNameOfMember(superMethod);
  final String presentation=returnType.getCanonicalText() + " " + GroovyPresentationUtil.getSignaturePresentation(methodSignature);
  final String basePresentation=superReturnType.getCanonicalText() + " " + GroovyPresentationUtil.getSignaturePresentation(superMethodSignature);
  return GroovyBundle.message("return.type.is.incompatible",presentation,qName,basePresentation,baseQName);
}
