{
  if (superReturnType == null)   return null;
  PsiType substitutedSuperReturnType;
  if (!superMethodSignature.isRaw() && superMethodSignature.equals(methodSignature)) {
    PsiSubstitutor unifyingSubstitutor=MethodSignatureUtil.getSuperMethodSignatureSubstitutor(methodSignature,superMethodSignature);
    substitutedSuperReturnType=unifyingSubstitutor == null ? superReturnType : unifyingSubstitutor.substitute(superMethodSignature.getSubstitutor().substitute(superReturnType));
  }
 else {
    substitutedSuperReturnType=TypeConversionUtil.erasure(superReturnType);
  }
  if (returnType.equals(substitutedSuperReturnType))   return null;
  if (!(returnType instanceof PsiPrimitiveType) && substitutedSuperReturnType.getDeepComponentType() instanceof PsiClassType && TypeConversionUtil.isAssignable(substitutedSuperReturnType,returnType)) {
    return null;
  }
  String qName=getQName(method);
  String baseQName=getQName(superMethod);
  final String presentation=returnType.getCanonicalText() + " " + GroovyPresentationUtil.getSignaturePresentation(methodSignature);
  final String basePresentation=superReturnType.getCanonicalText() + " " + GroovyPresentationUtil.getSignaturePresentation(superMethodSignature);
  return GroovyBundle.message("return.type.is.incompatible",presentation,qName,basePresentation,baseQName);
}
