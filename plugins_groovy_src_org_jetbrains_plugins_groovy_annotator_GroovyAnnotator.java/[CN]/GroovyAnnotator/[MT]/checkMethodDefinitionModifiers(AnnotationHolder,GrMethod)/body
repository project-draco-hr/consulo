{
  final GrModifierList modifiersList=method.getModifierList();
  checkAccessModifiers(holder,modifiersList,method);
  checkDuplicateModifiers(holder,modifiersList,method);
  checkOverrideAnnotation(holder,modifiersList,method);
  boolean isMethodAbstract=modifiersList.hasExplicitModifier(GrModifier.ABSTRACT);
  final boolean isMethodStatic=modifiersList.hasExplicitModifier(GrModifier.STATIC);
  if (method.getParent() instanceof GroovyFileBase) {
    if (isMethodAbstract) {
      final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("script.cannot.have.modifier.abstract"));
      registerAbstractMethodFix(annotation,method,false);
    }
    if (modifiersList.hasExplicitModifier(GrModifier.NATIVE)) {
      final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("script.cannot.have.modifier.native"));
      annotation.registerFix(new GrModifierFix(method,modifiersList,GrModifier.NATIVE,false,false));
    }
  }
 else   if (method.getParent() != null && method.getParent().getParent() instanceof GrTypeDefinition) {
    GrTypeDefinition containingTypeDef=((GrTypeDefinition)method.getParent().getParent());
    if (containingTypeDef.isInterface()) {
      if (isMethodStatic) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("interface.must.have.no.static.method"));
        annotation.registerFix(new GrModifierFix(method,modifiersList,GrModifier.STATIC,true,false));
      }
      if (modifiersList.hasExplicitModifier(GrModifier.PRIVATE)) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("interface.must.have.no.private.method"));
        annotation.registerFix(new GrModifierFix(method,modifiersList,GrModifier.PRIVATE,true,false));
      }
    }
 else     if (containingTypeDef.isAnonymous()) {
      if (isMethodStatic) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("static.declaration.in.inner.class"));
        annotation.registerFix(new GrModifierFix(method,modifiersList,GrModifier.STATIC,false,false));
      }
      if (method.isConstructor()) {
        holder.createErrorAnnotation(method.getNameIdentifierGroovy(),GroovyBundle.message("constructors.are.not.allowed.in.anonymous.class"));
      }
      if (isMethodAbstract) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("anonymous.class.cannot.have.abstract.method"));
        registerAbstractMethodFix(annotation,method,false);
      }
    }
 else {
      PsiModifierList typeDefModifiersList=containingTypeDef.getModifierList();
      LOG.assertTrue(typeDefModifiersList != null,"modifiers list must be not null");
      if (!typeDefModifiersList.hasExplicitModifier(GrModifier.ABSTRACT)) {
        if (isMethodAbstract) {
          final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("only.abstract.class.can.have.abstract.method"));
          registerAbstractMethodFix(annotation,method,true);
        }
      }
      if (!isMethodAbstract) {
        if (method.getBlock() == null) {
          final Annotation annotation=holder.createErrorAnnotation(method.getNameIdentifierGroovy(),GroovyBundle.message("not.abstract.method.should.have.body"));
          annotation.registerFix(new AddMethodBodyFix(method));
        }
      }
      if (isMethodStatic) {
        checkStaticDeclarationsInInnerClass(method,holder);
      }
    }
  }
}
