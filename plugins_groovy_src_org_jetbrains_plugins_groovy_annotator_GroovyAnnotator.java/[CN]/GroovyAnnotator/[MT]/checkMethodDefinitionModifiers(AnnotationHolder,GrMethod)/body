{
  final GrModifierList modifiersList=method.getModifierList();
  checkAccessModifiers(holder,modifiersList,method);
  checkDuplicateModifiers(holder,modifiersList,method);
  checkOverrideAnnotation(holder,modifiersList,method);
  checkModifierIsNotAllowed(modifiersList,VOLATILE,GroovyBundle.message("method.has.incorrect.modifier.volatile"),holder);
  if (method.hasModifierProperty(FINAL) && method.hasModifierProperty(ABSTRACT)) {
    final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("illegal.combination.of.modifiers.abstract.and.final"));
    annotation.registerFix(new GrModifierFix(method,modifiersList,FINAL,false,false));
    annotation.registerFix(new GrModifierFix(method,modifiersList,ABSTRACT,false,false));
  }
  boolean isMethodAbstract=modifiersList.hasExplicitModifier(ABSTRACT);
  if (method.getParent() instanceof GroovyFileBase) {
    if (isMethodAbstract) {
      final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,ABSTRACT),GroovyBundle.message("script.method.cannot.have.modifier.abstract"));
      registerMakeAbstractMethodNotAbstractFix(annotation,method,false);
    }
    checkModifierIsNotAllowed(modifiersList,NATIVE,GroovyBundle.message("script.cannot.have.modifier.native"),holder);
  }
 else   if (method.getParent() != null && method.getParent().getParent() instanceof GrTypeDefinition) {
    GrTypeDefinition containingTypeDef=((GrTypeDefinition)method.getParent().getParent());
    if (containingTypeDef.isInterface()) {
      checkModifierIsNotAllowed(modifiersList,STATIC,GroovyBundle.message("interface.must.have.no.static.method"),holder);
      checkModifierIsNotAllowed(modifiersList,PRIVATE,GroovyBundle.message("interface.members.are.not.allowed.to.be",PRIVATE),holder);
      checkModifierIsNotAllowed(modifiersList,PROTECTED,GroovyBundle.message("interface.members.are.not.allowed.to.be",PROTECTED),holder);
    }
 else     if (containingTypeDef.isAnonymous()) {
      if (isMethodAbstract) {
        final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,ABSTRACT),GroovyBundle.message("anonymous.class.cannot.have.abstract.method"));
        registerMakeAbstractMethodNotAbstractFix(annotation,method,false);
      }
    }
 else {
      PsiModifierList typeDefModifiersList=containingTypeDef.getModifierList();
      LOG.assertTrue(typeDefModifiersList != null,"modifiers list must be not null");
      if (!typeDefModifiersList.hasExplicitModifier(ABSTRACT) && isMethodAbstract) {
        final Annotation annotation=holder.createErrorAnnotation(modifiersList,GroovyBundle.message("only.abstract.class.can.have.abstract.method"));
        registerMakeAbstractMethodNotAbstractFix(annotation,method,true);
      }
    }
  }
  if (method.hasModifierProperty(NATIVE) && method.getBlock() != null) {
    final Annotation annotation=holder.createErrorAnnotation(getModifierOrList(modifiersList,NATIVE),GroovyBundle.message("native.methods.cannot.have.body"));
    annotation.registerFix(new GrModifierFix((PsiMember)modifiersList.getParent(),modifiersList,NATIVE,true,false));
    annotation.registerFix(new DeleteMethodBodyFix(method));
  }
}
