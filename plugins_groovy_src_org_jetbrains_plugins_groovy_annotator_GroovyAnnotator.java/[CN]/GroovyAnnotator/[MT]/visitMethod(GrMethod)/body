{
  checkMethodWithTypeParamsShouldHaveReturnType(myHolder,method);
  checkInnerMethod(myHolder,method);
  checkOptionalParametersInAbstractMethod(myHolder,method);
  final PsiElement nameIdentifier=method.getNameIdentifierGroovy();
  if (nameIdentifier.getNode().getElementType() == GroovyTokenTypes.mSTRING_LITERAL) {
    checkStringLiteral(nameIdentifier,nameIdentifier.getText());
  }
  GrOpenBlock block=method.getBlock();
  if (block != null && TypeInferenceHelper.isTooComplexTooAnalyze(block)) {
    myHolder.createWeakWarningAnnotation(nameIdentifier,GroovyBundle.message("method.0.is.too.complex.too.analyze",method.getName()));
  }
  final PsiClass containingClass=method.getContainingClass();
  if (method.isConstructor()) {
    if (containingClass instanceof GrAnonymousClassDefinition) {
      myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("constructors.are.not.allowed.in.anonymous.class"));
    }
 else     if (containingClass != null && containingClass.isInterface()) {
      myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("constructors.are.not.allowed.in.interface"));
    }
  }
  if (!method.hasModifierProperty(ABSTRACT) && method.getBlock() == null && !method.hasModifierProperty(NATIVE)) {
    final Annotation annotation=myHolder.createErrorAnnotation(nameIdentifier,GroovyBundle.message("not.abstract.method.should.have.body"));
    annotation.registerFix(new AddMethodBodyFix(method));
  }
  checkOverridingMethod(myHolder,method);
}
