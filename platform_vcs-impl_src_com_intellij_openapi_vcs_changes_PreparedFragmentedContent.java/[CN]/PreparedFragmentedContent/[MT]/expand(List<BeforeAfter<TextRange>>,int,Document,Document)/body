{
  if (myRanges == null || myRanges.isEmpty())   return Collections.emptyList();
  if (lines == -1) {
    final List<BeforeAfter<TextRange>> shiftedRanges=new ArrayList<BeforeAfter<TextRange>>(1);
    shiftedRanges.add(new BeforeAfter<TextRange>(new TextRange(0,oldDocument.getLineCount() == 0 ? 0 : oldDocument.getLineCount() - 1),new TextRange(0,document.getLineCount() == 0 ? 0 : document.getLineCount() - 1)));
    return shiftedRanges;
  }
  final List<BeforeAfter<TextRange>> shiftedRanges=new ArrayList<BeforeAfter<TextRange>>(myRanges.size());
  final int oldLineCount=oldDocument.getLineCount();
  final int lineCount=document.getLineCount();
  for (  BeforeAfter<TextRange> range : myRanges) {
    final TextRange newBefore=expandRange(range.getBefore(),lines,oldLineCount);
    final TextRange newAfter=expandRange(range.getAfter(),lines,lineCount);
    shiftedRanges.add(new BeforeAfter<TextRange>(newBefore,newAfter));
  }
  final List<BeforeAfter<TextRange>> zippedRanges=new ArrayList<BeforeAfter<TextRange>>(myRanges.size());
  final ListIterator<BeforeAfter<TextRange>> iterator=shiftedRanges.listIterator();
  BeforeAfter<TextRange> previous=iterator.next();
  while (iterator.hasNext()) {
    final BeforeAfter<TextRange> current=iterator.next();
    if (neighbourOrIntersect(previous.getBefore(),current.getBefore()) || neighbourOrIntersect(previous.getAfter(),current.getAfter())) {
      previous=new BeforeAfter<TextRange>(previous.getBefore().union(current.getBefore()),previous.getAfter().union(current.getAfter()));
    }
 else {
      zippedRanges.add(previous);
      previous=current;
    }
  }
  zippedRanges.add(previous);
  return zippedRanges;
}
