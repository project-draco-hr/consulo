{
  mxGraph graph=layout.getGraph();
  for (int i=0; i < vertices.length; i++) {
    internalVertices[i]=new mxGraphHierarchyNode(vertices[i]);
    vertexMapper.put(vertices[i],internalVertices[i]);
    Object[] conns=layout.getEdges(vertices[i]);
    List<Object> outgoingCells=Arrays.asList(graph.getOpposites(conns,vertices[i]));
    internalVertices[i].connectsAsSource=new LinkedHashSet<mxGraphHierarchyEdge>(outgoingCells.size());
    Iterator<Object> iter=outgoingCells.iterator();
    while (iter.hasNext()) {
      Object cell=iter.next();
      if (cell != vertices[i] && graph.getModel().isVertex(cell) && !layout.isVertexIgnored(cell)) {
        Object[] undirectEdges=graph.getEdgesBetween(vertices[i],cell,false);
        Object[] directedEdges=graph.getEdgesBetween(vertices[i],cell,true);
        if (undirectEdges != null && undirectEdges.length > 0 && (edgeMapper.get(undirectEdges[0]) == null) && (directedEdges.length * 2 >= undirectEdges.length)) {
          ArrayList<Object> listEdges=new ArrayList<Object>(undirectEdges.length);
          for (int j=0; j < undirectEdges.length; j++) {
            listEdges.add(undirectEdges[j]);
          }
          mxGraphHierarchyEdge internalEdge=new mxGraphHierarchyEdge(listEdges);
          Iterator<Object> iter2=listEdges.iterator();
          while (iter2.hasNext()) {
            Object edge=iter2.next();
            edgeMapper.put(edge,internalEdge);
            graph.resetEdge(edge);
            if (layout.isDisableEdgeStyle()) {
              layout.setEdgeStyleEnabled(edge,false);
              layout.setOrthogonalEdge(edge,true);
            }
          }
          internalEdge.source=internalVertices[i];
          internalVertices[i].connectsAsSource.add(internalEdge);
        }
      }
    }
    internalVertices[i].temp[0]=0;
  }
}
