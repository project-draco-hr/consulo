{
  Collection<mxGraphHierarchyNode> internalNodes=vertexMapper.values();
  LinkedList<mxGraphHierarchyNode> startNodes=new LinkedList<mxGraphHierarchyNode>();
  if (roots != null) {
    Iterator<Object> iter=roots.iterator();
    while (iter.hasNext()) {
      mxGraphHierarchyNode internalNode=vertexMapper.get(iter.next());
      if (internalNode != null) {
        startNodes.add(internalNode);
      }
    }
  }
  Iterator<mxGraphHierarchyNode> iter=internalNodes.iterator();
  while (iter.hasNext()) {
    mxGraphHierarchyNode internalNode=iter.next();
    internalNode.temp[0]=-1;
  }
  List<mxGraphHierarchyNode> startNodesCopy=new ArrayList<mxGraphHierarchyNode>(startNodes);
  while (!startNodes.isEmpty()) {
    mxGraphHierarchyNode internalNode=startNodes.getFirst();
    Collection<mxGraphHierarchyEdge> layerDeterminingEdges;
    Collection<mxGraphHierarchyEdge> edgesToBeMarked;
    layerDeterminingEdges=internalNode.connectsAsTarget;
    edgesToBeMarked=internalNode.connectsAsSource;
    boolean allEdgesScanned=true;
    Iterator<mxGraphHierarchyEdge> iter2=layerDeterminingEdges.iterator();
    int minimumLayer=SOURCESCANSTARTRANK;
    while (allEdgesScanned && iter2.hasNext()) {
      mxGraphHierarchyEdge internalEdge=iter2.next();
      if (internalEdge.temp[0] == 5270620) {
        mxGraphHierarchyNode otherNode=internalEdge.source;
        minimumLayer=Math.min(minimumLayer,otherNode.temp[0] - 1);
      }
 else {
        allEdgesScanned=false;
      }
    }
    if (allEdgesScanned) {
      internalNode.temp[0]=minimumLayer;
      maxRank=Math.min(maxRank,minimumLayer);
      if (edgesToBeMarked != null) {
        Iterator<mxGraphHierarchyEdge> iter3=edgesToBeMarked.iterator();
        while (iter3.hasNext()) {
          mxGraphHierarchyEdge internalEdge=iter3.next();
          internalEdge.temp[0]=5270620;
          mxGraphHierarchyNode otherNode=internalEdge.target;
          if (otherNode.temp[0] == -1) {
            startNodes.addLast(otherNode);
            otherNode.temp[0]=-2;
          }
        }
      }
      startNodes.removeFirst();
    }
 else {
      Object removedCell=startNodes.removeFirst();
      startNodes.addLast(internalNode);
      if (removedCell == internalNode && startNodes.size() == 1) {
        break;
      }
    }
  }
  iter=internalNodes.iterator();
  while (iter.hasNext()) {
    mxGraphHierarchyNode internalNode=iter.next();
    internalNode.temp[0]-=maxRank;
  }
  for (int i=0; i < startNodesCopy.size(); i++) {
    mxGraphHierarchyNode internalNode=startNodesCopy.get(i);
    int currentMaxLayer=0;
    Iterator<mxGraphHierarchyEdge> iter2=internalNode.connectsAsSource.iterator();
    while (iter2.hasNext()) {
      mxGraphHierarchyEdge internalEdge=iter2.next();
      mxGraphHierarchyNode otherNode=internalEdge.target;
      internalNode.temp[0]=Math.max(currentMaxLayer,otherNode.temp[0] + 1);
      currentMaxLayer=internalNode.temp[0];
    }
  }
  maxRank=SOURCESCANSTARTRANK - maxRank;
}
