{
  final List<ProcessingItem> processedItems=new ArrayList<ProcessingItem>();
  for (  ProcessingItem item : items) {
    final MyProcessingItem processingItem=(MyProcessingItem)item;
    if (!AndroidCompileUtil.isModuleAffected(context,processingItem.myModule)) {
      continue;
    }
    final List<VirtualFile> cfgFiles=processingItem.getProguardConfigFiles();
    final String[] proguardCfgOsPaths=AndroidCompileUtil.toOsPaths(cfgFiles.toArray(new VirtualFile[cfgFiles.size()]));
    final String[] classFilesDirOsPaths=AndroidCompileUtil.toOsPaths(processingItem.getClassFilesDirs());
    final String[] libClassFilesDirOsPaths=AndroidCompileUtil.toOsPaths(processingItem.getLibClassFilesDirs());
    final String[] externalJarOsPaths=AndroidCompileUtil.toOsPaths(processingItem.getExternalJars());
    try {
      final String inputJarOsPath=AndroidCommonUtils.buildTempInputJar(classFilesDirOsPaths,libClassFilesDirOsPaths);
      final String logsDirOsPath=processingItem.getLogsDirectoryOsPath();
      final Map<CompilerMessageCategory,List<String>> messages=AndroidCompileUtil.toCompilerMessageCategoryKeys(AndroidCommonUtils.launchProguard(processingItem.getTarget(),processingItem.getSdkToolsRevision(),processingItem.getSdkOsPath(),proguardCfgOsPaths,processingItem.isIncludeSystemProguardFile(),inputJarOsPath,externalJarOsPaths,processingItem.getOutputJarOsPath(),logsDirOsPath));
      CompilerUtil.refreshIOFile(new File(processingItem.getOutputJarOsPath()));
      AndroidCompileUtil.addMessages(context,messages,processingItem.myModule);
      if (messages.get(CompilerMessageCategory.ERROR).isEmpty()) {
        processedItems.add(item);
      }
    }
 catch (    IOException e) {
      if (e.getMessage() == null) {
        LOG.error(e);
      }
 else {
        LOG.info(e);
        context.addMessage(CompilerMessageCategory.ERROR,"I/O error: " + e.getMessage(),null,-1,-1);
      }
    }
  }
  return processedItems.toArray(new ProcessingItem[processedItems.size()]);
}
