{
  List<ThreadState> result=new ArrayList<ThreadState>();
  StringBuilder lastThreadStack=new StringBuilder();
  ThreadState lastThreadState=null;
  boolean expectingThreadState=false;
  boolean haveNonEmptyStackTrace=false;
  for (  @NonNls String line : StringUtil.tokenize(threadDump,"\r\n")) {
    if (line.startsWith("============") || line.contains("Java-level deadlock")) {
      break;
    }
    ThreadState state=tryParseThreadStart(line);
    if (state != null) {
      if (lastThreadState != null) {
        lastThreadState.setStackTrace(lastThreadStack.toString(),!haveNonEmptyStackTrace);
      }
      lastThreadState=state;
      result.add(lastThreadState);
      lastThreadStack.setLength(0);
      haveNonEmptyStackTrace=false;
      lastThreadStack.append(line).append("\n");
      expectingThreadState=true;
    }
 else {
      boolean parsedThreadState=false;
      if (expectingThreadState) {
        expectingThreadState=false;
        parsedThreadState=tryParseThreadState(line,lastThreadState);
      }
      lastThreadStack.append(line).append("\n");
      if (!parsedThreadState && line.trim().startsWith("at")) {
        haveNonEmptyStackTrace=true;
      }
    }
  }
  if (lastThreadState != null) {
    lastThreadState.setStackTrace(lastThreadStack.toString(),!haveNonEmptyStackTrace);
  }
  for (  ThreadState threadState : result) {
    inferThreadStateDetail(threadState);
    final String s=findWaitingForLock(threadState.getStackTrace());
    if (s != null) {
      for (      ThreadState lockOwner : result) {
        if (lockOwner == threadState) {
          continue;
        }
        final String marker="- locked <" + s + ">";
        if (lockOwner.getStackTrace().contains(marker)) {
          if (threadState.isAwaitedBy(lockOwner)) {
            threadState.addDeadlockedThread(lockOwner);
            lockOwner.addDeadlockedThread(threadState);
          }
          lockOwner.addWaitingThread(threadState);
          break;
        }
      }
    }
  }
  sortThreads(result);
  return result;
}
