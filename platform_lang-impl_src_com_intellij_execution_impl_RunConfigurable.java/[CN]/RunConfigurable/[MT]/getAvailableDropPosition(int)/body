{
  int[] rows=myTree.getSelectionRows();
  if (rows == null || rows.length != 1) {
    return null;
  }
  int oldIndex=rows[0];
  int newIndex=oldIndex + direction;
  if (!getKind((DefaultMutableTreeNode)myTree.getPathForRow(oldIndex).getLastPathComponent()).supportsDnD())   return null;
  while (newIndex > 0 && newIndex < myTree.getRowCount()) {
    TreePath targetPath=myTree.getPathForRow(newIndex);
    boolean allowInto=getKind((DefaultMutableTreeNode)targetPath.getLastPathComponent()) == FOLDER && !myTree.isExpanded(targetPath);
    RowsDnDSupport.RefinedDropSupport.Position position=allowInto && myTreeModel.isDropInto(myTree,oldIndex,newIndex) ? INTO : direction > 0 ? BELOW : ABOVE;
    if (myTreeModel.canDrop(oldIndex,newIndex,position)) {
      return Trinity.create(oldIndex,newIndex,position);
    }
    if (position == BELOW && newIndex < myTree.getRowCount() - 1 && myTreeModel.canDrop(oldIndex,newIndex + 1,ABOVE)) {
      return Trinity.create(oldIndex,newIndex + 1,ABOVE);
    }
    if (position == ABOVE && newIndex > 1 && myTreeModel.canDrop(oldIndex,newIndex - 1,BELOW)) {
      return Trinity.create(oldIndex,newIndex - 1,BELOW);
    }
    if (position == BELOW && myTreeModel.canDrop(oldIndex,newIndex,ABOVE)) {
      return Trinity.create(oldIndex,newIndex,ABOVE);
    }
    if (position == ABOVE && myTreeModel.canDrop(oldIndex,newIndex,BELOW)) {
      return Trinity.create(oldIndex,newIndex,BELOW);
    }
    newIndex+=direction;
  }
  return null;
}
