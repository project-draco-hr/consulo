{
  if (namespacePrefix.length() == 0 && (!(element instanceof XmlTag) || !(element.getParent() instanceof XmlDocument)) || XML.equals(namespacePrefix)) {
    return;
  }
  final String namespaceByPrefix=context.getNamespaceByPrefix(namespacePrefix);
  if (namespaceByPrefix.length() != 0) {
    return;
  }
  final XmlFile containingFile=(XmlFile)context.getContainingFile();
  if (!HighlightLevelUtil.shouldInspect(containingFile))   return;
  final XmlExtension extension=XmlExtension.getExtension(containingFile);
  if (extension.isPrefixDeclared(context,namespacePrefix)) {
    return;
  }
  final String localizedMessage=XmlErrorMessages.message("unbound.namespace",namespacePrefix);
  if (namespacePrefix.length() == 0) {
    final XmlTag tag=(XmlTag)element;
    if (!XmlUtil.JSP_URI.equals(tag.getNamespace())) {
      reportTagProblem(tag,localizedMessage,null,ProblemHighlightType.INFORMATION,withFixes ? new CreateNSDeclarationIntentionFix(context,namespacePrefix,token) : null,holder);
    }
    return;
  }
  final int prefixLength=namespacePrefix.length();
  final TextRange range=new TextRange(0,prefixLength);
  final HighlightInfoType infoType=extension.getHighlightInfoType(containingFile);
  final ProblemHighlightType highlightType=infoType == HighlightInfoType.ERROR ? ProblemHighlightType.ERROR : ProblemHighlightType.LIKE_UNKNOWN_SYMBOL;
  if (element instanceof XmlTag) {
    final CreateNSDeclarationIntentionFix fix=withFixes ? new CreateNSDeclarationIntentionFix(context,namespacePrefix,token) : null;
    reportTagProblem(element,localizedMessage,range,highlightType,fix,holder);
  }
 else {
    holder.registerProblem(element,localizedMessage,highlightType,range);
  }
}
