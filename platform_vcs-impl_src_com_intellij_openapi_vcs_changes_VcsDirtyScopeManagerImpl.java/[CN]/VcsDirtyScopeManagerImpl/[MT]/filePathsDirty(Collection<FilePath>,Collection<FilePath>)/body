{
  try {
    final MultiMap<AbstractVcs,FilePath> filesConverted=groupByVcs(filesDirty);
    final MultiMap<AbstractVcs,FilePath> dirsConverted=groupByVcs(dirsRecursivelyDirty);
    if (filesConverted.isEmpty() && dirsConverted.isEmpty())     return;
    if (LOG.isDebugEnabled()) {
      LOG.debug("dirty files: " + toString(filesConverted) + "; dirty dirs: "+ toString(dirsConverted)+ "; "+ findFirstInterestingCallerClass());
    }
    boolean hasSomethingDirty;
synchronized (LOCK) {
      if (!myReady)       return;
      markDirty(myDirtBuilder,filesConverted,false);
      markDirty(myDirtBuilder,dirsConverted,true);
      hasSomethingDirty=!myDirtBuilder.isEmpty();
    }
    if (hasSomethingDirty) {
      myChangeListManager.scheduleUpdate();
    }
  }
 catch (  ProcessCanceledException ignore) {
  }
}
