{
  pathHandler.startPath();
  current=reader.read();
  loop:   for (; ; ) {
    try {
switch (current) {
case 0xD:
case 0xA:
case 0x20:
case 0x9:
        current=reader.read();
      break;
case 'z':
case 'Z':
    current=reader.read();
  pathHandler.closePath();
break;
case 'm':
parsem();
break;
case 'M':
parseM();
break;
case 'l':
parsel();
break;
case 'L':
parseL();
break;
case 'h':
parseh();
break;
case 'H':
parseH();
break;
case 'v':
parsev();
break;
case 'V':
parseV();
break;
case 'c':
parsec();
break;
case 'C':
parseC();
break;
case 'q':
parseq();
break;
case 'Q':
parseQ();
break;
case 's':
parses();
break;
case 'S':
parseS();
break;
case 't':
parset();
break;
case 'T':
parseT();
break;
case 'a':
parsea();
break;
case 'A':
parseA();
break;
case -1:
break loop;
default :
reportUnexpected(current);
break;
}
}
 catch (ParseException e) {
errorHandler.error(e);
skipSubPath();
}
}
skipSpaces();
if (current != -1) {
reportError("end.of.stream.expected",new Object[]{new Integer(current)});
}
pathHandler.endPath();
}
