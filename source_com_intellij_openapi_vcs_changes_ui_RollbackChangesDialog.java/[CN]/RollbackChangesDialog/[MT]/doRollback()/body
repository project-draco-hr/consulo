{
  final List<VcsException> vcsExceptions=new ArrayList<VcsException>();
  final List<FilePath> pathsToRefresh=new ArrayList<FilePath>();
  Runnable rollbackAction=new Runnable(){
    public void run(){
      ChangesUtil.processChangesByVcs(myProject,myBrowser.getCurrentIncludedChanges(),new ChangesUtil.PerVcsProcessor<Change>(){
        public void process(        AbstractVcs vcs,        List<Change> changes){
          final ChangeProvider environment=vcs.getChangeProvider();
          if (environment != null) {
            pathsToRefresh.addAll(getFilePaths(changes));
            final List<VcsException> exceptions=environment.rollbackChanges(changes);
            if (exceptions.size() > 0) {
              vcsExceptions.addAll(exceptions);
            }
          }
        }
      }
);
      if (!myRefreshSynchronously) {
        doRefresh(pathsToRefresh,true);
      }
      AbstractVcsHelper.getInstance(myProject).showErrors(vcsExceptions,VcsBundle.message("changes.action.rollback.text"));
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(rollbackAction,VcsBundle.message("changes.action.rollback.text"),true,myProject);
  if (myRefreshSynchronously) {
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      public void run(){
        doRefresh(pathsToRefresh,false);
      }
    }
);
  }
}
