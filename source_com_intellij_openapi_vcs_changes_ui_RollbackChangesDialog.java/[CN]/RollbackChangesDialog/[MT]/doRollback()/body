{
  final List<VcsException> vcsExceptions=new ArrayList<VcsException>();
  Runnable rollbackAction=new Runnable(){
    public void run(){
      final List<FilePath> pathsToRefresh=new ArrayList<FilePath>();
      ChangesUtil.processChangesByVcs(myProject,myBrowser.getCurrentIncludedChanges(),new ChangesUtil.PerVcsProcessor<Change>(){
        public void process(        AbstractVcs vcs,        List<Change> changes){
          final ChangeProvider environment=vcs.getChangeProvider();
          if (environment != null) {
            pathsToRefresh.addAll(getFilePathes(changes));
            final List<VcsException> exceptions=environment.rollbackChanges(changes);
            if (exceptions.size() > 0) {
              vcsExceptions.addAll(exceptions);
            }
          }
        }
      }
);
      final LvcsAction lvcsAction=LocalVcs.getInstance(myProject).startAction("Rollback","",true);
      VirtualFileManager.getInstance().refresh(true,new Runnable(){
        public void run(){
          lvcsAction.finish();
          FileStatusManager.getInstance(myProject).fileStatusesChanged();
          for (          FilePath path : pathsToRefresh) {
            VcsDirtyScopeManager.getInstance(myProject).fileDirty(path);
          }
        }
      }
);
      AbstractVcsHelper.getInstance(myProject).showErrors(vcsExceptions,"Rollback");
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(rollbackAction,"Rollback",true,myProject);
}
