{
  if (root.canRepresent(element))   return new AsyncResult.Done<AbstractTreeNode>(root);
  if (root instanceof ProjectViewNode && file != null && !((ProjectViewNode)root).contains(file)) {
    return new AsyncResult.Rejected<AbstractTreeNode>();
  }
  final AsyncResult<AbstractTreeNode> async=new AsyncResult<AbstractTreeNode>();
  expand(root,new Runnable(){
    public void run(){
      final DefaultMutableTreeNode rootNode=getNodeForElement(root);
      if (rootNode != null) {
        final List<AbstractTreeNode> kids=collectChildren(rootNode);
        for (        final AbstractTreeNode node : kids) {
          final boolean[] nodeWasCollapsed=new boolean[]{true};
          final DefaultMutableTreeNode nodeForElement=getNodeForElement(node);
          if (nodeForElement != null) {
            nodeWasCollapsed[0]=getTree().isCollapsed(new TreePath(nodeForElement.getPath()));
          }
          if (nonStopCondition.value(node)) {
            expandPathTo(file,node,element,nonStopCondition).doWhenDone(new AsyncResult.Handler<AbstractTreeNode>(){
              public void run(              AbstractTreeNode abstractTreeNode){
                async.setDone(abstractTreeNode);
              }
            }
).doWhenRejected(new Runnable(){
              public void run(){
                if (nodeWasCollapsed[0]) {
                  collapseChildren(node,null);
                }
              }
            }
);
          }
 else {
            async.setRejected();
          }
        }
      }
 else {
        async.setRejected();
      }
    }
  }
);
  return async;
}
