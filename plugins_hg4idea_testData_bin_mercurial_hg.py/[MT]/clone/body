def clone(ui, source, dest=None, pull=False, rev=None, update=True, stream=False, branch=None):
    "Make a copy of an existing repository.\n\n    Create a copy of an existing repository in a new directory.  The\n    source and destination are URLs, as passed to the repository\n    function.  Returns a pair of repository objects, the source and\n    newly created destination.\n\n    The location of the source is added to the new repository's\n    .hg/hgrc file, as the default to be used for future pulls and\n    pushes.\n\n    If an exception is raised, the partly cloned/updated destination\n    repository will be deleted.\n\n    Arguments:\n\n    source: repository object or URL\n\n    dest: URL of destination repository to create (defaults to base\n    name of source repository)\n\n    pull: always pull from source repository, even in local case\n\n    stream: stream raw data uncompressed from repository (fast over\n    LAN, slow over WAN)\n\n    rev: revision to clone up to (implies pull=True)\n\n    update: update working directory after clone completes, if\n    destination is local repository (True means update to default rev,\n    anything else is treated as a revision)\n\n    branch: branches to clone\n    "
    if isinstance(source, str):
        origsource = ui.expandpath(source)
        (source, branch) = parseurl(origsource, branch)
        src_repo = repository(ui, source)
    else:
        src_repo = source
        branch = None
        origsource = source = src_repo.url()
    (rev, checkout) = addbranchrevs(src_repo, src_repo, branch, rev)
    if (dest is None):
        dest = defaultdest(source)
        ui.status((_('destination directory: %s\n') % dest))
    else:
        dest = ui.expandpath(dest)
    dest = localpath(dest)
    source = localpath(source)
    if os.path.exists(dest):
        if (not os.path.isdir(dest)):
            raise util.Abort((_("destination '%s' already exists") % dest))
        elif os.listdir(dest):
            raise util.Abort((_("destination '%s' is not empty") % dest))


    class DirCleanup(object):

        def __init__(self, dir_):
            self.rmtree = shutil.rmtree
            self.dir_ = dir_

        def close(self):
            self.dir_ = None

        def cleanup(self):
            if self.dir_:
                self.rmtree(self.dir_, True)
    src_lock = dest_lock = dir_cleanup = None
    try:
        if islocal(dest):
            dir_cleanup = DirCleanup(dest)
        abspath = origsource
        copy = False
        if (src_repo.cancopy() and islocal(dest)):
            abspath = os.path.abspath(util.drop_scheme('file', origsource))
            copy = ((not pull) and (not rev))
        if copy:
            try:
                src_lock = src_repo.lock(wait=False)
            except error.LockError:
                copy = False
        if copy:
            src_repo.hook('preoutgoing', throw=True, source='clone')
            hgdir = os.path.realpath(os.path.join(dest, '.hg'))
            if (not os.path.exists(dest)):
                os.mkdir(dest)
            else:
                dir_cleanup.dir_ = hgdir
            try:
                dest_path = hgdir
                os.mkdir(dest_path)
            except OSError as inst:
                if (inst.errno == errno.EEXIST):
                    dir_cleanup.close()
                    raise util.Abort((_("destination '%s' already exists") % dest))
                raise
            for f in src_repo.store.copylist():
                src = os.path.join(src_repo.sharedpath, f)
                dst = os.path.join(dest_path, f)
                dstbase = os.path.dirname(dst)
                if (dstbase and (not os.path.exists(dstbase))):
                    os.mkdir(dstbase)
                if os.path.exists(src):
                    if dst.endswith('data'):
                        dest_lock = lock.lock(os.path.join(dstbase, 'lock'))
                    util.copyfiles(src, dst)
            dest_repo = repository(ui, dest)
            src_repo.hook('outgoing', source='clone', node=('0' * 40))
        else:
            try:
                dest_repo = repository(ui, dest, create=True)
            except OSError as inst:
                if (inst.errno == errno.EEXIST):
                    dir_cleanup.close()
                    raise util.Abort((_("destination '%s' already exists") % dest))
                raise
            revs = None
            if rev:
                if ('lookup' not in src_repo.capabilities):
                    raise util.Abort(_("src repository does not support revision lookup and so doesn't support clone by revision"))
                revs = [src_repo.lookup(r) for r in rev]
                checkout = revs[0]
            if dest_repo.local():
                dest_repo.clone(src_repo, heads=revs, stream=stream)
            elif src_repo.local():
                src_repo.push(dest_repo, revs=revs)
            else:
                raise util.Abort(_('clone from remote to remote not supported'))
        if dir_cleanup:
            dir_cleanup.close()
        if dest_repo.local():
            fp = dest_repo.opener('hgrc', 'w', text=True)
            fp.write('[paths]\n')
            fp.write(('default = %s\n' % abspath))
            fp.close()
            dest_repo.ui.setconfig('paths', 'default', abspath)
            if update:
                if (update is not True):
                    checkout = update
                    if src_repo.local():
                        checkout = src_repo.lookup(update)
                for test in (checkout, 'default', 'tip'):
                    if (test is None):
                        continue
                    try:
                        uprev = dest_repo.lookup(test)
                        break
                    except error.RepoLookupError:
                        continue
                bn = dest_repo[uprev].branch()
                dest_repo.ui.status((_('updating to branch %s\n') % encoding.tolocal(bn)))
                _update(dest_repo, uprev)
        return (src_repo, dest_repo)
    finally:
        release(src_lock, dest_lock)
        if (dir_cleanup is not None):
            dir_cleanup.cleanup()
