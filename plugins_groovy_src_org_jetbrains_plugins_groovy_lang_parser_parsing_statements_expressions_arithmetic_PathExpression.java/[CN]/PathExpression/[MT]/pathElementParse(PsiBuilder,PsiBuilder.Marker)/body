{
  TokenSet DOTS=TokenSet.create(mSPREAD_DOT,mOPTIONAL_DOT,mMEMBER_POINTER,mDOT);
  GroovyElementType res;
  if (DOTS.contains(builder.getTokenType()) || ParserUtils.lookAhead(builder,mNLS,mDOT)) {
    if (ParserUtils.lookAhead(builder,mNLS,mDOT)) {
      ParserUtils.getToken(builder,mNLS);
    }
    ParserUtils.getToken(builder,DOTS);
    ParserUtils.getToken(builder,mNLS);
    TypeArguments.parse(builder);
    res=namePartParse(builder);
    if (!res.equals(WRONGWAY)) {
      if (mLPAREN.equals(builder.getTokenType()) || mLCURLY.equals(builder.getTokenType())) {
        pathElementParse(builder,marker);
      }
 else {
        PsiBuilder.Marker newMarker=marker.precede();
        marker.done(PATH_PROPERTY_REFERENCE);
        pathElementParse(builder,newMarker);
      }
    }
 else {
      builder.error(GroovyBundle.message("path.selector.expected"));
      marker.drop();
    }
  }
 else   if (mLPAREN.equals(builder.getTokenType())) {
    methodCallArgsParse(builder);
    if (mLCURLY.equals(builder.getTokenType())) {
      pathElementParse(builder,marker);
    }
 else {
      PsiBuilder.Marker newMarker=marker.precede();
      marker.done(PATH_METHOD_CALL);
      pathElementParse(builder,newMarker);
    }
  }
 else   if (mLCURLY.equals(builder.getTokenType())) {
    appendedBlockParse(builder);
    PsiBuilder.Marker newMarker=marker.precede();
    marker.done(PATH_METHOD_CALL);
    pathElementParse(builder,newMarker);
  }
 else   if (mLBRACK.equals(builder.getTokenType()) && !ParserUtils.lookAhead(builder,mLBRACK,mCOLON) && !ParserUtils.lookAhead(builder,mLBRACK,mNLS,mCOLON)) {
    indexPropertyArgsParse(builder);
    PsiBuilder.Marker newMarker=marker.precede();
    marker.done(PATH_INDEX_PROPERTY);
    pathElementParse(builder,newMarker);
  }
 else {
    marker.drop();
  }
  return PATH_EXPRESSION;
}
