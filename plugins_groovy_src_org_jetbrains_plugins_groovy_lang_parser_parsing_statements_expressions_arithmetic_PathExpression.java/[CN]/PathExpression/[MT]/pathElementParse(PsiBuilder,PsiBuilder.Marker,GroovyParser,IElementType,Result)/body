{
  GroovyElementType res;
  if (DOTS.contains(builder.getTokenType()) || ParserUtils.lookAhead(builder,mNLS,mDOT)) {
    if (ParserUtils.lookAhead(builder,mNLS,mDOT)) {
      ParserUtils.getToken(builder,mNLS);
    }
    ParserUtils.getToken(builder,DOTS);
    ParserUtils.getToken(builder,mNLS);
    TypeArguments.parse(builder);
    if (kNEW.equals(builder.getTokenType())) {
      res=PrimaryExpression.newExprParse(builder,parser,marker);
    }
 else     if (kTHIS.equals(builder.getTokenType()) || kSUPER.equals(builder.getTokenType())) {
      res=parseThisSuperExpression(builder,qualifierType);
    }
 else {
      res=namePartParse(builder,parser);
    }
    if (!res.equals(WRONGWAY)) {
      PsiBuilder.Marker newMarker=marker.precede();
      marker.done(res);
      if (checkForLCurly(builder)) {
        PsiBuilder.Marker argsMarker=builder.mark();
        argsMarker.done(ARGUMENTS);
        ParserUtils.getToken(builder,mNLS);
        result=pathElementParse(builder,newMarker,parser,res,METHOD_CALL);
      }
 else {
        result=pathElementParse(builder,newMarker,parser,res,INVOKED_EXPR);
      }
    }
 else {
      builder.error(GroovyBundle.message("path.selector.expected"));
      marker.drop();
    }
  }
 else   if (mLPAREN.equals(builder.getTokenType())) {
    PrimaryExpression.methodCallArgsParse(builder,parser);
    if (checkForLCurly(builder)) {
      ParserUtils.getToken(builder,mNLS);
      result=pathElementParse(builder,marker,parser,qualifierType,METHOD_CALL);
    }
 else {
      PsiBuilder.Marker newMarker=marker.precede();
      marker.done(PATH_METHOD_CALL);
      result=pathElementParse(builder,newMarker,parser,qualifierType,METHOD_CALL);
    }
  }
 else   if (checkForLCurly(builder)) {
    ParserUtils.getToken(builder,mNLS);
    appendedBlockParse(builder,parser);
    if (checkForLCurly(builder)) {
      ParserUtils.getToken(builder,mNLS);
      result=pathElementParse(builder,marker,parser,qualifierType,METHOD_CALL);
    }
 else {
      PsiBuilder.Marker newMarker=marker.precede();
      marker.done(PATH_METHOD_CALL);
      result=pathElementParse(builder,newMarker,parser,PATH_METHOD_CALL,METHOD_CALL);
    }
  }
 else   if (checkForArrayAccess(builder)) {
    indexPropertyArgsParse(builder,parser);
    PsiBuilder.Marker newMarker=marker.precede();
    marker.done(PATH_INDEX_PROPERTY);
    if (checkForLCurly(builder)) {
      PsiBuilder.Marker argsMarker=builder.mark();
      argsMarker.done(ARGUMENTS);
      ParserUtils.getToken(builder,mNLS);
      result=pathElementParse(builder,newMarker,parser,PATH_INDEX_PROPERTY,METHOD_CALL);
    }
 else {
      result=pathElementParse(builder,newMarker,parser,PATH_INDEX_PROPERTY,INVOKED_EXPR);
    }
  }
 else {
    marker.drop();
  }
  return result;
}
