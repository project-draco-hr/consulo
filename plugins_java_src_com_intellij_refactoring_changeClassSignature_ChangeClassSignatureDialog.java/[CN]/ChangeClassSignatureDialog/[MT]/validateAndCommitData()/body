{
  final PsiTypeParameter[] parameters=myClass.getTypeParameters();
  final Map<String,TypeParameterInfo> infos=new HashMap<String,TypeParameterInfo>();
  for (  final TypeParameterInfo info : myTypeParameterInfos) {
    if (!info.isForExistingParameter() && !JavaPsiFacade.getInstance(myClass.getProject()).getNameHelper().isIdentifier(info.getNewName())) {
      return RefactoringBundle.message("error.wrong.name.input",info.getNewName());
    }
    final String newName=info.isForExistingParameter() ? parameters[info.getOldParameterIndex()].getName() : info.getNewName();
    TypeParameterInfo existing=infos.get(newName);
    if (existing != null) {
      return myClass.getName() + " already contains type parameter " + newName;
    }
    infos.put(newName,info);
  }
  LOG.assertTrue(myTypeCodeFragments.size() == myTypeParameterInfos.size());
  for (int i=0; i < myTypeCodeFragments.size(); i++) {
    final PsiTypeCodeFragment codeFragment=myTypeCodeFragments.get(i);
    TypeParameterInfo info=myTypeParameterInfos.get(i);
    if (info.getOldParameterIndex() >= 0)     continue;
    PsiType type;
    try {
      type=codeFragment.getType();
      if (type instanceof PsiPrimitiveType) {
        return "Type parameter can't be primitive";
      }
    }
 catch (    PsiTypeCodeFragment.TypeSyntaxException e) {
      return RefactoringBundle.message("changeClassSignature.bad.default.value",codeFragment.getText(),info.getNewName());
    }
catch (    PsiTypeCodeFragment.NoTypeException e) {
      return RefactoringBundle.message("changeSignature.no.type.for.parameter",info.getNewName());
    }
    info.setDefaultValue(type);
  }
  return null;
}
