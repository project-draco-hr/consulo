{
  final StringCharacterIterator it=new StringCharacterIterator(methodSignature);
  final StringBuilder formals=new StringBuilder();
  if (it.current() == '<') {
    SignatureParser.INSTANCE.parseFormalTypeParameters(it,formals);
  }
  if (it.current() != '(') {
    throw new SignatureParsingException(CompilerBundle.message("error.signature.parsing.expected.other.symbol","(",formals.toString()));
  }
  it.next();
  final String[] paramSignatures;
  if (it.current() != ')') {
    final List<String> params=new ArrayList<String>();
    while (it.current() != ')') {
      final StringBuilder typeSignature=new StringBuilder();
      SignatureParser.INSTANCE.parseTypeSignature(it,typeSignature);
      params.add(typeSignature.toString());
    }
    paramSignatures=ArrayUtil.toStringArray(params);
  }
 else {
    paramSignatures=ArrayUtil.EMPTY_STRING_ARRAY;
  }
  it.next();
  final StringBuilder returnTypeSignature=new StringBuilder();
  SignatureParser.INSTANCE.parseReturnType(it,returnTypeSignature);
  final StringBuilder throwsSignature=new StringBuilder();
  if (it.current() != CharacterIterator.DONE) {
    SignatureParser.INSTANCE.parseThrowsSignature(it,throwsSignature);
  }
  return new GenericMethodSignature(formals.toString(),paramSignatures,returnTypeSignature.toString(),throwsSignature.toString());
}
