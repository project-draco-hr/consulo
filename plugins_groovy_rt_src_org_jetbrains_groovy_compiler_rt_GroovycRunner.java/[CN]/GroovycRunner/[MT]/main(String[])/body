{
  if (args.length != 2) {
    if (args.length != 3 || !"--indy".equals(args[2])) {
      System.err.println("There is no arguments for groovy compiler");
      System.exit(1);
    }
    System.setProperty("groovy.target.indy","true");
  }
  final boolean forStubs="stubs".equals(args[0]);
  final File argsFile=new File(args[1]);
  if (!argsFile.exists()) {
    System.err.println("Arguments file for groovy compiler not found");
    System.exit(1);
  }
  try {
    final CompilerConfiguration config=new CompilerConfiguration();
    config.setClasspath("");
    config.setOutput(new PrintWriter(System.err));
    config.setWarningLevel(WarningMessage.PARANOIA);
    final List<CompilerMessage> compilerMessages=new ArrayList<CompilerMessage>();
    final List<CompilationUnitPatcher> patchers=new ArrayList<CompilationUnitPatcher>();
    final List<File> srcFiles=new ArrayList<File>();
    final Map<String,File> class2File=new HashMap<String,File>();
    final String[] finalOutput=new String[1];
    fillFromArgsFile(argsFile,config,patchers,compilerMessages,srcFiles,class2File,finalOutput);
    if (srcFiles.isEmpty())     return;
    if (forStubs) {
      Map<String,Object> options=new HashMap<String,Object>();
      options.put("stubDir",config.getTargetDirectory());
      options.put("keepStubs",Boolean.TRUE);
      config.setJointCompilationOptions(options);
    }
    System.out.println(GroovyRtConstants.PRESENTABLE_MESSAGE + "Groovyc: loading sources...");
    final AstAwareResourceLoader resourceLoader=new AstAwareResourceLoader(class2File);
    final CompilationUnit unit=createCompilationUnit(forStubs,config,finalOutput[0],buildClassLoaderFor(config,resourceLoader));
    unit.addPhaseOperation(new CompilationUnit.SourceUnitOperation(){
      public void call(      SourceUnit source) throws CompilationFailedException {
        File file=new File(source.getName());
        for (        ClassNode aClass : source.getAST().getClasses()) {
          resourceLoader.myClass2File.put(aClass.getName(),file);
        }
      }
    }
,Phases.CONVERSION);
    addSources(forStubs,srcFiles,unit);
    runPatchers(patchers,compilerMessages,unit,resourceLoader,srcFiles);
    System.out.println(GroovyRtConstants.PRESENTABLE_MESSAGE + "Groovyc: compiling...");
    final List<GroovyCompilerWrapper.OutputItem> compiledFiles=new GroovyCompilerWrapper(compilerMessages,forStubs).compile(unit);
    System.out.println(GroovyRtConstants.CLEAR_PRESENTABLE);
    System.out.println();
    reportCompiledItems(compiledFiles);
    System.out.println();
    if (compiledFiles.isEmpty()) {
      reportNotCompiledItems(srcFiles);
    }
    int errorCount=0;
    for (    CompilerMessage message : compilerMessages) {
      if (message.getCategory() == GroovyCompilerMessageCategories.ERROR) {
        if (errorCount > 100) {
          continue;
        }
        errorCount++;
      }
      printMessage(message);
    }
  }
 catch (  Throwable e) {
    e.printStackTrace();
    System.exit(1);
  }
}
