{
  final PsiTryStatement tryStatement=PsiTreeUtil.getParentOfType(location,PsiTryStatement.class);
  final PsiCodeBlock tryBlock=tryStatement.getTryBlock();
  final PsiElementFactory factory=tryStatement.getManager().getElementFactory();
  final Set<PsiType> exceptionsThrown=ExceptionUtils.calculateExceptionsThrown(tryBlock,factory);
  final int numExceptionsThrown=exceptionsThrown.size();
  final Set<PsiType> exceptionsCaught=new HashSet<PsiType>(numExceptionsThrown);
  final PsiParameter[] parameters=tryStatement.getCatchBlockParameters();
  final List<String> typesMasked=new ArrayList<String>();
  for (  final PsiParameter parameter : parameters) {
    if (parameter.equals(location.getParent())) {
      final PsiType typeCaught=parameter.getType();
      for (      Object aExceptionsThrown : exceptionsThrown) {
        final PsiType typeThrown=(PsiType)aExceptionsThrown;
        if (exceptionsCaught.contains(typeThrown)) {
        }
 else         if (typeCaught.equals(typeThrown)) {
          exceptionsCaught.add(typeCaught);
        }
 else         if (typeCaught.isAssignableFrom(typeThrown)) {
          exceptionsCaught.add(typeCaught);
          typesMasked.add(typeThrown.getPresentableText());
        }
      }
    }
  }
  Collections.sort(typesMasked);
  String typesMaskedString="";
  for (int i=0; i < typesMasked.size(); i++) {
    if (i == typesMasked.size() - 1) {
      typesMaskedString+=" and ";
    }
 else     if (i != 0) {
      typesMaskedString+=", ";
    }
    typesMaskedString+=typesMasked.get(i);
  }
  if (typesMasked.size() == 1) {
    return "Catch of #ref is too broad, masking exception " + typesMaskedString + "  #loc";
  }
 else {
    return "Catch of #ref is too broad, masking exceptions " + typesMaskedString + "  #loc";
  }
}
