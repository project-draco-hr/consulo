{
  Set<DocumentReference> otherAffected=new HashSet<DocumentReference>();
  if (!myUndoableGroup.isValid()) {
    reportCannotUndo(CommonBundle.message("cannot.undo.error.roots.was.changed.message"),myUndoableGroup.getAffectedDocuments());
    return;
  }
  if (containsAnotherChanges(otherAffected)) {
    reportCannotUndo(CommonBundle.message("cannot.undo.error.other.affected.files.changed.message"),otherAffected);
    return;
  }
  if (containsNonUndoableActions()) {
    reportCannotUndo(CommonBundle.message("cannot.undo.error.contains.nonundoable.changes.message"),myUndoableGroup.getAffectedDocuments());
    return;
  }
  if (myUndoableGroup.askConfirmation()) {
    if (canceledByUser()) {
      return;
    }
  }
 else {
    if (restore(getBeforeState())) {
      setBeforeState(new EditorAndState(myEditor,myEditor.getState(FileEditorStateLevel.UNDO)));
      return;
    }
  }
  Collection<VirtualFile> readOnlyFiles=collectReadOnlyAffectedFiles();
  if (!readOnlyFiles.isEmpty()) {
    final Project project=myManager.getProject();
    final VirtualFile[] files=readOnlyFiles.toArray(new VirtualFile[readOnlyFiles.size()]);
    if (project == null) {
      VirtualFileManager.getInstance().fireReadOnlyModificationAttempt(files);
      return;
    }
    final ReadonlyStatusHandler.OperationStatus operationStatus=ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(files);
    if (operationStatus.hasReadonlyFiles())     return;
  }
  Collection<Document> readOnlyDocuments=collectReadOnlyDocuments();
  if (!readOnlyDocuments.isEmpty()) {
    for (    Document document : readOnlyDocuments) {
      document.fireReadOnlyModificationAttempt();
    }
    return;
  }
  removeLastFromMyStacks();
  addLastToReverseStacks();
  performAction();
  restore(getAfterState());
}
