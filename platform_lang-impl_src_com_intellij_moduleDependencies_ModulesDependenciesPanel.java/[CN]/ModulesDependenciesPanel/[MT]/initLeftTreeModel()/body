{
  final DefaultMutableTreeNode root=(DefaultMutableTreeNode)myLeftTreeModel.getRoot();
  root.removeAllChildren();
  myModulesGraph=buildGraph();
  setSplitterProportion();
  ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
    @Override public void run(){
      final ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
      final Map<Module,Boolean> inCycle=new HashMap<Module,Boolean>();
      for (      Module module : myModules) {
        if (progressIndicator != null) {
          if (progressIndicator.isCanceled())           return;
          progressIndicator.setText(AnalysisScopeBundle.message("update.module.tree.progress.text",module.getName()));
        }
        if (!module.isDisposed()) {
          Boolean isInCycle=inCycle.get(module);
          if (isInCycle == null) {
            isInCycle=!GraphAlgorithms.getInstance().findCycles(myModulesGraph,module).isEmpty();
            inCycle.put(module,isInCycle);
          }
          final DefaultMutableTreeNode moduleNode=new DefaultMutableTreeNode(new MyUserObject(isInCycle.booleanValue(),module));
          root.add(moduleNode);
          final Iterator<Module> out=myModulesGraph.getOut(module);
          while (out.hasNext()) {
            moduleNode.add(new DefaultMutableTreeNode(new MyUserObject(false,out.next())));
          }
        }
      }
    }
  }
,AnalysisScopeBundle.message("update.module.tree.progress.title"),true,myProject);
  sortSubTree(root);
  myLeftTreeModel.reload();
}
