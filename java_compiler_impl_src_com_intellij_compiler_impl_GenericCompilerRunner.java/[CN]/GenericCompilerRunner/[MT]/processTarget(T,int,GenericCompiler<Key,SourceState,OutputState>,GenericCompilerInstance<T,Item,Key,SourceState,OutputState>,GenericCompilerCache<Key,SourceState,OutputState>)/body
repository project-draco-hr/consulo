{
  if (LOG.isDebugEnabled()) {
    LOG.debug("Processing target '" + target + "' (id="+ targetId+ ") by "+ compiler);
  }
  final List<Item> items=instance.getItems(target);
  checkForErrorsOrCanceled();
  final List<GenericCompilerProcessingItem<Item,SourceState,OutputState>> toProcess=new ArrayList<GenericCompilerProcessingItem<Item,SourceState,OutputState>>();
  final THashSet<Key> keySet=new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler));
  final Ref<IOException> exception=Ref.create(null);
  DumbService.getInstance(myProject).waitForSmartMode();
  final Map<Item,SourceState> sourceStates=new HashMap<Item,SourceState>();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    @Override public void run(){
      try {
        for (        Item item : items) {
          final Key key=item.getKey();
          keySet.add(key);
          if (item.isExcluded())           continue;
          final GenericCompilerCache.PersistentStateData<SourceState,OutputState> data=cache.getState(targetId,key);
          SourceState sourceState=data != null ? data.mySourceState : null;
          final OutputState outputState=data != null ? data.myOutputState : null;
          if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) {
            sourceStates.put(item,item.computeSourceState());
            toProcess.add(new GenericCompilerProcessingItem<Item,SourceState,OutputState>(item,sourceState,outputState));
          }
        }
      }
 catch (      IOException e) {
        exception.set(e);
      }
    }
  }
);
  if (!exception.isNull()) {
    throw exception.get();
  }
  final List<Key> toRemove=new ArrayList<Key>();
  cache.processSources(targetId,new Processor<Key>(){
    @Override public boolean process(    Key key){
      if (!keySet.contains(key)) {
        toRemove.add(key);
      }
      return true;
    }
  }
);
  if (LOG.isDebugEnabled()) {
    LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size()+ " items will be removed");
    for (int i=0; i < Math.min(100,toProcess.size()); i++) {
      LOG.debug("to process:" + toProcess.get(i).getItem().getKey());
    }
    for (int i=0; i < Math.min(100,toRemove.size()); i++) {
      LOG.debug("to delete:" + toRemove.get(i));
    }
  }
  if (toProcess.isEmpty() && toRemove.isEmpty()) {
    return false;
  }
  if (myOnlyCheckStatus) {
    throw new ExitException(ExitStatus.CANCELLED);
  }
  List<GenericCompilerCacheState<Key,SourceState,OutputState>> obsoleteItems=new ArrayList<GenericCompilerCacheState<Key,SourceState,OutputState>>();
  for (  Key key : toRemove) {
    final GenericCompilerCache.PersistentStateData<SourceState,OutputState> data=cache.getState(targetId,key);
    obsoleteItems.add(new GenericCompilerCacheState<Key,SourceState,OutputState>(key,data.mySourceState,data.myOutputState));
  }
  final List<Item> processedItems=new ArrayList<Item>();
  final List<File> filesToRefresh=new ArrayList<File>();
  final List<File> dirsToRefresh=new ArrayList<File>();
  instance.processItems(target,toProcess,obsoleteItems,new GenericCompilerInstance.OutputConsumer<Item>(){
    @Override public void addFileToRefresh(    @NotNull File file){
      filesToRefresh.add(file);
    }
    @Override public void addDirectoryToRefresh(    @NotNull File dir){
      dirsToRefresh.add(dir);
    }
    @Override public void addProcessedItem(    @NotNull Item sourceItem){
      processedItems.add(sourceItem);
    }
  }
);
  checkForErrorsOrCanceled();
  CompilerUtil.runInContext(myContext,CompilerBundle.message("progress.updating.caches"),new ThrowableRunnable<IOException>(){
    @Override public void run() throws IOException {
      for (      Key key : toRemove) {
        cache.remove(targetId,key);
      }
      CompilerUtil.refreshIOFiles(filesToRefresh);
      CompilerUtil.refreshIODirectories(dirsToRefresh);
      if (LOG.isDebugEnabled()) {
        LOG.debug("refreshed " + filesToRefresh.size() + " files and "+ dirsToRefresh.size()+ " dirs");
        for (int i=0; i < Math.min(100,filesToRefresh.size()); i++) {
          LOG.debug("file: " + filesToRefresh.get(i));
        }
        for (int i=0; i < Math.min(100,dirsToRefresh.size()); i++) {
          LOG.debug("dir: " + dirsToRefresh.get(i));
        }
      }
      final RunResult runResult=new ReadAction(){
        protected void run(        final Result result) throws Throwable {
          for (          Item item : processedItems) {
            SourceState sourceState=sourceStates.get(item);
            if (sourceState == null) {
              sourceState=item.computeSourceState();
            }
            cache.putState(targetId,item.getKey(),sourceState,item.computeOutputState());
          }
        }
      }
.executeSilently();
      Throwables.propagateIfPossible(runResult.getThrowable(),IOException.class);
    }
  }
);
  return true;
}
