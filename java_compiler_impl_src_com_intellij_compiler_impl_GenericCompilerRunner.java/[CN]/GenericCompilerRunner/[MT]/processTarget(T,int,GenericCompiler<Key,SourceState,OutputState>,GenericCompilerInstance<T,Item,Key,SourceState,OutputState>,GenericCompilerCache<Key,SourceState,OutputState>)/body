{
  if (LOG.isDebugEnabled()) {
    LOG.debug("Processing target '" + target + "' (id="+ targetId+ ")");
  }
  final List<Item> items=instance.getItems(target);
  if (myContext.getMessageCount(CompilerMessageCategory.ERROR) > 0)   return true;
  final List<GenericCompilerItemState<Item,SourceState,OutputState>> toProcess=new ArrayList<GenericCompilerItemState<Item,SourceState,OutputState>>();
  final THashSet<Key> keySet=new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler));
  final Ref<IOException> exception=Ref.create(null);
  DumbService.getInstance(myProject).waitForSmartMode();
  final Map<Item,SourceState> sourceStates=new HashMap<Item,SourceState>();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    @Override public void run(){
      try {
        for (        Item item : items) {
          final Key key=item.getKey();
          keySet.add(key);
          final GenericCompilerCache.PersistentStateData<SourceState,OutputState> data=cache.getState(targetId,key);
          SourceState sourceState=data != null ? data.mySourceState : null;
          final OutputState outputState=data != null ? data.myOutputState : null;
          if (myForceCompile || sourceState == null || !item.isSourceUpToDate(sourceState) || outputState == null || !item.isOutputUpToDate(outputState)) {
            sourceStates.put(item,item.computeSourceState());
            toProcess.add(new GenericCompilerItemState<Item,SourceState,OutputState>(item,sourceState,outputState));
          }
        }
      }
 catch (      IOException e) {
        exception.set(e);
      }
    }
  }
);
  if (!exception.isNull()) {
    throw exception.get();
  }
  final List<Key> toRemove=new ArrayList<Key>();
  cache.processSources(targetId,new Processor<Key>(){
    @Override public boolean process(    Key key){
      if (!keySet.contains(key)) {
        toRemove.add(key);
      }
      return true;
    }
  }
);
  if (LOG.isDebugEnabled()) {
    LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size()+ " items will be removed");
  }
  if (toProcess.isEmpty() && toRemove.isEmpty()) {
    return false;
  }
  if (myOnlyCheckStatus) {
    throw new CompileDriver.ExitException(CompileDriver.ExitStatus.CANCELLED);
  }
  List<GenericCompilerItemState<Key,SourceState,OutputState>> obsoleteItems=new ArrayList<GenericCompilerItemState<Key,SourceState,OutputState>>();
  for (  Key key : toRemove) {
    final GenericCompilerCache.PersistentStateData<SourceState,OutputState> data=cache.getState(targetId,key);
    obsoleteItems.add(new GenericCompilerItemState<Key,SourceState,OutputState>(key,data.mySourceState,data.myOutputState));
  }
  final List<Item> processedItems=new ArrayList<Item>();
  final List<File> toRefresh=new ArrayList<File>();
  instance.processItems(target,toProcess,obsoleteItems,new GenericCompilerInstance.OutputConsumer<Item>(){
    @Override public void addFileToRefresh(    @NotNull File file){
      toRefresh.add(file);
    }
    @Override public void addProcessedItem(    @NotNull Item sourceItem){
      processedItems.add(sourceItem);
    }
  }
);
  if (myContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
    return true;
  }
  for (  Key key : toRemove) {
    cache.remove(targetId,key);
  }
  CompilerUtil.refreshIOFiles(toRefresh);
  final RunResult runResult=new ReadAction(){
    protected void run(    final Result result) throws Throwable {
      for (      Item item : processedItems) {
        SourceState sourceState=sourceStates.get(item);
        if (sourceState == null) {
          sourceState=item.computeSourceState();
        }
        cache.putState(targetId,item.getKey(),sourceState,item.computeOutputState());
      }
    }
  }
.executeSilently();
  Throwables.propagateIfPossible(runResult.getThrowable(),IOException.class);
  return true;
}
