{
  final GenericCompilerCache<Key,SourceState,OutputState> cache=CompilerCacheManager.getInstance(myProject).getGenericCompilerCache(compiler);
  GenericCompilerPersistentData data=new GenericCompilerPersistentData(getGenericCompilerCacheDir(myProject,compiler),compiler.getVersion());
  if (data.isVersionChanged()) {
    LOG.info("Clearing cache for " + compiler.getDescription());
    cache.wipe();
  }
  Set<String> targetsToRemove=new HashSet<String>(data.getAllTargets());
  for (  T target : instance.getAllTargets()) {
    targetsToRemove.remove(target.getId());
  }
  if (!myOnlyCheckStatus) {
    for (    final String target : targetsToRemove) {
      final int id=data.removeId(target);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Removing obsolete target '" + target + "' (id="+ id+ ")");
      }
      final List<Key> keys=new ArrayList<Key>();
      CompilerUtil.runInContext(myContext,"Processing obsolete targets...",new ThrowableRunnable<IOException>(){
        @Override public void run() throws IOException {
          cache.processSources(id,new CommonProcessors.CollectProcessor<Key>(keys));
          List<GenericCompilerCacheState<Key,SourceState,OutputState>> obsoleteSources=new ArrayList<GenericCompilerCacheState<Key,SourceState,OutputState>>();
          for (          Key key : keys) {
            final GenericCompilerCache.PersistentStateData<SourceState,OutputState> state=cache.getState(id,key);
            obsoleteSources.add(new GenericCompilerCacheState<Key,SourceState,OutputState>(key,state.mySourceState,state.myOutputState));
          }
          instance.processObsoleteTarget(target,obsoleteSources);
        }
      }
);
      checkForErrorsOrCanceled();
      for (      Key key : keys) {
        cache.remove(id,key);
      }
    }
  }
  boolean didSomething=false;
  for (  T target : instance.getSelectedTargets()) {
    int id=data.getId(target.getId());
    didSomething|=processTarget(target,id,compiler,instance,cache);
  }
  data.save();
  return didSomething;
}
