{
  final Map<String,Couple<Method>> candidates=ContainerUtilRt.newTreeMap();
  for (  Method method : aClass.getMethods()) {
    if (!Modifier.isPublic(method.getModifiers())) {
      continue;
    }
    Pair<String,Boolean> propertyData=getPropertyData(method.getName());
    if (propertyData == null || propertyData.first.equals("class") || method.getParameterTypes().length != (propertyData.second ? 1 : 0)) {
      continue;
    }
    Couple<Method> candidate=candidates.get(propertyData.first);
    if (candidate == null) {
      candidate=Couple.getEmpty();
    }
    if ((propertyData.second ? candidate.second : candidate.first) != null) {
      continue;
    }
    candidate=Couple.of(propertyData.second ? candidate.first : method,propertyData.second ? method : candidate.second);
    candidates.put(propertyData.first,candidate);
  }
  for (  Map.Entry<String,Couple<Method>> candidate : candidates.entrySet()) {
    Couple<Method> methods=candidate.getValue();
    if (methods.first != null && methods.second != null && methods.first.getReturnType().equals(methods.second.getParameterTypes()[0]) && methods.first.getAnnotation(Transient.class) == null && methods.second.getAnnotation(Transient.class) == null) {
      accessors.add(new PropertyAccessor(candidate.getKey(),methods.first.getReturnType(),methods.first,methods.second));
    }
  }
}
