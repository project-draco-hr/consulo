{
  boolean headChanged=false;
  boolean branchFileChanged=false;
  boolean packedRefsChanged=false;
  boolean rebaseFileChanged=false;
  boolean mergeFileChanged=false;
  for (  VFileEvent event : events) {
    final VirtualFile file=event.getFile();
    if (file == null) {
      continue;
    }
    String filePath=GitFileUtils.stripFileProtocolPrefix(file.getPath());
    if (myRepositoryFiles.isHeadFile(filePath)) {
      headChanged=true;
    }
 else     if (myRepositoryFiles.isBranchFile(filePath)) {
      branchFileChanged=true;
    }
 else     if (myRepositoryFiles.isPackedRefs(filePath)) {
      packedRefsChanged=true;
    }
 else     if (myRepositoryFiles.isRebaseFile(filePath)) {
      rebaseFileChanged=true;
    }
 else     if (myRepositoryFiles.isMergeFile(filePath)) {
      mergeFileChanged=true;
    }
  }
  boolean updateCurrentBranch=false;
  boolean updateCurrentRevision=false;
  boolean updateState=false;
  if (headChanged) {
    updateCurrentBranch=true;
    updateCurrentRevision=true;
    updateState=true;
  }
  if (branchFileChanged) {
    updateCurrentRevision=true;
  }
  if (rebaseFileChanged || mergeFileChanged) {
    updateState=true;
  }
  if (updateCurrentBranch) {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      public void run(){
        myRepository.update(GitRepository.TrackedTopic.CURRENT_BRANCH);
      }
    }
);
  }
  if (updateCurrentRevision) {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      public void run(){
        myRepository.update(GitRepository.TrackedTopic.CURRENT_REVISION);
      }
    }
);
  }
  if (updateState) {
    ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
      public void run(){
        myRepository.update(GitRepository.TrackedTopic.STATE);
      }
    }
);
  }
}
