{
  if (!(file instanceof PropertiesFile))   return null;
  PropertiesFile propertiesFile=((PropertiesFile)file);
  final List<Property> properties=propertiesFile.getProperties();
  List<ProblemDescriptor> problemDescriptors=new ArrayList<ProblemDescriptor>();
  for (  Property property : properties) {
    String value=property.getValue();
    Set<Integer> parameters=new HashSet<Integer>();
    if (value != null) {
      int index=value.indexOf('{');
      while (index != -1) {
        value=value.substring(index + 1);
        final int comma=value.indexOf(',');
        final int brace=value.indexOf('}');
        if (comma == -1 && brace == -1)         break;
        if (comma == -1) {
          index=brace;
        }
 else         if (brace == -1) {
          index=comma;
        }
 else {
          index=Math.min(comma,brace);
        }
        try {
          parameters.add(new Integer(value.substring(0,index)));
        }
 catch (        NumberFormatException e) {
          break;
        }
        index=value.indexOf('{');
      }
      for (      Integer integer : parameters) {
        for (int i=0; i < integer.intValue(); i++) {
          if (!parameters.contains(new Integer(i))) {
            ASTNode[] nodes=property.getNode().getChildren(null);
            PsiElement valElement=nodes.length < 3 ? property : nodes[2].getPsi();
            problemDescriptors.add(manager.createProblemDescriptor(valElement,PropertiesBundle.message("unused.message.format.parameter.problem.descriptor",integer.toString(),Integer.toString(i)),(LocalQuickFix[])null,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
            break;
          }
        }
      }
    }
  }
  return problemDescriptors.isEmpty() ? null : problemDescriptors.toArray(new ProblemDescriptor[problemDescriptors.size()]);
}
