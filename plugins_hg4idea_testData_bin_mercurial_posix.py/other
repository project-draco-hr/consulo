from i18n import _
import osutil
import os, sys, errno, stat, getpass, pwd, grp, fcntl
posixfile = open
nulldev = '/dev/null'
normpath = os.path.normpath
samestat = os.path.samestat
rename = os.rename
expandglobs = False
umask = os.umask(0)
os.umask(umask)
if (sys.platform == 'darwin'):

    def realpath(path):
        '\n        Returns the true, canonical file system path equivalent to the given\n        path.\n\n        Equivalent means, in this case, resulting in the same, unique\n        file system link to the path. Every file system entry, whether a file,\n        directory, hard link or symbolic link or special, will have a single\n        path preferred by the system, but may allow multiple, differing path\n        lookups to point to it.\n\n        Most regular UNIX file systems only allow a file system entry to be\n        looked up by its distinct path. Obviously, this does not apply to case\n        insensitive file systems, whether case preserving or not. The most\n        complex issue to deal with is file systems transparently reencoding the\n        path, such as the non-standard Unicode normalisation required for HFS+\n        and HFSX.\n        '
        F_GETPATH = 50
        O_SYMLINK = 2097152
        try:
            fd = os.open(path, O_SYMLINK)
        except OSError as err:
            if (err.errno is errno.ENOENT):
                return path
            raise
        try:
            return fcntl.fcntl(fd, F_GETPATH, ('\x00' * 1024)).rstrip('\x00')
        finally:
            os.close(fd)
else:
    realpath = os.path.realpath
