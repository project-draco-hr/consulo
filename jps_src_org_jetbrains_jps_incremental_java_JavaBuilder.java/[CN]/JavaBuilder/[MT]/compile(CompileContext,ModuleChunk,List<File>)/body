{
  if (files.isEmpty()) {
    return ExitCode.OK;
  }
  ProjectPaths paths=ProjectPaths.KEY.get(context);
  if (paths == null) {
    ProjectPaths.KEY.set(context,paths=new ProjectPaths(context.getProject()));
  }
  final Collection<File> classpath=paths.getCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Collection<File> platformCp=paths.getPlatformCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Map<File,Set<File>> outs=buildOutputDirectoriesMap(context,chunk);
  final List<String> options=getCompilationOptions(context,chunk);
  final int ERROR=0, WARNING=1;
  final int[] statistics=new int[]{0,0};
  final boolean compilationOk=myJavacCompiler.compile(options,files,classpath,platformCp,outs,new EmbeddedJavac.OutputConsumer(){
    public void outputLineAvailable(    String line){
      context.processMessage(new CompilerMessage(JAVAC_COMPILER_NAME,BuildMessage.Kind.INFO,line));
    }
    public void report(    Diagnostic<? extends JavaFileObject> diagnostic){
      final CompilerMessage.Kind kind;
switch (diagnostic.getKind()) {
case ERROR:
        kind=BuildMessage.Kind.ERROR;
      statistics[ERROR]++;
    break;
case MANDATORY_WARNING:
case WARNING:
  kind=BuildMessage.Kind.WARNING;
statistics[WARNING]++;
break;
default :
kind=BuildMessage.Kind.INFO;
}
final String srcPath;
final JavaFileObject source=diagnostic.getSource();
if (source != null) {
srcPath=FileUtil.toSystemIndependentName(new File(source.toUri()).getPath());
}
 else {
srcPath=null;
}
context.processMessage(new CompilerMessage(JAVAC_COMPILER_NAME,kind,diagnostic.getMessage(Locale.US),srcPath,diagnostic.getStartPosition(),diagnostic.getEndPosition(),diagnostic.getPosition(),diagnostic.getLineNumber(),diagnostic.getColumnNumber()));
}
}
);
if (!compilationOk || statistics[ERROR] > 0) {
throw new ProjectBuildException("Compilation failed: errors: " + statistics[ERROR] + "; warnings: "+ statistics[WARNING]);
}
return ExitCode.OK;
}
