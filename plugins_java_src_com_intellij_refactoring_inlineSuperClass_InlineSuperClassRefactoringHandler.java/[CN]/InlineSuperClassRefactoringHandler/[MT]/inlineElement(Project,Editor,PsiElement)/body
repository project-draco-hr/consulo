{
  PsiClass superClass=(PsiClass)element;
  Collection<PsiClass> inheritors=DirectClassInheritorsSearch.search((PsiClass)element).findAll();
  if (!superClass.getManager().isInProject(superClass)) {
    CommonRefactoringUtil.showErrorHint(project,editor,"Cannot inline non-project class",REFACTORING_NAME,null);
    return;
  }
  for (  PsiClass inheritor : inheritors) {
    if (PsiTreeUtil.isAncestor(superClass,inheritor,false)) {
      CommonRefactoringUtil.showErrorHint(project,editor,"Cannot inline into the inner class. Move \'" + inheritor.getName() + "\' to upper level",REFACTORING_NAME,null);
      return;
    }
    if (inheritor instanceof PsiAnonymousClass) {
      CommonRefactoringUtil.showErrorHint(project,editor,"Cannot inline into anonymous class.",REFACTORING_NAME,null);
      return;
    }
  }
  PsiClass chosen=null;
  PsiReference reference=editor != null ? TargetElementUtilBase.findReference(editor,editor.getCaretModel().getOffset()) : null;
  if (reference != null) {
    final PsiElement resolve=reference.resolve();
    if (resolve == superClass) {
      final PsiElement referenceElement=reference.getElement();
      if (referenceElement != null) {
        final PsiElement parent=referenceElement.getParent();
        if (parent instanceof PsiReferenceList) {
          final PsiElement gParent=parent.getParent();
          if (gParent instanceof PsiClass && inheritors.contains(gParent)) {
            chosen=(PsiClass)gParent;
          }
        }
      }
    }
  }
  new InlineSuperClassRefactoringDialog(project,superClass,chosen,inheritors.toArray(new PsiClass[inheritors.size()])).show();
}
