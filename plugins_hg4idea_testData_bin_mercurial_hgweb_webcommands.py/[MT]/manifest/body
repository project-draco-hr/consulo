def manifest(web, req, tmpl):
    ctx = webutil.changectx(web.repo, req)
    path = webutil.cleanpath(web.repo, req.form.get('file', [''])[0])
    mf = ctx.manifest()
    node = ctx.node()
    files = {}
    dirs = {}
    parity = paritygen(web.stripecount)
    if (path and (path[(-1)] != '/')):
        path += '/'
    l = len(path)
    abspath = ('/' + path)
    for (f, n) in mf.iteritems():
        if (f[:l] != path):
            continue
        remain = f[l:]
        elements = remain.split('/')
        if (len(elements) == 1):
            files[remain] = f
        else:
            h = dirs
            for elem in elements[0:(-1)]:
                if (elem not in h):
                    h[elem] = {}
                h = h[elem]
                if (len(h) > 1):
                    break
            h[None] = None
    if (mf and (not files) and (not dirs)):
        raise ErrorResponse(HTTP_NOT_FOUND, ('path not found: ' + path))

    def filelist(**map):
        for f in sorted(files):
            full = files[f]
            fctx = ctx.filectx(full)
            yield {'file': full, 'parity': parity.next(), 'basename': f, 'date': fctx.date(), 'size': fctx.size(), 'permissions': mf.flags(full), }

    def dirlist(**map):
        for d in sorted(dirs):
            emptydirs = []
            h = dirs[d]
            while (isinstance(h, dict) and (len(h) == 1)):
                (k, v) = h.items()[0]
                if v:
                    emptydirs.append(k)
                h = v
            path = ('%s%s' % (abspath, d))
            yield {'parity': parity.next(), 'path': path, 'emptydirs': '/'.join(emptydirs), 'basename': d, }
    return tmpl('manifest', rev=ctx.rev(), node=hex(node), path=abspath, up=webutil.up(abspath), upparity=parity.next(), fentries=filelist, dentries=dirlist, archives=web.archivelist(hex(node)), tags=webutil.nodetagsdict(web.repo, node), inbranch=webutil.nodeinbranch(web.repo, ctx), branches=webutil.nodebranchdict(web.repo, ctx))
