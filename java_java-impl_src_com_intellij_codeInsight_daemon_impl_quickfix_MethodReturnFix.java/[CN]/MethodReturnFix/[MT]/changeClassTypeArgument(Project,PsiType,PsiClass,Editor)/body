{
  if (superClass == null || !superClass.hasTypeParameters())   return false;
  final PsiClass superReturnTypeClass=PsiUtil.resolveClassInType(superReturnType);
  if (superReturnTypeClass == null || !(superReturnTypeClass instanceof PsiTypeParameter || superReturnTypeClass.hasTypeParameters()))   return false;
  final PsiClass derivedClass=myMethod.getContainingClass();
  if (derivedClass == null)   return false;
  final PsiReferenceParameterList referenceParameterList=findTypeArgumentsList(superClass,derivedClass);
  if (referenceParameterList == null)   return false;
  final PsiElement resolve=((PsiJavaCodeReferenceElement)referenceParameterList.getParent()).resolve();
  if (!(resolve instanceof PsiClass))   return false;
  final PsiClass baseClass=(PsiClass)resolve;
  PsiType returnType=myReturnType;
  if (returnType instanceof PsiPrimitiveType) {
    returnType=((PsiPrimitiveType)returnType).getBoxedType(derivedClass);
  }
  final PsiSubstitutor superClassSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(superClass,baseClass,PsiSubstitutor.EMPTY);
  final PsiType superReturnTypeInBaseClassType=superClassSubstitutor.substitute(superReturnType);
  final PsiSubstitutor psiSubstitutor=JavaPsiFacade.getInstance(project).getResolveHelper().inferTypeArguments(baseClass.getTypeParameters(),new PsiType[]{superReturnTypeInBaseClassType},new PsiType[]{returnType},PsiUtil.getLanguageLevel(superClass));
  final TypeMigrationRules rules=new TypeMigrationRules(TypeMigrationLabeler.getElementType(derivedClass));
  rules.setMigrationRootType(JavaPsiFacade.getElementFactory(project).createType(baseClass,psiSubstitutor));
  rules.setBoundScope(new LocalSearchScope(derivedClass));
  TypeMigrationProcessor.runHighlightingTypeMigration(project,editor,rules,referenceParameterList);
  return true;
}
