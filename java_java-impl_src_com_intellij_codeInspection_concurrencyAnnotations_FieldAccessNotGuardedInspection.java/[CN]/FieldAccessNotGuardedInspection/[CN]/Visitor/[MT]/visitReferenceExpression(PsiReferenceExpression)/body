{
  final PsiElement referent=expression.resolve();
  if (referent == null || !(referent instanceof PsiField)) {
    return;
  }
  final PsiField field=(PsiField)referent;
  final String guard=JCiPUtil.findGuardForMember(field);
  if (guard == null) {
    return;
  }
  final PsiMethod containingMethod=PsiTreeUtil.getParentOfType(expression,PsiMethod.class);
  if (containingMethod != null && JCiPUtil.isGuardedBy(containingMethod,guard)) {
    return;
  }
  if (containingMethod != null && containingMethod.isConstructor()) {
    return;
  }
  if ("this".equals(guard)) {
    if (containingMethod != null && containingMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
      return;
    }
  }
  if (findLockTryStatement(expression,guard) != null) {
    PsiElement lockExpr=expression;
    while (lockExpr != null) {
      PsiElement child=lockExpr;
      while (child != null) {
        if (isLockGuardStatement(guard,child,"lock"))         return;
        child=child.getPrevSibling();
      }
      lockExpr=lockExpr.getParent();
    }
  }
  PsiElement check=expression;
  while (true) {
    final PsiSynchronizedStatement syncStatement=PsiTreeUtil.getParentOfType(check,PsiSynchronizedStatement.class);
    if (syncStatement == null) {
      break;
    }
    final PsiExpression lockExpression=syncStatement.getLockExpression();
    if (lockExpression != null && lockExpression.getText().equals(guard)) {
      return;
    }
    check=syncStatement;
  }
  myHolder.registerProblem(expression,"Access to field <code>#ref</code> outside of declared guards #loc");
}
