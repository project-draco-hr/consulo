{
  final PsiElement referent=expression.resolve();
  if (referent == null || !(referent instanceof PsiField)) {
    return;
  }
  final PsiField field=(PsiField)referent;
  final String guard=JCiPUtil.findGuardForMember(field);
  if (guard == null) {
    return;
  }
  final PsiMethod containingMethod=PsiTreeUtil.getParentOfType(expression,PsiMethod.class);
  if (containingMethod != null && JCiPUtil.isGuardedBy(containingMethod,guard)) {
    return;
  }
  if (containingMethod != null && containingMethod.isConstructor()) {
    return;
  }
  if ("this".equals(guard)) {
    if (containingMethod != null && containingMethod.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
      return;
    }
  }
  PsiElement lockExpr=findLockTryStatement(expression,guard);
  while (lockExpr != null) {
    PsiElement child=lockExpr;
    while (child != null) {
      if (isLockGuardStatement(guard,child,"lock"))       return;
      child=child.getPrevSibling();
    }
    lockExpr=lockExpr.getParent();
  }
  PsiElement check=expression;
  while (true) {
    final PsiSynchronizedStatement syncStatement=PsiTreeUtil.getParentOfType(check,PsiSynchronizedStatement.class);
    if (syncStatement == null) {
      break;
    }
    final PsiExpression lockExpression=syncStatement.getLockExpression();
    if (lockExpression != null && lockExpression.getText().equals(guard)) {
      return;
    }
    check=syncStatement;
  }
  myHolder.registerProblem(expression,"Access to field <code>#ref</code> outside of declared guards #loc");
}
