{
  maxOccurs*=group.getMaxOccurs();
switch (group.getGroupType()) {
case LEAF:
    if (maxOccurs > 1 || maxOccurs == 1 && !existing.contains(group)) {
      descriptors.add(group.getLeafDescriptor());
    }
  break;
case SEQUENCE:
if (anchor.isEmpty()) {
  if (!group.getSubGroups().isEmpty()) {
    return processGroup(group.getSubGroups().get(0),descriptors,anchor,existing,maxOccurs);
  }
}
 else {
  for (Iterator<XmlElementsGroup> iterator=group.getSubGroups().iterator(); iterator.hasNext(); ) {
    XmlElementsGroup subGroup=iterator.next();
    if (anchor.contains(subGroup)) {
      processGroup(subGroup,descriptors,anchor,existing,maxOccurs);
      if (iterator.hasNext()) {
        return processGroup(iterator.next(),descriptors,anchor,existing,maxOccurs);
      }
      return true;
    }
  }
}
break;
case CHOICE:
if (group.getMaxOccurs() == 1) {
for (XmlElementsGroup subGroup : group.getSubGroups()) {
if (existing.contains(subGroup)) {
  return processGroup(subGroup,descriptors,anchor,existing,maxOccurs);
}
}
}
case ALL:
case GROUP:
for (XmlElementsGroup subGroup : group.getSubGroups()) {
processGroup(subGroup,descriptors,anchor,existing,maxOccurs);
}
break;
}
return true;
}
