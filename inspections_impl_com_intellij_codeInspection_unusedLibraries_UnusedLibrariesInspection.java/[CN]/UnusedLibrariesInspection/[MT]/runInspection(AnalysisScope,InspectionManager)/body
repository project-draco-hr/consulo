{
  final Project project=getContext().getProject();
  final ArrayList<VirtualFile> libraryRoots=new ArrayList<VirtualFile>();
  if (scope.getScopeType() == AnalysisScope.PROJECT) {
    libraryRoots.addAll(Arrays.asList(LibraryUtil.getLibraryRoots(project,false,false)));
  }
 else {
    final Set<Module> modules=new HashSet<Module>();
    scope.accept(new PsiRecursiveElementVisitor(){
      public void visitFile(      PsiFile file){
        if (!(file instanceof PsiCompiledElement)) {
          final VirtualFile virtualFile=file.getVirtualFile();
          if (virtualFile != null) {
            modules.add(ModuleUtil.findModuleForFile(virtualFile,project));
          }
        }
      }
    }
);
    libraryRoots.addAll(Arrays.asList(LibraryUtil.getLibraryRoots(modules.toArray(new Module[modules.size()]),false,false)));
  }
  GlobalSearchScope searchScope=null;
  try {
    @NonNls final String libsName="libs";
    searchScope=GlobalSearchScope.filterScope(project,new NamedScope(libsName,PackageSetFactory.getInstance().compile("lib:*..*")));
  }
 catch (  ParsingException e) {
  }
  final AnalysisScope analysisScope=new AnalysisScope(searchScope,project);
  analysisScope.setSearchInLibraries(true);
  final BackwardDependenciesBuilder builder=new BackwardDependenciesBuilder(project,analysisScope);
  BACKWARD_ANALYSIS.setTotalAmount(builder.getTotalFileCount());
  ((ProgressManagerImpl)ProgressManager.getInstance()).executeProcessUnderProgress(new Runnable(){
    public void run(){
      builder.analyze();
    }
  }
,new ProgressIndicatorBase(){
    public void setFraction(    final double fraction){
      super.setFraction(fraction);
      BACKWARD_ANALYSIS.setDoneAmount(((int)fraction * BACKWARD_ANALYSIS.getTotalAmount()));
      getContext().incrementJobDoneAmount(BACKWARD_ANALYSIS,getText2());
    }
  }
);
  final Map<PsiFile,Set<PsiFile>> dependencies=builder.getDependencies();
  for (  PsiFile file : dependencies.keySet()) {
    final VirtualFile virtualFile=file.getVirtualFile();
    LOG.assertTrue(virtualFile != null);
    for (Iterator<VirtualFile> i=libraryRoots.iterator(); i.hasNext(); ) {
      if (VfsUtil.isAncestor(i.next(),virtualFile,false)) {
        i.remove();
      }
    }
  }
  if (libraryRoots.size() > 0) {
    ProjectFileIndex projectIndex=ProjectRootManager.getInstance(project).getFileIndex();
    Map<OrderEntry,Set<VirtualFile>> unusedLibs=new HashMap<OrderEntry,Set<VirtualFile>>();
    for (    VirtualFile libraryRoot : libraryRoots) {
      final List<OrderEntry> orderEntries=projectIndex.getOrderEntriesForFile(libraryRoot);
      for (      OrderEntry orderEntry : orderEntries) {
        Set<VirtualFile> files=unusedLibs.get(orderEntry);
        if (files == null) {
          files=new HashSet<VirtualFile>();
          unusedLibs.put(orderEntry,files);
        }
        files.add(libraryRoot);
      }
    }
    final RefManager refManager=getRefManager();
    final RefProject refProject=refManager.getRefProject();
    for (    OrderEntry orderEntry : unusedLibs.keySet()) {
      if (orderEntry instanceof LibraryOrderEntry) {
        RefEntity problemEntity=refProject;
        if (((LibraryOrderEntry)orderEntry).getLibraryLevel() == LibraryTableImplUtil.MODULE_LEVEL) {
          problemEntity=refManager.getRefModule(orderEntry.getOwnerModule());
        }
        final Set<VirtualFile> files=unusedLibs.get(orderEntry);
        if (files.size() < orderEntry.getFiles(OrderRootType.CLASSES).length) {
          final String unusedLibraryRoots=StringUtil.join(files,new Function<VirtualFile,String>(){
            public String fun(            final VirtualFile file){
              return file.getPresentableName();
            }
          }
,",");
          addProblemElement(problemEntity,manager.createProblemDescriptor(InspectionsBundle.message("unused.library.roots.problem.descriptor",unusedLibraryRoots,orderEntry.getPresentableName()),(LocalQuickFix)null));
        }
 else {
          addProblemElement(problemEntity,manager.createProblemDescriptor(InspectionsBundle.message("unused.library.problem.descriptor",orderEntry.getPresentableName()),(LocalQuickFix)null));
        }
      }
    }
  }
}
