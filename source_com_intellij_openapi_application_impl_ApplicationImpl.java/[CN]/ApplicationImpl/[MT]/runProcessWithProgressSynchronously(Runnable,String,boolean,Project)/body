{
  assertIsDispatchThread();
  if (myExceptionalThreadWithReadAccess != null || ApplicationManager.getApplication().isUnitTestMode()) {
    process.run();
    return true;
  }
  boolean smoothProgress=true;
  if (Patches.MAC_HIDE_QUIT_HACK) {
    smoothProgress=false;
  }
  final ProgressWindow window=new ProgressWindow(canBeCanceled,project);
  window.setTitle(progressTitle);
  final BlockingProgressIndicator progress=window;
class MyThread extends Thread {
    private final Runnable myProcess;
    public MyThread(){
      super("Process with Progress");
      myProcess=process;
    }
    public void run(){
      if (myExceptionalThreadWithReadAccess != this) {
        if (myExceptionalThreadWithReadAccess == null) {
          LOG.error("myExceptionalThreadWithReadAccess = null!");
        }
 else {
          LOG.error("myExceptionalThreadWithReadAccess != thread, process = " + ((MyThread)myExceptionalThreadWithReadAccess).myProcess);
        }
      }
      try {
        ProgressManager.getInstance().runProcess(myProcess,progress);
      }
 catch (      ProcessCanceledException e) {
      }
    }
  }
  final MyThread thread=new MyThread();
  try {
    myExceptionalThreadWithReadAccess=thread;
    final boolean[] threadStarted=new boolean[]{false};
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (myExceptionalThreadWithReadAccess != thread) {
          if (myExceptionalThreadWithReadAccess == null) {
            LOG.error("myExceptionalThreadWithReadAccess = null!");
          }
 else {
            LOG.error("myExceptionalThreadWithReadAccess != thread, process = " + ((MyThread)myExceptionalThreadWithReadAccess).myProcess);
          }
        }
        thread.start();
        threadStarted[0]=true;
      }
    }
);
    progress.startBlocking();
    LOG.assertTrue(threadStarted[0]);
    LOG.assertTrue(!smoothProgress || !progress.isRunning());
  }
  finally {
    myExceptionalThreadWithReadAccess=null;
  }
  return !progress.isCanceled();
}
