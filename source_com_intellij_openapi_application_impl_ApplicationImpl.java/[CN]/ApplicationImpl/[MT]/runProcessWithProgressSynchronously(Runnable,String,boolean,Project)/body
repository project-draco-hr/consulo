{
  assertIsDispatchThread();
  if (myExceptionalThreadWithReadAccess != null || myExceptionalThreadWithReadAccessRunnable != null || ApplicationManager.getApplication().isUnitTestMode() || ApplicationManager.getApplication().isHeadlessEnvironment()) {
    process.run();
    return true;
  }
  final ProgressWindow progress=new ProgressWindow(canBeCanceled,project);
  progress.setTitle(progressTitle);
  try {
    myExceptionalThreadWithReadAccessRunnable=process;
    final boolean[] threadStarted=new boolean[]{false};
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (myExceptionalThreadWithReadAccessRunnable != process) {
          LOG.error("myExceptionalThreadWithReadAccessRunnable != process, process = " + myExceptionalThreadWithReadAccessRunnable);
        }
        executeOnPooledThread(new Runnable(){
          public void run(){
            if (myExceptionalThreadWithReadAccessRunnable != process) {
              LOG.error("myExceptionalThreadWithReadAccessRunnable != process, process = " + myExceptionalThreadWithReadAccessRunnable);
            }
            myExceptionalThreadWithReadAccess=Thread.currentThread();
            boolean old=setExceptionalThreadWithReadAccessFlag(true);
            LOG.assertTrue(isReadAccessAllowed());
            try {
              ProgressManager.getInstance().runProcess(process,progress);
            }
 catch (            ProcessCanceledException e) {
            }
 finally {
              setExceptionalThreadWithReadAccessFlag(old);
            }
          }
        }
);
        threadStarted[0]=true;
      }
    }
);
    progress.startBlocking();
    LOG.assertTrue(threadStarted[0]);
    LOG.assertTrue(!progress.isRunning());
  }
  finally {
    myExceptionalThreadWithReadAccess=null;
    myExceptionalThreadWithReadAccessRunnable=null;
  }
  return !progress.isCanceled();
}
