{
  assertIsDispatchThread();
  if (myExceptionalThreadWithReadAccess != null || ApplicationManager.getApplication().isUnitTestMode() || ApplicationManager.getApplication().isHeadlessEnvironment()) {
    process.run();
    return true;
  }
  final ProgressWindow progress=new ProgressWindow(canBeCanceled,project);
  progress.setTitle(progressTitle);
class MyThread extends Thread {
    private final Runnable myProcess;
    public MyThread(){
      super("Process with Progress");
      myProcess=process;
    }
    public void run(){
      if (myExceptionalThreadWithReadAccess != this) {
        if (myExceptionalThreadWithReadAccess == null) {
          LOG.error("myExceptionalThreadWithReadAccess = null!");
        }
 else {
          LOG.error("myExceptionalThreadWithReadAccess != thread, process = " + ((MyThread)myExceptionalThreadWithReadAccess).myProcess);
        }
      }
      try {
        ProgressManager.getInstance().runProcess(myProcess,progress);
      }
 catch (      ProcessCanceledException e) {
      }
    }
  }
  final MyThread thread=new MyThread();
  try {
    myExceptionalThreadWithReadAccess=thread;
    final boolean[] threadStarted=new boolean[]{false};
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        if (myExceptionalThreadWithReadAccess != thread) {
          if (myExceptionalThreadWithReadAccess == null) {
            LOG.error("myExceptionalThreadWithReadAccess = null!");
          }
 else {
            LOG.error("myExceptionalThreadWithReadAccess != thread, process = " + ((MyThread)myExceptionalThreadWithReadAccess).myProcess);
          }
        }
        thread.start();
        threadStarted[0]=true;
      }
    }
);
    progress.startBlocking();
    LOG.assertTrue(threadStarted[0]);
    LOG.assertTrue(!progress.isRunning());
  }
  finally {
    myExceptionalThreadWithReadAccess=null;
  }
  return !progress.isCanceled();
}
