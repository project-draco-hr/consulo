{
  if (!ApplicationManager.getApplication().isUnitTestMode() && HintManager.getInstance().hasShownHintsThatWillHideByOtherHint())   return null;
  ApplicationManager.getApplication().assertReadAccessAllowed();
  PsiManager manager=ref.getManager();
  if (manager == null)   return null;
  PsiElement refname=ref.getReferenceNameElement();
  if (!(refname instanceof PsiIdentifier))   return null;
  PsiElement refElement=ref.resolve();
  if (refElement != null)   return null;
  String name=ref.getQualifiedName();
  final JavaPsiFacade facade=JavaPsiFacade.getInstance(manager.getProject());
  if (facade.getResolveHelper().resolveReferencedClass(name,ref) != null)   return null;
  PsiShortNamesCache cache=facade.getShortNamesCache();
  GlobalSearchScope scope=ref.getResolveScope();
  PsiClass[] classes=cache.getClassesByName(name,scope);
  if (classes.length == 0)   return null;
  try {
    Pattern pattern=Pattern.compile(DaemonCodeAnalyzerSettings.getInstance().NO_AUTO_IMPORT_PATTERN);
    Matcher matcher=pattern.matcher(name);
    if (matcher.matches())     return null;
  }
 catch (  PatternSyntaxException e) {
  }
  List<PsiClass> availableClasses=new ArrayList<PsiClass>();
  boolean isAnnotationReference=ref.getParent() instanceof PsiAnnotation;
  for (  PsiClass aClass : classes) {
    if (isFromDefaultPackage(aClass))     continue;
    if (isAnnotationReference && !aClass.isAnnotationType())     continue;
    if (!aClass.hasModifierProperty(PsiModifier.PUBLIC))     continue;
    if (CompletionUtil.isInExcludedPackage(aClass))     continue;
    availableClasses.add(aClass);
  }
  if (availableClasses.isEmpty())   return null;
  PsiReferenceParameterList parameterList=ref.getParameterList();
  int refTypeArgsLength=parameterList == null ? 0 : parameterList.getTypeArguments().length;
  if (refTypeArgsLength != 0) {
    List<PsiClass> typeArgMatched=new ArrayList<PsiClass>(availableClasses);
    for (int i=typeArgMatched.size() - 1; i >= 0; i--) {
      PsiClass aClass=typeArgMatched.get(i);
      PsiTypeParameter[] typeParameters=aClass.getTypeParameters();
      if (refTypeArgsLength != typeParameters.length) {
        typeArgMatched.remove(i);
      }
    }
    if (!typeArgMatched.isEmpty()) {
      availableClasses=typeArgMatched;
    }
  }
  PsiFile psiFile=ref.getContainingFile();
  if (availableClasses.size() > 1) {
    reduceSuggestedClassesBasedOnDependencyRuleViolation(psiFile,availableClasses);
  }
  classes=availableClasses.toArray(new PsiClass[availableClasses.size()]);
  CodeInsightUtil.sortIdenticalShortNameClasses(classes,psiFile);
  final QuestionAction action=new AddImportAction(manager.getProject(),ref,editor,classes);
  DaemonCodeAnalyzerImpl codeAnalyzer=(DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(manager.getProject());
  if (classes.length == 1 && CodeStyleSettingsManager.getSettings(manager.getProject()).ADD_UNAMBIGIOUS_IMPORTS_ON_THE_FLY && !isCaretNearRef(editor,ref) && !PsiUtil.isInJspFile(psiFile) && codeAnalyzer.canChangeFileSilently(psiFile) && !hasUnresolvedImportWhichCanImport(psiFile,classes[0].getName())) {
    CommandProcessor.getInstance().runUndoTransparentAction(new Runnable(){
      public void run(){
        action.execute();
      }
    }
);
    return null;
  }
  String hintText=getMessage(classes.length > 1,classes[0].getQualifiedName());
  return Pair.create(hintText,action);
}
