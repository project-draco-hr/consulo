{
  if (psiClass instanceof PsiAnonymousClass)   return null;
  if (psiClass instanceof JspClass)   return null;
  if (psiClass instanceof PsiTypeParameter)   return null;
  if (IGNORE_DEPRECATED && psiClass.isDeprecated()) {
    return null;
  }
  PsiDocComment docComment=psiClass.getDocComment();
  final PsiIdentifier nameIdentifier=psiClass.getNameIdentifier();
  final PsiElement elementToHighlight=nameIdentifier != null ? nameIdentifier : psiClass;
  if (docComment == null) {
    return isJavaDocRequired(psiClass) ? new ProblemDescriptor[]{createDescriptor(elementToHighlight,REQUIRED_JAVADOC_IS_ABSENT,manager,isOnTheFly)} : null;
  }
  PsiDocTag[] tags=docComment.getTags();
  @NonNls String[] tagsToCheck={"author","version","since"};
  @NonNls String[] absentDescriptionKeys={"inspection.javadoc.problem.missing.author.description","inspection.javadoc.problem.missing.version.description","inspection.javadoc.problem.missing.since.description"};
  boolean[] isTagRequired=new boolean[tagsToCheck.length];
  boolean[] isTagPresent=new boolean[tagsToCheck.length];
  boolean someTagsAreRequired=false;
  for (int i=0; i < tagsToCheck.length; i++) {
    final String tag=tagsToCheck[i];
    someTagsAreRequired|=isTagRequired[i]=isTagRequired(psiClass,tag);
  }
  if (someTagsAreRequired) {
    for (    PsiDocTag tag : tags) {
      String tagName=tag.getName();
      for (int i=0; i < tagsToCheck.length; i++) {
        final String tagToCheck=tagsToCheck[i];
        if (tagToCheck.equals(tagName)) {
          isTagPresent[i]=true;
        }
      }
    }
  }
  final ArrayList<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>(2);
  for (int i=0; i < tagsToCheck.length; i++) {
    final String tagToCheck=tagsToCheck[i];
    if (isTagRequired[i] && !isTagPresent[i]) {
      problems.add(createMissingTagDescriptor(elementToHighlight,tagToCheck,manager,isOnTheFly));
    }
  }
  ArrayList<ProblemDescriptor> tagProblems=getTagValuesProblems(psiClass,tags,manager,isOnTheFly);
  if (tagProblems != null) {
    problems.addAll(tagProblems);
  }
  checkForPeriodInDoc(docComment,problems,manager,isOnTheFly);
  checkInlineTags(manager,problems,docComment.getDescriptionElements(),JavaPsiFacade.getInstance(docComment.getProject()).getJavadocManager(),isOnTheFly);
  checkForBadCharacters(docComment,problems,manager,isOnTheFly);
  for (  PsiDocTag tag : tags) {
    for (int i=0; i < tagsToCheck.length; i++) {
      final String tagToCheck=tagsToCheck[i];
      if (tagToCheck.equals(tag.getName()) && extractTagDescription(tag).length() == 0) {
        problems.add(createDescriptor(elementToHighlight,InspectionsBundle.message(absentDescriptionKeys[i]),manager,isOnTheFly));
      }
    }
  }
  checkDuplicateTags(tags,problems,manager,isOnTheFly);
  if (isTagRequired(psiClass,"param") && psiClass.hasTypeParameters() && nameIdentifier != null) {
    ArrayList<PsiTypeParameter> absentParameters=null;
    final PsiTypeParameter[] typeParameters=psiClass.getTypeParameters();
    for (    PsiTypeParameter typeParameter : typeParameters) {
      if (!isFound(tags,typeParameter)) {
        if (absentParameters == null)         absentParameters=new ArrayList<PsiTypeParameter>(1);
        absentParameters.add(typeParameter);
      }
    }
    if (absentParameters != null) {
      for (      PsiTypeParameter psiTypeParameter : absentParameters) {
        problems.add(createMissingParamTagDescriptor(nameIdentifier,psiTypeParameter,manager,isOnTheFly));
      }
    }
  }
  return problems.isEmpty() ? null : problems.toArray(new ProblemDescriptor[problems.size()]);
}
