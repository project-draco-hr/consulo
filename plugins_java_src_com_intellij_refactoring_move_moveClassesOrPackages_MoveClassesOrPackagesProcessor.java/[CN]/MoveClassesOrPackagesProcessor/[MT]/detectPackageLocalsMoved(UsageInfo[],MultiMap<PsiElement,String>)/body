{
  final HashSet<PsiClass> movedClasses=new HashSet<PsiClass>();
  final HashMap<PsiClass,HashSet<PsiElement>> reportedClassToContainers=new HashMap<PsiClass,HashSet<PsiElement>>();
  final PackageWrapper aPackage=myTargetPackage;
  for (  UsageInfo usage : usages) {
    PsiElement element=usage.getElement();
    if (element == null)     continue;
    if (usage instanceof MoveRenameUsageInfo && !(usage instanceof NonCodeUsageInfo) && ((MoveRenameUsageInfo)usage).getReferencedElement() instanceof PsiClass) {
      PsiClass aClass=(PsiClass)((MoveRenameUsageInfo)usage).getReferencedElement();
      if (!movedClasses.contains(aClass)) {
        movedClasses.add(aClass);
      }
      String visibility=VisibilityUtil.getVisibilityModifier(aClass.getModifierList());
      if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {
        if (PsiTreeUtil.getParentOfType(element,PsiImportStatement.class) != null)         continue;
        PsiElement container=ConflictsUtil.getContainer(element);
        HashSet<PsiElement> reported=reportedClassToContainers.get(aClass);
        if (reported == null) {
          reported=new HashSet<PsiElement>();
          reportedClassToContainers.put(aClass,reported);
        }
        if (!reported.contains(container)) {
          reported.add(container);
          PsiFile containingFile=element.getContainingFile();
          if (containingFile != null && !isInsideMoved(element)) {
            PsiDirectory directory=containingFile.getContainingDirectory();
            if (directory != null) {
              PsiPackage usagePackage=JavaDirectoryService.getInstance().getPackage(directory);
              if (aPackage != null && usagePackage != null && !aPackage.equalToPackage(usagePackage)) {
                final String message=RefactoringBundle.message("a.package.local.class.0.will.no.longer.be.accessible.from.1",CommonRefactoringUtil.htmlEmphasize(aClass.getName()),RefactoringUIUtil.getDescription(container,true));
                conflicts.putValue(aClass,message);
              }
            }
          }
        }
      }
    }
  }
  final MyClassInstanceReferenceVisitor instanceReferenceVisitor=new MyClassInstanceReferenceVisitor(conflicts);
  for (  final PsiClass aClass : movedClasses) {
    String visibility=VisibilityUtil.getVisibilityModifier(aClass.getModifierList());
    if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {
      findInstancesOfPackageLocal(aClass,usages,instanceReferenceVisitor);
    }
 else {
      findPublicClassConflicts(aClass,instanceReferenceVisitor);
    }
  }
}
