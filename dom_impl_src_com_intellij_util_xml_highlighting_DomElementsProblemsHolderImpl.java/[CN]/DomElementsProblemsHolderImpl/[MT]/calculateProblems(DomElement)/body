{
synchronized (PsiLock.LOCK) {
    if (!myCachedErrors.containsKey(mainElement)) {
      final DomElementAnnotationHolderImpl holder=new DomElementAnnotationHolderImpl();
      ((DomElementAnnotationsManagerImpl)DomElementAnnotationsManager.getInstance(mainElement.getManager().getProject())).annotate(mainElement,holder,myRootType);
      final List<DomElementProblemDescriptor> result=new SmartList<DomElementProblemDescriptor>();
      boolean childrenHaveErrors=false;
      for (      final DomElementProblemDescriptor descriptor : holder) {
        final DomElement errorElement=descriptor.getDomElement();
        LOG.assertTrue(DomUtil.isAncestor(mainElement,errorElement,false),"It's only allowed to create DOM problems for the subtree of the element being annotated.\n Error element: " + descriptor + "\nAnnotated element:"+ mainElement);
        if (!mainElement.equals(errorElement)) {
          addProblem(errorElement,descriptor);
          childrenHaveErrors=true;
          result.clear();
        }
 else         if (!childrenHaveErrors) {
          result.add(descriptor);
        }
      }
      myCachedErrors.put(mainElement,result);
    }
    return !myCachedErrors.get(mainElement).isEmpty();
  }
}
