{
  myExpression=null;
  if (myElements.length == 1 && myElements[0] instanceof PsiExpression) {
    final PsiExpression expression=(PsiExpression)myElements[0];
    if (expression instanceof PsiAssignmentExpression && expression.getParent() instanceof PsiExpressionStatement) {
      myElements[0]=expression.getParent();
    }
 else {
      myExpression=expression;
    }
  }
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(myElements[0]);
  myCodeFragmentMember=codeFragment.getUserData(ElementToWorkOn.PARENT);
  if (myCodeFragmentMember == null) {
    myCodeFragmentMember=codeFragment.getParent();
  }
  if (myCodeFragmentMember == null) {
    myCodeFragmentMember=ControlFlowUtil.findCodeFragment(codeFragment.getContext()).getParent();
  }
  myControlFlowWrapper=new ControlFlowWrapper(myProject,codeFragment,myElements);
  try {
    myExitStatements=myControlFlowWrapper.prepareExitStatements(myElements);
    if (myControlFlowWrapper.isGenerateConditionalExit()) {
      myGenerateConditionalExit=true;
    }
 else {
      myHasReturnStatement=myExpression == null && myControlFlowWrapper.isReturnPresentBetween();
    }
    myFirstExitStatementCopy=myControlFlowWrapper.getFirstExitStatementCopy();
  }
 catch (  ControlFlowWrapper.ExitStatementsNotSameException e) {
    myExitStatements=myControlFlowWrapper.getExitStatements();
    showMultipleExitPointsMessage();
    return false;
  }
  myOutputVariables=myControlFlowWrapper.getOutputVariables();
  checkCanBeChainedConstructor();
  return chooseTargetClass(codeFragment,pass);
}
