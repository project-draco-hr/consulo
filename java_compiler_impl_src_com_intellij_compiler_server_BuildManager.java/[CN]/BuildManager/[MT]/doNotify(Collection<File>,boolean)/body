{
  myRequestsProcessor.submit(new Runnable(){
    @Override public void run(){
      final List<String> filtered=new ArrayList<String>(paths.size());
      for (      File file : paths) {
        final String path=FileUtil.toSystemIndependentName(file.getPath());
        if (PATH_FILTER.fun(path)) {
          filtered.add(path);
        }
      }
      if (filtered.isEmpty()) {
        return;
      }
synchronized (myProjectDataMap) {
        if (IS_UNIT_TEST_MODE) {
          if (notifyDeletion) {
            LOG.info("Registering deleted paths: " + filtered);
          }
 else {
            LOG.info("Registering changed paths: " + filtered);
          }
        }
        for (        Map.Entry<String,ProjectData> entry : myProjectDataMap.entrySet()) {
          final ProjectData data=entry.getValue();
          if (notifyDeletion) {
            data.addDeleted(filtered);
          }
 else {
            data.addChanged(filtered);
          }
          final RequestFuture future=myBuildsInProgress.get(entry.getKey());
          if (future != null && !future.isCancelled() && !future.isDone()) {
            final UUID sessionId=future.getRequestID();
            final Channel channel=myMessageDispatcher.getConnectedChannel(sessionId);
            if (channel != null) {
              final CmdlineRemoteProto.Message.ControllerMessage message=CmdlineRemoteProto.Message.ControllerMessage.newBuilder().setType(CmdlineRemoteProto.Message.ControllerMessage.Type.FS_EVENT).setFsEvent(data.createNextEvent()).build();
              Channels.write(channel,CmdlineProtoUtil.toMessage(sessionId,message));
            }
          }
        }
      }
    }
  }
);
}
