{
  final String projectPath=getProjectPath(project);
  final UUID sessionId=UUID.randomUUID();
  final CmdlineRemoteProto.Message.ControllerMessage params;
  CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals=myGlobals;
  if (globals == null) {
    globals=buildGlobalSettings();
    myGlobals=globals;
  }
  if (isRebuild) {
    params=CmdlineProtoUtil.createRebuildRequest(projectPath,userData,globals);
  }
 else {
    params=isMake ? CmdlineProtoUtil.createMakeRequest(projectPath,modules,artifacts,userData,globals) : CmdlineProtoUtil.createForceCompileRequest(projectPath,modules,artifacts,paths,userData,globals);
  }
  myMessageDispatcher.registerBuildMessageHandler(sessionId,handler,params);
  if (myListenPort < 0) {
    try {
      myListenPort=startListening();
    }
 catch (    Exception e) {
      myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
      handler.handleFailure(CmdlineProtoUtil.createFailure(e.getMessage(),null));
      handler.sessionTerminated();
      return null;
    }
  }
  final RequestFuture<BuildMessageHandler> future=new RequestFuture<BuildMessageHandler>(handler,sessionId,new RequestFuture.CancelAction<com.intellij.compiler.server.BuildMessageHandler>(){
    @Override public void cancel(    RequestFuture<BuildMessageHandler> future) throws Exception {
      myMessageDispatcher.cancelSession(future.getRequestID());
    }
  }
);
  SequentialTaskExecutor sequential;
synchronized (myProjectToExecutorMap) {
    sequential=myProjectToExecutorMap.get(projectPath);
    if (sequential == null) {
      sequential=new SequentialTaskExecutor(myPooledThreadExecutor);
      myProjectToExecutorMap.put(projectPath,sequential);
    }
  }
  sequential.submit(new Runnable(){
    @Override public void run(){
      try {
        if (project.isDisposed()) {
          future.cancel(false);
          return;
        }
        final Process process=launchBuildProcess(myListenPort,sessionId);
        final OSProcessHandler processHandler=new OSProcessHandler(process,null){
          @Override protected boolean shouldDestroyProcessRecursively(){
            return true;
          }
        }
;
        processHandler.addProcessListener(new ProcessAdapter(){
          @Override public void processTerminated(          ProcessEvent event){
            final BuildMessageHandler handler=myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
            if (handler != null) {
              handler.sessionTerminated();
            }
          }
          @Override public void onTextAvailable(          ProcessEvent event,          Key outputType){
            final String text=event.getText();
            if (!StringUtil.isEmpty(text)) {
              LOG.info("BUILDER_PROCESS [" + outputType.toString() + "]: "+ text.trim());
            }
          }
        }
);
        processHandler.startNotify();
        processHandler.waitFor();
      }
 catch (      ExecutionException e) {
        myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
        handler.handleFailure(CmdlineProtoUtil.createFailure(e.getMessage(),e));
        handler.sessionTerminated();
      }
 finally {
        future.setDone();
      }
    }
  }
);
  return future;
}
