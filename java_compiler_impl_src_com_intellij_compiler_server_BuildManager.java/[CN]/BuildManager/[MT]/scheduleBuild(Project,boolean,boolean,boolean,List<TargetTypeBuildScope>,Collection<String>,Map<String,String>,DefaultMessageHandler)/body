{
  final String projectPath=getProjectPath(project);
  final UUID sessionId=UUID.randomUUID();
  if (myListenPort < 0) {
    try {
synchronized (this) {
        if (myListenPort < 0) {
          myListenPort=startListening();
        }
      }
    }
 catch (    Exception e) {
      handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),null));
      handler.sessionTerminated(sessionId);
      return null;
    }
  }
  try {
    final RequestFuture<BuilderMessageHandler> future=new RequestFuture<BuilderMessageHandler>(handler,sessionId,new RequestFuture.CancelAction<BuilderMessageHandler>(){
      @Override public void cancel(      RequestFuture<BuilderMessageHandler> future) throws Exception {
        myMessageDispatcher.cancelSession(future.getRequestID());
      }
    }
);
    runCommand(new Runnable(){
      @Override public void run(){
        if (future.isCancelled() || project.isDisposed()) {
          handler.sessionTerminated(sessionId);
          future.setDone();
          return;
        }
        final CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings globals=CmdlineRemoteProto.Message.ControllerMessage.GlobalSettings.newBuilder().setGlobalOptionsPath(PathManager.getOptionsPath()).build();
        CmdlineRemoteProto.Message.ControllerMessage.FSEvent currentFSChanges;
        final SequentialTaskExecutor projectTaskQueue;
synchronized (myProjectDataMap) {
          ProjectData data=myProjectDataMap.get(projectPath);
          if (data == null) {
            data=new ProjectData(new SequentialTaskExecutor(myPooledThreadExecutor));
            myProjectDataMap.put(projectPath,data);
          }
          if (isRebuild) {
            data.dropChanges();
          }
          if (IS_UNIT_TEST_MODE) {
            LOG.info("Scheduling build for " + projectPath + "; CHANGED: "+ new HashSet<String>(data.myChanged)+ "; DELETED: "+ new HashSet<String>(data.myDeleted));
          }
          currentFSChanges=data.getAndResetRescanFlag() ? null : data.createNextEvent();
          projectTaskQueue=data.taskQueue;
        }
        final CmdlineRemoteProto.Message.ControllerMessage params;
        if (isRebuild) {
          params=CmdlineProtoUtil.createRebuildRequest(projectPath,scopes,userData,globals);
        }
 else         if (onlyCheckUpToDate) {
          params=CmdlineProtoUtil.createUpToDateCheckRequest(projectPath,scopes,paths,userData,globals,currentFSChanges);
        }
 else {
          params=isMake ? CmdlineProtoUtil.createMakeRequest(projectPath,scopes,userData,globals,currentFSChanges) : CmdlineProtoUtil.createForceCompileRequest(projectPath,scopes,paths,userData,globals,currentFSChanges);
        }
        myMessageDispatcher.registerBuildMessageHandler(sessionId,new BuilderMessageHandlerWrapper(handler){
          @Override public void sessionTerminated(          UUID sessionId){
            try {
              super.sessionTerminated(sessionId);
            }
  finally {
              future.setDone();
            }
          }
        }
,params);
        try {
          projectTaskQueue.submit(new Runnable(){
            @Override public void run(){
              Throwable execFailure=null;
              try {
                if (project.isDisposed()) {
                  return;
                }
                myBuildsInProgress.put(projectPath,future);
                final OSProcessHandler processHandler=launchBuildProcess(project,myListenPort,sessionId);
                final StringBuilder stdErrOutput=new StringBuilder();
                processHandler.addProcessListener(new ProcessAdapter(){
                  @Override public void onTextAvailable(                  ProcessEvent event,                  Key outputType){
                    final String text=event.getText();
                    if (!StringUtil.isEmptyOrSpaces(text)) {
                      LOG.info("BUILDER_PROCESS [" + outputType.toString() + "]: "+ text.trim());
                      if (stdErrOutput.length() < 1024 && ProcessOutputTypes.STDERR.equals(outputType)) {
                        stdErrOutput.append(text);
                      }
                    }
                  }
                }
);
                processHandler.startNotify();
                final boolean terminated=processHandler.waitFor();
                if (terminated) {
                  final int exitValue=processHandler.getProcess().exitValue();
                  if (exitValue != 0) {
                    final StringBuilder msg=new StringBuilder();
                    msg.append("Abnormal build process termination: ");
                    if (stdErrOutput.length() > 0) {
                      msg.append("\n").append(stdErrOutput);
                    }
 else {
                      msg.append("unknown error");
                    }
                    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(msg.toString(),null));
                  }
                }
 else {
                  handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure("Disconnected from build process",null));
                }
              }
 catch (              Throwable e) {
                execFailure=e;
              }
 finally {
                myBuildsInProgress.remove(projectPath);
                if (myMessageDispatcher.getAssociatedChannel(sessionId) == null) {
                  final BuilderMessageHandler unregistered=myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
                  if (unregistered != null) {
                    if (execFailure != null) {
                      unregistered.handleFailure(sessionId,CmdlineProtoUtil.createFailure(execFailure.getMessage(),execFailure));
                    }
                    unregistered.sessionTerminated(sessionId);
                  }
                }
              }
            }
          }
);
        }
 catch (        Throwable e) {
          final BuilderMessageHandler unregistered=myMessageDispatcher.unregisterBuildMessageHandler(sessionId);
          if (unregistered != null) {
            unregistered.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),e));
            unregistered.sessionTerminated(sessionId);
          }
        }
      }
    }
);
    return future;
  }
 catch (  Throwable e) {
    handler.handleFailure(sessionId,CmdlineProtoUtil.createFailure(e.getMessage(),e));
    handler.sessionTerminated(sessionId);
  }
  return null;
}
