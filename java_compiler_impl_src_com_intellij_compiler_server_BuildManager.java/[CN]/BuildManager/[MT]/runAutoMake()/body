{
  final Project[] openProjects=myProjectManager.getOpenProjects();
  if (openProjects.length > 0) {
    final List<RequestFuture> futures=new ArrayList<RequestFuture>();
    for (    final Project project : openProjects) {
      if (project.isDefault() || project.isDisposed()) {
        continue;
      }
      final CompilerWorkspaceConfiguration config=CompilerWorkspaceConfiguration.getInstance(project);
      if (!config.useOutOfProcessBuild() || !config.MAKE_PROJECT_ON_SAVE) {
        continue;
      }
      if (!config.ALLOW_AUTOMAKE_WHILE_RUNNING_APPLICATION) {
        final RunContentManager contentManager=ExecutionManager.getInstance(project).getContentManager();
        boolean hasRunningProcesses=false;
        for (        RunContentDescriptor descriptor : contentManager.getAllDescriptors()) {
          final ProcessHandler handler=descriptor.getProcessHandler();
          if (handler != null && !handler.isProcessTerminated()) {
            hasRunningProcesses=true;
            break;
          }
        }
        if (hasRunningProcesses) {
          continue;
        }
      }
      final List<String> emptyList=Collections.emptyList();
      final RequestFuture future=scheduleBuild(project,false,true,emptyList,emptyList,emptyList,Collections.<String,String>emptyMap(),new AutoMakeMessageHandler(project));
      if (future != null) {
        futures.add(future);
synchronized (myAutomakeFutures) {
          myAutomakeFutures.put(future,project);
        }
      }
    }
    try {
      for (      RequestFuture future : futures) {
        future.waitFor();
      }
    }
  finally {
synchronized (myAutomakeFutures) {
        myAutomakeFutures.keySet().removeAll(futures);
      }
    }
  }
}
