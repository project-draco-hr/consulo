{
  String prefix=result.getPrefixMatcher().getPrefix();
  final PsiElement position=parameters.getPosition();
  final ExpectedTypeInfo[] expectedTypes=PsiJavaPatterns.psiElement().beforeLeaf(PsiJavaPatterns.psiElement().withText(".")).accepts(position) ? ExpectedTypeInfo.EMPTY_ARRAY : JavaSmartCompletionContributor.getExpectedTypes(parameters);
  final CompletionType type=parameters.getCompletionType();
  final boolean smart=type == CompletionType.SMART;
  final boolean afterNew=JavaSmartCompletionContributor.AFTER_NEW.accepts(position);
  List<LookupElementWeigher> afterNegativeStats=new ArrayList<LookupElementWeigher>();
  if (!smart) {
    ContainerUtil.addIfNotNull(afterNegativeStats,preferStatics(position,expectedTypes));
  }
  if (!JavaCompletionData.START_FOR.accepts(position)) {
    afterNegativeStats.add(new PreferByKindWeigher(type,position));
  }
  ContainerUtil.addIfNotNull(afterNegativeStats,recursion(parameters,expectedTypes));
  if (!smart && !afterNew) {
    afterNegativeStats.add(new PreferExpected(false,expectedTypes));
  }
  afterNegativeStats.add(new PreferSimilarlyEnding(expectedTypes,prefix));
  List<LookupElementWeigher> afterProximity=new ArrayList<LookupElementWeigher>();
  afterProximity.add(new PreferContainingSameWords(expectedTypes));
  if (smart) {
    afterProximity.add(new PreferFieldsAndGetters());
  }
  afterProximity.add(new PreferShorter(expectedTypes,prefix));
  CompletionSorter sorter=CompletionSorter.defaultSorter(parameters,result.getPrefixMatcher());
  if (!smart && afterNew) {
    sorter=sorter.weighBefore("liftShorter",new PreferExpected(true,expectedTypes));
  }
 else {
    final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(position.getProject()).getFileIndex();
    sorter=((CompletionSorterImpl)sorter).withClassifier("liftShorter",true,new ClassifierFactory<LookupElement>("liftShorterClasses"){
      @Override public Classifier<LookupElement> createClassifier(      Classifier<LookupElement> next){
        return new LiftShorterItemsClassifier(next,new LiftShorterItemsClassifier.LiftingCondition(){
          @Override public boolean shouldLift(          LookupElement shorterElement,          LookupElement longerElement){
            if (super.shouldLift(shorterElement,longerElement)) {
              return true;
            }
            Object object=shorterElement.getObject();
            if (object instanceof PsiClass) {
              PsiClass psiClass=(PsiClass)object;
              PsiFile file=psiClass.getContainingFile();
              if (file != null) {
                VirtualFile vFile=file.getOriginalFile().getVirtualFile();
                if (vFile != null && fileIndex.isInSource(vFile)) {
                  return true;
                }
              }
              Object longerObject=longerElement.getObject();
              if (longerObject instanceof PsiMember && psiClass.getManager().areElementsEquivalent(psiClass,((PsiMember)longerObject).getContainingClass())) {
                return true;
              }
            }
            return false;
          }
        }
);
      }
    }
);
  }
  if (smart) {
    sorter=sorter.weighBefore("negativeStats",new PreferDefaultTypeWeigher(expectedTypes,parameters));
  }
  sorter=sorter.weighAfter("negativeStats",afterNegativeStats.toArray(new LookupElementWeigher[afterNegativeStats.size()]));
  sorter=sorter.weighAfter("prefix",new PreferNonGeneric(),new PreferAccessible(position),new PreferSimple(),new PreferEnumConstants(parameters));
  sorter=sorter.weighAfter("proximity",afterProximity.toArray(new LookupElementWeigher[afterProximity.size()]));
  return result.withRelevanceSorter(sorter);
}
