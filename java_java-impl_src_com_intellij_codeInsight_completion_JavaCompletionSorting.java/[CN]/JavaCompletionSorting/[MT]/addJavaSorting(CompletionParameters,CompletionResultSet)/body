{
  final PsiElement position=parameters.getPosition();
  final ExpectedTypeInfo[] expectedTypes=PsiJavaPatterns.psiElement().beforeLeaf(PsiJavaPatterns.psiElement().withText(".")).accepts(position) ? ExpectedTypeInfo.EMPTY_ARRAY : JavaSmartCompletionContributor.getExpectedTypes(parameters);
  final CompletionType type=parameters.getCompletionType();
  final boolean smart=type == CompletionType.SMART;
  final boolean afterNew=JavaSmartCompletionContributor.AFTER_NEW.accepts(position);
  List<LookupElementWeigher> afterNegativeStats=new ArrayList<LookupElementWeigher>();
  ContainerUtil.addIfNotNull(afterNegativeStats,smart ? new PreferDefaultTypeWeigher(expectedTypes,parameters) : preferStatics(position));
  afterNegativeStats.add(new PreferLocalVariablesLiteralsAndAnnoMethodsWeigher(type));
  ContainerUtil.addIfNotNull(afterNegativeStats,recursion(parameters,expectedTypes));
  if (!smart && !afterNew) {
    afterNegativeStats.add(new PreferExpected(false,expectedTypes));
  }
  afterNegativeStats.add(new PreferSimilarlyEnding(expectedTypes));
  List<LookupElementWeigher> afterProximity=new ArrayList<LookupElementWeigher>();
  afterProximity.add(new PreferContainingSameWords(expectedTypes));
  if (smart) {
    afterProximity.add(new PreferFieldsAndGetters());
  }
  afterProximity.add(new PreferShorter(expectedTypes));
  CompletionSorter sorter=CompletionSorter.defaultSorter(parameters);
  if (!smart && afterNew) {
    sorter=sorter.weighBefore("liftShorter",new PreferExpected(true,expectedTypes));
  }
  sorter=sorter.weighAfter("negativeStats",afterNegativeStats.toArray(new LookupElementWeigher[afterNegativeStats.size()]));
  sorter=sorter.weighAfter("prefix",new PreferNonGeneric(),new PreferAccessible(position),new PreferSimple(),new PreferEnumConstants(parameters));
  sorter=sorter.weighAfter("proximity",afterProximity.toArray(new LookupElementWeigher[afterProximity.size()]));
  return result.withRelevanceSorter(sorter);
}
