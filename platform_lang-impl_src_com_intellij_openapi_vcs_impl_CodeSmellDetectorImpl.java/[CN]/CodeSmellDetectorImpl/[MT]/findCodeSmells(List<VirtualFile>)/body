{
  final List<CodeSmellInfo> result=new ArrayList<CodeSmellInfo>();
  final PsiManager manager=PsiManager.getInstance(myProject);
  final FileDocumentManager fileManager=FileDocumentManager.getInstance();
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  if (ApplicationManager.getApplication().isWriteAccessAllowed())   throw new RuntimeException("Must not run under write action");
  ProgressManager.getInstance().run(new Task.Modal(myProject,VcsBundle.message("checking.code.smells.progress.title"),true){
    @Override public void run(    @NotNull ProgressIndicator progress){
      try {
        for (int i=0; i < filesToCheck.size(); i++) {
          if (progress.isCanceled())           throw new ProcessCanceledException();
          final VirtualFile file=filesToCheck.get(i);
          progress.setText(VcsBundle.message("searching.for.code.smells.processing.file.progress.text",file.getPresentableUrl()));
          progress.setFraction((double)i / (double)filesToCheck.size());
          final PsiFile psiFile=ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>(){
            @Override public PsiFile compute(){
              return manager.findFile(file);
            }
          }
);
          if (psiFile != null) {
            final Document document=ApplicationManager.getApplication().runReadAction(new Computable<Document>(){
              @Override public Document compute(){
                return fileManager.getDocument(file);
              }
            }
);
            if (document != null) {
              final List<CodeSmellInfo> codeSmells=findCodeSmells(psiFile,progress,document);
              result.addAll(codeSmells);
            }
          }
        }
      }
 catch (      ProcessCanceledException e) {
        throw e;
      }
catch (      Exception e) {
        LOG.error(e);
        myException=e;
      }
    }
  }
);
  if (myException != null) {
    Rethrow.reThrowRuntime(myException);
  }
  return result;
}
