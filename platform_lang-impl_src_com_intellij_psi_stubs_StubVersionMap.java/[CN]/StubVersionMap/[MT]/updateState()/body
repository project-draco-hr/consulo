{
  final long currentStubIndexStamp=IndexingStamp.getIndexCreationStamp(StubUpdatingIndex.INDEX_ID);
  File allIndexedFiles=allIndexedFilesRegistryFile();
  List<String> removedFileTypes=new ArrayList<String>();
  List<FileType> updatedFileTypes=new ArrayList<FileType>();
  List<FileType> addedFileTypes=new ArrayList<FileType>();
  long lastUsedCounter=currentStubIndexStamp;
  if (allIndexedFiles.lastModified() == currentStubIndexStamp) {
    FileTypeRegistry fileTypeRegistry=FileTypeRegistry.getInstance();
    Set<FileType> loadedFileTypes=new THashSet<FileType>();
    for (    String fileTypeInfo : StringUtil.split(FileUtil.loadFile(allIndexedFiles,ourEncoding),LINE_SEPARATOR)) {
      List<String> strings=StringUtil.split(fileTypeInfo,RECORD_SEPARATOR);
      String fileTypeName=strings.get(0);
      long usedTimeStamp=Long.parseLong(strings.get(2));
      lastUsedCounter=Math.min(lastUsedCounter,usedTimeStamp);
      FileType fileType=fileTypeRegistry.findFileTypeByName(fileTypeName);
      if (fileType == null)       removedFileTypes.add(fileTypeName);
 else {
        loadedFileTypes.add(fileType);
        Object owner=getVersionOwner(fileType);
        if (owner == null)         removedFileTypes.add(fileTypeName);
 else {
          if (!Comparing.equal(strings.get(1),typeAndVersion(owner))) {
            updatedFileTypes.add(fileType);
          }
 else {
            registerStamp(fileType,usedTimeStamp);
          }
        }
      }
    }
    for (    FileType fileType : fileTypeToVersionOwner.keySet()) {
      if (!loadedFileTypes.contains(fileType)) {
        addedFileTypes.add(fileType);
      }
    }
    if (!addedFileTypes.isEmpty() || !removedFileTypes.isEmpty()) {
      StubUpdatingIndex.LOG.info("requesting complete stub index rebuild due to changes: " + (addedFileTypes.isEmpty() ? "" : "added file types:" + StringUtil.join(addedFileTypes,new Function<FileType,String>(){
        @Override public String fun(        FileType fileType){
          return fileType.getName();
        }
      }
,",") + ";") + (removedFileTypes.isEmpty() ? "" : "removed file types:" + StringUtil.join(removedFileTypes,",")));
      throw new IOException();
    }
  }
 else {
    addedFileTypes.addAll(fileTypeToVersionOwner.keySet());
  }
  long counter=lastUsedCounter - 1;
  for (  FileType fileType : ContainerUtil.concat(updatedFileTypes,addedFileTypes)) {
    while (versionToFileType.containsKey(counter))     --counter;
    registerStamp(fileType,counter);
  }
  if (!addedFileTypes.isEmpty() || !updatedFileTypes.isEmpty() || !removedFileTypes.isEmpty()) {
    if (!addedFileTypes.isEmpty()) {
      StubUpdatingIndex.LOG.info("Following new file types will be indexed:" + StringUtil.join(addedFileTypes,new Function<FileType,String>(){
        @Override public String fun(        FileType fileType){
          return fileType.getName();
        }
      }
,","));
    }
    if (!updatedFileTypes.isEmpty()) {
      StubUpdatingIndex.LOG.info("Stub version was changed for " + StringUtil.join(updatedFileTypes,new Function<FileType,String>(){
        @Override public String fun(        FileType fileType){
          return fileType.getName();
        }
      }
,","));
    }
    if (!removedFileTypes.isEmpty()) {
      StubUpdatingIndex.LOG.info("Following file types will not be indexed:" + StringUtil.join(removedFileTypes,","));
    }
    StringBuilder allFileTypes=new StringBuilder();
    for (    FileType fileType : fileTypeToVersionOwner.keySet()) {
      Object owner=fileTypeToVersionOwner.get(fileType);
      long timestamp=fileTypeToVersion.get(fileType);
      allFileTypes.append(fileType.getName()).append(RECORD_SEPARATOR).append(typeAndVersion(owner)).append(RECORD_SEPARATOR).append(timestamp).append(LINE_SEPARATOR);
    }
    FileUtil.writeToFile(allIndexedFiles,allFileTypes.toString().getBytes(ourEncoding));
    FileUtil.setLastModified(allIndexedFiles,currentStubIndexStamp);
  }
  myStubIndexStamp=currentStubIndexStamp;
}
