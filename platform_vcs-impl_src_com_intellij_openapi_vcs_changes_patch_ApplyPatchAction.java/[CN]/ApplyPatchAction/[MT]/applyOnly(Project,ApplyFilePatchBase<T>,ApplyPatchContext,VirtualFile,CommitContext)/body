{
  final T patchBase=patch.getPatch();
  final Application application=ApplicationManager.getApplication();
  final ApplyFilePatch.Result result=application.runWriteAction(new Computable<ApplyFilePatch.Result>(){
    @Override public ApplyFilePatch.Result compute(){
      try {
        return patch.apply(file,context,project,new FilePathImpl(file),new Getter<CharSequence>(){
          @Override public CharSequence get(){
            return getBaseContents((TextFilePatch)patchBase,commitContext,project);
          }
        }
);
      }
 catch (      IOException e) {
        LOG.error(e);
        return ApplyFilePatch.Result.createThrow(e);
      }
    }
  }
);
  final ApplyPatchStatus status;
  try {
    status=result.getStatus();
  }
 catch (  IOException e) {
    showIOException(project,patchBase.getBeforeName(),e);
    return ApplyPatchStatus.FAILURE;
  }
  if (ApplyPatchStatus.ALREADY_APPLIED.equals(status) || ApplyPatchStatus.SUCCESS.equals(status)) {
    return status;
  }
  final ApplyPatchForBaseRevisionTexts mergeData=result.getMergeData();
  if (mergeData != null) {
    return ApplicationManager.getApplication().runWriteAction(new Computable<ApplyPatchStatus>(){
      @Override public ApplyPatchStatus compute(){
        if (mergeData.getBase() != null) {
          return showMergeDialog(project,file,mergeData.getBase(),mergeData.getPatched(),ApplyPatchMergeRequestFactory.INSTANCE);
        }
 else {
          try {
            return showBadDiffDialog(project,file,mergeData,false);
          }
 catch (          final IOException e) {
            SwingUtilities.invokeLater(new Runnable(){
              @Override public void run(){
                showIOException(project,patchBase.getBeforeName(),e);
              }
            }
);
          }
          return ApplyPatchStatus.FAILURE;
        }
      }
    }
);
  }
  return status;
}
