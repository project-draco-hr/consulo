{
  final TreeUtil.CommonParentState commonParents=new TreeUtil.CommonParentState();
  while (leaf != null) {
    commonParents.strongWhiteSpaceHolder=null;
    final IElementType tokenType=getNextTokenType();
    final TreeElement next;
    if (tokenType instanceof IChameleonElementType) {
      next=TreeUtil.nextLeaf(leaf,commonParents,tokenType);
    }
 else {
      next=TreeUtil.nextLeaf(leaf,commonParents,null);
    }
    if (next == null || tokenType == null)     break;
    if (tokenType != next.getElementType() && myProcessor.isTokenValid(tokenType)) {
      final TreeElement firstMissing=myProcessor.process(myLexer,myContext);
      final CompositeElement unclosedElement=commonParents.strongWhiteSpaceHolder;
      if (unclosedElement != null) {
        if (commonParents.isStrongElementOnRisingSlope || unclosedElement.getFirstChildNode() == null) {
          TreeUtil.addChildren(unclosedElement,firstMissing);
        }
 else {
          TreeUtil.insertBefore(unclosedElement.getFirstChildNode(),firstMissing);
        }
      }
 else {
        final ASTNode insertBefore=commonParents.nextLeafBranchStart;
        TreeElement insertAfter=commonParents.startLeafBranchStart;
        TreeElement current=commonParents.startLeafBranchStart;
        while (current != insertBefore) {
          final TreeElement treeNext=current.getTreeNext();
          if (treeNext == insertBefore) {
            insertAfter=current;
            break;
          }
          if (isInsertAfterElement(treeNext)) {
            insertAfter=current;
            break;
          }
          if (treeNext.getUserData(TreeUtil.UNCLOSED_ELEMENT_PROPERTY) != null) {
            insertAfter=null;
            TreeUtil.addChildren((CompositeElement)treeNext,firstMissing);
            break;
          }
          current=treeNext;
        }
        if (insertAfter != null)         TreeUtil.insertAfter(insertAfter,firstMissing);
      }
    }
    passTokenOrChameleon(next);
    leaf=next;
  }
}
