{
  final TreeUtil.CommonParentState commonParents=new TreeUtil.CommonParentState();
  while (leaf != null) {
    commonParents.strongWhiteSpaceHolder=null;
    final IElementType tokenType=getNextTokenType();
    final TreeElement next=TreeUtil.nextLeaf(leaf,commonParents,tokenType instanceof IChameleonElementType ? tokenType : null,false);
    if (next == null || tokenType == null)     break;
    if (tokenType != next.getElementType() && myProcessor.isTokenValid(tokenType)) {
      final TreeElement firstMissing=myProcessor.process(myLexer,myContext);
      final CompositeElement unclosedElement=commonParents.strongWhiteSpaceHolder;
      if (unclosedElement != null) {
        if (commonParents.isStrongElementOnRisingSlope || unclosedElement.getFirstChildNode() == null) {
          unclosedElement.rawAddChildren(firstMissing);
        }
 else {
          unclosedElement.getFirstChildNode().rawInsertBeforeMe(firstMissing);
        }
      }
 else {
        final ASTNode insertBefore=commonParents.nextLeafBranchStart;
        TreeElement insertAfter=commonParents.startLeafBranchStart;
        TreeElement current=commonParents.startLeafBranchStart;
        while (current != insertBefore) {
          final TreeElement treeNext=current.getTreeNext();
          if (treeNext == insertBefore) {
            insertAfter=current;
            break;
          }
          if (isInsertAfterElement(treeNext)) {
            insertAfter=current;
            break;
          }
          if (treeNext.getUserData(TreeUtil.UNCLOSED_ELEMENT_PROPERTY) != null) {
            insertAfter=null;
            ((CompositeElement)treeNext).rawAddChildren(firstMissing);
            break;
          }
          current=treeNext;
        }
        if (insertAfter != null)         insertAfter.rawInsertAfterMe(firstMissing);
      }
    }
    passTokenOrChameleon(next);
    leaf=next;
  }
}
