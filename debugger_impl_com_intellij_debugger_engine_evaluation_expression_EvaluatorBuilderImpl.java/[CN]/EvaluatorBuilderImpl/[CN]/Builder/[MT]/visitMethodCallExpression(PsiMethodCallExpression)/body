{
  if (LOG.isDebugEnabled()) {
    LOG.debug("visitMethodCallExpression " + expression);
  }
  final PsiExpressionList argumentList=expression.getArgumentList();
  final PsiExpression[] argExpressions=argumentList.getExpressions();
  List<Evaluator> argumentEvaluators=new ArrayList<Evaluator>(argExpressions.length);
  for (  PsiExpression psiExpression : argExpressions) {
    psiExpression.accept(this);
    if (myResult == null) {
      throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message("evaluation.error.invalid.expression",psiExpression.getText())));
    }
    argumentEvaluators.add(myResult);
  }
  PsiReferenceExpression methodExpr=expression.getMethodExpression();
  final JavaResolveResult resolveResult=methodExpr.advancedResolve(false);
  final PsiMethod psiMethod=(PsiMethod)resolveResult.getElement();
  PsiExpression qualifier=methodExpr.getQualifierExpression();
  Evaluator objectEvaluator;
  JVMName contextClass;
  if (psiMethod != null) {
    PsiClass methodPsiClass=psiMethod.getContainingClass();
    contextClass=JVMNameUtil.getJVMQualifiedName(methodPsiClass);
    if (psiMethod.hasModifierProperty(PsiModifier.STATIC)) {
      objectEvaluator=new TypeEvaluator(contextClass);
    }
 else     if (qualifier != null) {
      qualifier.accept(this);
      objectEvaluator=myResult;
    }
 else {
      int iterationCount=0;
      final PsiElement currentFileResolveScope=resolveResult.getCurrentFileResolveScope();
      if (currentFileResolveScope instanceof PsiClass) {
        PsiClass aClass=getContextPsiClass();
        while (aClass != null && !aClass.equals(currentFileResolveScope)) {
          aClass=getOuterClass(aClass);
          iterationCount++;
        }
      }
      objectEvaluator=new ThisEvaluator(iterationCount);
    }
  }
 else {
    if (qualifier != null) {
      PsiType type=qualifier.getType();
      if (type == null) {
        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message("evaluation.error.qualifier.type.unknown",qualifier.getText())));
      }
      contextClass=JVMNameUtil.getJVMQualifiedName(type);
      if (qualifier instanceof PsiReferenceExpression && ((PsiReferenceExpression)qualifier).resolve() instanceof PsiClass) {
        objectEvaluator=new TypeEvaluator(contextClass);
      }
 else {
        qualifier.accept(this);
        objectEvaluator=myResult;
      }
    }
 else {
      objectEvaluator=new ThisEvaluator();
      if (myContextPsiClass != null) {
        contextClass=JVMNameUtil.getJVMQualifiedName(myContextPsiClass);
      }
 else {
        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message("evaluation.error.method.not.found",methodExpr.getReferenceName())));
      }
    }
  }
  if (objectEvaluator == null) {
    throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message("evaluation.error.invalid.expression",expression.getText())));
  }
  myResult=new MethodEvaluator(objectEvaluator,contextClass,methodExpr.getReferenceName(),psiMethod != null ? JVMNameUtil.getJVMSignature(psiMethod) : null,argumentEvaluators);
}
