{
  ProgressManager.checkCanceled();
  ApplicationManager.getApplication().assertReadAccessAllowed();
  int clearCountOnStart=myClearCount.intValue();
  boolean physical=ref.getElement().isPhysical();
  TResult result=getCached(ref,maps,physical,incompleteCode);
  if (result != null) {
    return result;
  }
  Computable<TResult> computable=new Computable<TResult>(){
    @Override public TResult compute(){
      return resolver.resolve(ref,incompleteCode);
    }
  }
;
  RecursionGuard.StackStamp stamp=myGuard.markStack();
  result=needToPreventRecursion ? myGuard.doPreventingRecursion(Trinity.create(ref,incompleteCode,poly),true,computable) : computable.compute();
  if (stamp.mayCacheNow()) {
    cache(ref,result,maps,physical,incompleteCode,clearCountOnStart);
  }
  return result;
}
