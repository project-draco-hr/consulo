{
  ProgressManager.checkCanceled();
  final int clearCountOnStart=myClearCount.intValue();
  final boolean physical=ref.getElement().isPhysical();
  final TResult result=getCached(ref,maps,physical,incompleteCode);
  if (result != null) {
    return result;
  }
  Computable<TResult> computable=new Computable<TResult>(){
    @Override public TResult compute(){
      RecursionGuard.StackStamp stamp=myGuard.markStack();
      TResult result=resolver.resolve(ref,incompleteCode);
      if (stamp.mayCacheNow()) {
        cache(ref,result,maps,physical,incompleteCode,clearCountOnStart);
      }
      return result;
    }
  }
;
  return needToPreventRecursion ? myGuard.doPreventingRecursion(ref,computable) : computable.compute();
}
