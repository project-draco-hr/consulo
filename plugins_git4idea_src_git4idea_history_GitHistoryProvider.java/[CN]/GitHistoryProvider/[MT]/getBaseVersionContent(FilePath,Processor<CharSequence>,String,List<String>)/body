{
  if (StringUtil.isEmptyOrSpaces(beforeVersionId) || filePath.getVirtualFile() == null)   return false;
  final VirtualFile root=GitUtil.getGitRoot(filePath);
  if (root == null)   return false;
  final SHAHash shaHash=GitChangeUtils.commitExists(myProject,root,beforeVersionId,null,"--all");
  if (shaHash == null) {
    throw new VcsException("Can not apply patch to " + filePath.getPath() + ".\nCan not find revision '"+ beforeVersionId+ "'.");
  }
  final GitRevisionNumber mergeBase=GitHistoryUtils.getMergeBase(myProject,root,"HEAD",shaHash.getValue());
  if (mergeBase == null) {
    throw new VcsException("Can not apply patch to " + filePath.getPath() + ".\nBase revision '"+ beforeVersionId+ "', used in patch, is not on current branch (reachable from current HEAD),"+ "\nand there is no merge base between '"+ beforeVersionId+ "' and HEAD.");
  }
  final ContentRevision content=GitVcs.getInstance(myProject).getDiffProvider().createFileContent(new GitRevisionNumber(shaHash.getValue()),filePath.getVirtualFile());
  if (content == null) {
    throw new VcsException("Can not load content of '" + filePath.getPath() + "' for revision '"+ shaHash.getValue()+ "'");
  }
  final boolean matched=!processor.process(content.getContent());
  if (shaHash.getValue().startsWith(mergeBase.getRev())) {
    return matched;
  }
 else {
    if (matched) {
      warnings.add("Base revision '" + beforeVersionId + "', used in patch, is not on current branch (reachable from current HEAD)."+ "\nMerge base '"+ mergeBase.getRev()+ "' between '"+ beforeVersionId+ "' and HEAD was used.");
      return true;
    }
 else {
      throw new VcsException("Can not apply patch to " + filePath.getPath() + ".\nBase revision '"+ beforeVersionId+ "', used in patch, is not on current branch (reachable from current HEAD),"+ "\nand found merge base '"+ mergeBase.getRev()+ "' between '"+ beforeVersionId+ "' and HEAD doesn't match the context.");
    }
  }
}
