{
  List<Pair<File,Integer>> parentsToSkip=new SmartList<Pair<File,Integer>>();
  if (myTypeManager.isFileIgnored(dir.getName())) {
    return parentsToSkip;
  }
  if (myProgressIndicator != null) {
    if (myProgressIndicator.isCanceled()) {
      return parentsToSkip;
    }
    myProgressIndicator.setText2(dir.getPath());
  }
  File[] children=dir.listFiles();
  if (children == null) {
    children=ArrayUtil.EMPTY_FILE_ARRAY;
  }
  BitSet enabledForChildren=enabledDetectors;
  for (int i=0, detectorsLength=myDetectors.length; i < detectorsLength; i++) {
    if (!enabledDetectors.get(i))     continue;
    final ProjectStructureDetector.DirectoryProcessingResult result=myDetectors[i].detectRoots(dir,children,myBaseDir,myDetectedRoots[i]);
    if (!result.isProcessChildren()) {
      if (enabledForChildren == enabledDetectors) {
        enabledForChildren=new BitSet();
        enabledForChildren.or(enabledDetectors);
      }
      enabledForChildren.set(i,false);
    }
    final File parentToSkip=result.getParentToSkip();
    if (parentToSkip != null && !parentToSkip.equals(dir)) {
      parentsToSkip.add(Pair.create(parentToSkip,i));
    }
  }
  if (!enabledForChildren.isEmpty()) {
    for (    File child : children) {
      if (child.isDirectory()) {
        final List<Pair<File,Integer>> toSkip=processRecursively(child,enabledForChildren);
        if (!toSkip.isEmpty()) {
          if (enabledForChildren == enabledDetectors) {
            enabledForChildren=new BitSet();
            enabledForChildren.or(enabledDetectors);
          }
          for (          Pair<File,Integer> pair : toSkip) {
            enabledForChildren.set(pair.getSecond(),false);
            if (!pair.getFirst().equals(dir)) {
              parentsToSkip.add(pair);
            }
          }
          if (enabledForChildren.isEmpty()) {
            break;
          }
        }
      }
    }
  }
  return parentsToSkip;
}
