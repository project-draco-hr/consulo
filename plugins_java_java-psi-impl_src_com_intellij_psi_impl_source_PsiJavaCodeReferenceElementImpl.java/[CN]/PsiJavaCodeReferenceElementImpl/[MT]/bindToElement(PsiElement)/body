{
  CheckUtil.checkWritable(this);
  if (isReferenceTo(element))   return this;
switch (getKind()) {
case CLASS_NAME_KIND:
case CLASS_FQ_NAME_KIND:
    if (!(element instanceof PsiClass)) {
      throw cannotBindError(element);
    }
  return bindToClass((PsiClass)element);
case PACKAGE_NAME_KIND:
if (!(element instanceof PsiJavaPackage)) {
  throw cannotBindError(element);
}
return bindToPackage((PsiJavaPackage)element);
case CLASS_OR_PACKAGE_NAME_KIND:
case CLASS_FQ_OR_PACKAGE_NAME_KIND:
if (element instanceof PsiClass) {
return bindToClass((PsiClass)element);
}
 else if (element instanceof PsiJavaPackage) {
return bindToPackage((PsiJavaPackage)element);
}
 else {
throw cannotBindError(element);
}
case CLASS_IN_QUALIFIED_NEW_KIND:
if (element instanceof PsiClass) {
final PsiClass aClass=(PsiClass)element;
final String name=aClass.getName();
if (name == null) {
throw new IncorrectOperationException(aClass.toString());
}
final PsiJavaParserFacade parserFacade=JavaPsiFacade.getInstance(getProject()).getParserFacade();
final PsiJavaCodeReferenceElement ref=parserFacade.createReferenceFromText(name,getParent());
getTreeParent().replaceChildInternal(this,(TreeElement)ref.getNode());
return ref;
}
 else {
throw cannotBindError(element);
}
default :
LOG.assertTrue(false);
return null;
}
}
