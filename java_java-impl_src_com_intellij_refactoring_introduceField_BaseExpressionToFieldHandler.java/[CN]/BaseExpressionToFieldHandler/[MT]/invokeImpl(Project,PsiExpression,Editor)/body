{
  final PsiElement element=getPhysicalElement(selectedExpr);
  final PsiFile file=element.getContainingFile();
  LOG.assertTrue(file != null,"expr.getContainingFile() == null");
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + selectedExpr);
  }
  final PsiType tempType=getTypeByExpression(selectedExpr);
  if (tempType == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("unknown.expression.type"));
    CommonRefactoringUtil.showErrorHint(project,editor,message,getRefactoringName(),getHelpID());
    return false;
  }
  if (PsiType.VOID.equals(tempType)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    CommonRefactoringUtil.showErrorHint(project,editor,message,getRefactoringName(),getHelpID());
    return false;
  }
  myParentClass=getParentClass(selectedExpr);
  final List<PsiClass> classes=new ArrayList<PsiClass>();
  PsiClass aClass=myParentClass;
  while (aClass != null) {
    classes.add(aClass);
    aClass=PsiTreeUtil.getParentOfType(aClass,PsiClass.class,true);
  }
  if (classes.size() == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
    return !convertExpressionToField(selectedExpr,editor,file,project,tempType);
  }
 else {
    NavigationUtil.getPsiElementPopup(classes.toArray(new PsiClass[classes.size()]),new PsiClassListCellRenderer(),"Choose class to introduce " + (myIsConstant ? "constant" : "field"),new PsiElementProcessor<PsiClass>(){
      @Override public boolean execute(      PsiClass aClass){
        myParentClass=aClass;
        convertExpressionToField(selectedExpr,editor,file,project,tempType);
        return false;
      }
    }
).showInBestPositionFor(editor);
  }
  return true;
}
