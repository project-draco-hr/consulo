{
  final Map<PsiElement,String> conflicts=new HashMap<PsiElement,String>();
  final Project project=sourceClass.getProject();
  final GlobalSearchScope scope=GlobalSearchScope.allScope(project);
  final PsiClass existingClass=JavaPsiFacade.getInstance(project).findClass(StringUtil.getQualifiedName(newPackageName,newClassName),scope);
  if (existingClass != null) {
    conflicts.put(existingClass,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("there.already.exists.a.class.with.the.chosen.name"));
  }
  if (!myGenerateAccessors) {
    conflicts.putAll(calculateInitializersConflicts());
    final NecessaryAccessorsVisitor visitor=new NecessaryAccessorsVisitor();
    for (    PsiField field : fields) {
      field.accept(visitor);
    }
    for (    PsiMethod method : methods) {
      method.accept(visitor);
    }
    for (    PsiClass innerClass : innerClasses) {
      innerClass.accept(visitor);
    }
    final Set<PsiField> fieldsNeedingGetter=visitor.getFieldsNeedingGetter();
    for (    PsiField field : fieldsNeedingGetter) {
      conflicts.put(field,"Field \'" + field.getName() + "\' needs getter");
    }
    final Set<PsiField> fieldsNeedingSetter=visitor.getFieldsNeedingSetter();
    for (    PsiField field : fieldsNeedingSetter) {
      conflicts.put(field,"Field \'" + field.getName() + "\' needs getter");
    }
  }
  return showConflicts(conflicts);
}
