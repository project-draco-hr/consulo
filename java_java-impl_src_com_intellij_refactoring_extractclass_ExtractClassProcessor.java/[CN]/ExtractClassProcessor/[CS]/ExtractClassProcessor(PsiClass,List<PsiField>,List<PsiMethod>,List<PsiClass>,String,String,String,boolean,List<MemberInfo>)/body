{
  super(sourceClass.getProject());
  this.sourceClass=sourceClass;
  this.newPackageName=packageName;
  myNewVisibility=newVisibility;
  myGenerateAccessors=generateAccessors;
  this.enumConstants=new ArrayList<PsiField>();
  for (  MemberInfo constant : enumConstants) {
    this.enumConstants.add((PsiField)constant.getMember());
  }
  this.fields=new ArrayList<PsiField>(fields);
  this.methods=new ArrayList<PsiMethod>(methods);
  this.innerClasses=new ArrayList<PsiClass>(classes);
  this.newClassName=newClassName;
  delegateFieldName=calculateDelegateFieldName();
  requiresBackpointer=new BackpointerUsageVisitor(fields,innerClasses,methods,sourceClass).backpointerRequired();
  if (requiresBackpointer) {
    typeParams.addAll(Arrays.asList(sourceClass.getTypeParameters()));
  }
 else {
    final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
    final TypeParametersVisitor visitor=new TypeParametersVisitor(typeParamSet);
    for (    PsiField field : fields) {
      field.accept(visitor);
    }
    for (    PsiMethod method : methods) {
      method.accept(visitor);
      typeParamSet.removeAll(Arrays.asList(method.getTypeParameters()));
    }
    typeParams.addAll(typeParamSet);
  }
  myClass=ApplicationManager.getApplication().runWriteAction(new Computable<PsiClass>(){
    public PsiClass compute(){
      return buildClass();
    }
  }
);
  myExtractEnumProcessor=new ExtractEnumProcessor(myProject,this.enumConstants,fields,myClass);
}
