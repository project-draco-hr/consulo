{
  NewCompilerCache<Key,State> cache=CompilerCacheManager.getInstance(myProject).getNewCompilerCache(compiler);
  NewCompilerPersistentData data=new NewCompilerPersistentData(getNewCompilerCacheDir(myProject,compiler),compiler.getVersion());
  if (data.isVersionChanged()) {
    LOG.info("Clearing cache for " + compiler.getDescription());
    cache.wipe();
  }
  Set<String> targetsToRemove=new HashSet<String>(data.getAllTargets());
  for (  T target : instance.getAllTargets()) {
    targetsToRemove.remove(target.getId());
  }
  if (!myOnlyCheckStatus) {
    for (    String target : targetsToRemove) {
      int id=data.removeId(target);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Removing obsolete target '" + target + "' (id="+ id+ ")");
      }
      List<Key> keys=new ArrayList<Key>();
      cache.processSources(id,new CommonProcessors.CollectProcessor<Key>(keys));
      List<Pair<Key,State>> obsoleteSources=new ArrayList<Pair<Key,State>>();
      for (      Key key : keys) {
        final State state=cache.getState(id,key);
        obsoleteSources.add(Pair.create(key,state));
      }
      instance.processObsoleteTarget(target,obsoleteSources);
      if (myContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
        return true;
      }
      for (      Key key : keys) {
        cache.remove(id,key);
      }
    }
  }
  boolean didSomething=false;
  for (  T target : instance.getSelectedTargets()) {
    int id=data.getId(target.getId());
    didSomething|=processTarget(target,id,compiler,instance,cache);
  }
  data.save();
  return didSomething;
}
