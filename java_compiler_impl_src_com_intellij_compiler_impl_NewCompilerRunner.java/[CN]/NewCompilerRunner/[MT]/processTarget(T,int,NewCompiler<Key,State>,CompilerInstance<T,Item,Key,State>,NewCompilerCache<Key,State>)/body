{
  if (LOG.isDebugEnabled()) {
    LOG.debug("Processing target '" + target + "' (id="+ targetId+ ")");
  }
  final List<Item> items=instance.getItems(target);
  if (myContext.getMessageCount(CompilerMessageCategory.ERROR) > 0)   return true;
  final List<Pair<Item,State>> toProcess=new ArrayList<Pair<Item,State>>();
  final THashSet<Key> keySet=new THashSet<Key>(new SourceItemHashingStrategy<Key>(compiler));
  final Ref<IOException> exception=Ref.create(null);
  DumbService.getInstance(myProject).waitForSmartMode();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    @Override public void run(){
      try {
        for (        Item item : items) {
          final Key key=item.getKey();
          keySet.add(key);
          State output=cache.getState(targetId,key);
          if (myForceCompile || output == null || !item.isUpToDate(output)) {
            toProcess.add(Pair.create(item,output));
          }
        }
      }
 catch (      IOException e) {
        exception.set(e);
      }
    }
  }
);
  if (!exception.isNull()) {
    throw exception.get();
  }
  final List<Key> toRemove=new ArrayList<Key>();
  cache.processSources(targetId,new Processor<Key>(){
    @Override public boolean process(    Key key){
      if (!keySet.contains(key)) {
        toRemove.add(key);
      }
      return true;
    }
  }
);
  if (LOG.isDebugEnabled()) {
    LOG.debug(toProcess.size() + " items will be processed, " + toRemove.size()+ " items will be removed");
  }
  if (toProcess.isEmpty() && toRemove.isEmpty()) {
    return false;
  }
  if (myOnlyCheckStatus) {
    throw new CompileDriver.ExitException(CompileDriver.ExitStatus.CANCELLED);
  }
  List<Pair<Key,State>> obsoleteItems=new ArrayList<Pair<Key,State>>();
  for (  Key key : toRemove) {
    obsoleteItems.add(Pair.create(key,cache.getState(targetId,key)));
  }
  final List<Item> processedItems=new ArrayList<Item>();
  final List<File> toRefresh=new ArrayList<File>();
  instance.processItems(target,toProcess,obsoleteItems,new CompilerInstance.OutputConsumer<Item>(){
    @Override public void addFileToRefresh(    @NotNull File file){
      toRefresh.add(file);
    }
    @Override public void addProcessedItem(    @NotNull Item sourceItem){
      processedItems.add(sourceItem);
    }
  }
);
  if (myContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
    return true;
  }
  for (  Key key : toRemove) {
    cache.remove(targetId,key);
  }
  CompilerUtil.refreshIOFiles(toRefresh);
  for (  Item item : processedItems) {
    cache.putOutput(targetId,item.getKey(),item.computeState());
  }
  return true;
}
