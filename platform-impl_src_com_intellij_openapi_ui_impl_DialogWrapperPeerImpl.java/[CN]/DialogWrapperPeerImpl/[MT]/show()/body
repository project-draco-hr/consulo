{
  LOG.assertTrue(EventQueue.isDispatchThread(),"Access is allowed from event dispatch thread only");
  final AnCancelAction anCancelAction=new AnCancelAction();
  final JRootPane rootPane=getRootPane();
  anCancelAction.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0)),rootPane);
  myDisposeActions.add(new Runnable(){
    public void run(){
      anCancelAction.unregisterCustomShortcutSet(rootPane);
    }
  }
);
  if (!myCanBeParent && myWindowManager != null) {
    myWindowManager.doNotSuggestAsParent(myDialog);
  }
  final CommandProcessorEx commandProcessor=ApplicationManager.getApplication() != null ? (CommandProcessorEx)CommandProcessor.getInstance() : null;
  final boolean appStarted=commandProcessor != null;
  if (myDialog.isModal() && !isProgressDialog()) {
    if (ApplicationManager.getApplication() != null) {
      if (ApplicationManager.getApplication().getCurrentWriteAction(null) != null) {
        LOG.warn("Showing of a modal dialog inside write-action may be dangerous and resulting in unpredictable behavior! Current modalityState=" + ModalityState.current(),new Exception());
      }
    }
    if (appStarted) {
      commandProcessor.enterModal();
      LaterInvocator.enterModal(myDialog);
    }
  }
  if (appStarted) {
    hidePopupsIfNeeded();
  }
  try {
    myDialog.show();
  }
  finally {
    if (myDialog.isModal() && !isProgressDialog()) {
      if (appStarted) {
        commandProcessor.leaveModal();
        LaterInvocator.leaveModal(myDialog);
      }
    }
  }
}
