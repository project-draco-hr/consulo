{
  context.getProgressIndicator().pushState();
  context.getProgressIndicator().setText(CompilerBundle.message("progress.copying.resources"));
  final Map<String,Collection<OutputItem>> processed=new HashMap<String,Collection<OutputItem>>();
  final LinkedList<CopyCommand> copyCommands=new LinkedList<CopyCommand>();
  final long start=System.currentTimeMillis();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(myProject).getFileIndex();
      for (      final VirtualFile file : files) {
        if (context.getProgressIndicator().isCanceled()) {
          break;
        }
        final Module module=context.getModuleByFile(file);
        if (module == null) {
          continue;
        }
        final VirtualFile fileRoot=MakeUtil.getSourceRoot(context,module,file);
        if (fileRoot == null) {
          continue;
        }
        final String sourcePath=file.getPath();
        final String relativePath=VfsUtil.getRelativePath(file,fileRoot,'/');
        final String outputPath=CompilerPaths.getModuleOutputPath(module,((CompileContextEx)context).isInTestSourceContent(file));
        if (outputPath == null) {
          continue;
        }
        final String packagePrefix=fileIndex.getPackageNameByDirectory(fileRoot);
        final String targetPath;
        if (packagePrefix != null && packagePrefix.length() > 0) {
          targetPath=outputPath + "/" + packagePrefix.replace('.','/')+ "/"+ relativePath;
        }
 else {
          targetPath=outputPath + "/" + relativePath;
        }
        if (sourcePath.equals(targetPath)) {
          addToMap(processed,outputPath,new MyOutputItem(targetPath,file));
        }
 else {
          copyCommands.add(new CopyCommand(outputPath,sourcePath,targetPath,file));
        }
      }
    }
  }
);
  final Set<String> rootsToRefresh=new HashSet<String>();
  int idx=0;
  final int total=copyCommands.size();
  CopyCommand.ourCopyingTime=0L;
  while (!copyCommands.isEmpty()) {
    final CopyCommand command=copyCommands.removeFirst();
    if (context.getProgressIndicator().isCanceled()) {
      break;
    }
    context.getProgressIndicator().setFraction((idx++) * 1.0 / total);
    context.getProgressIndicator().setText2("Copying " + command.getFromPath() + "...");
    try {
      rootsToRefresh.add(command.getOutputPath());
      final MyOutputItem outputItem=command.copy();
      addToMap(processed,command.getOutputPath(),outputItem);
    }
 catch (    IOException e) {
      context.addMessage(CompilerMessageCategory.ERROR,CompilerBundle.message("error.copying",command.getFromPath(),command.getToPath(),e.getMessage()),command.getSourceFileUrl(),-1,-1);
    }
  }
  final long stop=System.currentTimeMillis();
  CompilerUtil.logDuration("Copying resources TOTAL",stop - start);
  CompilerUtil.logDuration("\tCopying resources (actual copying)",CopyCommand.ourCopyingTime);
  if (!rootsToRefresh.isEmpty()) {
    final List<File> dirs=new ArrayList<File>();
    for (    String path : rootsToRefresh) {
      dirs.add(new File(path));
    }
    CompilerUtil.refreshIODirectories(dirs);
    rootsToRefresh.clear();
  }
  for (Iterator<Map.Entry<String,Collection<OutputItem>>> it=processed.entrySet().iterator(); it.hasNext(); ) {
    Map.Entry<String,Collection<OutputItem>> entry=it.next();
    sink.add(entry.getKey(),entry.getValue(),VirtualFile.EMPTY_ARRAY);
    it.remove();
  }
  context.getProgressIndicator().popState();
}
