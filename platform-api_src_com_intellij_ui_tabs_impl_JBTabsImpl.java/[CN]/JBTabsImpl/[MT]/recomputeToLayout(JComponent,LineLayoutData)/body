{
  final int toolbarInset=getToolbarInset();
  data.displayedHToolbar=myHorizontalSide && selectedToolbar != null;
  data.toFitWidth=getWidth() - data.insets.left - data.insets.right- (data.displayedHToolbar ? toolbarInset : 0);
  if (isGhostsAlwaysVisible()) {
    data.toFitWidth-=getGhostTabWidth() * 2;
  }
  for (  TabInfo eachInfo : myVisibleInfos) {
    data.requiredWidth+=myInfo2Label.get(eachInfo).getPreferredSize().width;
    data.toLayout.add(eachInfo);
  }
  while (true) {
    if (data.requiredWidth <= data.toFitWidth - data.eachX)     break;
    if (data.toLayout.size() == 0)     break;
    final TabInfo first=data.toLayout.get(0);
    final TabInfo last=data.toLayout.get(data.toLayout.size() - 1);
    if (myRowDropPolicy == RowDropPolicy.leftFirst) {
      if (first != getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else       if (last != getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else {
        break;
      }
    }
 else {
      if (last != getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else       if (first != getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else {
        break;
      }
    }
  }
  for (int i=1; i < myVisibleInfos.size() - 1; i++) {
    final TabInfo each=myVisibleInfos.get(i);
    final TabInfo prev=myVisibleInfos.get(i - 1);
    final TabInfo next=myVisibleInfos.get(i + 1);
    if (data.toLayout.contains(each) && data.toDrop.contains(prev)) {
      myLeftGhost.setInfo(prev);
    }
 else     if (data.toLayout.contains(each) && data.toDrop.contains(next)) {
      myRightGhost.setInfo(next);
    }
  }
}
