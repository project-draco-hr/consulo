{
  for (  final PsiMember movedMember : myMovedMembers) {
    PsiMember element=movedMember;
    if (element instanceof PsiField) {
      String name=element.getName();
      if (targetClass.findFieldByName(name,false) != null) {
        String message=ConflictsUtil.getDescription(targetClass,false) + " already contains field " + ConflictsUtil.htmlEmphasize(name)+ ".";
        myConflicts.add(ConflictsUtil.capitalize(message));
      }
    }
 else     if (element instanceof PsiMethod) {
      PsiMethod method=(PsiMethod)element;
      if (targetClass.findMethodBySignature(method,false) != null) {
        String message=ConflictsUtil.getDescription(method,true) + " is already overridden in " + ConflictsUtil.getDescription(targetClass,false)+ ". Method will not be pushed down to that class.";
        myConflicts.add(ConflictsUtil.capitalize(message));
      }
    }
 else     if (element instanceof PsiClass) {
      PsiClass aClass=(PsiClass)element;
      final String name=aClass.getName();
      final PsiClass[] allInnerClasses=targetClass.getAllInnerClasses();
      for (      PsiClass innerClass : allInnerClasses) {
        if (innerClass.equals(element))         continue;
        if (name.equals(innerClass.getName())) {
          String message=ConflictsUtil.getDescription(targetClass,false) + " already contains inner class named " + ConflictsUtil.htmlEmphasize(name)+ ".";
          myConflicts.add(message);
        }
      }
    }
  }
}
