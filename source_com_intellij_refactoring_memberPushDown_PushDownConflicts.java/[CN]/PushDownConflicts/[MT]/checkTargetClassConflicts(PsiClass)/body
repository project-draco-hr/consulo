{
  for (Iterator iterator=myMovedMembers.iterator(); iterator.hasNext(); ) {
    PsiElement element=(PsiElement)iterator.next();
    if (element instanceof PsiField) {
      String name=((PsiField)element).getName();
      if (targetClass.findFieldByName(name,false) != null) {
        String message=ConflictsUtil.getDescription(targetClass,false) + " already contains field " + ConflictsUtil.htmlEmphasize(name)+ ".";
        myConflicts.add(ConflictsUtil.capitalize(message));
      }
    }
 else     if (element instanceof PsiMethod) {
      PsiMethod method=(PsiMethod)element;
      if (targetClass.findMethodBySignature(method,false) != null) {
        String message=ConflictsUtil.getDescription(method,true) + " is already overridden in " + ConflictsUtil.getDescription(targetClass,false)+ ". Method will not be pushed down to that class.";
        myConflicts.add(ConflictsUtil.capitalize(message));
      }
    }
 else     if (element instanceof PsiClass) {
      PsiClass aClass=(PsiClass)element;
      final String name=aClass.getName();
      final PsiClass[] allInnerClasses=targetClass.getAllInnerClasses();
      for (int i=0; i < allInnerClasses.length; i++) {
        PsiClass innerClass=allInnerClasses[i];
        if (name.equals(innerClass.getName())) {
          String message=ConflictsUtil.getDescription(targetClass,false) + " already contains inner class named " + ConflictsUtil.htmlEmphasize(name)+ ".";
          myConflicts.add(message);
        }
      }
    }
  }
}
