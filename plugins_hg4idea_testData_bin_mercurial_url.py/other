import urllib, urllib2, urlparse, httplib, os, re, socket, cStringIO
from i18n import _
import keepalive, util
_safe = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_.-/'
_safeset = None
_hex = None
has_https = hasattr(urllib2, 'HTTPSHandler')
if has_https:
    try:
        import ssl
        _ssl_wrap_socket = ssl.wrap_socket
        CERT_REQUIRED = ssl.CERT_REQUIRED
    except ImportError:
        CERT_REQUIRED = 2

        def _ssl_wrap_socket(sock, key_file, cert_file, cert_reqs=CERT_REQUIRED, ca_certs=None):
            if ca_certs:
                raise util.Abort(_('certificate checking requires Python 2.6'))
            ssl = socket.ssl(sock, key_file, cert_file)
            return httplib.FakeSocket(sock, ssl)
    try:
        _create_connection = socket.create_connection
    except AttributeError:
        _GLOBAL_DEFAULT_TIMEOUT = object()

        def _create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT, source_address=None):
            msg = 'getaddrinfo returns an empty list'
            (host, port) = address
            for res in socket.getaddrinfo(host, port, 0, socket.SOCK_STREAM):
                (af, socktype, proto, canonname, sa) = res
                sock = None
                try:
                    sock = socket.socket(af, socktype, proto)
                    if (timeout is not _GLOBAL_DEFAULT_TIMEOUT):
                        sock.settimeout(timeout)
                    if source_address:
                        sock.bind(source_address)
                    sock.connect(sa)
                    return sock
                except socket.error as msg:
                    if (sock is not None):
                        sock.close()
            raise socket.error, msg
if has_https:


    class BetterHTTPS(httplib.HTTPSConnection):
        send = keepalive.safesend

        def connect(self):
            if hasattr(self, 'ui'):
                cacerts = self.ui.config('web', 'cacerts')
            else:
                cacerts = None
            if cacerts:
                sock = _create_connection((self.host, self.port))
                self.sock = _ssl_wrap_socket(sock, self.key_file, self.cert_file, cert_reqs=CERT_REQUIRED, ca_certs=cacerts)
                self.ui.debug(_('server identity verification succeeded\n'))
            else:
                httplib.HTTPSConnection.connect(self)


    class httpsconnection(BetterHTTPS):
        response_class = keepalive.HTTPResponse
        send = _gen_sendfile(BetterHTTPS)
        getresponse = keepalive.wrapgetresponse(httplib.HTTPSConnection)

        def connect(self):
            if self.realhostport:
                self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.sock.connect((self.host, self.port))
                if _generic_proxytunnel(self):
                    self.sock = _ssl_wrap_socket(self.sock, self.cert_file, self.key_file)
            else:
                BetterHTTPS.connect(self)


    class httpshandler(keepalive.KeepAliveHandler, urllib2.HTTPSHandler):

        def __init__(self, ui):
            keepalive.KeepAliveHandler.__init__(self)
            urllib2.HTTPSHandler.__init__(self)
            self.ui = ui
            self.pwmgr = passwordmgr(self.ui)

        def _start_transaction(self, h, req):
            _generic_start_transaction(self, h, req)
            return keepalive.KeepAliveHandler._start_transaction(self, h, req)

        def https_open(self, req):
            self.auth = self.pwmgr.readauthtoken(req.get_full_url())
            return self.do_open(self._makeconnection, req)

        def _makeconnection(self, host, port=None, *args, **kwargs):
            keyfile = None
            certfile = None
            if (len(args) >= 1):
                keyfile = args[0]
            if (len(args) >= 2):
                certfile = args[1]
            args = args[2:]
            if (self.auth and ('key' in self.auth) and ('cert' in self.auth)):
                keyfile = self.auth['key']
                certfile = self.auth['cert']
            conn = httpsconnection(host, port, keyfile, certfile, *args, **kwargs)
            conn.ui = self.ui
            return conn
handlerfuncs = []
scheme_re = re.compile('^([a-zA-Z0-9+-.]+)://')
