def _generic_proxytunnel(self):
    proxyheaders = dict([(x, self.headers[x]) for x in self.headers if x.lower().startswith('proxy-')])
    self._set_hostport(self.host, self.port)
    self.send(('CONNECT %s HTTP/1.0\r\n' % self.realhostport))
    for header in proxyheaders.iteritems():
        self.send(('%s: %s\r\n' % header))
    self.send('\r\n')
    res = self.response_class(self.sock, strict=self.strict, method=self._method)
    while True:
        (version, status, reason) = res._read_status()
        if (status != httplib.CONTINUE):
            break
        while True:
            skip = res.fp.readline().strip()
            if (not skip):
                break
    res.status = status
    res.reason = reason.strip()
    if (res.status == 200):
        while True:
            line = res.fp.readline()
            if (line == '\r\n'):
                break
        return True
    if (version == 'HTTP/1.0'):
        res.version = 10
    elif version.startswith('HTTP/1.'):
        res.version = 11
    elif (version == 'HTTP/0.9'):
        res.version = 9
    else:
        raise httplib.UnknownProtocol(version)
    if (res.version == 9):
        res.length = None
        res.chunked = 0
        res.will_close = 1
        res.msg = httplib.HTTPMessage(cStringIO.StringIO())
        return False
    res.msg = httplib.HTTPMessage(res.fp)
    res.msg.fp = None
    trenc = res.msg.getheader('transfer-encoding')
    if (trenc and (trenc.lower() == 'chunked')):
        res.chunked = 1
        res.chunk_left = None
    else:
        res.chunked = 0
    res.will_close = res._check_close()
    length = res.msg.getheader('content-length')
    if (length and (not res.chunked)):
        try:
            res.length = int(length)
        except ValueError:
            res.length = None
        else:
            if (res.length < 0):
                res.length = None
    else:
        res.length = None
    if ((status == httplib.NO_CONTENT) or (status == httplib.NOT_MODIFIED) or (100 <= status < 200) or (res._method == 'HEAD')):
        res.length = 0
    if ((not res.will_close) and (not res.chunked) and (res.length is None)):
        res.will_close = 1
    self.proxyres = res
    return False
