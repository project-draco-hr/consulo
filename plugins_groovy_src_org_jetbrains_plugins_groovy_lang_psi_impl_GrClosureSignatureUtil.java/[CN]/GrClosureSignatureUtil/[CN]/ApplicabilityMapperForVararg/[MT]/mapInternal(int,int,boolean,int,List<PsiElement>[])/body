{
  if (notOptional > args.length - curArg)   return null;
  if (notOptional == args.length - curArg)   skipOptionals=true;
  while (curArg < args.length) {
    if (skipOptionals) {
      while (curParam < paramLength && params[curParam].isOptional())       curParam++;
    }
    if (curParam == paramLength)     break;
    if (params[curParam].isOptional()) {
      if (TypesUtil.isAssignable(params[curParam].getType(),types[curArg],manager,scope)) {
        List<PsiElement>[] copy=mapInternal(curParam + 1,curArg + 1,false,notOptional,copyMap(map));
        if (copy != null)         return copy;
      }
      skipOptionals=true;
    }
 else {
      if (!TypesUtil.isAssignableByMethodCallConversion(params[curParam].getType(),types[curArg],manager,scope))       return null;
      map[curParam]=Collections.<PsiElement>singletonList(args[curArg]);
      notOptional--;
      curArg++;
      curParam++;
    }
  }
  map[paramLength]=new ArrayList<PsiElement>(args.length - curArg);
  for (; curArg < args.length; curArg++) {
    if (!TypesUtil.isAssignableByMethodCallConversion(vararg,types[curArg],manager,scope))     return null;
    map[paramLength].add(args[curArg]);
  }
  return map;
}
