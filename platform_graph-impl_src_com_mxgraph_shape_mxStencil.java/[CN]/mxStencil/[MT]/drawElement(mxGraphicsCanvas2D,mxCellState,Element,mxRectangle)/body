{
  String name=node.getNodeName();
  double x0=aspect.getX();
  double y0=aspect.getY();
  double sx=aspect.getWidth();
  double sy=aspect.getHeight();
  double minScale=Math.min(sx,sy);
  if (name.equals("save")) {
    canvas.save();
  }
 else   if (name.equals("restore")) {
    canvas.restore();
  }
 else   if (name.equals("path")) {
    canvas.begin();
    Node childNode=node.getFirstChild();
    while (childNode != null) {
      if (childNode.getNodeType() == Node.ELEMENT_NODE) {
        drawElement(canvas,state,(Element)childNode,aspect);
      }
      childNode=childNode.getNextSibling();
    }
  }
 else   if (name.equals("close")) {
    canvas.close();
  }
 else   if (name.equals("move")) {
    lastMoveX=x0 + getDouble(node,"x") * sx;
    lastMoveY=y0 + getDouble(node,"y") * sy;
    canvas.moveTo(lastMoveX,lastMoveY);
  }
 else   if (name.equals("line")) {
    lastMoveX=x0 + getDouble(node,"x") * sx;
    lastMoveY=y0 + getDouble(node,"y") * sy;
    canvas.lineTo(lastMoveX,lastMoveY);
  }
 else   if (name.equals("quad")) {
    lastMoveX=x0 + getDouble(node,"x2") * sx;
    lastMoveY=y0 + getDouble(node,"y2") * sy;
    canvas.quadTo(x0 + getDouble(node,"x1") * sx,y0 + getDouble(node,"y1") * sy,lastMoveX,lastMoveY);
  }
 else   if (name.equals("curve")) {
    lastMoveX=x0 + getDouble(node,"x3") * sx;
    lastMoveY=y0 + getDouble(node,"y3") * sy;
    canvas.curveTo(x0 + getDouble(node,"x1") * sx,y0 + getDouble(node,"y1") * sy,x0 + getDouble(node,"x2") * sx,y0 + getDouble(node,"y2") * sy,lastMoveX,lastMoveY);
  }
 else   if (name.equals("arc")) {
    double r1=getDouble(node,"rx") * sx;
    double r2=getDouble(node,"ry") * sy;
    double angle=getDouble(node,"x-axis-rotation");
    double largeArcFlag=getDouble(node,"large-arc-flag");
    double sweepFlag=getDouble(node,"sweep-flag");
    double x=x0 + getDouble(node,"x") * sx;
    double y=y0 + getDouble(node,"y") * sy;
    double[] curves=mxUtils.arcToCurves(this.lastMoveX,this.lastMoveY,r1,r2,angle,largeArcFlag,sweepFlag,x,y);
    for (int i=0; i < curves.length; i+=6) {
      canvas.curveTo(curves[i],curves[i + 1],curves[i + 2],curves[i + 3],curves[i + 4],curves[i + 5]);
      lastMoveX=curves[i + 4];
      lastMoveY=curves[i + 5];
    }
  }
 else   if (name.equals("rect")) {
    canvas.rect(x0 + getDouble(node,"x") * sx,y0 + getDouble(node,"y") * sy,getDouble(node,"w") * sx,getDouble(node,"h") * sy);
  }
 else   if (name.equals("roundrect")) {
    double arcsize=getDouble(node,"arcsize");
    if (arcsize == 0) {
      arcsize=mxConstants.RECTANGLE_ROUNDING_FACTOR * 100;
    }
    double w=getDouble(node,"w") * sx;
    double h=getDouble(node,"h") * sy;
    double factor=arcsize / 100;
    double r=Math.min(w * factor,h * factor);
    canvas.roundrect(x0 + getDouble(node,"x") * sx,y0 + getDouble(node,"y") * sy,getDouble(node,"w") * sx,getDouble(node,"h") * sy,r,r);
  }
 else   if (name.equals("ellipse")) {
    canvas.ellipse(x0 + getDouble(node,"x") * sx,y0 + getDouble(node,"y") * sy,getDouble(node,"w") * sx,getDouble(node,"h") * sy);
  }
 else   if (name.equals("image")) {
    String src=evaluateAttribute(node,"src",state);
    canvas.image(x0 + getDouble(node,"x") * sx,y0 + getDouble(node,"y") * sy,getDouble(node,"w") * sx,getDouble(node,"h") * sy,src,false,getString(node,"flipH","0").equals("1"),getString(node,"flipV","0").equals("1"));
  }
 else   if (name.equals("text")) {
    String str=evaluateAttribute(node,"str",state);
    double rotation=getString(node,"vertical","0").equals("1") ? -90 : 0;
    canvas.text(x0 + getDouble(node,"x") * sx,y0 + getDouble(node,"y") * sy,0,0,str,node.getAttribute("align"),node.getAttribute("valign"),false,"",null,false,rotation);
  }
 else   if (name.equals("include-shape")) {
    mxStencil stencil=mxStencilRegistry.getStencil(node.getAttribute("name"));
    if (stencil != null) {
      double x=x0 + getDouble(node,"x") * sx;
      double y=y0 + getDouble(node,"y") * sy;
      double w=getDouble(node,"w") * sx;
      double h=getDouble(node,"h") * sy;
      mxRectangle tmp=new mxRectangle(x,y,w,h);
      stencil.drawShape(canvas,state,tmp,true);
      stencil.drawShape(canvas,state,tmp,false);
    }
  }
 else   if (name.equals("fillstroke")) {
    canvas.fillAndStroke();
  }
 else   if (name.equals("fill")) {
    canvas.fill();
  }
 else   if (name.equals("stroke")) {
    canvas.stroke();
  }
 else   if (name.equals("strokewidth")) {
    canvas.setStrokeWidth(getDouble(node,"width") * minScale);
  }
 else   if (name.equals("dashed")) {
    canvas.setDashed(node.getAttribute("dashed") == "1");
  }
 else   if (name.equals("dashpattern")) {
    String value=node.getAttribute("pattern");
    if (value != null) {
      String[] tmp=value.split(" ");
      StringBuffer pat=new StringBuffer();
      for (int i=0; i < tmp.length; i++) {
        if (tmp[i].length() > 0) {
          pat.append(Double.parseDouble(tmp[i]) * minScale);
          pat.append(" ");
        }
      }
      value=pat.toString();
    }
    canvas.setDashPattern(value);
  }
 else   if (name.equals("strokecolor")) {
    canvas.setStrokeColor(node.getAttribute("color"));
  }
 else   if (name.equals("linecap")) {
    canvas.setLineCap(node.getAttribute("cap"));
  }
 else   if (name.equals("linejoin")) {
    canvas.setLineJoin(node.getAttribute("join"));
  }
 else   if (name.equals("miterlimit")) {
    canvas.setMiterLimit(getDouble(node,"limit"));
  }
 else   if (name.equals("fillcolor")) {
    canvas.setFillColor(node.getAttribute("color"));
  }
 else   if (name.equals("fontcolor")) {
    canvas.setFontColor(node.getAttribute("color"));
  }
 else   if (name.equals("fontstyle")) {
    canvas.setFontStyle(getInt(node,"style",0));
  }
 else   if (name.equals("fontfamily")) {
    canvas.setFontFamily(node.getAttribute("family"));
  }
 else   if (name.equals("fontsize")) {
    canvas.setFontSize(getDouble(node,"size") * minScale);
  }
}
