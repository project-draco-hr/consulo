{
  final int insertCol=insertLocation.getColumn();
  final int insertRow=insertLocation.getRow();
  final GridInsertMode insertMode=insertLocation.getMode();
  Rectangle cellRect=getGridFeedbackRect(insertLocation,componentCount);
  FeedbackPainter painter=(insertMode == GridInsertMode.ColumnBefore || insertMode == GridInsertMode.ColumnAfter) ? myVertInsertFeedbackPainter : myHorzInsertFeedbackPainter;
  Rectangle rc;
  Rectangle rcFeedback=null;
  if (componentCount == 1 && insertMode != GridInsertMode.InCell) {
    RadComponent component=insertLocation.getContainer().getComponentAtGrid(insertRow,insertCol);
    if (component != null) {
      Rectangle bounds=component.getBounds();
      final GridLayoutManager layoutManager=(GridLayoutManager)insertLocation.getContainer().getLayout();
      int[] vGridLines=layoutManager.getVerticalGridLines();
      int[] hGridLines=layoutManager.getHorizontalGridLines();
      int cellWidth=vGridLines[insertCol + 1] - vGridLines[insertCol];
      int cellHeight=hGridLines[insertRow + 1] - hGridLines[insertRow];
      bounds.translate(-vGridLines[insertCol],-hGridLines[insertRow]);
      int spaceToRight=vGridLines[insertCol + 1] - vGridLines[insertCol] - (bounds.x + bounds.width);
      int spaceBelow=hGridLines[insertRow + 1] - hGridLines[insertRow] - (bounds.y + bounds.height);
      if (insertMode == GridInsertMode.RowBefore && bounds.y > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,0,cellWidth,bounds.y);
      }
 else       if (insertMode == GridInsertMode.RowAfter && spaceBelow > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,bounds.y + bounds.height,cellWidth,spaceBelow);
      }
 else       if (insertMode == GridInsertMode.ColumnBefore && bounds.x > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,0,bounds.x,cellHeight);
      }
 else       if (insertMode == GridInsertMode.ColumnAfter && spaceToRight > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(bounds.x + bounds.width,0,spaceToRight,cellHeight);
      }
      if (rcFeedback != null) {
        rcFeedback.translate(vGridLines[insertCol],hGridLines[insertRow]);
        rcFeedback=SwingUtilities.convertRectangle(insertLocation.getContainer().getDelegee(),rcFeedback,myEditor.getActiveDecorationLayer());
        myEditor.getActiveDecorationLayer().putFeedback(rcFeedback);
        return;
      }
    }
  }
  cellRect=SwingUtilities.convertRectangle(insertLocation.getContainer().getDelegee(),cellRect,myEditor.getActiveDecorationLayer());
  int w=4;
switch (insertMode) {
case ColumnBefore:
    rc=new Rectangle(cellRect.x - w,cellRect.y - INSERT_ARROW_SIZE,2 * w,cellRect.height + 2 * INSERT_ARROW_SIZE);
  break;
case ColumnAfter:
rc=new Rectangle((int)cellRect.getMaxX() - w,(int)cellRect.getMinY() - INSERT_ARROW_SIZE,2 * w,(int)cellRect.getHeight() + 2 * INSERT_ARROW_SIZE);
break;
case RowBefore:
rc=new Rectangle((int)cellRect.getMinX() - INSERT_ARROW_SIZE,(int)cellRect.getMinY() - w,(int)cellRect.getWidth() + 2 * INSERT_ARROW_SIZE,2 * w);
break;
case RowAfter:
rc=new Rectangle((int)cellRect.getMinX() - INSERT_ARROW_SIZE,(int)cellRect.getMaxY() - w,(int)cellRect.getWidth() + 2 * INSERT_ARROW_SIZE,2 * w);
break;
default :
rc=cellRect;
painter=null;
}
myEditor.getActiveDecorationLayer().putFeedback(rc,painter);
}
