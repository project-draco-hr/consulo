{
  if (!isIndexLeaf())   return false;
  int indexInParent=parent.search(keyAt(0));
  if (indexInParent >= 0) {
    if (doSanityCheck) {
      myAssert(parent.keyAt(indexInParent) == keyAt(0));
      myAssert(parent.addressAt(indexInParent + 1) == -address);
    }
    BtreeIndexNodeView sibling=new BtreeIndexNodeView(btree);
    sibling.setAddress(-parent.addressAt(indexInParent));
    final int toMove=(sibling.getMaxChildrenCount() - sibling.getChildrenCount()) / 2;
    if (toMove > 0) {
      if (doSanityCheck) {
        sibling.dump("Offloading to left sibling");
        parent.dump("parent before");
      }
      for (int i=0; i < toMove; ++i)       sibling.insert(keyAt(i),addressAt(i));
      if (doSanityCheck) {
        sibling.dump("Left sibling after");
      }
      parent.setKeyAt(indexInParent,keyAt(toMove));
      if (!parent.myIsDirty)       parent.markDirty();
      int indexOfLastChildToMove=(int)getChildrenCount() - toMove;
      btree.movedMembersCount+=indexOfLastChildToMove;
      if (btree.isLarge) {
        ByteBuffer buffer=getBytes(indexToOffset(toMove),indexOfLastChildToMove * INTERIOR_SIZE);
        putBytes(indexToOffset(0),buffer);
      }
 else {
        for (int i=0; i < indexOfLastChildToMove; ++i) {
          setAddressAt(i,addressAt(i + toMove));
          setKeyAt(i,keyAt(i + toMove));
        }
      }
      setChildrenCount((short)indexOfLastChildToMove);
    }
 else     if (indexInParent + 1 < parent.getChildrenCount()) {
      insertToRightSiblingWhenSorted(parent,indexInParent + 1,sibling);
    }
  }
 else   if (indexInParent == -1) {
    insertToRightSiblingWhenSorted(parent,0,new BtreeIndexNodeView(btree));
  }
  if (!isFull()) {
    if (doSanityCheck) {
      dump("old node after split:");
      parent.dump("Parent node after split");
    }
    return true;
  }
  return false;
}
