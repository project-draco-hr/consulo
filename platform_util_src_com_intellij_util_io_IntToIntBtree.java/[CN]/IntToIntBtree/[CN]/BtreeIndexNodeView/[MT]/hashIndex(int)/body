{
  final int length=btree.hashPageCapacity;
  int hash=value & 0x7fffffff;
  int index=hash % length;
  int keyAtIndex=keyAt(index);
  btree.hashSearchRequests++;
  int total=0;
  if (useDoubleHash) {
    if (keyAtIndex != value && keyAtIndex != HASH_FREE) {
      final int probe=1 + (hash % (length - 2));
      do {
        index-=probe;
        if (index < 0)         index+=length;
        keyAtIndex=keyAt(index);
        ++total;
        if (total > length) {
          throw new IllegalStateException("Index corrupted");
        }
      }
 while (keyAtIndex != value && keyAtIndex != HASH_FREE);
    }
  }
 else {
    while (keyAtIndex != value && keyAtIndex != HASH_FREE) {
      if (index == 0)       index=length;
      --index;
      keyAtIndex=keyAt(index);
      ++total;
      if (total > length)       throw new IllegalStateException("Index corrupted");
    }
  }
  btree.maxStepsSearchedInHash=Math.max(btree.maxStepsSearchedInHash,total);
  btree.totalHashStepsSearched+=total;
  return keyAtIndex == HASH_FREE ? -index - 1 : index;
}
