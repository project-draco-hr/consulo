{
  int indexInParent=isIndexLeaf() ? parent.search(keyAt(0)) : -1;
  BtreeIndexNodeView sibling=new BtreeIndexNodeView(btree);
  if (indexInParent > 0) {
    if (doSanityCheck) {
      myAssert(parent.keyAt(indexInParent) == keyAt(0));
      myAssert(parent.addressAt(indexInParent + 1) == -address);
    }
    int siblingAddress=parent.addressAt(indexInParent);
    sibling.setAddress(-siblingAddress);
    if (!sibling.isFull() && sibling.getChildrenCount() + 1 != sibling.getMaxChildrenCount()) {
      if (doSanityCheck) {
        sibling.dump("Offloading to left sibling");
        parent.dump("parent before");
      }
      sibling.insert(keyAt(0),addressAt(0),sibling.getChildrenCount());
      if (doSanityCheck) {
        sibling.dump("Left sibling after");
      }
      parent.setKeyAt(indexInParent,keyAt(1));
      int indexOflastChildToMove=getChildrenCount() - 1;
      if (btree.isLarge) {
        final int bytesToMove=indexOflastChildToMove * INTERIOR_SIZE;
        getBytes(indexToOffset(1),btree.buffer,0,bytesToMove);
        putBytes(indexToOffset(0),btree.buffer,0,bytesToMove);
      }
 else {
        for (int i=0; i < indexOflastChildToMove; ++i) {
          setAddressAt(i,addressAt(i + 1));
          setKeyAt(i,keyAt(i + 1));
        }
      }
      setChildrenCount((short)indexOflastChildToMove);
    }
 else     if (indexInParent + 1 < parent.getChildrenCount()) {
      insertToRightSibling(parent,indexInParent + 1,sibling);
    }
  }
  if (!isFull()) {
    sync();
    parent.sync();
    if (doSanityCheck) {
      dump("old node after split:");
      parent.dump("Parent node after split");
    }
    return true;
  }
  return false;
}
