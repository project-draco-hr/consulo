{
  if (doSanityCheck) {
    myAssert(isFull());
    dump("before split:" + isIndexLeaf());
  }
  BtreeIndexNodeView parent=null;
  if (parentAddress != 0) {
    parent=new BtreeIndexNodeView(btree);
    parent.setAddress(parentAddress);
    int indexInParent=isIndexLeaf() ? parent.search(keyAt(0)) : -1;
    BtreeIndexNodeView sibling=new BtreeIndexNodeView(btree);
    if (indexInParent > 0) {
      if (doSanityCheck) {
        myAssert(parent.keyAt(indexInParent) == keyAt(0));
        myAssert(parent.addressAt(indexInParent + 1) == -address);
      }
      int siblingAddress=parent.addressAt(indexInParent);
      sibling.setAddress(-siblingAddress);
      if (!sibling.isFull() && sibling.getChildrenCount() + 1 != sibling.getMaxChildrenCount()) {
        if (doSanityCheck) {
          sibling.dump("Offloading to left sibling");
          parent.dump("parent before");
        }
        sibling.insert(keyAt(0),addressAt(0),sibling.getChildrenCount());
        if (doSanityCheck) {
          sibling.dump("Left sibling after");
        }
        parent.setKeyAt(indexInParent,keyAt(1));
        int indexOflastChildToMove=getChildrenCount() - 1;
        if (btree.isLarge) {
          final int bytesToMove=indexOflastChildToMove * INTERIOR_SIZE;
          getBytes(indexToOffset(1),btree.buffer,0,bytesToMove);
          putBytes(indexToOffset(0),btree.buffer,0,bytesToMove);
        }
 else {
          for (int i=0; i < indexOflastChildToMove; ++i) {
            setAddressAt(i,addressAt(i + 1));
            setKeyAt(i,keyAt(i + 1));
          }
        }
        setChildrenCount((short)indexOflastChildToMove);
      }
 else       if (indexInParent + 1 < parent.getChildrenCount()) {
        insertToRightSibling(parent,indexInParent + 1,sibling);
      }
    }
    if (!isFull()) {
      sync();
      parent.sync();
      if (doSanityCheck) {
        dump("old node after split:");
        parent.dump("Parent node after split");
      }
      return parentAddress;
    }
  }
  short maxIndex=(short)(getMaxChildrenCount() / 2);
  BtreeIndexNodeView newIndexNode=new BtreeIndexNodeView(btree);
  newIndexNode.setAddress(btree.nextPage());
  boolean indexLeaf=isIndexLeaf();
  newIndexNode.setIndexLeaf(indexLeaf);
  short recordCount=getChildrenCount();
  short recordCountInNewNode=(short)(recordCount - maxIndex);
  newIndexNode.setChildrenCount(recordCountInNewNode);
  int medianKey;
  if (btree.isLarge) {
    final int bytesToMove=recordCountInNewNode * INTERIOR_SIZE;
    getBytes(indexToOffset(maxIndex),btree.buffer,0,bytesToMove);
    newIndexNode.putBytes(newIndexNode.indexToOffset(0),btree.buffer,0,bytesToMove);
  }
 else {
    for (int i=0; i < recordCountInNewNode; ++i) {
      newIndexNode.setAddressAt(i,addressAt(i + maxIndex));
      newIndexNode.setKeyAt(i,keyAt(i + maxIndex));
    }
  }
  if (indexLeaf) {
    medianKey=newIndexNode.keyAt(0);
  }
 else {
    newIndexNode.setAddressAt(recordCountInNewNode,addressAt(recordCount));
    --maxIndex;
    medianKey=keyAt(maxIndex);
  }
  setChildrenCount(maxIndex);
  if (parent != null) {
    if (doSanityCheck) {
      int medianKeyInParent=parent.search(medianKey);
      int ourKey=keyAt(0);
      int ourKeyInParent=parent.search(ourKey);
      parent.dump("About to insert " + medianKey + ","+ newIndexNode.address+ ","+ medianKeyInParent+ " our key "+ ourKey+ ", "+ ourKeyInParent);
      myAssert(medianKeyInParent < 0);
      myAssert(!parent.isFull());
    }
    parent.insert(medianKey,-newIndexNode.address);
    if (doSanityCheck) {
      parent.dump("After modifying parent");
      int search=parent.search(medianKey);
      myAssert(search >= 0);
      myAssert(parent.addressAt(search + 1) == -newIndexNode.address);
      dump("old node after split:");
      newIndexNode.dump("new node after split:");
    }
  }
 else {
    if (doSanityCheck) {
      btree.root.dump("Splitting root:" + medianKey);
    }
    int newRootAddress=btree.nextPage();
    if (doSanityCheck) {
      System.out.println("Pages:" + btree.pagesCount + ", elements:"+ btree.size+ ", average:"+ (btree.maxStepsSearched + 1));
    }
    btree.setRootAddress(newRootAddress);
    parentAddress=newRootAddress;
    btree.root.setChildrenCount((short)1);
    btree.root.setKeyAt(0,medianKey);
    btree.root.setAddressAt(0,-address);
    btree.root.setAddressAt(1,-newIndexNode.address);
    btree.root.sync();
    if (doSanityCheck) {
      btree.root.dump("New root");
      dump("First child");
      newIndexNode.dump("Second child");
    }
  }
  sync();
  newIndexNode.sync();
  return parentAddress;
}
