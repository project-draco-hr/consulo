{
  if (doSanityCheck) {
    myAssert(isFull());
    dump("before split:" + isIndexLeaf());
  }
  BtreeIndexNodeView parent=null;
  if (parentAddress != 0) {
    parent=new BtreeIndexNodeView(btree);
    parent.setAddress(parentAddress);
    if (btree.offloadToSiblingsBeforeSplit) {
      if (doOffloadToSiblingsSorted(parent))       return parentAddress;
    }
  }
  short maxIndex=(short)(getMaxChildrenCount() / 2);
  BtreeIndexNodeView newIndexNode=new BtreeIndexNodeView(btree);
  newIndexNode.setAddress(btree.nextPage(false));
  boolean indexLeaf=isIndexLeaf();
  newIndexNode.setIndexLeaf(indexLeaf);
  int nextPage=getNextPage();
  setNextPage(newIndexNode.address);
  newIndexNode.setNextPage(nextPage);
  final short recordCount=getChildrenCount();
  int medianKey;
  if (indexLeaf && isHashedLeaf()) {
    TIntIntHashMap map=new TIntIntHashMap(recordCount);
    getBytes(indexToOffset(0),btree.buffer,0,btree.pageSize - btree.metaDataLeafPageLength);
    int[] keys=new int[recordCount];
    int keyNumber=0;
    for (int i=0; i < btree.hashPageCapacity; ++i) {
      if (hashGetState(i) == HASH_FULL) {
        int key=Bits.getInt(btree.buffer,i * INTERIOR_SIZE + KEY_OFFSET);
        keys[keyNumber++]=key;
        map.put(key,Bits.getInt(btree.buffer,i * INTERIOR_SIZE));
        hashSetState(i,HASH_FREE);
      }
    }
    Arrays.sort(keys);
    final int avg=keys.length / 2;
    medianKey=keys[avg];
    --btree.hashedPagesCount;
    setChildrenCount((short)0);
    newIndexNode.setChildrenCount((short)0);
    for (int i=0; i < avg; ++i) {
      insert(keys[i],map.get(keys[i]));
      newIndexNode.insert(keys[avg + i],map.get(keys[avg + i]));
    }
  }
 else {
    short recordCountInNewNode=(short)(recordCount - maxIndex);
    newIndexNode.setChildrenCount(recordCountInNewNode);
    if (btree.isLarge) {
      final int bytesToMove=recordCountInNewNode * INTERIOR_SIZE;
      getBytes(indexToOffset(maxIndex),btree.buffer,0,bytesToMove);
      newIndexNode.putBytes(newIndexNode.indexToOffset(0),btree.buffer,0,bytesToMove);
    }
 else {
      for (int i=0; i < recordCountInNewNode; ++i) {
        newIndexNode.setAddressAt(i,addressAt(i + maxIndex));
        newIndexNode.setKeyAt(i,keyAt(i + maxIndex));
      }
    }
    if (indexLeaf) {
      medianKey=newIndexNode.keyAt(0);
    }
 else {
      newIndexNode.setAddressAt(recordCountInNewNode,addressAt(recordCount));
      --maxIndex;
      medianKey=keyAt(maxIndex);
    }
    setChildrenCount(maxIndex);
  }
  if (parent != null) {
    if (doSanityCheck) {
      int medianKeyInParent=parent.search(medianKey);
      int ourKey=keyAt(0);
      int ourKeyInParent=parent.search(ourKey);
      parent.dump("About to insert " + medianKey + ","+ newIndexNode.address+ ","+ medianKeyInParent+ " our key "+ ourKey+ ", "+ ourKeyInParent);
      myAssert(medianKeyInParent < 0);
      myAssert(!parent.isFull());
    }
    parent.insert(medianKey,-newIndexNode.address);
    if (doSanityCheck) {
      parent.dump("After modifying parent");
      int search=parent.search(medianKey);
      myAssert(search >= 0);
      myAssert(parent.addressAt(search + 1) == -newIndexNode.address);
      dump("old node after split:");
      newIndexNode.dump("new node after split:");
    }
  }
 else {
    if (doSanityCheck) {
      btree.root.dump("Splitting root:" + medianKey);
    }
    int newRootAddress=btree.nextPage(true);
    if (doSanityCheck) {
      System.out.println("Pages:" + btree.pagesCount + ", elements:"+ btree.count+ ", average:"+ (btree.height + 1));
    }
    btree.setRootAddress(newRootAddress);
    parentAddress=newRootAddress;
    ((BtreePage)btree.root).load();
    btree.root.setChildrenCount((short)1);
    btree.root.setKeyAt(0,medianKey);
    btree.root.setAddressAt(0,-address);
    btree.root.setAddressAt(1,-newIndexNode.address);
    btree.root.sync();
    if (doSanityCheck) {
      btree.root.dump("New root");
      dump("First child");
      newIndexNode.dump("Second child");
    }
  }
  sync();
  newIndexNode.sync();
  return parentAddress;
}
