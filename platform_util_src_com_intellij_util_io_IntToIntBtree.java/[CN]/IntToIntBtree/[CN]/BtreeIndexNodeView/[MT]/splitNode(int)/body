{
  final boolean indexLeaf=isIndexLeaf();
  if (doSanityCheck) {
    myAssert(isFull());
    dump("before split:" + indexLeaf);
  }
  final boolean hashedLeaf=isHashedLeaf();
  final short recordCount=getChildrenCount();
  BtreeIndexNodeView parent=null;
  HashLeafData hashLeafData=null;
  if (parentAddress != 0) {
    parent=new BtreeIndexNodeView(btree);
    parent.setAddress(parentAddress);
    if (btree.offloadToSiblingsBeforeSplit) {
      if (hashedLeaf) {
        hashLeafData=new HashLeafData(this,recordCount);
        if (doOffloadToSiblingsWhenHashed(parent,hashLeafData))         return parentAddress;
      }
 else {
        if (doOffloadToSiblingsSorted(parent))         return parentAddress;
      }
    }
  }
  short maxIndex=(short)(getMaxChildrenCount() / 2);
  BtreeIndexNodeView newIndexNode=new BtreeIndexNodeView(btree);
  newIndexNode.setAddress(btree.nextPage());
  syncWithStore();
  if (parent != null)   parent.syncWithStore();
  btree.root.syncWithStore();
  newIndexNode.setIndexLeaf(indexLeaf);
  int nextPage=getNextPage();
  setNextPage(newIndexNode.address);
  newIndexNode.setNextPage(nextPage);
  int medianKey=-1;
  if (indexLeaf && hashedLeaf) {
    if (hashLeafData == null)     hashLeafData=new HashLeafData(this,recordCount);
    final int[] keys=hashLeafData.keys;
    boolean defaultSplit=true;
    if (defaultSplit) {
      hashLeafData.clean();
      final TIntIntHashMap map=hashLeafData.values;
      final int avg=keys.length / 2;
      medianKey=keys[avg];
      --btree.hashedPagesCount;
      setChildrenCount((short)0);
      newIndexNode.setChildrenCount((short)0);
      for (int i=0; i < avg; ++i) {
        int key=keys[i];
        insert(key,map.get(key));
        key=keys[avg + i];
        newIndexNode.insert(key,map.get(key));
      }
    }
  }
 else {
    short recordCountInNewNode=(short)(recordCount - maxIndex);
    newIndexNode.setChildrenCount(recordCountInNewNode);
    if (btree.isLarge) {
      ByteBuffer buffer=getBytes(indexToOffset(maxIndex),recordCountInNewNode * INTERIOR_SIZE);
      newIndexNode.putBytes(newIndexNode.indexToOffset(0),buffer);
    }
 else {
      for (int i=0; i < recordCountInNewNode; ++i) {
        newIndexNode.setAddressAt(i,addressAt(i + maxIndex));
        newIndexNode.setKeyAt(i,keyAt(i + maxIndex));
      }
    }
    if (indexLeaf) {
      medianKey=newIndexNode.keyAt(0);
    }
 else {
      newIndexNode.setAddressAt(recordCountInNewNode,addressAt(recordCount));
      --maxIndex;
      medianKey=keyAt(maxIndex);
    }
    setChildrenCount(maxIndex);
  }
  if (parent != null) {
    if (doSanityCheck) {
      int medianKeyInParent=parent.search(medianKey);
      int ourKey=keyAt(0);
      int ourKeyInParent=parent.search(ourKey);
      parent.dump("About to insert " + medianKey + ","+ newIndexNode.address+ ","+ medianKeyInParent+ " our key "+ ourKey+ ", "+ ourKeyInParent);
      myAssert(medianKeyInParent < 0);
      myAssert(!parent.isFull());
    }
    parent.insert(medianKey,-newIndexNode.address);
    if (doSanityCheck) {
      parent.dump("After modifying parent");
      int search=parent.search(medianKey);
      myAssert(search >= 0);
      myAssert(parent.addressAt(search + 1) == -newIndexNode.address);
      dump("old node after split:");
      newIndexNode.dump("new node after split:");
    }
  }
 else {
    if (doSanityCheck) {
      btree.root.dump("Splitting root:" + medianKey);
    }
    int newRootAddress=btree.nextPage();
    newIndexNode.syncWithStore();
    syncWithStore();
    if (doSanityCheck) {
      System.out.println("Pages:" + btree.pagesCount + ", elements:"+ btree.count+ ", average:"+ (btree.height + 1));
    }
    btree.root.setAddress(newRootAddress);
    parentAddress=newRootAddress;
    btree.root.setChildrenCount((short)1);
    btree.root.setKeyAt(0,medianKey);
    btree.root.setAddressAt(0,-address);
    btree.root.setAddressAt(1,-newIndexNode.address);
    if (doSanityCheck) {
      btree.root.dump("New root");
      dump("First child");
      newIndexNode.dump("Second child");
    }
  }
  return parentAddress;
}
