{
  if (doSanityCheck) {
    myAssert(isFull());
    dump("before split:" + isIndexLeaf());
  }
  BtreeIndexNodeView parent=null;
  if (parentAddress != 0) {
    parent=new BtreeIndexNodeView(btree);
    parent.setAddress(parentAddress);
    if (btree.offloadToSiblingsBeforeSplit) {
      if (doOffloadToSiblings(parent))       return parentAddress;
    }
  }
  short maxIndex=(short)(getMaxChildrenCount() / 2);
  BtreeIndexNodeView newIndexNode=new BtreeIndexNodeView(btree);
  newIndexNode.setAddress(btree.nextPage());
  boolean indexLeaf=isIndexLeaf();
  newIndexNode.setIndexLeaf(indexLeaf);
  short recordCount=getChildrenCount();
  short recordCountInNewNode=(short)(recordCount - maxIndex);
  newIndexNode.setChildrenCount(recordCountInNewNode);
  int medianKey;
  if (btree.isLarge) {
    final int bytesToMove=recordCountInNewNode * INTERIOR_SIZE;
    getBytes(indexToOffset(maxIndex),btree.buffer,0,bytesToMove);
    newIndexNode.putBytes(newIndexNode.indexToOffset(0),btree.buffer,0,bytesToMove);
  }
 else {
    for (int i=0; i < recordCountInNewNode; ++i) {
      newIndexNode.setAddressAt(i,addressAt(i + maxIndex));
      newIndexNode.setKeyAt(i,keyAt(i + maxIndex));
    }
  }
  if (indexLeaf) {
    medianKey=newIndexNode.keyAt(0);
  }
 else {
    newIndexNode.setAddressAt(recordCountInNewNode,addressAt(recordCount));
    --maxIndex;
    medianKey=keyAt(maxIndex);
  }
  setChildrenCount(maxIndex);
  if (parent != null) {
    if (doSanityCheck) {
      int medianKeyInParent=parent.search(medianKey);
      int ourKey=keyAt(0);
      int ourKeyInParent=parent.search(ourKey);
      parent.dump("About to insert " + medianKey + ","+ newIndexNode.address+ ","+ medianKeyInParent+ " our key "+ ourKey+ ", "+ ourKeyInParent);
      myAssert(medianKeyInParent < 0);
      myAssert(!parent.isFull());
    }
    parent.insert(medianKey,-newIndexNode.address);
    if (doSanityCheck) {
      parent.dump("After modifying parent");
      int search=parent.search(medianKey);
      myAssert(search >= 0);
      myAssert(parent.addressAt(search + 1) == -newIndexNode.address);
      dump("old node after split:");
      newIndexNode.dump("new node after split:");
    }
  }
 else {
    if (doSanityCheck) {
      btree.root.dump("Splitting root:" + medianKey);
    }
    int newRootAddress=btree.nextPage();
    if (doSanityCheck) {
      System.out.println("Pages:" + btree.pagesCount + ", elements:"+ btree.count+ ", average:"+ (btree.maxStepsSearched + 1));
    }
    btree.setRootAddress(newRootAddress);
    parentAddress=newRootAddress;
    ((BtreePage)btree.root).load();
    btree.root.setChildrenCount((short)1);
    btree.root.setKeyAt(0,medianKey);
    btree.root.setAddressAt(0,-address);
    btree.root.setAddressAt(1,-newIndexNode.address);
    btree.root.sync();
    if (doSanityCheck) {
      btree.root.dump("New root");
      dump("First child");
      newIndexNode.dump("Second child");
    }
  }
  sync();
  newIndexNode.sync();
  return parentAddress;
}
