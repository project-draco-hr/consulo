{
  int hash, probe, index;
  final int length=btree.hashPageCapacity;
  hash=hash(val) & 0x7fffffff;
  index=hash % length;
  btree.hashSearchRequests++;
  int state=hashGetState(index);
  if (state == HASH_FREE) {
    return index;
  }
 else   if (state == HASH_FULL && keyAt(index) == val) {
    return -index - 1;
  }
 else {
    probe=1 + (hash % (length - 2));
    int total=0;
    do {
      index-=probe;
      if (index < 0) {
        index+=length;
      }
      ++total;
      state=hashGetState(index);
    }
 while (state == HASH_FULL && keyAt(index) != val);
    if (state == HASH_REMOVED) {
      int firstRemoved=index;
      while (state != HASH_FREE && (state == HASH_REMOVED || keyAt(index) != val)) {
        index-=probe;
        if (index < 0) {
          index+=length;
        }
        state=hashGetState(index);
        ++total;
      }
      return state == HASH_FULL ? -index - 1 : firstRemoved;
    }
    btree.maxStepsSearchedInHash=Math.max(btree.maxStepsSearchedInHash,total);
    btree.totalHashStepsSearched+=total;
    return state == HASH_FULL ? -index - 1 : index;
  }
}
