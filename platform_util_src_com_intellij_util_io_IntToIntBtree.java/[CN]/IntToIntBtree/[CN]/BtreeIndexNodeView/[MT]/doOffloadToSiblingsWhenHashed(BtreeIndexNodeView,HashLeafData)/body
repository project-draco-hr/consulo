{
  int indexInParent=parent.search(hashLeafData.keys[0]);
  if (indexInParent >= 0) {
    BtreeIndexNodeView sibling=new BtreeIndexNodeView(btree);
    sibling.setAddress(-parent.addressAt(indexInParent));
    int numberOfKeysToMove=(sibling.getMaxChildrenCount() - sibling.getChildrenCount()) / 2;
    if (!sibling.isFull() && numberOfKeysToMove > MIN_ITEMS_TO_SHARE) {
      if (doSanityCheck) {
        sibling.dump("Offloading to left sibling");
        parent.dump("parent before");
      }
      final int childrenCount=getChildrenCount();
      final int[] keys=hashLeafData.keys;
      final TIntIntHashMap map=hashLeafData.values;
      for (int i=0; i < numberOfKeysToMove; ++i) {
        final int key=keys[i];
        sibling.insert(key,map.get(key));
      }
      if (doSanityCheck) {
        sibling.dump("Left sibling after");
      }
      parent.setKeyAt(indexInParent,keys[numberOfKeysToMove]);
      setChildrenCount((short)0);
      --btree.hashedPagesCount;
      hashLeafData.clean();
      for (int i=numberOfKeysToMove; i < childrenCount; ++i) {
        final int key=keys[i];
        insert(key,map.get(key));
      }
    }
 else     if (indexInParent + 1 < parent.getChildrenCount()) {
      insertToRightSiblingWhenHashed(parent,hashLeafData,indexInParent,sibling);
    }
  }
 else   if (indexInParent == -1) {
    insertToRightSiblingWhenHashed(parent,hashLeafData,0,new BtreeIndexNodeView(btree));
  }
  if (!isFull()) {
    if (doSanityCheck) {
      dump("old node after split:");
      parent.dump("Parent node after split");
    }
    return true;
  }
  return false;
}
