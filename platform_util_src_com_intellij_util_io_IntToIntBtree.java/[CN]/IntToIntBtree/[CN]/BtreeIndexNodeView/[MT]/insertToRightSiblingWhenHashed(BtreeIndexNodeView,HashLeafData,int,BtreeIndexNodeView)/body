{
  sibling.setAddress(-parent.addressAt(indexInParent + 1));
  int numberOfKeysToMove=(sibling.getMaxChildrenCount() - sibling.getChildrenCount()) / 2;
  if (!sibling.isFull() && numberOfKeysToMove > MIN_ITEMS_TO_SHARE) {
    if (doSanityCheck) {
      sibling.dump("Offloading to right sibling");
      parent.dump("parent before");
    }
    final int[] keys=hashLeafData.keys;
    final TIntIntHashMap map=hashLeafData.values;
    final int childrenCount=getChildrenCount();
    final int lastChildIndex=childrenCount - numberOfKeysToMove;
    for (int i=lastChildIndex; i < childrenCount; ++i) {
      final int key=keys[i];
      sibling.insert(key,map.get(key));
    }
    if (doSanityCheck) {
      sibling.dump("Right sibling after");
    }
    parent.setKeyAt(indexInParent,keys[lastChildIndex]);
    setChildrenCount((short)0);
    --btree.hashedPagesCount;
    hashLeafData.clean();
    for (int i=0; i < lastChildIndex; ++i) {
      final int key=keys[i];
      insert(key,map.get(key));
    }
  }
}
