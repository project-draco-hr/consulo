{
  LOG.debug("CommonProxy.select called for " + uri.toString());
  isInstalledAssertion();
  myIDEAWide.resetAuthenticator();
  final String host=uri.getHost() == null ? "" : uri.getHost();
  final int port=uri.getPort();
  final String protocol=uri.getScheme();
  final HostInfo info=new HostInfo(protocol,host,port);
  final Map<String,ProxySelector> copy;
synchronized (myLock) {
    if (myNoProxy.contains(info)) {
      LOG.debug("CommonProxy.select returns no proxy (in no proxy list) for " + uri.toString());
      return ourNoProxy;
    }
    copy=new HashMap<String,ProxySelector>(myCustom);
  }
  for (  Map.Entry<String,ProxySelector> entry : copy.entrySet()) {
    final List<Proxy> proxies=entry.getValue().select(uri);
    if (proxies != null && proxies.size() > 0) {
      LOG.debug("CommonProxy.select returns custom proxy for " + uri.toString() + ", "+ proxies.toString());
      return proxies;
    }
  }
  final List<Proxy> selected=myIDEAWide.select(uri);
  final HttpConfigurable configurable;
  final Application application=ApplicationManager.getApplication();
  if (application != null && !application.isDisposed()) {
    configurable=application.runReadAction(new Computable<HttpConfigurable>(){
      @Override public HttpConfigurable compute(){
        if (application.isDisposeInProgress() || application.isDisposed())         return null;
        return HttpConfigurable.getInstance();
      }
    }
);
    if (configurable != null && configurable.USE_HTTP_PROXY) {
      configurable.LAST_ERROR=null;
    }
  }
  LOG.debug("CommonProxy.select returns something after common platform check for " + uri.toString() + ", "+ selected.toString());
  return selected;
}
