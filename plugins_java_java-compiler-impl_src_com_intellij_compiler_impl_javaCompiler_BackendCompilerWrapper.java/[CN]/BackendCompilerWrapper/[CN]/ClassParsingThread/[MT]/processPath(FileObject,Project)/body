{
  File file=fileObject.getFile();
  final String path=file.getPath();
  try {
    if (CompilerManager.MAKE_ENABLED) {
      byte[] fileContent=fileObject.getContent();
      final JavaDependencyCache dependencyCache=myCompileContext.getDependencyCache().findChild(JavaDependencyCache.class);
      final int newClassQName=dependencyCache.reparseClassFile(file,fileContent);
      final Cache newClassesCache=dependencyCache.getNewClassesCache();
      final String sourceFileName=newClassesCache.getSourceFileName(newClassQName);
      final String qName=dependencyCache.resolve(newClassQName);
      String relativePathToSource="/" + JavaMakeUtil.createRelativePathToSource(qName,sourceFileName);
      putName(sourceFileName,newClassQName,relativePathToSource,path);
      boolean haveToInstrument=myAddNotNullAssertions && hasNotNullAnnotations(newClassesCache,dependencyCache.getSymbolTable(),newClassQName,project);
      if (haveToInstrument) {
        try {
          ClassReader reader=new ClassReader(fileContent,0,fileContent.length);
          ClassWriter writer=new PsiClassWriter(myProject,myIsJdk16);
          if (NotNullVerifyingInstrumenter.processClassFile(reader,writer)) {
            fileObject=new FileObject(file,writer.toByteArray());
          }
        }
 catch (        Exception ignored) {
          LOG.info(ignored);
        }
      }
      fileObject.save();
    }
 else {
      final String _path=FileUtil.toSystemIndependentName(path);
      final int dollarIndex=_path.indexOf('$');
      final int tailIndex=dollarIndex >= 0 ? dollarIndex : _path.length() - ".class".length();
      final int slashIndex=_path.lastIndexOf('/');
      final String sourceFileName=_path.substring(slashIndex + 1,tailIndex) + ".java";
      String relativePathToSource=_path.substring(myOutputDir.length(),tailIndex) + ".java";
      putName(sourceFileName,0,relativePathToSource.startsWith("/") ? relativePathToSource : "/" + relativePathToSource,path);
    }
  }
 catch (  ClsFormatException e) {
    final String m=e.getMessage();
    String message=CompilerBundle.message("error.bad.class.file.format",StringUtil.isEmpty(m) ? path : m + "\n" + path);
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,message,null,-1,-1);
    LOG.info(e);
  }
catch (  IOException e) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
    LOG.info(e);
  }
 finally {
    myStatistics.incClassesCount();
    updateStatistics();
  }
}
