{
  File file=fileObject.getFile();
  final String path=file.getPath();
  try {
    if (Boolean.TRUE) {
      byte[] fileContent=fileObject.getContent();
      SymbolTableDummy symbolTable=new SymbolTableDummy();
      ClassFileReader classFileReader=new ClassFileReader(file,symbolTable,fileContent);
      final String sourceFileName=classFileReader.getSourceFileName();
      final String qName=classFileReader.getQualifiedName();
      String relativePathToSource="/" + MakeUtil.createRelativePathToSource(qName,sourceFileName);
      putName(sourceFileName,qName,relativePathToSource,path);
      boolean haveToInstrument=myAddNotNullAssertions;
      if (haveToInstrument) {
        try {
          ClassReader reader=new ClassReader(fileContent,0,fileContent.length);
          ClassWriter writer=new PsiClassWriter(myProject,myIsJdk16);
          final NotNullVerifyingInstrumenter instrumenter=new NotNullVerifyingInstrumenter(writer);
          reader.accept(instrumenter,0);
          if (instrumenter.isModification()) {
            fileObject=new FileObject(file,writer.toByteArray());
          }
        }
 catch (        Exception ignored) {
          LOG.info(ignored);
        }
      }
      fileObject.save();
    }
  }
 catch (  ClsFormatException e) {
    final String m=e.getMessage();
    String message=CompilerBundle.message("error.bad.class.file.format",StringUtil.isEmpty(m) ? path : m + "\n" + path);
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,message,null,-1,-1);
    LOG.info(e);
  }
catch (  IOException e) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
    LOG.info(e);
  }
 finally {
    myStatistics.incClassesCount();
    updateStatistics();
  }
}
