{
  final boolean isInMethod=psiBlock.getParent() instanceof PsiMethod;
  try {
    ControlFlow flow=new ControlFlowAnalyzer(myValueFactory,myInstructionFactory).buildControlFlow(psiBlock);
    if (flow == null)     return false;
    myInstructions=flow.getInstructions();
    myFields=flow.getFields();
    if (LOG.isDebugEnabled()) {
      for (int i=0; i < myInstructions.length; i++) {
        Instruction instruction=myInstructions[i];
        LOG.debug(i + ": " + instruction.toString());
      }
    }
    int branchCount=0;
    for (    Instruction instruction : myInstructions) {
      if (instruction instanceof BranchingInstruction)       branchCount++;
    }
    if (branchCount > 80)     return false;
    final ArrayList<DfaInstructionState> queue=new ArrayList<DfaInstructionState>();
    final DfaMemoryState initialState=createMemoryState();
    if (isInMethod) {
      PsiMethod method=(PsiMethod)psiBlock.getParent();
      final PsiParameter[] parameters=method.getParameterList().getParameters();
      for (      PsiParameter parameter : parameters) {
        if (AnnotationUtil.isNotNull(parameter)) {
          initialState.applyNotNull(myValueFactory.getVarFactory().create(parameter,false));
        }
      }
    }
    queue.add(new DfaInstructionState(myInstructions[0],initialState));
    long timeLimit=ourTimeLimit;
    final boolean unitTestMode=ApplicationManager.getApplication().isUnitTestMode();
    final long before=System.currentTimeMillis();
    while (!queue.isEmpty()) {
      if (!unitTestMode && System.currentTimeMillis() - before > timeLimit)       return false;
      ProgressManager.getInstance().checkCanceled();
      DfaInstructionState instructionState=queue.remove(0);
      if (LOG.isDebugEnabled()) {
        LOG.debug(instructionState.toString());
      }
      Instruction instruction=instructionState.getInstruction();
      long distance=instructionState.getDistanceFromStart();
      if (instruction instanceof BranchingInstruction) {
        if (!instruction.setMemoryStateProcessed(instructionState.getMemoryState().createCopy())) {
          return false;
        }
      }
      DfaInstructionState[] after=instruction.apply(this,instructionState.getMemoryState());
      if (after != null) {
        for (        DfaInstructionState state : after) {
          Instruction nextInstruction=state.getInstruction();
          if (!(nextInstruction instanceof BranchingInstruction) || !nextInstruction.isMemoryStateProcessed(state.getMemoryState())) {
            state.setDistanceFromStart(distance + 1);
            queue.add(state);
          }
        }
      }
    }
    return true;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    LOG.error(psiBlock.getText(),e);
    return false;
  }
catch (  EmptyStackException e) {
    return false;
  }
}
