{
  if (method instanceof GrGdkMethod && !method.hasModifierProperty(GrModifier.STATIC)) {
    LOG.assertTrue(caller != null);
    final GrExpression listOrMap=GroovyRefactoringUtil.generateArgFromMultiArg(PsiSubstitutor.EMPTY,Arrays.asList(namedArgs),null,method.getProject());
    GrExpression[] newArgs=new GrExpression[exprs.length + 2];
    System.arraycopy(exprs,0,newArgs,2,exprs.length);
    newArgs[0]=caller;
    newArgs[1]=listOrMap;
    invokeMethodOn(((GrGdkMethod)method).getStaticMethod(),null,newArgs,GrNamedArgument.EMPTY_ARRAY,closures,substitutor,context);
    return;
  }
  if (method.hasModifierProperty(GrModifier.STATIC)) {
    final PsiClass containingClass=method.getContainingClass();
    if (containingClass != null) {
      builder.append(containingClass.getQualifiedName()).append(".");
    }
  }
 else {
    LOG.assertTrue(caller != null,"instance method call should have caller");
    caller.accept(this);
    builder.append(".");
  }
  builder.append(method.getName());
  final GrClosureSignature signature=GrClosureSignatureUtil.createSignature(method,substitutor);
  new ArgumentListGenerator(builder,this.context).generate(signature,exprs,namedArgs,closures,context);
}
