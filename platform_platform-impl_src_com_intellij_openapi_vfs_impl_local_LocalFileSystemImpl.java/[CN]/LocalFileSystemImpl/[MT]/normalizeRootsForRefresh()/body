{
  final List<WatchRequestImpl> result=new ArrayList<WatchRequestImpl>();
synchronized (myLock) {
    TreeNode rootNode=new TreeNode();
    for (    WatchRequestImpl request : myRootsToWatch) {
      request.myDominated=false;
      String rootPath=request.getRootPath();
      TreeNode currentNode=rootNode;
      MainLoop:       for (      String subPath : splitPath(rootPath)) {
        TreeNode nextNode=currentNode.nodes.get(subPath);
        if (nextNode != null) {
          currentNode=nextNode;
          if (currentNode.watchRequest != null && currentNode.watchRequest.isToWatchRecursively()) {
            request.myDominated=true;
            break MainLoop;
          }
        }
 else {
          TreeNode newNode=new TreeNode();
          currentNode.nodes.put(subPath,newNode);
          currentNode=newNode;
        }
      }
      if (currentNode.watchRequest == null) {
        currentNode.watchRequest=request;
      }
 else {
        if (!currentNode.watchRequest.isToWatchRecursively()) {
          currentNode.watchRequest.myDominated=true;
          currentNode.watchRequest=request;
        }
 else {
          request.myDominated=true;
        }
      }
      if (currentNode.watchRequest.isToWatchRecursively() && !currentNode.nodes.isEmpty()) {
        visitTree(currentNode,new Consumer<TreeNode>(){
          @Override public void consume(          final TreeNode node){
            if (node.watchRequest != null) {
              node.watchRequest.myDominated=true;
            }
          }
        }
);
        currentNode.nodes.clear();
      }
    }
    visitTree(rootNode,new Consumer<TreeNode>(){
      @Override public void consume(      final TreeNode node){
        if (node.watchRequest != null) {
          result.add(node.watchRequest);
        }
      }
    }
);
    myNormalizedTree=rootNode;
  }
  return result.toArray(new WatchRequestImpl[result.size()]);
}
