{
  if (!(editor.getDocument() instanceof DocumentEx)) {
    myOriginalHandler.execute(editor,dataContext);
    return;
  }
  final DocumentEx doc=(DocumentEx)editor.getDocument();
  final Project project=PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(editor.getContentComponent()));
  LogicalPosition caretPosition=editor.getCaretModel().getLogicalPosition();
  final PsiDocumentManager docManager=PsiDocumentManager.getInstance(project);
  PsiFile psiFile=docManager.getPsiFile(doc);
  if (psiFile == null) {
    myOriginalHandler.execute(editor,dataContext);
    return;
  }
  int startLine=caretPosition.line;
  int endLine=startLine + 1;
  if (editor.getSelectionModel().hasSelection()) {
    startLine=doc.getLineNumber(editor.getSelectionModel().getSelectionStart());
    endLine=doc.getLineNumber(editor.getSelectionModel().getSelectionEnd());
    if (doc.getLineStartOffset(endLine) == editor.getSelectionModel().getSelectionEnd())     endLine--;
  }
  int caretRestoreOffset=-1;
  for (int i=startLine; i < endLine; i++) {
    if (i >= doc.getLineCount() - 1)     break;
    int lineEndOffset=doc.getLineEndOffset(startLine);
    docManager.commitDocument(doc);
    CharSequence text=doc.getCharsSequence();
    int firstNonSpaceOffsetInNextLine=doc.getLineStartOffset(startLine + 1);
    while (firstNonSpaceOffsetInNextLine < text.length() - 1 && (text.charAt(firstNonSpaceOffsetInNextLine) == ' ' || text.charAt(firstNonSpaceOffsetInNextLine) == '\t')) {
      firstNonSpaceOffsetInNextLine++;
    }
    PsiElement elementAtNextLineStart=psiFile.findElementAt(firstNonSpaceOffsetInNextLine);
    boolean isNextLineStartsWithComment=isCommentElement(elementAtNextLineStart);
    int lastNonSpaceOffsetInStartLine=lineEndOffset;
    while (lastNonSpaceOffsetInStartLine > 0 && (text.charAt(lastNonSpaceOffsetInStartLine - 1) == ' ' || text.charAt(lastNonSpaceOffsetInStartLine - 1) == '\t')) {
      lastNonSpaceOffsetInStartLine--;
    }
    int elemOffset=lastNonSpaceOffsetInStartLine > doc.getLineStartOffset(startLine) ? lastNonSpaceOffsetInStartLine - 1 : -1;
    PsiElement elementAtStartLineEnd=elemOffset == -1 ? null : psiFile.findElementAt(elemOffset);
    boolean isStartLineEndsWithComment=isCommentElement(elementAtStartLineEnd);
    if (lastNonSpaceOffsetInStartLine == doc.getLineStartOffset(startLine)) {
      doc.deleteString(doc.getLineStartOffset(startLine),firstNonSpaceOffsetInNextLine);
      int indent=-1;
      try {
        docManager.commitDocument(doc);
        indent=CodeStyleManager.getInstance(project).adjustLineIndent(psiFile,startLine == 0 ? 0 : doc.getLineStartOffset(startLine));
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
      if (caretRestoreOffset == -1) {
        caretRestoreOffset=indent;
      }
      continue;
    }
    doc.deleteString(lineEndOffset,lineEndOffset + doc.getLineSeparatorLength(startLine));
    text=doc.getCharsSequence();
    int start=lineEndOffset - 1;
    int end=lineEndOffset;
    while (start > 0 && (text.charAt(start) == ' ' || text.charAt(start) == '\t'))     start--;
    while (end < doc.getTextLength() && (text.charAt(end) == ' ' || text.charAt(end) == '\t'))     end++;
    docManager.commitDocument(doc);
    int rc=-1;
    for (    JoinLinesHandlerDelegate delegate : Extensions.getExtensions(JoinLinesHandlerDelegate.EP_NAME)) {
      rc=delegate.tryJoinLines(doc,psiFile,start,end);
      if (rc != -1)       break;
    }
    docManager.doPostponedOperationsAndUnblockDocument(doc);
    if (rc != -1) {
      if (caretRestoreOffset == -1)       caretRestoreOffset=rc;
      continue;
    }
    if (caretRestoreOffset == -1)     caretRestoreOffset=start == lineEndOffset ? start : start + 1;
    if (isStartLineEndsWithComment && isNextLineStartsWithComment) {
      if (text.charAt(end) == '*' && end < text.length() && text.charAt(end + 1) != '/') {
        end++;
        while (end < doc.getTextLength() && (text.charAt(end) == ' ' || text.charAt(end) == '\t'))         end++;
      }
 else       if (text.charAt(end) == '/') {
        end+=2;
        while (end < doc.getTextLength() && (text.charAt(end) == ' ' || text.charAt(end) == '\t'))         end++;
      }
      doc.replaceString(start == lineEndOffset ? start : start + 1,end," ");
      continue;
    }
    while (end < doc.getTextLength() && (text.charAt(end) == ' ' || text.charAt(end) == '\t'))     end++;
    doc.replaceString(start == lineEndOffset ? start : start + 1,end," ");
    if (start <= doc.getLineStartOffset(startLine)) {
      try {
        docManager.commitDocument(doc);
        CodeStyleManager.getInstance(project).adjustLineIndent(psiFile,doc.getLineStartOffset(startLine));
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
    int prevLineCount=doc.getLineCount();
    docManager.commitDocument(doc);
    try {
      CodeStyleManager.getInstance(project).reformatText(psiFile,start + 1,end);
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
    if (prevLineCount < doc.getLineCount()) {
      docManager.doPostponedOperationsAndUnblockDocument(doc);
      end=doc.getLineEndOffset(startLine) + doc.getLineSeparatorLength(startLine);
      start=end - doc.getLineSeparatorLength(startLine);
      int addedLinesCount=doc.getLineCount() - prevLineCount - 1;
      while (end < doc.getTextLength() && (text.charAt(end) == ' ' || text.charAt(end) == '\t' || text.charAt(end) == '\n' && addedLinesCount > 0)) {
        if (text.charAt(end) == '\n')         addedLinesCount--;
        end++;
      }
      doc.replaceString(start,end," ");
    }
    docManager.commitDocument(doc);
  }
  if (editor.getSelectionModel().hasSelection()) {
    editor.getCaretModel().moveToOffset(editor.getSelectionModel().getSelectionEnd());
  }
 else   if (caretRestoreOffset != -1) {
    editor.getCaretModel().moveToOffset(caretRestoreOffset);
    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
    editor.getSelectionModel().removeSelection();
  }
}
