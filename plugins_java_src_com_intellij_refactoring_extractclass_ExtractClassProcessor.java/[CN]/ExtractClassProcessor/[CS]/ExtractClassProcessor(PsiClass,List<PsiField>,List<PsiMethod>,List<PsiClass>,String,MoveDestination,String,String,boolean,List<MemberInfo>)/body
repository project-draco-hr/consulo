{
  super(sourceClass.getProject());
  this.sourceClass=sourceClass;
  this.newPackageName=packageName;
  myMoveDestination=moveDestination;
  myNewVisibility=newVisibility;
  myGenerateAccessors=generateAccessors;
  this.enumConstants=new ArrayList<PsiField>();
  for (  MemberInfo constant : enumConstants) {
    if (constant.isChecked()) {
      this.enumConstants.add((PsiField)constant.getMember());
    }
  }
  this.fields=new ArrayList<PsiField>(fields);
  this.methods=new ArrayList<PsiMethod>(methods);
  this.innerClasses=new ArrayList<PsiClass>(classes);
  this.newClassName=newClassName;
  delegateFieldName=calculateDelegateFieldName();
  requiresBackpointer=new BackpointerUsageVisitor(fields,innerClasses,methods,sourceClass).backpointerRequired();
  if (requiresBackpointer) {
    ContainerUtil.addAll(typeParams,sourceClass.getTypeParameters());
  }
 else {
    final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
    final TypeParametersVisitor visitor=new TypeParametersVisitor(typeParamSet);
    for (    PsiField field : fields) {
      field.accept(visitor);
    }
    for (    PsiMethod method : methods) {
      method.accept(visitor);
      typeParamSet.removeAll(Arrays.asList(method.getTypeParameters()));
    }
    typeParams.addAll(typeParamSet);
  }
  myClass=new WriteCommandAction<PsiClass>(myProject,getCommandName()){
    @Override protected void run(    Result<PsiClass> result) throws Throwable {
      result.setResult(buildClass());
    }
  }
.execute().getResultObject();
  myExtractEnumProcessor=new ExtractEnumProcessor(myProject,this.enumConstants,myClass);
}
