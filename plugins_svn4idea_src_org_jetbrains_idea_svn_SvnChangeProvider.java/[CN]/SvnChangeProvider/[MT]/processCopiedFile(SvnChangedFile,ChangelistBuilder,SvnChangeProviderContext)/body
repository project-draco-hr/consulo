{
  boolean foundRename=false;
  final SVNStatus copiedStatus=copiedFile.getStatus();
  final String copyFromURL=copiedFile.getCopyFromURL();
  final FilePath copiedToPath=copiedFile.getFilePath();
  final Set<SvnChangedFile> deletedToDelete=new HashSet<SvnChangedFile>();
  for (Iterator<SvnChangedFile> iterator=context.getDeletedFiles().iterator(); iterator.hasNext(); ) {
    SvnChangedFile deletedFile=iterator.next();
    final SVNStatus deletedStatus=deletedFile.getStatus();
    if ((deletedStatus != null) && (deletedStatus.getURL() != null) && Comparing.equal(copyFromURL,deletedStatus.getURL().toString())) {
      final String clName=changeListNameFromStatus(copiedFile.getStatus());
      builder.processChangeInList(context.createMovedChange(createBeforeRevision(deletedFile,true),CurrentContentRevision.create(copiedFile.getFilePath()),copiedStatus,deletedStatus),clName,SvnVcs.getKey());
      deletedToDelete.add(deletedFile);
      for (Iterator<SvnChangedFile> iterChild=context.getDeletedFiles().iterator(); iterChild.hasNext(); ) {
        SvnChangedFile deletedChild=iterChild.next();
        final SVNStatus childStatus=deletedChild.getStatus();
        if (childStatus == null) {
          continue;
        }
        final SVNURL childUrl=childStatus.getURL();
        if (childUrl == null) {
          continue;
        }
        final String childURL=childUrl.toString();
        if (StringUtil.startsWithConcatenationOf(childURL,copyFromURL,"/")) {
          String relativePath=childURL.substring(copyFromURL.length());
          File newPath=new File(copiedFile.getFilePath().getIOFile(),relativePath);
          FilePath newFilePath=myFactory.createFilePathOn(newPath);
          if (!context.isDeleted(newFilePath)) {
            builder.processChangeInList(context.createMovedChange(createBeforeRevision(deletedChild,true),CurrentContentRevision.create(newFilePath),context.getTreeConflictStatus(newPath),childStatus),clName,SvnVcs.getKey());
            deletedToDelete.add(deletedChild);
          }
        }
      }
      foundRename=true;
      break;
    }
  }
  final List<SvnChangedFile> deletedFiles=context.getDeletedFiles();
  for (  SvnChangedFile file : deletedToDelete) {
    deletedFiles.remove(file);
  }
  if (!foundRename && copiedStatus.getURL() != null) {
    File wcPath=guessWorkingCopyPath(copiedStatus.getFile(),copiedStatus.getURL(),copyFromURL);
    SVNStatus status;
    try {
      status=context.getClient().doStatus(wcPath,false);
    }
 catch (    SVNException ex) {
      status=null;
    }
    if (status != null && SvnVcs.svnStatusIs(status,SVNStatusType.STATUS_DELETED)) {
      final FilePath filePath=myFactory.createFilePathOnDeleted(wcPath,false);
      final SvnContentRevision beforeRevision=SvnContentRevision.createBaseRevision(myVcs,filePath,status.getRevision());
      final ContentRevision afterRevision=CurrentContentRevision.create(copiedFile.getFilePath());
      builder.processChangeInList(context.createMovedChange(beforeRevision,afterRevision,copiedStatus,status),changeListNameFromStatus(status),SvnVcs.getKey());
      foundRename=true;
    }
  }
  if (!foundRename) {
    LOG.info("Rename not found for " + copiedFile.getFilePath().getPresentableUrl());
    context.processStatus(copiedFile.getFilePath(),copiedStatus);
  }
}
