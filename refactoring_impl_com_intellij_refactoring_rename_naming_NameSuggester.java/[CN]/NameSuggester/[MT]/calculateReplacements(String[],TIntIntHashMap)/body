{
  TreeMap<Pair<Integer,Integer>,String> replacements=new TreeMap<Pair<Integer,Integer>,String>(new Comparator<Pair<Integer,Integer>>(){
    public int compare(    Pair<Integer,Integer> pair,    Pair<Integer,Integer> pair1){
      return pair.getFirst().compareTo(pair1.getFirst());
    }
  }
);
  for (Iterator<OriginalToNewChange> iterator=myChanges.iterator(); iterator.hasNext(); ) {
    final OriginalToNewChange change=iterator.next();
    final int first=change.oldFirst;
    final int last=change.oldLast;
    if (change.getOldLength() > 0) {
      if (containsAllBetween(matches,first,last)) {
        final String newString=change.getNewString();
        final int propertyWordFirst=matches.get(first);
        if (first >= myOldClassName.length || last >= myOldClassName.length) {
          LOG.assertTrue(false,"old class name = " + myOldClassNameAsGiven + ", new class name = "+ myNewClassNameAsGiven+ ", propertyWords = "+ Arrays.asList(propertyWords).toString());
        }
        final String replacement=suggestReplacement(myOldClassName[first],propertyWords[propertyWordFirst],newString);
        replacements.put(Pair.create(new Integer(propertyWordFirst),new Integer(matches.get(last))),replacement);
      }
    }
 else {
      final String newString=change.getNewString();
      final int propertyWordToInsertBefore;
      if (matches.containsKey(first)) {
        propertyWordToInsertBefore=matches.get(first);
      }
 else {
        propertyWordToInsertBefore=propertyWords.length;
      }
      replacements.put(Pair.create(new Integer(propertyWordToInsertBefore),new Integer(propertyWordToInsertBefore - 1)),newString);
    }
  }
  return replacements;
}
