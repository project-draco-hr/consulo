{
  myParentDisposable=parentDisposable;
  Extensions.cleanRootArea(myParentDisposable);
  myFileTypeRegistry=new CoreFileTypeRegistry();
  myEncodingRegistry=new CoreEncodingRegistry();
  myApplication=new MockApplication(myParentDisposable);
  ApplicationManager.setApplication(myApplication,new StaticGetter<FileTypeRegistry>(myFileTypeRegistry),new StaticGetter<EncodingRegistry>(myEncodingRegistry),myParentDisposable);
  myLocalFileSystem=createLocalFileSystem();
  myJarFileSystem=createJarFileSystem();
  Extensions.registerAreaClass(ExtensionAreas.IDEA_PROJECT,null);
  final MutablePicoContainer appContainer=myApplication.getPicoContainer();
  registerComponentInstance(appContainer,FileDocumentManager.class,new MockFileDocumentManagerImpl(new Function<CharSequence,Document>(){
    @Override public Document fun(    CharSequence charSequence){
      return new DocumentImpl(charSequence);
    }
  }
,null));
  FileSystemPersistence fileSystemPersistence=new FileSystemPersistence(){
    @Override public void refresh(    boolean asynchronous,    Runnable postAction,    @NotNull ModalityState modalityState){
    }
    @Override public int getCheapFileSystemModificationCount(){
      return 0;
    }
    @Nullable @Override public VirtualFile findFileById(    int id){
      return null;
    }
  }
;
  VirtualFileManagerImpl virtualFileManager=new VirtualFileManagerImpl(new VirtualFileSystem[]{myLocalFileSystem,myJarFileSystem},new MessageBusImpl(myApplication,null),fileSystemPersistence);
  registerComponentInstance(appContainer,VirtualFileManager.class,virtualFileManager);
  myApplication.registerService(VirtualFilePointerManager.class,new CoreVirtualFilePointerManager());
  myApplication.registerService(DefaultASTFactory.class,new CoreASTFactory());
  myApplication.registerService(PsiBuilderFactory.class,new PsiBuilderFactoryImpl());
  myApplication.registerService(ReferenceProvidersRegistry.class,new MockReferenceProvidersRegistry());
  myApplication.registerService(StubTreeLoader.class,new CoreStubTreeLoader());
  myApplication.registerService(PsiReferenceService.class,new PsiReferenceServiceImpl());
  registerApplicationExtensionPoint(ContentBasedFileSubstitutor.EP_NAME,ContentBasedFileSubstitutor.class);
  registerExtensionPoint(Extensions.getRootArea(),BinaryFileStubBuilders.EP_NAME,FileTypeExtensionPoint.class);
  ProgressIndicatorProvider.ourInstance=createProgressIndicatorProvider();
  myApplication.registerService(JobLauncher.class,new JobLauncher(){
    @Override public <T>boolean invokeConcurrentlyUnderProgress(    @NotNull List<T> things,    ProgressIndicator progress,    boolean failFastOnAcquireReadAction,    @NotNull Processor<T> thingProcessor) throws ProcessCanceledException {
      for (      T thing : things) {
        if (!thingProcessor.process(thing))         return false;
      }
      return true;
    }
    @Override public Job<Void> submitToJobThread(    int priority,    @NotNull Runnable action,    Consumer<Future> onDoneCallback){
      action.run();
      if (onDoneCallback != null)       onDoneCallback.consume(new Future(){
        @Override public boolean cancel(        boolean mayInterruptIfRunning){
          return false;
        }
        @Override public boolean isCancelled(){
          return false;
        }
        @Override public boolean isDone(){
          return true;
        }
        @Override public Object get() throws InterruptedException, ExecutionException {
          return null;
        }
        @Override public Object get(        long timeout,        TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
          return null;
        }
      }
);
      return null;
    }
  }
);
}
