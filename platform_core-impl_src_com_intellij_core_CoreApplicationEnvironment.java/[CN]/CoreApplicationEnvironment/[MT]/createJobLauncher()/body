{
  return new JobLauncher(){
    @Override public <T>boolean invokeConcurrentlyUnderProgress(    @NotNull List<T> things,    ProgressIndicator progress,    boolean runInReadAction,    boolean failFastOnAcquireReadAction,    @NotNull Processor<? super T> thingProcessor){
      for (      T thing : things) {
        if (!thingProcessor.process(thing))         return false;
      }
      return true;
    }
    @NotNull @Override public <T>AsyncFuture<Boolean> invokeConcurrentlyUnderProgressAsync(    @NotNull List<T> things,    ProgressIndicator progress,    boolean failFastOnAcquireReadAction,    @NotNull Processor<? super T> thingProcessor){
      return AsyncUtil.wrapBoolean(invokeConcurrentlyUnderProgress(things,progress,failFastOnAcquireReadAction,thingProcessor));
    }
    @NotNull @Override public Job<Void> submitToJobThread(    @NotNull Runnable action,    Consumer<Future> onDoneCallback){
      action.run();
      if (onDoneCallback != null)       onDoneCallback.consume(new Future(){
        @Override public boolean cancel(        boolean mayInterruptIfRunning){
          return false;
        }
        @Override public boolean isCancelled(){
          return false;
        }
        @Override public boolean isDone(){
          return true;
        }
        @Override public Object get(){
          return null;
        }
        @Override public Object get(        long timeout,        @NotNull TimeUnit unit){
          return null;
        }
      }
);
      return Job.NULL_JOB;
    }
  }
;
}
