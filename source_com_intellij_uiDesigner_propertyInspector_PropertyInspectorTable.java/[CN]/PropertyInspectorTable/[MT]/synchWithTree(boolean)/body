{
  if (myInsideSynch) {
    return;
  }
  myInsideSynch=true;
  try {
    final RadComponent newSelectedComponent=myComponentTree.getSelectedComponent();
    LOG.assertTrue(newSelectedComponent != null);
    if (!forceSynch && newSelectedComponent.equals(myComponent)) {
      return;
    }
    if (isEditing()) {
      cellEditor.stopCellEditing();
    }
    final int selectedRow=getSelectedRow();
    Property selectedProperty=null;
    if (selectedRow >= 0 && selectedRow < myProperties.size()) {
      selectedProperty=myProperties.get(selectedRow);
    }
    myComponent=newSelectedComponent;
    myProperties.clear();
    collectProperties(myComponent,myProperties);
    myExpandedProperties.clear();
    myModel.fireTableDataChanged();
    final ArrayList<Property> reversePath=new ArrayList<Property>(2);
    while (selectedProperty != null) {
      reversePath.add(selectedProperty);
      selectedProperty=selectedProperty.getParent();
    }
    int indexToSelect=-1;
    for (int i=reversePath.size() - 1; i >= 0; i--) {
      final Property property=reversePath.get(i);
      int index=findPropertyByName(property.getName());
      if (index == -1 && indexToSelect != -1) {
        expandProperty(indexToSelect);
        index=findPropertyByName(property.getName());
        if (index != -1) {
          indexToSelect=index;
        }
 else {
          break;
        }
      }
 else {
        indexToSelect=index;
      }
    }
    if (indexToSelect != -1) {
      getSelectionModel().setSelectionInterval(indexToSelect,indexToSelect);
    }
 else     if (getRowCount() > 0) {
      getSelectionModel().setSelectionInterval(0,0);
    }
    TableUtil.scrollSelectionToVisible(this);
  }
  finally {
    myInsideSynch=false;
  }
}
