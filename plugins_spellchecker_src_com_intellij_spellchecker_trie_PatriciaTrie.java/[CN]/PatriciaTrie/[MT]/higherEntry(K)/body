{
  int keyLength=length(key);
  if (keyLength == 0) {
    if (!root.isEmpty()) {
      if (size() > 1) {
        return nextEntry(root);
      }
 else {
        return null;
      }
    }
 else {
      return firstEntry();
    }
  }
  TrieEntry<K,V> found=getNearestEntryForKey(key,keyLength);
  if (key.equals(found.key))   return nextEntry(found);
  int bitIndex=bitIndex(key,found.key);
  if (isValidBitIndex(bitIndex)) {
    TrieEntry<K,V> added=new TrieEntry<K,V>(key,null,bitIndex);
    addEntry(added,keyLength);
    incrementSize();
    TrieEntry<K,V> ceil=nextEntry(added);
    removeEntry(added);
    modCount-=2;
    return ceil;
  }
 else   if (isNullBitKey(bitIndex)) {
    if (!root.isEmpty())     return firstEntry();
 else     if (size() > 1)     return nextEntry(firstEntry());
 else     return null;
  }
 else   if (isEqualBitKey(bitIndex)) {
    return nextEntry(found);
  }
  throw new IllegalStateException("invalid lookup: " + key);
}
