{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  for (  GroovyInlineMethodUtil.ReferenceExpressionInfo info : infos) {
    if (!PsiUtil.isAccessible(call,info.declaration)) {
      if (info.declaration instanceof PsiMethod) {
        String className=info.containingClass.getName();
        String signature=GroovyRefactoringUtil.getMethodSignature((PsiMethod)info.declaration);
        String name=CommonRefactoringUtil.htmlEmphasize(className + "." + signature);
        conflicts.putValue(info.declaration,GroovyRefactoringBundle.message("method.is.not.accessible.form.context.0",name));
      }
 else       if (info.declaration instanceof PsiField) {
        if (!(info.declaration instanceof GrField && ((GrField)info.declaration).getGetters().length > 0)) {
          String className=info.containingClass.getName();
          String name=CommonRefactoringUtil.htmlEmphasize(className + "." + info.getPresentation());
          conflicts.putValue(info.declaration,GroovyRefactoringBundle.message("field.is.not.accessible.form.context.0",name));
        }
      }
    }
    final Ref<Boolean> hasSuper=new Ref<Boolean>(false);
    info.expression.accept(new GroovyRecursiveElementVisitor(){
      @Override public void visitSuperExpression(      GrSuperReferenceExpression superExpression){
        hasSuper.set(true);
      }
    }
);
    if (hasSuper.get()) {
      conflicts.putValue(info.expression,GroovyRefactoringBundle.message("super.reference.is.used"));
    }
  }
  return conflicts;
}
