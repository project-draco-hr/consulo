{
  try {
    final File file=new File(path);
    byte[] fileContent=ArrayUtil.EMPTY_BYTE_ARRAY;
    try {
      fileContent=FileUtil.loadFileBytes(file);
    }
 catch (    IOException ignored) {
    }
    final DependencyCache dependencyCache=myCompileContext.getDependencyCache();
    final int newClassQName=dependencyCache.reparseClassFile(file,fileContent);
    final Cache newClassesCache=dependencyCache.getNewClassesCache();
    final String sourceFileName=newClassesCache.getSourceFileName(newClassQName);
    final String qName=dependencyCache.resolve(newClassQName);
    String relativePathToSource="/" + MakeUtil.createRelativePathToSource(qName,sourceFileName);
    putName(sourceFileName,newClassQName,relativePathToSource,path);
    if (myAddNotNullAssertions && hasNotNullAnnotations(newClassesCache,dependencyCache.getSymbolTable(),newClassQName)) {
      try {
        ClassReader reader=new ClassReader(fileContent,0,fileContent.length);
        ClassWriter writer=new PsiClassWriter(myProject,myIsJdk16);
        final NotNullVerifyingInstrumenter instrumenter=new NotNullVerifyingInstrumenter(writer);
        reader.accept(instrumenter,0);
        if (instrumenter.isModification()) {
          final FileOutputStream output=new FileOutputStream(file);
          try {
            output.write(writer.toByteArray());
          }
  finally {
            output.close();
          }
        }
      }
 catch (      Exception ignored) {
        LOG.info(ignored);
      }
    }
  }
 catch (  ClsFormatException e) {
    String message;
    final String m=e.getMessage();
    if (m == null || "".equals(m)) {
      message=CompilerBundle.message("error.bad.class.file.format",path);
    }
 else {
      message=CompilerBundle.message("error.bad.class.file.format",m + "\n" + path);
    }
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,message,null,-1,-1);
  }
 finally {
    myClassesCount+=1;
    updateStatistics();
  }
}
