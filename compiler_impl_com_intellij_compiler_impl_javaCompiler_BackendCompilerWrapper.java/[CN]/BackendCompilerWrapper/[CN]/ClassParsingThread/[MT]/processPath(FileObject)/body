{
  File file=fileObject.getFile();
  byte[] fileContent=fileObject.getContent();
  String path=file.getPath();
  try {
    final DependencyCache dependencyCache=myCompileContext.getDependencyCache();
    final int newClassQName=dependencyCache.reparseClassFile(file,fileContent);
    final Cache newClassesCache=dependencyCache.getNewClassesCache();
    final String sourceFileName=newClassesCache.getSourceFileName(newClassQName);
    final String qName=dependencyCache.resolve(newClassQName);
    String relativePathToSource="/" + MakeUtil.createRelativePathToSource(qName,sourceFileName);
    putName(sourceFileName,newClassQName,relativePathToSource,path);
    boolean fileContentChanged=false;
    if (myAddNotNullAssertions && hasNotNullAnnotations(newClassesCache,dependencyCache.getSymbolTable(),newClassQName)) {
      try {
        ClassReader reader=new ClassReader(fileContent,0,fileContent.length);
        ClassWriter writer=new PsiClassWriter(myProject,myIsJdk16);
        final NotNullVerifyingInstrumenter instrumenter=new NotNullVerifyingInstrumenter(writer);
        reader.accept(instrumenter,0);
        if (instrumenter.isModification()) {
          fileContent=writer.toByteArray();
          fileContentChanged=true;
        }
      }
 catch (      Exception ignored) {
        LOG.info(ignored);
      }
    }
    if (fileContentChanged || !fileObject.isSaved()) {
      writeFile(file,fileContent);
    }
  }
 catch (  ClsFormatException e) {
    String message;
    final String m=e.getMessage();
    if (m == null || "".equals(m)) {
      message=CompilerBundle.message("error.bad.class.file.format",path);
    }
 else {
      message=CompilerBundle.message("error.bad.class.file.format",m + "\n" + path);
    }
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,message,null,-1,-1);
  }
catch (  IOException e) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
  }
 finally {
    myClassesCount+=1;
    updateStatistics();
  }
}
