{
  File file=fileObject.getFile();
  final String path=file.getPath();
  try {
    if (CompilerConfiguration.MAKE_ENABLED) {
      byte[] fileContent=fileObject.getContent();
      final DependencyCache dependencyCache=myCompileContext.getDependencyCache();
      final int newClassQName=dependencyCache.reparseClassFile(file,fileContent);
      final Cache newClassesCache=dependencyCache.getNewClassesCache();
      final String sourceFileName=newClassesCache.getSourceFileName(newClassQName);
      final String qName=dependencyCache.resolve(newClassQName);
      String relativePathToSource="/" + MakeUtil.createRelativePathToSource(qName,sourceFileName);
      putName(myChunk,sourceFileName,newClassQName,relativePathToSource,path);
      boolean haveToInstrument=myAddNotNullAssertions && hasNotNullAnnotations(newClassesCache,dependencyCache.getSymbolTable(),newClassQName);
      boolean fileContentChanged=false;
      if (haveToInstrument) {
        try {
          ClassReader reader=new ClassReader(fileContent,0,fileContent.length);
          ClassWriter writer=new PsiClassWriter(myProject,myIsJdk16);
          final NotNullVerifyingInstrumenter instrumenter=new NotNullVerifyingInstrumenter(writer);
          reader.accept(instrumenter,0);
          if (instrumenter.isModification()) {
            fileContent=writer.toByteArray();
            fileContentChanged=true;
          }
        }
 catch (        Exception ignored) {
          LOG.info(ignored);
        }
      }
      if (fileContentChanged || !fileObject.isSaved()) {
        writeFile(file,fileContent);
      }
    }
 else {
      final String _path=FileUtil.toSystemIndependentName(path);
      final int dollarIndex=_path.indexOf('$');
      final int tailIndex=dollarIndex >= 0 ? dollarIndex : _path.length() - ".class".length();
      final int slashIndex=_path.lastIndexOf('/');
      final String sourceFileName=_path.substring(slashIndex + 1,tailIndex) + ".java";
      String relativePathToSource=_path.substring(myOutputDir.length(),tailIndex) + ".java";
      putName(myChunk,sourceFileName,0,relativePathToSource.startsWith("/") ? relativePathToSource : "/" + relativePathToSource,path);
    }
  }
 catch (  ClsFormatException e) {
    String message;
    final String m=e.getMessage();
    if (m == null || "".equals(m)) {
      message=CompilerBundle.message("error.bad.class.file.format",path);
    }
 else {
      message=CompilerBundle.message("error.bad.class.file.format",m + "\n" + path);
    }
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,message,null,-1,-1);
  }
catch (  IOException e) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
  }
 finally {
    myClassesCount++;
    updateStatistics();
  }
}
