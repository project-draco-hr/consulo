{
  chunk.setSourcesFilter(sourcesFilter);
  if (ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
    public Boolean compute(){
      return chunk.getFilesToCompile().length == 0 ? Boolean.TRUE : Boolean.FALSE;
    }
  }
).booleanValue()) {
    return;
  }
  int exitValue=0;
  try {
    Process process=myCompiler.launchProcess(chunk,outputDir,myCompileContext);
    final ClassParsingThread classParsingThread=new ClassParsingThread();
    classParsingThread.start();
    OutputParser errorParser=myCompiler.createErrorParser(outputDir);
    CompilerParsingThread errorParsingThread=errorParser == null ? null : new SynchedCompilerParsing(process,myCompileContext,errorParser,classParsingThread,true,errorParser.isTrimLines());
    if (errorParsingThread != null) {
      errorParsingThread.start();
    }
    OutputParser outputParser=myCompiler.createOutputParser(outputDir);
    CompilerParsingThread outputParsingThread=outputParser == null ? null : new SynchedCompilerParsing(process,myCompileContext,outputParser,classParsingThread,false,outputParser.isTrimLines());
    if (outputParsingThread != null) {
      outputParsingThread.start();
    }
    try {
      exitValue=process.waitFor();
    }
 catch (    InterruptedException e) {
      process.destroy();
      exitValue=process.exitValue();
    }
    joinThread(errorParsingThread);
    joinThread(outputParsingThread);
    classParsingThread.stopParsing();
    joinThread(classParsingThread);
    registerParsingException(outputParsingThread);
    registerParsingException(errorParsingThread);
  }
  finally {
    compileFinished(exitValue,chunk,outputDir);
    myModuleName=null;
  }
}
