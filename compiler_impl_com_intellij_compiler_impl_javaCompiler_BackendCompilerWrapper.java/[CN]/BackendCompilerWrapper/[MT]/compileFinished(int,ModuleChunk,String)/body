{
  if (exitValue != 0 && !myCompileContext.getProgressIndicator().isCanceled() && myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,CompilerBundle.message("error.compiler.internal.error",exitValue),null,-1,-1);
  }
  myCompiler.compileFinished();
  final VirtualFile[] sourceRoots=chunk.getSourceRoots();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      final Set<VirtualFile> compiledWithErrors=getFilesCompiledWithErrors();
      final FileTypeManager typeManager=FileTypeManager.getInstance();
      final String outputDirPath=outputDir.replace(File.separatorChar,'/');
      if (LOG.isDebugEnabled()) {
        LOG.debug("myFileNameToSourceMap contains entries: " + chunk.myFileNameToSourceMap.size());
      }
      try {
        for (        final VirtualFile root : sourceRoots) {
          final String packagePrefix=myProjectFileIndex.getPackageNameByDirectory(root);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Building output items for " + root.getPresentableUrl() + "; output dir = "+ outputDirPath+ "; packagePrefix = \""+ packagePrefix+ "\"");
          }
          buildOutputItemsList(chunk,outputDirPath,root,typeManager,compiledWithErrors,root,packagePrefix);
        }
      }
 catch (      CacheCorruptedException e) {
        myCompileContext.requestRebuildNextTime(CompilerBundle.message("error.compiler.caches.corrupted"));
        if (LOG.isDebugEnabled()) {
          LOG.debug(e);
        }
      }
    }
  }
);
  CompilerUtil.refreshIOFilesInterruptibly(myCompileContext,chunk.myFilesToRefresh,"Refreshing moved files");
  chunk.myFileNameToSourceMap.clear();
  chunk.myFilesToRefresh.clear();
}
