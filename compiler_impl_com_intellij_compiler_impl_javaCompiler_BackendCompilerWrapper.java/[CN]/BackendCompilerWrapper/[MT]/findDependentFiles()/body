{
  myCompileContext.getProgressIndicator().setText(CompilerBundle.message("progress.checking.dependencies"));
  final int[] dependentClassInfos=myCompileContext.getDependencyCache().findDependentClasses(myCompileContext,myProject,mySuccesfullyCompiledJavaFiles);
  final Set<VirtualFile> dependentFiles=new HashSet<VirtualFile>();
  final CacheCorruptedException[] _ex=new CacheCorruptedException[]{null};
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        CompilerConfiguration compilerConfiguration=CompilerConfiguration.getInstance(myProject);
        SourceFileFinder sourceFileFinder=new SourceFileFinder(myProject,myCompileContext);
        final Cache cache=myCompileContext.getDependencyCache().getCache();
        for (        final int infoQName : dependentClassInfos) {
          final String qualifiedName=myCompileContext.getDependencyCache().resolve(infoQName);
          final VirtualFile file=sourceFileFinder.findSourceFile(qualifiedName,cache.getSourceFileName(cache.getClassId(infoQName)));
          if (file != null) {
            if (!compilerConfiguration.isExcludedFromCompilation(file)) {
              dependentFiles.add(file);
              if (ApplicationManager.getApplication().isUnitTestMode()) {
                CompilerManagerImpl.addRecompiledPath(file.getPath());
              }
            }
          }
 else {
            if (LOG.isDebugEnabled()) {
              LOG.debug("No source file for " + myCompileContext.getDependencyCache().resolve(infoQName) + " found");
            }
          }
        }
      }
 catch (      CacheCorruptedException e) {
        _ex[0]=e;
      }
    }
  }
);
  if (_ex[0] != null) {
    throw _ex[0];
  }
  myCompileContext.getProgressIndicator().setText(CompilerBundle.message("progress.found.dependent.files",dependentFiles.size()));
  return dependentFiles.toArray(new VirtualFile[dependentFiles.size()]);
}
