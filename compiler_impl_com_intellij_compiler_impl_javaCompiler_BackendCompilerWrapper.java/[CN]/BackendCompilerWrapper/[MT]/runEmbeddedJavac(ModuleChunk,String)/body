{
  final String[] commands=myCompiler.createStartupCommand(chunk,myCompileContext,outputDir);
  List<String> modifiedCommands=new ArrayList<String>();
  int index=commands.length;
  boolean cpKeywordDetected=false;
  for (int idx=0; idx < commands.length; idx++) {
    String command=commands[idx];
    if ("com.sun.tools.javac.Main".equals(command)) {
      index=idx;
    }
 else {
      if (idx > index) {
        if (cpKeywordDetected) {
          cpKeywordDetected=false;
          if (command.startsWith("@")) {
            command=JavacRunner.readClasspath(command.substring(1));
          }
        }
 else         if ("-classpath".equals(command) || "-cp".equals(command)) {
          cpKeywordDetected=true;
        }
        modifiedCommands.add(command);
      }
    }
  }
  OutputParser outputParser=myCompiler.createOutputParser();
  final PipedInputStream in=new PipedInputStream();
  PipedOutputStream out=new PipedOutputStream(in);
  final PrintWriter writer=new PrintWriter(out);
  final String[] strings=modifiedCommands.toArray(new String[modifiedCommands.size()]);
  return new Pair<OutputParser,Process>(outputParser,new Process(){
    public OutputStream getOutputStream(){
      throw new UnsupportedOperationException("Not Implemented in: " + getClass().getName());
    }
    public InputStream getInputStream(){
      throw new UnsupportedOperationException("Not Implemented in: " + getClass().getName());
    }
    public void destroy(){
    }
    public int waitFor(){
      myExitCode=com.sun.tools.javac.Main.compile(strings,writer);
      writer.println(JavaCompilerParsingThread.TERMINATION_STRING);
      writer.flush();
      return myExitCode;
    }
    public InputStream getErrorStream(){
      return in;
    }
    public int exitValue(){
      return myExitCode;
    }
  }
);
}
