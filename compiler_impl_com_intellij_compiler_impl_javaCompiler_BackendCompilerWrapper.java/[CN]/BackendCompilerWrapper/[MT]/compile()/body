{
  VirtualFile[] dependentFiles=null;
  Application application=ApplicationManager.getApplication();
  final Set<VirtualFile> allDependent=new HashSet<VirtualFile>();
  COMPILE:   try {
    if (myFilesToCompile.length > 0) {
      if (application.isUnitTestMode()) {
        saveTestData();
      }
      final Map<Module,Set<VirtualFile>> moduleToFilesMap=buildModuleToFilesMap(myCompileContext,myFilesToCompile);
      compileModules(moduleToFilesMap);
    }
    do {
      dependentFiles=findDependentFiles();
      if (dependentFiles.length > 0) {
        final List<VirtualFile> deps=Arrays.asList(dependentFiles);
        myFilesToRecompile.addAll(deps);
        allDependent.addAll(deps);
        if (myCompileContext.getProgressIndicator().isCanceled() || myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
          break COMPILE;
        }
        final VirtualFile[] filesInScope=getFilesInScope(dependentFiles);
        if (filesInScope.length == 0) {
          break;
        }
        final Map<Module,Set<VirtualFile>> moduleToFilesMap=buildModuleToFilesMap(myCompileContext,filesInScope);
        myCompileContext.getDependencyCache().clearTraverseRoots();
        compileModules(moduleToFilesMap);
      }
    }
 while (dependentFiles.length > 0 && myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) == 0);
  }
 catch (  IOException e) {
    throw new CompilerException(CompilerBundle.message("error.compiler.process.not.started",e.getMessage()),e);
  }
catch (  SecurityException e) {
    throw new CompilerException(CompilerBundle.message("error.compiler.process.not.started",e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw new CompilerException(e.getMessage(),e);
  }
 finally {
    myCompileContext.getProgressIndicator().setText(CompilerBundle.message("progress.deleting.temp.files"));
    for (    final Module module : myModuleToTempDirMap.keySet()) {
      final VirtualFile file=myModuleToTempDirMap.get(module);
      if (file != null) {
        final File ioFile=application.runReadAction(new Computable<File>(){
          public File compute(){
            return new File(file.getPath());
          }
        }
);
        FileUtil.asyncDelete(ioFile);
      }
    }
    myModuleToTempDirMap.clear();
  }
  if (myCompileContext.getProgressIndicator().isCanceled()) {
    myFilesToRecompile.clear();
    return TranslatingCompiler.EMPTY_OUTPUT_ITEM_ARRAY;
  }
  myCompileContext.getProgressIndicator().setText(CompilerBundle.message("progress.updating.caches"));
  myCompileContext.getDependencyCache().update();
  myFilesToRecompile.removeAll(mySuccesfullyCompiledJavaFiles);
  if (myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) != 0) {
    myFilesToRecompile.addAll(allDependent);
  }
  processPackageInfoFiles();
  return myOutputItems.toArray(new TranslatingCompiler.OutputItem[myOutputItems.size()]);
}
