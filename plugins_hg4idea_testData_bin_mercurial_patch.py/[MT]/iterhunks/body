def iterhunks(ui, fp, sourcefile=None):
    'Read a patch and yield the following events:\n    - ("file", afile, bfile, firsthunk): select a new target file.\n    - ("hunk", hunk): a new hunk is ready to be applied, follows a\n    "file" event.\n    - ("git", gitchanges): current diff is in git format, gitchanges\n    maps filenames to gitpatch records. Unique event.\n    '
    changed = {}
    current_hunk = None
    afile = ''
    bfile = ''
    state = None
    hunknum = 0
    emitfile = False
    git = False
    BFILE = 1
    context = None
    lr = linereader(fp)
    gitworkdone = False
    empty = None
    while True:
        newfile = newgitfile = False
        x = lr.readline()
        if (not x):
            break
        if current_hunk:
            if x.startswith('\\ '):
                current_hunk.fix_newline()
            yield ('hunk', current_hunk)
            current_hunk = None
            empty = False
        if ((sourcefile or (state == BFILE)) and (((not context) and (x[0] == '@')) or ((context is not False) and x.startswith('***************')))):
            try:
                if ((context is None) and x.startswith('***************')):
                    context = True
                gpatch = changed.get(bfile)
                create = ((afile == '/dev/null') or (gpatch and (gpatch.op == 'ADD')))
                remove = ((bfile == '/dev/null') or (gpatch and (gpatch.op == 'DELETE')))
                current_hunk = hunk(x, (hunknum + 1), lr, context, create, remove)
            except PatchError as err:
                ui.debug(err)
                current_hunk = None
                continue
            hunknum += 1
            if emitfile:
                emitfile = False
                yield ('file', (afile, bfile, current_hunk))
                empty = False
        elif ((state == BFILE) and x.startswith('GIT binary patch')):
            current_hunk = binhunk(changed[bfile])
            hunknum += 1
            if emitfile:
                emitfile = False
                yield ('file', (('a/' + afile), ('b/' + bfile), current_hunk))
                empty = False
            current_hunk.extract(lr)
        elif x.startswith('diff --git'):
            m = gitre.match(x)
            gitworkdone = False
            if m:
                (afile, bfile) = m.group(1, 2)
                if (not git):
                    git = True
                    gitpatches = scangitpatch(lr, x)[1]
                    yield ('git', gitpatches)
                    for gp in gitpatches:
                        changed[gp.path] = gp
                gp = changed.get(bfile)
                if (gp and ((gp.op in ('COPY', 'DELETE', 'RENAME', 'ADD')) or gp.mode)):
                    afile = bfile
                    gitworkdone = True
                newgitfile = True
        elif x.startswith('---'):
            l2 = lr.readline()
            if (not l2.startswith('+++')):
                lr.push(l2)
                continue
            newfile = True
            context = False
            afile = parsefilename(x)
            bfile = parsefilename(l2)
        elif x.startswith('***'):
            l2 = lr.readline()
            if (not l2.startswith('---')):
                lr.push(l2)
                continue
            l3 = lr.readline()
            lr.push(l3)
            if (not l3.startswith('***************')):
                lr.push(l2)
                continue
            newfile = True
            context = True
            afile = parsefilename(x)
            bfile = parsefilename(l2)
        if newfile:
            if empty:
                raise NoHunks
            empty = (not gitworkdone)
            gitworkdone = False
        if (newgitfile or newfile):
            emitfile = True
            state = BFILE
            hunknum = 0
    if current_hunk:
        if current_hunk.complete():
            yield ('hunk', current_hunk)
            empty = False
        else:
            raise PatchError((_('malformed patch %s %s') % (afile, current_hunk.desc)))
    if (((empty is None) and (not gitworkdone)) or empty):
        raise NoHunks
