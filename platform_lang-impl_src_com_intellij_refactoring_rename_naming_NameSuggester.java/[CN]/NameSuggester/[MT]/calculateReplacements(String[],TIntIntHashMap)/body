{
  TreeMap<Pair<Integer,Integer>,String> replacements=new TreeMap<Pair<Integer,Integer>,String>(new Comparator<Pair<Integer,Integer>>(){
    public int compare(    Pair<Integer,Integer> pair,    Pair<Integer,Integer> pair1){
      return pair.getFirst().compareTo(pair1.getFirst());
    }
  }
);
  for (  final OriginalToNewChange change : myChanges) {
    final int first=change.oldFirst;
    final int last=change.oldLast;
    if (change.getOldLength() > 0) {
      if (containsAllBetween(matches,first,last)) {
        final String newString=change.getNewString();
        final int propertyWordFirst=matches.get(first);
        if (first >= myOldClassName.length || last >= myOldClassName.length) {
          LOG.assertTrue(false,"old class name = " + myOldClassNameAsGiven + ", new class name = "+ myNewClassNameAsGiven+ ", propertyWords = "+ Arrays.asList(propertyWords).toString());
        }
        final String replacement=suggestReplacement(propertyWords[propertyWordFirst],newString);
        replacements.put(Pair.create(propertyWordFirst,matches.get(last)),replacement);
      }
    }
 else {
      final String newString=change.getNewString();
      final int propertyWordToInsertBefore;
      if (matches.containsKey(first)) {
        propertyWordToInsertBefore=matches.get(first);
      }
 else {
        if (matches.contains(last)) {
          propertyWordToInsertBefore=matches.get(last) + 1;
        }
 else {
          propertyWordToInsertBefore=propertyWords.length;
        }
      }
      replacements.put(Pair.create(propertyWordToInsertBefore,propertyWordToInsertBefore - 1),newString);
    }
  }
  return replacements;
}
