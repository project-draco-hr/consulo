{
  ObjectTree.executeActionWithRecursiveGuard(this,myTree.getNodesInExecution(),new ObjectTreeAction<ObjectNode<T>>(){
    @Override public void execute(    @NotNull ObjectNode<T> each){
      action.beforeTreeExecution(myObject);
      ObjectNode<T>[] childrenArray=getChildrenArray();
      for (int i=childrenArray.length - 1; i >= 0; i--) {
        childrenArray[i].execute(disposeTree,action);
      }
      if (disposeTree) {
synchronized (myTree.treeLock) {
          myChildren=null;
        }
      }
      try {
        action.execute(myObject);
        myTree.fireExecuted(myObject);
      }
 catch (      ProcessCanceledException e) {
        throw new ProcessCanceledException(e);
      }
catch (      Throwable e) {
        LOG.error(e);
      }
      if (disposeTree) {
        myTree.putNode(myObject,null);
synchronized (myTree.treeLock) {
          if (myParent != null) {
            myParent.removeChild(ObjectNode.this);
          }
 else {
            myTree.removeRootObject(myObject);
          }
        }
      }
    }
    @Override public void beforeTreeExecution(    @NotNull ObjectNode<T> parent){
    }
  }
);
  return true;
}
