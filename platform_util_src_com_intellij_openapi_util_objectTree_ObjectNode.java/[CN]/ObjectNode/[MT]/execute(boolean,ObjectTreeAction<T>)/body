{
  ObjectTree.executeActionWithRecursiveGuard(this,myTree.getNodesInExecution(),new ObjectTreeAction<ObjectNode<T>>(){
    @Override public void execute(    @NotNull ObjectNode<T> each){
      try {
        action.beforeTreeExecution(myObject);
      }
 catch (      Throwable t) {
        LOG.error(t);
      }
      ObjectNode<T>[] childrenArray;
      int size;
synchronized (myTree.treeLock) {
        ObjectNode<T>[] children=myChildren;
        childrenArray=children == null ? EMPTY_ARRAY : children;
        size=myChildrenSize;
      }
      for (int i=size - 1; i >= 0; i--) {
        childrenArray[i].execute(disposeTree,action);
      }
      if (disposeTree) {
synchronized (myTree.treeLock) {
          myChildren=null;
          myChildrenSize=0;
        }
      }
      try {
        action.execute(myObject);
        myTree.fireExecuted(myObject);
      }
 catch (      ProcessCanceledException e) {
        throw new ProcessCanceledException(e);
      }
catch (      Throwable e) {
        LOG.error(e);
      }
      if (disposeTree) {
        remove();
      }
    }
    @Override public void beforeTreeExecution(    @NotNull ObjectNode<T> parent){
    }
  }
);
}
