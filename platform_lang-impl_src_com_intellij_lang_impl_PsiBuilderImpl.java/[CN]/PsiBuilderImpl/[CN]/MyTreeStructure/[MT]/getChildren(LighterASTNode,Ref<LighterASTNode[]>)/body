{
  if (item instanceof LazyParseableToken) {
    final FlyweightCapableTreeStructure<LighterASTNode> tree=((LazyParseableToken)item).parseContents();
    final LighterASTNode root=tree.getRoot();
    return tree.getChildren(tree.prepareForGetChildren(root),into);
  }
  if (item instanceof Token || item instanceof ErrorItem)   return 0;
  StartMarker marker=(StartMarker)item;
  count=0;
  if (marker.myCachedChildren != null) {
    count=marker.myCachedChildren.length;
    if (into.get() == null || into.get().length < count) {
      into.set(new LighterASTNode[count]);
    }
    System.arraycopy(marker.myCachedChildren,0,into.get(),0,count);
    return count;
  }
  ProductionMarker child=marker.myFirstChild;
  ProductionMarker prevChild=null;
  int lexIndex=marker.myLexemeIndex;
  boolean hasCollapsed=false;
  while (child != null) {
    lexIndex=insertLeaves(lexIndex,child.myLexemeIndex,into,marker.myBuilder);
    if (child instanceof StartMarker && ((StartMarker)child).myDoneMarker.myCollapse) {
      final int start=marker.myBuilder.myLexStarts[child.myLexemeIndex];
      final int end=marker.myBuilder.myLexStarts[((StartMarker)child).myDoneMarker.myLexemeIndex];
      insertLeaf(into,start,end,child.getTokenType(),marker.myBuilder);
      if (prevChild != null)       prevChild.myNext=child.myNext;
      if (marker.myFirstChild == child)       marker.myFirstChild=child.myNext;
      if (marker.myLastChild == child)       marker.myLastChild=prevChild;
      hasCollapsed=true;
    }
 else {
      ensureCapacity(into);
      into.get()[count++]=child;
      prevChild=child;
    }
    if (child instanceof StartMarker) {
      lexIndex=((StartMarker)child).myDoneMarker.myLexemeIndex;
    }
    child=child.myNext;
  }
  insertLeaves(lexIndex,marker.myDoneMarker.myLexemeIndex,into,marker.myBuilder);
  if (hasCollapsed) {
    marker.myCachedChildren=new LighterASTNode[count];
    System.arraycopy(into.get(),0,marker.myCachedChildren,0,count);
  }
  return count;
}
