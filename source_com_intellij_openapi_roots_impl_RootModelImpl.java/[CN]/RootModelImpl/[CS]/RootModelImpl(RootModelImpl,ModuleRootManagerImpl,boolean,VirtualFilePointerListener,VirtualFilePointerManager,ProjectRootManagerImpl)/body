{
  myFilePointerManager=filePointerManager;
  myModuleRootManager=moduleRootManager;
  myProjectRootManager=projectRootManager;
  myModuleLibraryTable=new ModuleLibraryTable(this,myProjectRootManager,myFilePointerManager);
  myWritable=writable;
  LOG.assertTrue(!writable || virtualFilePointerListener == null);
  myVirtualFilePointerListener=virtualFilePointerListener;
  myInheritedCompilerOutput=rootModel.myInheritedCompilerOutput;
  if (rootModel.myCompilerOutputPointer != null) {
    myCompilerOutputPointer=pointerFactory().duplicate(rootModel.myCompilerOutputPointer);
  }
  if (rootModel.myCompilerOutputPathForTestsPointer != null) {
    myCompilerOutputPathForTestsPointer=pointerFactory().duplicate(rootModel.myCompilerOutputPathForTestsPointer);
  }
  if (rootModel.myExplodedDirectoryPointer != null) {
    myExplodedDirectoryPointer=pointerFactory().duplicate(rootModel.myExplodedDirectoryPointer);
  }
  myExcludeOutput=rootModel.myExcludeOutput;
  myExcludeExploded=rootModel.myExcludeExploded;
  final TreeSet<ContentEntry> thatContent=rootModel.myContent;
  for (  ContentEntry contentEntry : thatContent) {
    if (contentEntry instanceof ClonableContentEntry) {
      myContent.add(((ClonableContentEntry)contentEntry).cloneEntry(this));
    }
  }
  final List<OrderEntry> order=rootModel.myOrderEntries;
  for (  OrderEntry orderEntry : order) {
    if (orderEntry instanceof ClonableOrderEntry) {
      myOrderEntries.add(((ClonableOrderEntry)orderEntry).cloneEntry(this,myProjectRootManager,myFilePointerManager));
    }
  }
  myOrderEntryProperties=rootModel.myOrderEntryProperties.copy(this);
  myJavadocPointerContainer=myFilePointerManager.createContainer(myVirtualFilePointerFactory);
  myJavadocPointerContainer.addAll(rootModel.myJavadocPointerContainer);
}
