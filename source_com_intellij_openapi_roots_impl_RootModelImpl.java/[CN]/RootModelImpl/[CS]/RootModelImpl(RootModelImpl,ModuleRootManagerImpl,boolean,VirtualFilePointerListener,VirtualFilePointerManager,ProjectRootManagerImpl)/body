{
  myFilePointerManager=filePointerManager;
  myModuleRootManager=moduleRootManager;
  myProjectRootManager=projectRootManager;
  myModuleLibraryTable=new ModuleLibraryTable(this,myProjectRootManager,myFilePointerManager);
  myWritable=writable;
  LOG.assertTrue(!writable || virtualFilePointerListener == null);
  myVirtualFilePointerListener=virtualFilePointerListener;
  if (rootModel.myCompilerOutputPath != null) {
    myCompilerOutputPath=pointerFactory().duplicate(rootModel.myCompilerOutputPath);
  }
  if (rootModel.myCompilerOutputPathForTests != null) {
    myCompilerOutputPathForTests=pointerFactory().duplicate(rootModel.myCompilerOutputPathForTests);
  }
  if (rootModel.myExplodedDirectory != null) {
    myExplodedDirectory=pointerFactory().duplicate(rootModel.myExplodedDirectory);
  }
  myExcludeOutput=rootModel.myExcludeOutput;
  myExcludeExploded=rootModel.myExcludeExploded;
  final TreeSet<ContentEntry> thatContent=rootModel.myContent;
  for (Iterator<ContentEntry> iterator=thatContent.iterator(); iterator.hasNext(); ) {
    ContentEntry contentEntry=iterator.next();
    if (contentEntry instanceof ClonableContentEntry) {
      myContent.add(((ClonableContentEntry)contentEntry).cloneEntry(this));
    }
  }
  final List<OrderEntry> order=rootModel.myOrder;
  for (int i=0; i < order.size(); i++) {
    OrderEntry orderEntry=order.get(i);
    if (orderEntry instanceof ClonableOrderEntry) {
      myOrder.add(((ClonableOrderEntry)orderEntry).cloneEntry(this,myProjectRootManager,myFilePointerManager));
    }
  }
  myOrderEntryProperties=rootModel.myOrderEntryProperties.copy(this);
  myJavadocPointerContainer=myFilePointerManager.createContainer(myVirtualFilePointerFactory);
  myJavadocPointerContainer.addAll(rootModel.myJavadocPointerContainer);
}
