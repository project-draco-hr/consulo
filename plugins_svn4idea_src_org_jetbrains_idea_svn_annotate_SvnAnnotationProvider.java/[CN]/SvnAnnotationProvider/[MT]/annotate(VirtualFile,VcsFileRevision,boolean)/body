{
  if (file.isDirectory()) {
    throw new VcsException(SvnBundle.message("exception.text.cannot.annotate.directory"));
  }
  final FileAnnotation[] annotation=new FileAnnotation[1];
  final VcsException[] exception=new VcsException[1];
  Runnable command=new Runnable(){
    public void run(){
      final ProgressIndicator progress=ProgressManager.getInstance().getProgressIndicator();
      try {
        final File ioFile=new File(file.getPath()).getAbsoluteFile();
        final String contents;
        if (loadExternally) {
          final ByteArrayOutputStream buffer=new ByteArrayOutputStream();
          myVcs.createWCClient().doGetFileContents(ioFile,SVNRevision.UNDEFINED,SVNRevision.BASE,true,buffer);
          contents=LoadTextUtil.getTextByBinaryPresentation(buffer.toByteArray(),file,false).toString();
        }
 else {
          revision.loadContent();
          contents=LoadTextUtil.getTextByBinaryPresentation(revision.getContent(),file,false).toString();
        }
        final SvnFileAnnotation result=new SvnFileAnnotation(myVcs,file,contents);
        SVNWCClient wcClient=myVcs.createWCClient();
        SVNInfo info=wcClient.doInfo(ioFile,SVNRevision.WORKING);
        if (info == null) {
          exception[0]=new VcsException(new SVNException(SVNErrorMessage.create(SVNErrorCode.UNKNOWN,"File ''{0}'' is not under version control",ioFile)));
          return;
        }
        final String url=info.getURL() == null ? null : info.getURL().toString();
        SVNLogClient client=myVcs.createLogClient();
        setLogClientOptions(client);
        SVNRevision endRevision=((SvnFileRevision)revision).getRevision();
        if (SVNRevision.WORKING.equals(endRevision)) {
          endRevision=info.getRevision();
        }
        if (progress != null) {
          progress.setText(SvnBundle.message("progress.text.computing.annotation",file.getName()));
        }
        final ISVNAnnotateHandler annotateHandler=new ISVNAnnotateHandler(){
          public void handleLine(          Date date,          long revision,          String author,          String line){
            if (progress != null) {
              progress.checkCanceled();
            }
            result.appendLineInfo(date,revision,author,null,-1,null);
          }
          public void handleLine(          final Date date,          final long revision,          final String author,          final String line,          final Date mergedDate,          final long mergedRevision,          final String mergedAuthor,          final String mergedPath,          final int lineNumber) throws SVNException {
            if (progress != null) {
              progress.checkCanceled();
            }
            if (revision == -1)             return;
            if ((mergedDate != null) && (revision > mergedRevision)) {
              result.setLineInfo(lineNumber,date,revision,author,mergedDate,mergedRevision,mergedAuthor);
            }
 else {
              result.setLineInfo(lineNumber,date,revision,author,null,-1,null);
            }
          }
          public boolean handleRevision(          final Date date,          final long revision,          final String author,          final File contents) throws SVNException {
            if (progress != null) {
              progress.checkCanceled();
            }
            return false;
          }
          public void handleEOF(){
          }
        }
;
        final boolean supportsMergeinfo=SvnUtil.checkRepositoryVersion15(myVcs,url);
        final SVNRevision svnRevision=((SvnRevisionNumber)revision.getRevisionNumber()).getRevision();
        final MySteppedLogGetter logGetter=new MySteppedLogGetter(myVcs,ioFile,progress,client,endRevision,result,url);
        logGetter.go();
        final LinkedList<SVNRevision> rp=logGetter.getRevisionPoints();
        for (int i=0; i < rp.size() - 1; i++) {
          client.doAnnotate(ioFile,svnRevision,rp.get(i + 1),rp.get(i),true,supportsMergeinfo,annotateHandler,null);
        }
        annotation[0]=result;
      }
 catch (      SVNException e) {
        exception[0]=new VcsException(e);
      }
catch (      IOException e) {
        exception[0]=new VcsException(e);
      }
catch (      VcsException e) {
        exception[0]=e;
      }
    }
  }
;
  if (ApplicationManager.getApplication().isDispatchThread()) {
    ProgressManager.getInstance().runProcessWithProgressSynchronously(command,SvnBundle.message("action.text.annotate"),false,myVcs.getProject());
  }
 else {
    command.run();
  }
  if (exception[0] != null) {
    throw new VcsException(exception[0]);
  }
  return annotation[0];
}
