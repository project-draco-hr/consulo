{
  DebuggerManagerThreadImpl.assertIsManagerThread();
  SuspendContextImpl suspendContext=evaluationContext.getSuspendContext();
  SuspendManagerUtil.assertSuspendContext(suspendContext);
  myEvaluationDispatcher.getMulticaster().evaluationStarted(suspendContext);
  beforeMethodInvocation(suspendContext,method);
  ThreadReferenceProxyImpl invokeThread=suspendContext.getThread();
  if (SuspendManagerUtil.isEvaluating(getSuspendManager(),invokeThread)) {
    throw EvaluateExceptionUtil.NESTED_EVALUATION_ERROR;
  }
  Set<SuspendContextImpl> suspendingContexts=SuspendManagerUtil.getSuspendingContexts(getSuspendManager(),invokeThread);
  final ThreadReference invokeThreadRef=invokeThread.getThreadReference();
  if (invokeThreadRef == null) {
    throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message("error.cannot.invoke.method.in.collected.thread"));
  }
  for (  final SuspendContextImpl suspendingContext : suspendingContexts) {
    final ThreadReferenceProxyImpl suspendContextThread=suspendingContext.getThread();
    if (suspendContextThread != invokeThread) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Resuming " + invokeThread + " that is paused by "+ suspendContextThread);
      }
      LOG.assertTrue(suspendContextThread == null || !invokeThreadRef.equals(suspendContextThread.getThreadReference()));
      getSuspendManager().resumeThread(suspendingContext,invokeThread);
    }
  }
  Object resumeData=SuspendManagerUtil.prepareForResume(suspendContext);
  suspendContext.setIsEvaluating(evaluationContext);
  getVirtualMachineProxy().clearCaches();
  try {
    while (true) {
      try {
        return invokeMethodAndFork(suspendContext);
      }
 catch (      ClassNotLoadedException e) {
        ReferenceType loadedClass=loadClass(evaluationContext,e.className(),evaluationContext.getClassLoader());
        if (loadedClass == null) {
          throw EvaluateExceptionUtil.createEvaluateException(e);
        }
      }
    }
  }
 catch (  ClassNotLoadedException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  InvocationException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  IncompatibleThreadStateException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  InvalidTypeException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  ObjectCollectedException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  UnsupportedOperationException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
catch (  InternalException e) {
    throw EvaluateExceptionUtil.createEvaluateException(e);
  }
 finally {
    suspendContext.setIsEvaluating(null);
    SuspendManagerUtil.restoreAfterResume(suspendContext,resumeData);
    for (    SuspendContextImpl suspendingContext : mySuspendManager.getEventContexts()) {
      if (suspendingContexts.contains(suspendingContext) && !suspendingContext.isEvaluating() && !suspendingContext.suspends(invokeThread)) {
        mySuspendManager.suspendThread(suspendingContext,invokeThread);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("getVirtualMachine().clearCaches()");
    }
    getVirtualMachineProxy().clearCaches();
    afterMethodInvocation(suspendContext);
    myEvaluationDispatcher.getMulticaster().evaluationFinished(suspendContext);
  }
}
