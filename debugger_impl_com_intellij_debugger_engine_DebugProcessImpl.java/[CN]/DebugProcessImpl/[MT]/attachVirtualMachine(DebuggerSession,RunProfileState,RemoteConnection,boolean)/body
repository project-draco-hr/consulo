{
  mySession=session;
  myWaitFor.down();
  ApplicationManager.getApplication().assertIsDispatchThread();
  LOG.assertTrue(isInInitialState());
  myConnection=remoteConnection;
  createVirtualMachine(state,pollConnection);
  try {
synchronized (myProcessListeners) {
      myExecutionResult=state.execute();
      if (myExecutionResult == null) {
        fail();
        return null;
      }
      for (      ProcessListener processListener : myProcessListeners) {
        myExecutionResult.getProcessHandler().addProcessListener(processListener);
      }
      myProcessListeners.clear();
    }
  }
 catch (  ExecutionException e) {
    fail();
    throw e;
  }
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    return myExecutionResult;
  }
  final Alarm debugPortTimeout=new Alarm(Alarm.ThreadToUse.SHARED_THREAD);
  myExecutionResult.getProcessHandler().addProcessListener(new ProcessAdapter(){
    public void processTerminated(    ProcessEvent event){
      debugPortTimeout.cancelAllRequests();
    }
    public void startNotified(    ProcessEvent event){
      debugPortTimeout.addRequest(new Runnable(){
        public void run(){
          if (isInInitialState()) {
            ApplicationManager.getApplication().invokeLater(new Runnable(){
              public void run(){
                String message=DebuggerBundle.message("status.connect.failed",DebuggerBundle.getAddressDisplayName(remoteConnection),DebuggerBundle.getTransportName(remoteConnection));
                Messages.showErrorDialog(myProject,message,DebuggerBundle.message("title.generic.debug.dialog"));
              }
            }
);
          }
        }
      }
,LOCAL_START_TIMEOUT);
    }
  }
);
  return myExecutionResult;
}
