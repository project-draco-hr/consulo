def incoming(ui, repo, source='default', **opts):
    'show new changesets found in source\n\n    Show new changesets found in the specified path/URL or the default\n    pull location. These are the changesets that would have been pulled\n    if a pull at the time you issued this command.\n\n    For remote repository, using --bundle avoids downloading the\n    changesets twice if the incoming is followed by a pull.\n\n    See pull for valid source format details.\n    '
    limit = cmdutil.loglimit(opts)
    (source, branches) = hg.parseurl(ui.expandpath(source), opts.get('branch'))
    other = hg.repository(cmdutil.remoteui(repo, opts), source)
    ui.status((_('comparing with %s\n') % url.hidepassword(source)))
    (revs, checkout) = hg.addbranchrevs(repo, other, branches, opts.get('rev'))
    if revs:
        revs = [other.lookup(rev) for rev in revs]
    (common, incoming, rheads) = repo.findcommonincoming(other, heads=revs, force=opts['force'])
    if (not incoming):
        try:
            os.unlink(opts['bundle'])
        except:
            pass
        ui.status(_('no changes found\n'))
        return 1
    cleanup = None
    try:
        fname = opts['bundle']
        if (fname or (not other.local())):
            if ((revs is None) and other.capable('changegroupsubset')):
                revs = rheads
            if (revs is None):
                cg = other.changegroup(incoming, 'incoming')
            else:
                cg = other.changegroupsubset(incoming, revs, 'incoming')
            bundletype = ((other.local() and 'HG10BZ') or 'HG10UN')
            fname = cleanup = changegroup.writebundle(cg, fname, bundletype)
            if opts['bundle']:
                cleanup = None
            if (not other.local()):
                other = bundlerepo.bundlerepository(ui, repo.root, fname)
        o = other.changelog.nodesbetween(incoming, revs)[0]
        if opts.get('newest_first'):
            o.reverse()
        displayer = cmdutil.show_changeset(ui, other, opts)
        count = 0
        for n in o:
            if ((limit is not None) and (count >= limit)):
                break
            parents = [p for p in other.changelog.parents(n) if (p != nullid)]
            if (opts.get('no_merges') and (len(parents) == 2)):
                continue
            count += 1
            displayer.show(other[n])
        displayer.close()
    finally:
        if hasattr(other, 'close'):
            other.close()
        if cleanup:
            os.unlink(cleanup)
