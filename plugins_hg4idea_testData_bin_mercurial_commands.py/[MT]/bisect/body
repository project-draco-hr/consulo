def bisect(ui, repo, rev=None, extra=None, command=None, reset=None, good=None, bad=None, skip=None, noupdate=None):
    'subdivision search of changesets\n\n    This command helps to find changesets which introduce problems. To\n    use, mark the earliest changeset you know exhibits the problem as\n    bad, then mark the latest changeset which is free from the problem\n    as good. Bisect will update your working directory to a revision\n    for testing (unless the -U/--noupdate option is specified). Once\n    you have performed tests, mark the working directory as good or\n    bad, and bisect will either update to another candidate changeset\n    or announce that it has found the bad revision.\n\n    As a shortcut, you can also use the revision argument to mark a\n    revision as good or bad without checking it out first.\n\n    If you supply a command, it will be used for automatic bisection.\n    Its exit status will be used to mark revisions as good or bad:\n    status 0 means good, 125 means to skip the revision, 127\n    (command not found) will abort the bisection, and any other\n    non-zero exit status means the revision is bad.\n    '

    def print_result(nodes, good):
        displayer = cmdutil.show_changeset(ui, repo, {})
        if (len(nodes) == 1):
            if good:
                ui.write(_('The first good revision is:\n'))
            else:
                ui.write(_('The first bad revision is:\n'))
            displayer.show(repo[nodes[0]])
        else:
            if good:
                ui.write(_('Due to skipped revisions, the first good revision could be any of:\n'))
            else:
                ui.write(_('Due to skipped revisions, the first bad revision could be any of:\n'))
            for n in nodes:
                displayer.show(repo[n])
        displayer.close()

    def check_state(state, interactive=True):
        if ((not state['good']) or (not state['bad'])):
            if ((good or bad or skip or reset) and interactive):
                return
            if (not state['good']):
                raise util.Abort(_('cannot bisect (no known good revisions)'))
            else:
                raise util.Abort(_('cannot bisect (no known bad revisions)'))
        return True
    if (rev in 'good bad reset init'.split()):
        ui.warn(_("(use of 'hg bisect <cmd>' is deprecated)\n"))
        (cmd, rev, extra) = (rev, extra, None)
        if (cmd == 'good'):
            good = True
        elif (cmd == 'bad'):
            bad = True
        else:
            reset = True
    elif (extra or (((((good + bad) + skip) + reset) + bool(command)) > 1)):
        raise util.Abort(_('incompatible arguments'))
    if reset:
        p = repo.join('bisect.state')
        if os.path.exists(p):
            os.unlink(p)
        return
    state = hbisect.load_state(repo)
    if command:
        changesets = 1
        try:
            while changesets:
                status = util.system(command)
                if (status == 125):
                    transition = 'skip'
                elif (status == 0):
                    transition = 'good'
                elif (status == 127):
                    raise util.Abort((_('failed to execute %s') % command))
                elif (status < 0):
                    raise util.Abort((_('%s killed') % command))
                else:
                    transition = 'bad'
                ctx = repo[(rev or '.')]
                state[transition].append(ctx.node())
                ui.status((_('Changeset %d:%s: %s\n') % (ctx, ctx, transition)))
                check_state(state, interactive=False)
                (nodes, changesets, good) = hbisect.bisect(repo.changelog, state)
                cmdutil.bail_if_changed(repo)
                hg.clean(repo, nodes[0], show_stats=False)
        finally:
            hbisect.save_state(repo, state)
        return print_result(nodes, good)
    node = repo.lookup((rev or '.'))
    if (good or bad or skip):
        if good:
            state['good'].append(node)
        elif bad:
            state['bad'].append(node)
        elif skip:
            state['skip'].append(node)
        hbisect.save_state(repo, state)
    if (not check_state(state)):
        return
    (nodes, changesets, good) = hbisect.bisect(repo.changelog, state)
    if (changesets == 0):
        print_result(nodes, good)
    else:
        assert (len(nodes) == 1)
        node = nodes[0]
        (tests, size) = (0, 2)
        while (size <= changesets):
            (tests, size) = ((tests + 1), (size * 2))
        rev = repo.changelog.rev(node)
        ui.write((_('Testing changeset %d:%s (%d changesets remaining, ~%d tests)\n') % (rev, short(node), changesets, tests)))
        if (not noupdate):
            cmdutil.bail_if_changed(repo)
            return hg.clean(repo, node)
