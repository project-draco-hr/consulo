def grep(ui, repo, pattern, *pats, **opts):
    'search for a pattern in specified files and revisions\n\n    Search revisions of files for a regular expression.\n\n    This command behaves differently than Unix grep. It only accepts\n    Python/Perl regexps. It searches repository history, not the\n    working directory. It always prints the revision number in which a\n    match appears.\n\n    By default, grep only prints output for the first revision of a\n    file in which it finds a match. To get it to print every revision\n    that contains a change in match status ("-" for a match that\n    becomes a non-match, or "+" for a non-match that becomes a match),\n    use the --all flag.\n    '
    reflags = 0
    if opts.get('ignore_case'):
        reflags |= re.I
    try:
        regexp = re.compile(pattern, reflags)
    except Exception as inst:
        ui.warn((_('grep: invalid match pattern: %s\n') % inst))
        return None
    (sep, eol) = (':', '\n')
    if opts.get('print0'):
        sep = eol = '\x00'
    getfile = util.lrucachefunc(repo.file)

    def matchlines(body):
        begin = 0
        linenum = 0
        while True:
            match = regexp.search(body, begin)
            if (not match):
                break
            (mstart, mend) = match.span()
            linenum += (body.count('\n', begin, mstart) + 1)
            lstart = ((body.rfind('\n', begin, mstart) + 1) or begin)
            begin = ((body.find('\n', mend) + 1) or len(body))
            lend = (begin - 1)
            yield (linenum, (mstart - lstart), (mend - lstart), body[lstart:lend])


    class linestate(object):

        def __init__(self, line, linenum, colstart, colend):
            self.line = line
            self.linenum = linenum
            self.colstart = colstart
            self.colend = colend

        def __hash__(self):
            return hash((self.linenum, self.line))

        def __eq__(self, other):
            return (self.line == other.line)
    matches = {}
    copies = {}

    def grepbody(fn, rev, body):
        matches[rev].setdefault(fn, [])
        m = matches[rev][fn]
        for (lnum, cstart, cend, line) in matchlines(body):
            s = linestate(line, lnum, cstart, cend)
            m.append(s)

    def difflinestates(a, b):
        sm = difflib.SequenceMatcher(None, a, b)
        for (tag, alo, ahi, blo, bhi) in sm.get_opcodes():
            if (tag == 'insert'):
                for i in xrange(blo, bhi):
                    yield ('+', b[i])
            elif (tag == 'delete'):
                for i in xrange(alo, ahi):
                    yield ('-', a[i])
            elif (tag == 'replace'):
                for i in xrange(alo, ahi):
                    yield ('-', a[i])
                for i in xrange(blo, bhi):
                    yield ('+', b[i])

    def display(fn, ctx, pstates, states):
        rev = ctx.rev()
        datefunc = ((ui.quiet and util.shortdate) or util.datestr)
        found = False
        filerevmatches = {}
        if opts.get('all'):
            iter = difflinestates(pstates, states)
        else:
            iter = [('', l) for l in states]
        for (change, l) in iter:
            cols = [fn, str(rev)]
            if opts.get('line_number'):
                cols.append(str(l.linenum))
            if opts.get('all'):
                cols.append(change)
            if opts.get('user'):
                cols.append(ui.shortuser(ctx.user()))
            if opts.get('date'):
                cols.append(datefunc(ctx.date()))
            if opts.get('files_with_matches'):
                c = (fn, rev)
                if (c in filerevmatches):
                    continue
                filerevmatches[c] = 1
            else:
                cols.append(l.line)
            ui.write(sep.join(cols), eol)
            found = True
        return found
    skip = {}
    revfiles = {}
    matchfn = cmdutil.match(repo, pats, opts)
    found = False
    follow = opts.get('follow')

    def prep(ctx, fns):
        rev = ctx.rev()
        pctx = ctx.parents()[0]
        parent = pctx.rev()
        matches.setdefault(rev, {})
        matches.setdefault(parent, {})
        files = revfiles.setdefault(rev, [])
        for fn in fns:
            flog = getfile(fn)
            try:
                fnode = ctx.filenode(fn)
            except error.LookupError:
                continue
            copied = flog.renamed(fnode)
            copy = (follow and copied and copied[0])
            if copy:
                copies.setdefault(rev, {})[fn] = copy
            if (fn in skip):
                if copy:
                    skip[copy] = True
                continue
            files.append(fn)
            if (fn not in matches[rev]):
                grepbody(fn, rev, flog.read(fnode))
            pfn = (copy or fn)
            if (pfn not in matches[parent]):
                try:
                    fnode = pctx.filenode(pfn)
                    grepbody(pfn, parent, flog.read(fnode))
                except error.LookupError:
                    pass
    for ctx in cmdutil.walkchangerevs(repo, matchfn, opts, prep):
        rev = ctx.rev()
        parent = ctx.parents()[0].rev()
        for fn in sorted(revfiles.get(rev, [])):
            states = matches[rev][fn]
            copy = copies.get(rev, {}).get(fn)
            if (fn in skip):
                if copy:
                    skip[copy] = True
                continue
            pstates = matches.get(parent, {}).get((copy or fn), [])
            if (pstates or states):
                r = display(fn, ctx, pstates, states)
                found = (found or r)
                if (r and (not opts.get('all'))):
                    skip[fn] = True
                    if copy:
                        skip[copy] = True
        del matches[rev]
        del revfiles[rev]
