def remove(ui, repo, *pats, **opts):
    'remove the specified files on the next commit\n\n    Schedule the indicated files for removal from the repository.\n\n    This only removes files from the current branch, not from the\n    entire project history. -A/--after can be used to remove only\n    files that have already been deleted, -f/--force can be used to\n    force deletion, and -Af can be used to remove files from the next\n    revision without deleting them from the working directory.\n\n    The following table details the behavior of remove for different\n    file states (columns) and option combinations (rows). The file\n    states are Added [A], Clean [C], Modified [M] and Missing [!] (as\n    reported by hg status). The actions are Warn, Remove (from branch)\n    and Delete (from disk)::\n\n             A  C  M  !\n      none   W  RD W  R\n      -f     R  RD RD R\n      -A     W  W  W  R\n      -Af    R  R  R  R\n\n    This command schedules the files to be removed at the next commit.\n    To undo a remove before that, see hg revert.\n    '
    (after, force) = (opts.get('after'), opts.get('force'))
    if ((not pats) and (not after)):
        raise util.Abort(_('no files specified'))
    m = cmdutil.match(repo, pats, opts)
    s = repo.status(match=m, clean=True)
    (modified, added, deleted, clean) = (s[0], s[1], s[3], s[6])
    for f in m.files():
        if ((f not in repo.dirstate) and (not os.path.isdir(m.rel(f)))):
            ui.warn((_('not removing %s: file is untracked\n') % m.rel(f)))

    def warn(files, reason):
        for f in files:
            ui.warn((_('not removing %s: file %s (use -f to force removal)\n') % (m.rel(f), reason)))
    if force:
        (remove, forget) = (((modified + deleted) + clean), added)
    elif after:
        (remove, forget) = (deleted, [])
        warn(((modified + added) + clean), _('still exists'))
    else:
        (remove, forget) = ((deleted + clean), [])
        warn(modified, _('is modified'))
        warn(added, _('has been marked for add'))
    for f in sorted((remove + forget)):
        if (ui.verbose or (not m.exact(f))):
            ui.status((_('removing %s\n') % m.rel(f)))
    repo.forget(forget)
    repo.remove(remove, unlink=(not after))
