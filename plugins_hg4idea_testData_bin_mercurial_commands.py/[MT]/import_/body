def import_(ui, repo, patch1, *patches, **opts):
    'import an ordered set of patches\n\n    Import a list of patches and commit them individually (unless\n    --no-commit is specified).\n\n    If there are outstanding changes in the working directory, import\n    will abort unless given the -f/--force flag.\n\n    You can import a patch straight from a mail message. Even patches\n    as attachments work (to use the body part, it must have type\n    text/plain or text/x-patch). From and Subject headers of email\n    message are used as default committer and commit message. All\n    text/plain body parts before first diff are added to commit\n    message.\n\n    If the imported patch was generated by hg export, user and\n    description from patch override values from message headers and\n    body. Values given on command line with -m/--message and -u/--user\n    override these.\n\n    If --exact is specified, import will set the working directory to\n    the parent of each patch before applying it, and will abort if the\n    resulting changeset has a different ID than the one recorded in\n    the patch. This may happen due to character set problems or other\n    deficiencies in the text patch format.\n\n    With -s/--similarity, hg will attempt to discover renames and\n    copies in the patch in the same way as \'addremove\'.\n\n    To read a patch from standard input, use "-" as the patch name. If\n    a URL is specified, the patch will be downloaded from it.\n    See \'hg help dates\' for a list of formats valid for -d/--date.\n    '
    patches = ((patch1,) + patches)
    date = opts.get('date')
    if date:
        opts['date'] = util.parsedate(date)
    try:
        sim = float((opts.get('similarity') or 0))
    except ValueError:
        raise util.Abort(_('similarity must be a number'))
    if ((sim < 0) or (sim > 100)):
        raise util.Abort(_('similarity must be between 0 and 100'))
    if (opts.get('exact') or (not opts.get('force'))):
        cmdutil.bail_if_changed(repo)
    d = opts['base']
    strip = opts['strip']
    wlock = lock = None

    def tryone(ui, hunk):
        (tmpname, message, user, date, branch, nodeid, p1, p2) = patch.extract(ui, hunk)
        if (not tmpname):
            return None
        commitid = _('to working directory')
        try:
            cmdline_message = cmdutil.logmessage(opts)
            if cmdline_message:
                message = cmdline_message
            elif message:
                message = message.strip()
            else:
                message = None
            ui.debug(('message:\n%s\n' % message))
            wp = repo.parents()
            if opts.get('exact'):
                if ((not nodeid) or (not p1)):
                    raise util.Abort(_('not a Mercurial patch'))
                p1 = repo.lookup(p1)
                p2 = repo.lookup((p2 or hex(nullid)))
                if (p1 != wp[0].node()):
                    hg.clean(repo, p1)
                repo.dirstate.setparents(p1, p2)
            elif p2:
                try:
                    p1 = repo.lookup(p1)
                    p2 = repo.lookup(p2)
                    if (p1 == wp[0].node()):
                        repo.dirstate.setparents(p1, p2)
                except error.RepoError:
                    pass
            if (opts.get('exact') or opts.get('import_branch')):
                repo.dirstate.setbranch((branch or 'default'))
            files = {}
            try:
                patch.patch(tmpname, ui, strip=strip, cwd=repo.root, files=files, eolmode=None)
            finally:
                files = patch.updatedir(ui, repo, files, similarity=(sim / 100.0))
            if (not opts.get('no_commit')):
                if opts.get('exact'):
                    m = None
                else:
                    m = cmdutil.matchfiles(repo, (files or []))
                n = repo.commit(message, (opts.get('user') or user), (opts.get('date') or date), match=m, editor=cmdutil.commiteditor)
                if opts.get('exact'):
                    if (hex(n) != nodeid):
                        repo.rollback()
                        raise util.Abort(_('patch is damaged or loses information'))
                repo.dirstate.write()
                if n:
                    commitid = short(n)
            return commitid
        finally:
            os.unlink(tmpname)
    try:
        wlock = repo.wlock()
        lock = repo.lock()
        lastcommit = None
        for p in patches:
            pf = os.path.join(d, p)
            if (pf == '-'):
                ui.status(_('applying patch from stdin\n'))
                pf = sys.stdin
            else:
                ui.status((_('applying %s\n') % p))
                pf = url.open(ui, pf)
            haspatch = False
            for hunk in patch.split(pf):
                commitid = tryone(ui, hunk)
                if commitid:
                    haspatch = True
                    if lastcommit:
                        ui.status((_('applied %s\n') % lastcommit))
                    lastcommit = commitid
            if (not haspatch):
                raise util.Abort(_('no diffs found'))
    finally:
        release(lock, wlock)
