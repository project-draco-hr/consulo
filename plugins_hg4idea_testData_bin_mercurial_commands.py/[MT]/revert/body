def revert(ui, repo, *pats, **opts):
    'restore individual files or directories to an earlier state\n\n    (Use update -r to check out earlier revisions, revert does not\n    change the working directory parents.)\n\n    With no revision specified, revert the named files or directories\n    to the contents they had in the parent of the working directory.\n    This restores the contents of the affected files to an unmodified\n    state and unschedules adds, removes, copies, and renames. If the\n    working directory has two parents, you must explicitly specify a\n    revision.\n\n    Using the -r/--rev option, revert the given files or directories\n    to their contents as of a specific revision. This can be helpful\n    to "roll back" some or all of an earlier change. See \'hg help\n    dates\' for a list of formats valid for -d/--date.\n\n    Revert modifies the working directory. It does not commit any\n    changes, or change the parent of the working directory. If you\n    revert to a revision other than the parent of the working\n    directory, the reverted files will thus appear modified\n    afterwards.\n\n    If a file has been deleted, it is restored. If the executable mode\n    of a file was changed, it is reset.\n\n    If names are given, all files matching the names are reverted.\n    If no arguments are given, no files are reverted.\n\n    Modified files are saved with a .orig suffix before reverting.\n    To disable these backups, use --no-backup.\n    '
    if opts['date']:
        if opts['rev']:
            raise util.Abort(_("you can't specify a revision and a date"))
        opts['rev'] = cmdutil.finddate(ui, repo, opts['date'])
    if ((not pats) and (not opts.get('all'))):
        raise util.Abort(_('no files or directories specified; use --all to revert the whole repo'))
    (parent, p2) = repo.dirstate.parents()
    if ((not opts.get('rev')) and (p2 != nullid)):
        raise util.Abort(_('uncommitted merge - please provide a specific revision'))
    ctx = repo[opts.get('rev')]
    node = ctx.node()
    mf = ctx.manifest()
    if (node == parent):
        pmf = mf
    else:
        pmf = None
    names = {}
    wlock = repo.wlock()
    try:
        m = cmdutil.match(repo, pats, opts)
        m.bad = (lambda x, y: False)
        for abs in repo.walk(m):
            names[abs] = (m.rel(abs), m.exact(abs))

        def badfn(path, msg):
            if (path in names):
                return
            path_ = (path + '/')
            for f in names:
                if f.startswith(path_):
                    return
            ui.warn(('%s: %s\n' % (m.rel(path), msg)))
        m = cmdutil.match(repo, pats, opts)
        m.bad = badfn
        for abs in repo[node].walk(m):
            if (abs not in names):
                names[abs] = (m.rel(abs), m.exact(abs))
        m = cmdutil.matchfiles(repo, names)
        changes = repo.status(match=m)[:4]
        (modified, added, removed, deleted) = map(set, changes)
        cwd = repo.getcwd()
        for f in added:
            src = repo.dirstate.copied(f)
            if (src and (src not in names) and (repo.dirstate[src] == 'r')):
                removed.add(src)
                names[src] = (repo.pathto(src, cwd), True)

        def removeforget(abs):
            if (repo.dirstate[abs] == 'a'):
                return _('forgetting %s\n')
            return _('removing %s\n')
        revert = ([], _('reverting %s\n'))
        add = ([], _('adding %s\n'))
        remove = ([], removeforget)
        undelete = ([], _('undeleting %s\n'))
        disptable = ((modified, revert, remove, True, True), (added, revert, remove, True, False), (removed, undelete, None, False, False), (deleted, revert, remove, False, False))
        for (abs, (rel, exact)) in sorted(names.items()):
            mfentry = mf.get(abs)
            target = repo.wjoin(abs)

            def handle(xlist, dobackup):
                xlist[0].append(abs)
                if (dobackup and (not opts.get('no_backup')) and util.lexists(target)):
                    bakname = ('%s.orig' % rel)
                    ui.note((_('saving current version of %s as %s\n') % (rel, bakname)))
                    if (not opts.get('dry_run')):
                        util.copyfile(target, bakname)
                if (ui.verbose or (not exact)):
                    msg = xlist[1]
                    if (not isinstance(msg, basestring)):
                        msg = msg(abs)
                    ui.status((msg % rel))
            for (table, hitlist, misslist, backuphit, backupmiss) in disptable:
                if (abs not in table):
                    continue
                if mfentry:
                    handle(hitlist, backuphit)
                elif (misslist is not None):
                    handle(misslist, backupmiss)
                break
            else:
                if (abs not in repo.dirstate):
                    if mfentry:
                        handle(add, True)
                    elif exact:
                        ui.warn((_('file not managed: %s\n') % rel))
                    continue
                if (node == parent):
                    if exact:
                        ui.warn((_('no changes needed to %s\n') % rel))
                    continue
                if (pmf is None):
                    pmf = repo[parent].manifest()
                if (abs in pmf):
                    if mfentry:
                        if ((pmf[abs] != mfentry) or (pmf.flags(abs) != mf.flags(abs))):
                            handle(revert, False)
                    else:
                        handle(remove, False)
        if (not opts.get('dry_run')):

            def checkout(f):
                fc = ctx[f]
                repo.wwrite(f, fc.data(), fc.flags())
            audit_path = util.path_auditor(repo.root)
            for f in remove[0]:
                if (repo.dirstate[f] == 'a'):
                    repo.dirstate.forget(f)
                    continue
                audit_path(f)
                try:
                    util.unlink(repo.wjoin(f))
                except OSError:
                    pass
                repo.dirstate.remove(f)
            normal = None
            if (node == parent):
                if (p2 != nullid):
                    normal = repo.dirstate.normallookup
                else:
                    normal = repo.dirstate.normal
            for f in revert[0]:
                checkout(f)
                if normal:
                    normal(f)
            for f in add[0]:
                checkout(f)
                repo.dirstate.add(f)
            normal = repo.dirstate.normallookup
            if ((node == parent) and (p2 == nullid)):
                normal = repo.dirstate.normal
            for f in undelete[0]:
                checkout(f)
                normal(f)
    finally:
        wlock.release()
