def help_(ui, name=None, with_version=False, unknowncmd=False):
    'show help for a given topic or a help overview\n\n    With no arguments, print a list of commands with short help messages.\n\n    Given a topic, extension, or command name, print help for that\n    topic.'
    option_lists = []
    textwidth = (util.termwidth() - 2)

    def addglobalopts(aliases):
        if ui.verbose:
            option_lists.append((_('global options:'), globalopts))
            if (name == 'shortlist'):
                option_lists.append((_('use "hg help" for the full list of commands'), ()))
        else:
            if (name == 'shortlist'):
                msg = _('use "hg help" for the full list of commands or "hg -v" for details')
            elif aliases:
                msg = (_('use "hg -v help%s" to show aliases and global options') % ((name and (' ' + name)) or ''))
            else:
                msg = (_('use "hg -v help %s" to show global options') % name)
            option_lists.append((msg, ()))

    def helpcmd(name):
        if with_version:
            version_(ui)
            ui.write('\n')
        try:
            (aliases, entry) = cmdutil.findcmd(name, table, strict=unknowncmd)
        except error.AmbiguousCommand as inst:
            prefix = inst.args[0]
            select = (lambda c: c.lstrip('^').startswith(prefix))
            helplist(_('list of commands:\n\n'), select)
            return
        if getattr(entry[0], 'badalias', False):
            if (not unknowncmd):
                entry[0](ui)
            return
        if (len(entry) > 2):
            if entry[2].startswith('hg'):
                ui.write(('%s\n' % entry[2]))
            else:
                ui.write(('hg %s %s\n' % (aliases[0], entry[2])))
        else:
            ui.write(('hg %s\n' % aliases[0]))
        if ((not ui.quiet) and (len(aliases) > 1)):
            ui.write((_('\naliases: %s\n') % ', '.join(aliases[1:])))
        doc = gettext(entry[0].__doc__)
        if (not doc):
            doc = _('(no help text available)')
        if hasattr(entry[0], 'definition'):
            doc = (_('alias for: hg %s\n\n%s') % (entry[0].definition, doc))
        if ui.quiet:
            doc = doc.splitlines()[0]
        keep = ((ui.verbose and ['verbose']) or [])
        (formatted, pruned) = minirst.format(doc, textwidth, keep=keep)
        ui.write(('\n%s\n' % formatted))
        if pruned:
            ui.write((_('\nuse "hg -v help %s" to show verbose help\n') % name))
        if (not ui.quiet):
            if entry[1]:
                option_lists.append((_('options:\n'), entry[1]))
            addglobalopts(False)

    def helplist(header, select=None):
        h = {}
        cmds = {}
        for (c, e) in table.iteritems():
            f = c.split('|', 1)[0]
            if (select and (not select(f))):
                continue
            if ((not select) and (name != 'shortlist') and (e[0].__module__ != __name__)):
                continue
            if ((name == 'shortlist') and (not f.startswith('^'))):
                continue
            f = f.lstrip('^')
            if ((not ui.debugflag) and f.startswith('debug')):
                continue
            doc = e[0].__doc__
            if (doc and ('DEPRECATED' in doc) and (not ui.verbose)):
                continue
            doc = gettext(doc)
            if (not doc):
                doc = _('(no help text available)')
            h[f] = doc.splitlines()[0].rstrip()
            cmds[f] = c.lstrip('^')
        if (not h):
            ui.status(_('no commands defined\n'))
            return
        ui.status(header)
        fns = sorted(h)
        m = max(map(len, fns))
        for f in fns:
            if ui.verbose:
                commands = cmds[f].replace('|', ', ')
                ui.write((' %s:\n      %s\n' % (commands, h[f])))
            else:
                ui.write((' %-*s   %s\n' % (m, f, util.wrap(h[f], (m + 4)))))
        if (not ui.quiet):
            addglobalopts(True)

    def helptopic(name):
        for (names, header, doc) in help.helptable:
            if (name in names):
                break
        else:
            raise error.UnknownCommand(name)
        if (not doc):
            doc = _('(no help text available)')
        if hasattr(doc, '__call__'):
            doc = doc()
        ui.write(('%s\n\n' % header))
        ui.write(('%s\n' % minirst.format(doc, textwidth, indent=4)))

    def helpext(name):
        try:
            mod = extensions.find(name)
            doc = (gettext(mod.__doc__) or _('no help text available'))
        except KeyError:
            mod = None
            doc = extensions.disabledext(name)
            if (not doc):
                raise error.UnknownCommand(name)
        if ('\n' not in doc):
            (head, tail) = (doc, '')
        else:
            (head, tail) = doc.split('\n', 1)
        ui.write((_('%s extension - %s\n\n') % (name.split('.')[(-1)], head)))
        if tail:
            ui.write(minirst.format(tail, textwidth))
            ui.status('\n\n')
        if mod:
            try:
                ct = mod.cmdtable
            except AttributeError:
                ct = {}
            modcmds = set([c.split('|', 1)[0] for c in ct])
            helplist(_('list of commands:\n\n'), modcmds.__contains__)
        else:
            ui.write(_('use "hg help extensions" for information on enabling extensions\n'))

    def helpextcmd(name):
        (cmd, ext, mod) = extensions.disabledcmd(name, ui.config('ui', 'strict'))
        doc = gettext(mod.__doc__).splitlines()[0]
        msg = help.listexts((_("'%s' is provided by the following extension:") % cmd), {ext: doc, }, len(ext), indent=4)
        ui.write(minirst.format(msg, textwidth))
        ui.write('\n\n')
        ui.write(_('use "hg help extensions" for information on enabling extensions\n'))
    if (name and (name != 'shortlist')):
        i = None
        if unknowncmd:
            queries = (helpextcmd,)
        else:
            queries = (helptopic, helpcmd, helpext, helpextcmd)
        for f in queries:
            try:
                f(name)
                i = None
                break
            except error.UnknownCommand as inst:
                i = inst
        if i:
            raise i
    else:
        if (ui.verbose or with_version):
            version_(ui)
        else:
            ui.status(_('Mercurial Distributed SCM\n'))
        ui.status('\n')
        if (name == 'shortlist'):
            header = _('basic commands:\n\n')
        else:
            header = _('list of commands:\n\n')
        helplist(header)
        if (name != 'shortlist'):
            (exts, maxlength) = extensions.enabled()
            text = help.listexts(_('enabled extensions:'), exts, maxlength)
            if text:
                ui.write(('\n%s\n' % minirst.format(text, textwidth)))
    opt_output = []
    for (title, options) in option_lists:
        opt_output.append((('\n%s' % title), None))
        for (shortopt, longopt, default, desc) in options:
            if ((_('DEPRECATED') in desc) and (not ui.verbose)):
                continue
            opt_output.append((('%2s%s' % ((shortopt and ('-%s' % shortopt)), (longopt and (' --%s' % longopt)))), ('%s%s' % (desc, ((default and (_(' (default: %s)') % default)) or '')))))
    if (not name):
        ui.write(_('\nadditional help topics:\n\n'))
        topics = []
        for (names, header, doc) in help.helptable:
            topics.append((sorted(names, key=len, reverse=True)[0], header))
        topics_len = max([len(s[0]) for s in topics])
        for (t, desc) in topics:
            ui.write((' %-*s  %s\n' % (topics_len, t, desc)))
    if opt_output:
        opts_len = max(([len(line[0]) for line in opt_output if line[1]] or [0]))
        for (first, second) in opt_output:
            if second:
                second = util.wrap(second, (opts_len + 3))
                ui.write((' %-*s  %s\n' % (opts_len, first, second)))
            else:
                ui.write(('%s\n' % first))
