def summary(ui, repo, **opts):
    'summarize working directory state\n\n    This generates a brief summary of the working directory state,\n    including parents, branch, commit status, and available updates.\n\n    With the --remote option, this will check the default paths for\n    incoming and outgoing changes. This can be time-consuming.\n    '
    ctx = repo[None]
    parents = ctx.parents()
    pnode = parents[0].node()
    tags = repo.tags()
    for p in parents:
        t = ' '.join([t for t in tags if (tags[t] == p.node())])
        if (p.rev() == (-1)):
            if (not len(repo)):
                t += _(' (empty repository)')
            else:
                t += _(' (no revision checked out)')
        ui.write((_('parent: %d:%s %s\n') % (p.rev(), str(p), t)))
        if p.description():
            ui.status(((' ' + p.description().splitlines()[0].strip()) + '\n'))
    branch = ctx.branch()
    bheads = repo.branchheads(branch)
    m = (_('branch: %s\n') % branch)
    if (branch != 'default'):
        ui.write(m)
    else:
        ui.status(m)
    st = list(repo.status(unknown=True))[:6]
    ms = merge_.mergestate(repo)
    st.append([f for f in ms if (ms[f] == 'u')])
    labels = [_('%d modified'), _('%d added'), _('%d removed'), _('%d deleted'), _('%d unknown'), _('%d ignored'), _('%d unresolved')]
    t = []
    for (s, l) in zip(st, labels):
        if s:
            t.append((l % len(s)))
    t = ', '.join(t)
    cleanworkdir = False
    if (len(parents) > 1):
        t += _(' (merge)')
    elif (branch != parents[0].branch()):
        t += _(' (new branch)')
    elif ((not st[0]) and (not st[1]) and (not st[2])):
        t += _(' (clean)')
        cleanworkdir = True
    elif (pnode not in bheads):
        t += _(' (new branch head)')
    if cleanworkdir:
        ui.status((_('commit: %s\n') % t.strip()))
    else:
        ui.write((_('commit: %s\n') % t.strip()))
    new = ([0] * len(repo))
    cl = repo.changelog
    for a in [cl.rev(n) for n in bheads]:
        new[a] = 1
    for a in cl.ancestors(*[cl.rev(n) for n in bheads]):
        new[a] = 1
    for a in [p.rev() for p in parents]:
        if (a >= 0):
            new[a] = 0
    for a in cl.ancestors(*[p.rev() for p in parents]):
        new[a] = 0
    new = sum(new)
    if (new == 0):
        ui.status(_('update: (current)\n'))
    elif (pnode not in bheads):
        ui.write((_('update: %d new changesets (update)\n') % new))
    else:
        ui.write((_('update: %d new changesets, %d branch heads (merge)\n') % (new, len(bheads))))
    if opts.get('remote'):
        t = []
        (source, branches) = hg.parseurl(ui.expandpath('default'))
        other = hg.repository(cmdutil.remoteui(repo, {}), source)
        (revs, checkout) = hg.addbranchrevs(repo, other, branches, opts.get('rev'))
        ui.debug(('comparing with %s\n' % url.hidepassword(source)))
        repo.ui.pushbuffer()
        (common, incoming, rheads) = repo.findcommonincoming(other)
        repo.ui.popbuffer()
        if incoming:
            t.append(_('1 or more incoming'))
        (dest, branches) = hg.parseurl(ui.expandpath('default-push', 'default'))
        (revs, checkout) = hg.addbranchrevs(repo, repo, branches, None)
        other = hg.repository(cmdutil.remoteui(repo, {}), dest)
        ui.debug(('comparing with %s\n' % url.hidepassword(dest)))
        repo.ui.pushbuffer()
        o = repo.findoutgoing(other)
        repo.ui.popbuffer()
        o = repo.changelog.nodesbetween(o, None)[0]
        if o:
            t.append((_('%d outgoing') % len(o)))
        if t:
            ui.write((_('remote: %s\n') % ', '.join(t)))
        else:
            ui.status(_('remote: (synced)\n'))
