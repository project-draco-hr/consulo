def resolve(ui, repo, *pats, **opts):
    'various operations to help finish a merge\n\n    This command includes several actions that are often useful while\n    performing a merge, after running ``merge`` but before running\n    ``commit``.  (It is only meaningful if your working directory has\n    two parents.)  It is most relevant for merges with unresolved\n    conflicts, which are typically a result of non-interactive merging with\n    ``internal:merge`` or a command-line merge tool like ``diff3``.\n\n    The available actions are:\n\n      1) list files that were merged with conflicts (U, for unresolved)\n         and without conflicts (R, for resolved): ``hg resolve -l``\n         (this is like ``status`` for merges)\n      2) record that you have resolved conflicts in certain files:\n         ``hg resolve -m [file ...]`` (default: mark all unresolved files)\n      3) forget that you have resolved conflicts in certain files:\n         ``hg resolve -u [file ...]`` (default: unmark all resolved files)\n      4) discard your current attempt(s) at resolving conflicts and\n         restart the merge from scratch: ``hg resolve file...``\n         (or ``-a`` for all unresolved files)\n\n    Note that Mercurial will not let you commit files with unresolved merge\n    conflicts.  You must use ``hg resolve -m ...`` before you can commit\n    after a conflicting merge.\n    '
    (all, mark, unmark, show, nostatus) = [opts.get(o) for o in 'all mark unmark list no_status'.split()]
    if ((show and (mark or unmark)) or (mark and unmark)):
        raise util.Abort(_('too many options specified'))
    if (pats and all):
        raise util.Abort(_("can't specify --all and patterns"))
    if (not (all or pats or show or mark or unmark)):
        raise util.Abort(_('no files or directories specified; use --all to remerge all files'))
    ms = merge_.mergestate(repo)
    m = cmdutil.match(repo, pats, opts)
    for f in ms:
        if m(f):
            if show:
                if nostatus:
                    ui.write(('%s\n' % f))
                else:
                    ui.write(('%s %s\n' % (ms[f].upper(), f)))
            elif mark:
                ms.mark(f, 'r')
            elif unmark:
                ms.mark(f, 'u')
            else:
                wctx = repo[None]
                mctx = wctx.parents()[(-1)]
                a = repo.wjoin(f)
                util.copyfile(a, (a + '.resolve'))
                ms.resolve(f, wctx, mctx)
                util.rename((a + '.resolve'), (a + '.orig'))
