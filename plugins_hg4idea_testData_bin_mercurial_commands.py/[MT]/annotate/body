def annotate(ui, repo, *pats, **opts):
    'show changeset information by line for each file\n\n    List changes in files, showing the revision id responsible for\n    each line\n\n    This command is useful for discovering when a change was made and\n    by whom.\n\n    Without the -a/--text option, annotate will avoid processing files\n    it detects as binary. With -a, annotate will annotate the file\n    anyway, although the results will probably be neither useful\n    nor desirable.\n    '
    if opts.get('follow'):
        opts['file'] = 1
    datefunc = ((ui.quiet and util.shortdate) or util.datestr)
    getdate = util.cachefunc((lambda x: datefunc(x[0].date())))
    if (not pats):
        raise util.Abort(_('at least one filename or pattern is required'))
    opmap = [('user', (lambda x: ui.shortuser(x[0].user()))), ('number', (lambda x: str(x[0].rev()))), ('changeset', (lambda x: short(x[0].node()))), ('date', getdate), ('file', (lambda x: x[0].path()))]
    if ((not opts.get('user')) and (not opts.get('changeset')) and (not opts.get('date')) and (not opts.get('file'))):
        opts['number'] = 1
    linenumber = (opts.get('line_number') is not None)
    if (linenumber and (not opts.get('changeset')) and (not opts.get('number'))):
        raise util.Abort(_('at least one of -n/-c is required for -l'))
    funcmap = [func for (op, func) in opmap if opts.get(op)]
    if linenumber:
        lastfunc = funcmap[(-1)]
        funcmap[(-1)] = (lambda x: ('%s:%s' % (lastfunc(x), x[1])))
    ctx = repo[opts.get('rev')]
    m = cmdutil.match(repo, pats, opts)
    follow = (not opts.get('no_follow'))
    for abs in ctx.walk(m):
        fctx = ctx[abs]
        if ((not opts.get('text')) and util.binary(fctx.data())):
            ui.write((_('%s: binary file\n') % ((pats and m.rel(abs)) or abs)))
            continue
        lines = fctx.annotate(follow=follow, linenumber=linenumber)
        pieces = []
        for f in funcmap:
            l = [f(n) for (n, dummy) in lines]
            if l:
                ml = max(map(len, l))
                pieces.append([('%*s' % (ml, x)) for x in l])
        if pieces:
            for (p, l) in zip(zip(*pieces), lines):
                ui.write(('%s: %s' % (' '.join(p), l[1])))
