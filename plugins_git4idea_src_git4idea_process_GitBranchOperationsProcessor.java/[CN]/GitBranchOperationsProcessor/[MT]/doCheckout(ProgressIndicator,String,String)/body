{
  final GitMessageWithFilesDetector checkoutListener=new GitMessageWithFilesDetector(GitMessageWithFilesDetector.Event.LOCAL_CHANGES_OVERWRITTEN_BY_CHECKOUT,myRepository.getRoot());
  GitSimpleEventDetector unmergedDetector=new GitSimpleEventDetector(GitSimpleEventDetector.Event.UNMERGED);
  GitMessageWithFilesDetector untrackedOverwrittenByCheckout=new GitMessageWithFilesDetector(GitMessageWithFilesDetector.Event.UNTRACKED_FILES_OVERWRITTEN_BY,myRepository.getRoot());
  GitCommandResult result=Git.checkout(myRepository,reference,newBranch,checkoutListener,unmergedDetector,untrackedOverwrittenByCheckout);
  if (result.success()) {
    refreshRoot();
    updateRepository();
    if (newBranch == null) {
      notifySuccess(String.format("Checked out <b><code>%s</code></b>",reference));
    }
 else {
      notifySuccess(String.format("Checked out new branch <b><code>%s</code></b> from <b><code>%s</code></b>",newBranch,reference));
    }
  }
 else   if (unmergedDetector.hasHappened()) {
    GitConflictResolver gitConflictResolver=prepareConflictResolverForUnmergedFilesBeforeCheckout();
    if (gitConflictResolver.merge()) {
      doCheckout(indicator,reference,newBranch);
    }
  }
 else   if (checkoutListener.wasMessageDetected()) {
    List<Change> affectedChanges=getChangesAffectedByCheckout(checkoutListener.getRelativeFilePaths());
    if (GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject,affectedChanges)) {
      smartCheckout(reference,newBranch,indicator);
    }
  }
 else   if (untrackedOverwrittenByCheckout.wasMessageDetected()) {
    LOG.info("doCheckout: untracked files would be overwritten by checkout");
    UntrackedFilesNotifier.notifyUntrackedFilesOverwrittenBy(myProject,untrackedOverwrittenByCheckout.getFiles(),"checkout");
  }
 else {
    showErrorMessage("Couldn't checkout " + reference,result.getErrorOutput());
  }
}
