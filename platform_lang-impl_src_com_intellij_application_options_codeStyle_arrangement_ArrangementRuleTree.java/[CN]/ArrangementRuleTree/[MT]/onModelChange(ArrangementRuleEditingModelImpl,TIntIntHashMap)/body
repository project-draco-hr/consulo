{
  myModels.forEachValue(myModelNodesRefresher);
  final TIntObjectHashMap<ArrangementRuleEditingModelImpl> changedModelMappings=new TIntObjectHashMap<ArrangementRuleEditingModelImpl>();
  final TIntObjectHashMap<ArrangementNodeComponent> changedRendererMappings=new TIntObjectHashMap<ArrangementNodeComponent>();
  rowChanges.forEachEntry(new TIntIntProcedure(){
    @Override public boolean execute(    int oldRow,    int newRow){
      ArrangementRuleEditingModelImpl m=myModels.remove(oldRow);
      if (m != null) {
        changedModelMappings.put(newRow,m);
      }
      ArrangementNodeComponent renderer=myRenderers.remove(oldRow);
      if (renderer != null) {
        changedRendererMappings.put(newRow,renderer);
      }
      return true;
    }
  }
);
  putAll(changedModelMappings,myModels);
  putAll(changedRendererMappings,myRenderers);
  ArrangementTreeNode topMost=model.getTopMost();
  ArrangementTreeNode bottomMost=model.getBottomMost();
  expandAll(myTree,new TreePath(myTreeModel.getRoot()));
  doClearSelection();
  myExplicitSelectionChange=true;
  try {
    for (ArrangementTreeNode node=bottomMost; node != null; node=node.getParent()) {
      TreePath path=new TreePath(node.getPath());
      int row=myTree.getRowForPath(path);
      myRenderers.remove(row);
      myTreeModel.nodeChanged(node);
      mySelectionModel.addSelectionPath(path);
      ArrangementMatchCondition matchCondition=node.getBackingSetting();
      if (matchCondition != null) {
        getNodeComponentAt(row,matchCondition).setSelected(true);
      }
      if (node == topMost) {
        break;
      }
    }
  }
  finally {
    myExplicitSelectionChange=false;
  }
}
