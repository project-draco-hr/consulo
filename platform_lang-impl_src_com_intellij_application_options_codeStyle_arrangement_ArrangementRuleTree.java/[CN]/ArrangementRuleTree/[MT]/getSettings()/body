{
  int[] rows=myModels.keys();
  Arrays.sort(rows);
  List<StdArrangementMatchRule> rules=new ArrayList<StdArrangementMatchRule>();
  ArrangementMatchCondition prevGroup=null;
  Set<ArrangementMatchCondition> implicitGroupConditions=new HashSet<ArrangementMatchCondition>();
  for (  int row : rows) {
    ArrangementRuleEditingModelImpl model=myModels.get(row);
    ArrangementTreeNode topMost=model.getTopMost();
    ArrangementMatchCondition currentGroup=topMost.getBackingCondition();
    if (prevGroup != null && !prevGroup.equals(currentGroup)) {
      rules.add(new StdArrangementMatchRule(new StdArrangementEntryMatcher(prevGroup)));
      implicitGroupConditions.add(prevGroup);
      prevGroup=null;
    }
    if (!myMatchRulesRoot.equals(topMost) && !topMost.equals(model.getBottomMost()) && !implicitGroupConditions.contains(currentGroup)) {
      prevGroup=currentGroup;
    }
    rules.add(model.getRule());
  }
  if (prevGroup != null) {
    rules.add(new StdArrangementMatchRule(new StdArrangementEntryMatcher(prevGroup)));
  }
  if (myGroupingsRoot == null) {
    return new StdArrangementSettings(rules);
  }
 else {
    return new StdArrangementSettings(myGroupingRulesManager.buildRules(myGroupingsRoot),rules);
  }
}
