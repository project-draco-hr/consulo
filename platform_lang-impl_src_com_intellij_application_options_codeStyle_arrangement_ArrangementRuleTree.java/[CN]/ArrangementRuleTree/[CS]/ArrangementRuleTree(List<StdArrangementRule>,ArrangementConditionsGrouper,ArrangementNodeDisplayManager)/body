{
  myGrouper=grouper;
  myFactory=new ArrangementNodeComponentFactory(displayManager,new Consumer<ArrangementAtomMatchCondition>(){
    @Override public void consume(    @NotNull ArrangementAtomMatchCondition setting){
      removeConditionFromActiveModel(setting);
    }
  }
);
  myRoot=new ArrangementTreeNode(null);
  myTreeModel=new DefaultTreeModel(myRoot);
  myTree=new Tree(myTreeModel){
    @Override protected void setExpandedState(    TreePath path,    boolean state){
      if (state) {
        super.setExpandedState(path,state);
      }
    }
    @NotNull @Override protected Condition<Integer> getWideSelectionBackgroundCondition(){
      return new Condition<Integer>(){
        @Override public boolean value(        Integer row){
          TreePath path=getPathForRow(row);
          if (path == null) {
            return false;
          }
          return isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition());
        }
      }
;
    }
    @Override protected void processMouseEvent(    MouseEvent e){
      if (e.getClickCount() > 0 && getNodeComponentAt(e.getX(),e.getY()) == null) {
        TreePath path=myTree.getPathForLocation(e.getX(),e.getY());
        if (path == null || !isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition())) {
          mySkipSelectionChange=true;
        }
      }
      try {
        super.processMouseEvent(e);
        if (mySkipSelectionChange && getActiveModel() == null) {
          notifySelectionListeners(null);
        }
      }
  finally {
        mySkipSelectionChange=false;
      }
    }
  }
;
  myTree.setSelectionModel(mySelectionModel);
  myTree.setRootVisible(false);
  mySelectionModel.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      if (myExplicitSelectionChange) {
        return;
      }
      TreePath[] paths=e.getPaths();
      if (paths == null) {
        return;
      }
      for (int i=0; i < paths.length; i++) {
        onSelectionChange(paths[i],e.isAddedPath(i));
      }
    }
  }
);
  myTree.addMouseMotionListener(new MouseAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      onMouseMoved(e);
    }
  }
);
  myTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      onMouseClicked(e);
    }
  }
);
  myTree.getActionMap().put("selectNext",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectNextRule();
    }
  }
);
  myTree.getActionMap().put("selectPrevious",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectPreviousRule();
    }
  }
);
  setRules(rules);
  myTree.setShowsRootHandles(false);
  myTree.setCellRenderer(new MyCellRenderer());
}
