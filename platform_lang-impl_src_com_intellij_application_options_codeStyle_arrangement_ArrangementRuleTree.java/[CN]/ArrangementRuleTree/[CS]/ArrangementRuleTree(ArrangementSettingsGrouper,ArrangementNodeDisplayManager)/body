{
  myGrouper=grouper;
  myFactory=new ArrangementNodeComponentFactory(displayManager,new Consumer<ArrangementAtomMatchCondition>(){
    @Override public void consume(    @NotNull ArrangementAtomMatchCondition setting){
      removeConditionFromActiveModel(setting);
    }
  }
);
  myRoot=new ArrangementTreeNode(null);
  myTreeModel=new DefaultTreeModel(myRoot);
  myTree=new Tree(myTreeModel){
    @Override protected void setExpandedState(    TreePath path,    boolean state){
      if (state) {
        super.setExpandedState(path,state);
      }
    }
    @NotNull @Override protected Condition<Integer> getWideSelectionBackgroundCondition(){
      return new Condition<Integer>(){
        @Override public boolean value(        Integer row){
          TreePath path=getPathForRow(row);
          if (path == null) {
            return false;
          }
          return isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition());
        }
      }
;
    }
    @Override protected void processMouseEvent(    MouseEvent e){
      if (e.getClickCount() > 0 && getNodeComponentAt(e.getLocationOnScreen()) == null) {
        TreePath path=myTree.getPathForLocation(e.getX(),e.getY());
        if (path == null) {
          mySkipSelectionChange=true;
        }
        if (path == null || !isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition())) {
          mySkipSelectionChange=true;
        }
      }
      try {
        super.processMouseEvent(e);
        if (mySkipSelectionChange) {
          notifySelectionListeners(null);
        }
      }
  finally {
        mySkipSelectionChange=false;
      }
    }
  }
;
  myTree.setSelectionModel(mySelectionModel);
  myTree.setRootVisible(false);
  mySelectionModel.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      if (myExplicitSelectionChange) {
        return;
      }
      TreePath[] paths=e.getPaths();
      if (paths == null) {
        return;
      }
      for (int i=0; i < paths.length; i++) {
        onSelectionChange(paths[i],e.isAddedPath(i));
      }
    }
  }
);
  myTree.addMouseMotionListener(new MouseAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      onMouseMoved(e);
    }
  }
);
  myTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      onMouseClicked(e);
    }
  }
);
  myTree.getActionMap().put("selectNext",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectNextRule();
    }
  }
);
  myTree.getActionMap().put("selectPrevious",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectPreviousRule();
    }
  }
);
  List<ArrangementMatchCondition> rules=new ArrayList<ArrangementMatchCondition>();
  rules.add(new ArrangementCompositeMatchCondition(ArrangementCompositeMatchCondition.Operator.AND).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.TYPE,ArrangementEntryType.FIELD)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.PUBLIC)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.STATIC)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.FINAL)));
  rules.add(new ArrangementCompositeMatchCondition(ArrangementCompositeMatchCondition.Operator.AND).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.TYPE,ArrangementEntryType.FIELD)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.PRIVATE)));
  rules.add(new ArrangementCompositeMatchCondition(ArrangementCompositeMatchCondition.Operator.AND).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.TYPE,ArrangementEntryType.METHOD)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.PUBLIC)));
  rules.add(new ArrangementCompositeMatchCondition(ArrangementCompositeMatchCondition.Operator.AND).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.TYPE,ArrangementEntryType.METHOD)).addOperand(new ArrangementAtomMatchCondition(ArrangementSettingType.MODIFIER,ArrangementModifier.PRIVATE)));
  map(rules);
  expandAll(myTree,new TreePath(myRoot));
  myTree.setShowsRootHandles(false);
  myTree.setCellRenderer(new MyCellRenderer());
  if (ArrangementConstants.LOG_RULE_MODIFICATION) {
    LOG.info("Arrangement tree is constructed. Models:");
    myModels.forEachValue(new TObjectProcedure<ArrangementRuleEditingModelImpl>(){
      @Override public boolean execute(      ArrangementRuleEditingModelImpl model){
        LOG.info(String.format("  row %d, model '%s'",model.getRow(),model.getMatchCondition()));
        return true;
      }
    }
);
  }
}
