{
  myUiGroupingRules=uiGroupingRules;
  myFactory=new ArrangementMatchNodeComponentFactory(displayManager,colorsProvider,new Runnable(){
    @Override public void run(){
      notifySelectionListeners();
    }
  }
,uiGroupingRules);
  myGroupingsRoot=myGroupingRulesManager.buildAvailableRules(settingsFilter,displayManager);
  ArrangementTreeNode root=new ArrangementTreeNode(null);
  if (myGroupingsRoot != null) {
    root.add(myGroupingsRoot);
  }
  myMatchRulesRoot=new ArrangementSectionNode(ApplicationBundle.message("arrangement.settings.section.match"));
  root.add(myMatchRulesRoot);
  myTreeModel=new DefaultTreeModel(root);
  final Condition<Integer> wideSelectionCondition=new Condition<Integer>(){
    @Override public boolean value(    Integer row){
      TreePath path=myTree.getPathForRow(row);
      if (path == null) {
        return false;
      }
      return isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition());
    }
  }
;
  myTree=new Tree(myTreeModel){
    @Override protected void setExpandedState(    TreePath path,    boolean state){
      if (state) {
        super.setExpandedState(path,state);
      }
    }
    @NotNull @Override protected Condition<Integer> getWideSelectionBackgroundCondition(){
      return wideSelectionCondition;
    }
    @Override protected void processMouseEvent(    MouseEvent e){
      if (e.getClickCount() > 0 && getNodeComponentAt(e.getX(),e.getY()) == null) {
        TreePath path=myTree.getPathForLocation(e.getX(),e.getY());
        if (path == null || !isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition())) {
          mySkipSelectionChange=true;
        }
      }
      try {
        super.processMouseEvent(e);
        List<ArrangementRuleEditingModelImpl> activeModels=getActiveModels();
        if (mySkipSelectionChange && activeModels.isEmpty()) {
          notifySelectionListeners();
        }
      }
  finally {
        mySkipSelectionChange=false;
      }
    }
  }
;
  myTree.setSelectionModel(mySelectionModel);
  myTree.setRootVisible(false);
  myTree.setRowHeight(0);
  mySelectionModel.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      if (myExplicitSelectionChange) {
        return;
      }
      TreePath[] paths=e.getPaths();
      if (paths == null) {
        return;
      }
      for (int i=0; i < paths.length; i++) {
        onSelectionChange(paths[i],e.isAddedPath(i));
      }
    }
  }
);
  myTree.addMouseMotionListener(new MouseAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      onMouseMoved(e);
    }
  }
);
  myTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent e){
      onMouseClicked(e);
    }
  }
);
  myTree.getActionMap().put("selectNext",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectNextRule();
    }
  }
);
  myTree.getActionMap().put("selectPrevious",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectPreviousRule();
    }
  }
);
  setSettings(settings);
  myTree.setShowsRootHandles(false);
  MyCellRenderer renderer=new MyCellRenderer();
  myTree.setCellRenderer(renderer);
  myTree.setEditable(true);
  myTree.setCellEditor(new MyCellEditor(myTree,renderer));
  myTree.setUI(new WideSelectionTreeUI(true,wideSelectionCondition){
    @Override protected boolean shouldPaintExpandControl(    TreePath path,    int row,    boolean isExpanded,    boolean hasBeenExpanded,    boolean isLeaf){
      return false;
    }
  }
);
}
