{
  myUiGroupingRules=uiGroupingRules;
  myEditor=new ArrangementRuleEditor(settingsFilter,colorsProvider,displayManager);
  myFactory=new ArrangementMatchNodeComponentFactory(displayManager,colorsProvider,null,uiGroupingRules);
  myGroupingsRoot=myGroupingRulesManager.buildAvailableRules(settingsFilter,displayManager);
  ArrangementTreeNode root=new ArrangementTreeNode(null);
  if (myGroupingsRoot != null) {
    root.add(myGroupingsRoot);
  }
  myMatchRulesRoot=new ArrangementSectionNode(ApplicationBundle.message("arrangement.settings.section.match"));
  root.add(myMatchRulesRoot);
  myTreeModel=new DefaultTreeModel(root);
  final Condition<Integer> wideSelectionCondition=new Condition<Integer>(){
    @Override public boolean value(    Integer row){
      TreePath path=myTree.getPathForRow(row);
      if (path == null) {
        return false;
      }
      return isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition());
    }
  }
;
  myTree=new Tree(myTreeModel){
    @Override protected void setExpandedState(    TreePath path,    boolean state){
      if (state) {
        super.setExpandedState(path,state);
      }
    }
    @NotNull @Override protected Condition<Integer> getWideSelectionBackgroundCondition(){
      return wideSelectionCondition;
    }
    @Override protected void processMouseEvent(    MouseEvent e){
      if (e.getClickCount() > 0 && getNodeComponentAt(e.getX(),e.getY()) == null) {
        TreePath path=myTree.getPathForLocation(e.getX(),e.getY());
        if (path == null || !isEmptyCondition(((ArrangementTreeNode)path.getLastPathComponent()).getBackingCondition())) {
          mySkipSelectionChange=true;
        }
      }
      try {
        super.processMouseEvent(e);
        List<ArrangementRuleEditingModelImpl> activeModels=getActiveModels();
        if (mySkipSelectionChange && activeModels.isEmpty()) {
          hideEditor();
        }
      }
  finally {
        mySkipSelectionChange=false;
      }
    }
  }
;
  myTree.setSelectionModel(mySelectionModel);
  myTree.setRootVisible(false);
  myTree.setRowHeight(0);
  mySelectionModel.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      if (myExplicitSelectionChange) {
        return;
      }
      TreePath[] paths=e.getPaths();
      if (paths == null) {
        return;
      }
      for (int i=0; i < paths.length; i++) {
        onSelectionChange(paths[i],e.isAddedPath(i));
      }
    }
  }
);
  myTree.addMouseMotionListener(new MouseAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      onMouseMoved(e);
    }
  }
);
  myTree.addMouseListener(new MouseAdapter(){
    @Override public void mouseEntered(    MouseEvent e){
      onMouseEntered(e);
    }
    @Override public void mouseExited(    MouseEvent e){
      onMouseExited();
    }
    @Override public void mouseClicked(    MouseEvent e){
      onMouseClicked(e);
    }
  }
);
  myTree.getActionMap().put("selectNext",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectNextRule();
    }
  }
);
  myTree.getActionMap().put("selectPrevious",new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      selectPreviousRule();
    }
  }
);
  setSettings(settings);
  myTree.setShowsRootHandles(false);
  MyCellRenderer renderer=new MyCellRenderer();
  myTree.setCellRenderer(renderer);
  myTree.setEditable(true);
  myTree.setCellEditor(new MyCellEditor(myTree,renderer));
  myTree.setUI(new WideSelectionTreeUI(true,wideSelectionCondition){
    @Override protected boolean shouldPaintExpandControl(    TreePath path,    int row,    boolean isExpanded,    boolean hasBeenExpanded,    boolean isLeaf){
      return false;
    }
    @Override protected void paintSelectedRows(    Graphics g,    JTree tr){
      if (myRowUnderMouse < 0) {
        super.paintSelectedRows(g,tr);
        return;
      }
      final Rectangle rect=tr.getVisibleRect();
      final int firstVisibleRow=tr.getClosestRowForLocation(rect.x,rect.y);
      final int lastVisibleRow=tr.getClosestRowForLocation(rect.x,rect.y + rect.height);
      for (int row=firstVisibleRow; row <= lastVisibleRow; row++) {
        Color color=null;
        if (tr.getSelectionModel().isRowSelected(row) && wideSelectionCondition.value(row)) {
          color=UIUtil.getTreeSelectionBackground(tr.hasFocus());
        }
 else         if (row == myRowUnderMouse) {
          color=UIUtil.getDecoratedRowColor();
        }
        if (color == null) {
          color=myTree.getBackground();
        }
        final Rectangle bounds=tr.getRowBounds(row);
        g.setColor(color);
        g.fillRect(0,bounds.y,tr.getWidth(),bounds.height);
      }
    }
  }
);
  myEditor.applyBackground(myTree.getBackground());
}
