{
  if (C_LIB == null) {
    throw new IllegalStateException("no CLIB");
  }
  int our_pid=C_LIB.getpid();
  int process_pid=getProcessPid(process);
  try {
    String[] psCmd=getCmd();
    Process p=Runtime.getRuntime().exec(psCmd);
    @SuppressWarnings({"IOResourceOpenedButNotSafelyClosed"}) BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));
    BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()));
    try {
      String s;
      stdInput.readLine();
      int foundPid=0;
      while ((s=stdInput.readLine()) != null) {
        StringTokenizer st=new StringTokenizer(s," ");
        int parent_pid=Integer.parseInt(st.nextToken());
        int pid=Integer.parseInt(st.nextToken());
        ProcessInfo.register(pid,parent_pid);
        if (pid == process_pid) {
          if (parent_pid == our_pid) {
            foundPid=pid;
          }
 else {
            throw new IllegalStateException("process is not our child");
          }
        }
      }
      if (foundPid != 0) {
        ProcessInfo.killProcTree(foundPid,signal);
      }
 else {
        throw new IllegalStateException("process not found: " + process_pid + ", idea pid ="+ our_pid);
      }
      StringBuffer errorStr=new StringBuffer();
      while ((s=stdError.readLine()) != null) {
        errorStr.append(s).append("\n");
      }
      if (errorStr.length() > 0) {
        throw new IllegalStateException("error:" + errorStr.toString());
      }
    }
  finally {
      stdInput.close();
      stdError.close();
    }
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}
