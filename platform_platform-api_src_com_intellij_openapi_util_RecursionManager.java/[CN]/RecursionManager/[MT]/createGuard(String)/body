{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    Object key,    Computable<T> computation){
      Object realKey=Pair.create(id,key);
      LinkedHashMap<Object,Integer> progressMap=ourProgress.get();
      if (progressMap.containsKey(realKey)) {
        int stamp=ourStamp.get() + 1;
        ourStamp.set(stamp);
        boolean inLoop=false;
        for (        Map.Entry<Object,Integer> entry : progressMap.entrySet()) {
          if (inLoop) {
            entry.setValue(stamp);
          }
 else           if (entry.getKey().equals(realKey)) {
            inLoop=true;
          }
        }
        return null;
      }
      progressMap.put(realKey,ourStamp.get());
      try {
        return computation.compute();
      }
  finally {
        ourStamp.set(progressMap.remove(realKey));
      }
    }
    @Override public StackStamp markStack(){
      final Integer stamp=ourStamp.get();
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return Comparing.equal(stamp,ourStamp.get());
        }
      }
;
    }
  }
;
}
