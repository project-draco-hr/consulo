{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    Object key,    Computable<T> computation){
      Object realKey=Pair.create(id,key);
      LinkedHashMap<Object,Set<Object>> progressMap=ourProgress.get();
      if (progressMap == null) {
        ourProgress.set(progressMap=new LinkedHashMap<Object,Set<Object>>());
      }
 else       if (progressMap.containsKey(realKey)) {
        disableCachingForStackLoop(realKey,progressMap);
        ourRecursionsMet.set((ourRecursionsMet.get() != null ? ourRecursionsMet.get() : 0) + 1);
        return null;
      }
      progressMap.put(realKey,null);
      try {
        return computation.compute();
      }
  finally {
        Set<Object> deps=progressMap.remove(realKey);
        Set<Object> noCache=ourNoCache.get();
        if (noCache != null && deps != null) {
          noCache.removeAll(deps);
        }
      }
    }
    @Override public StackStamp markStack(){
      final Integer stamp=ourRecursionsMet.get();
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return Comparing.equal(stamp,ourRecursionsMet.get());
        }
      }
;
    }
  }
;
}
