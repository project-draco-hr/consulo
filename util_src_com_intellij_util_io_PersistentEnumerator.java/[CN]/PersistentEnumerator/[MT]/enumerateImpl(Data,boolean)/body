{
  int depth=0;
  final int valueHC=myDataDescriptor.getHashCode(value);
  int hc=valueHC;
  int vector=FIRST_VECTOR_OFFSET;
  int pos;
  int lastVector;
  do {
    lastVector=vector;
    pos=vector + (hc & LEVEL_MASK) * 4;
    hc>>>=BITS_PER_LEVEL;
    vector=myStorage.getInt(pos);
    depth++;
  }
 while (vector > 0);
  if (vector == 0) {
    if (!saveNewValue) {
      return NULL_ID;
    }
    final int newId=writeData(value,valueHC);
    myStorage.putInt(pos,-newId);
    return newId;
  }
 else {
    int collision=-vector;
    boolean splitVector=false;
    int candidateHC;
    do {
      candidateHC=hashCodeOf(collision);
      if (candidateHC != valueHC) {
        splitVector=true;
        break;
      }
      Data candidate=valueOf(collision);
      if (myDataDescriptor.isEqual(value,candidate)) {
        return collision;
      }
      collision=nextCanditate(collision);
    }
 while (collision != 0);
    if (!saveNewValue) {
      return NULL_ID;
    }
    final int newId=writeData(value,valueHC);
    if (splitVector) {
      depth--;
      do {
        final int valueHCByte=hcByte(valueHC,depth);
        final int oldHCByte=hcByte(candidateHC,depth);
        if (valueHCByte == oldHCByte) {
          int newVector=allocVector();
          myStorage.putInt(lastVector + oldHCByte * 4,newVector);
          lastVector=newVector;
        }
 else {
          myStorage.putInt(lastVector + valueHCByte * 4,-newId);
          myStorage.putInt(lastVector + oldHCByte * 4,vector);
          break;
        }
        depth++;
      }
 while (true);
    }
 else {
      myStorage.putInt(newId,vector);
      myStorage.putInt(pos,-newId);
    }
    return newId;
  }
}
