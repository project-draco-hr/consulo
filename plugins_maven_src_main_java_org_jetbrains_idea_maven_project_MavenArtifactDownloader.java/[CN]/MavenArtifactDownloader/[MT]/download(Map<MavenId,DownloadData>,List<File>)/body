{
  List<Future> futures=new ArrayList<Future>();
  final AtomicInteger downloaded=new AtomicInteger();
  int total=0;
  for (  DownloadData each : toDownload.values()) {
    total+=each.classifiersWithExtensions.size();
  }
  final DownloadResult result=new DownloadResult();
  result.unresolvedSources.addAll(toDownload.keySet());
  result.unresolvedDocs.addAll(toDownload.keySet());
  try {
    for (    final Map.Entry<MavenId,DownloadData> eachEntry : toDownload.entrySet()) {
      myProgress.checkCanceled();
      final DownloadData data=eachEntry.getValue();
      final MavenId id=eachEntry.getKey();
      for (      final DownloadElement eachElement : data.classifiersWithExtensions) {
        final int finalTotal=total;
        futures.add(EXECUTOR.submit(new Runnable(){
          public void run(){
            try {
              myProgress.checkCanceled();
              myProgress.setFraction(((double)downloaded.getAndIncrement()) / finalTotal);
              MavenArtifact a=myEmbedder.resolve(id,eachElement.extension,eachElement.classifier,new ArrayList<MavenRemoteRepository>(data.repositories));
              File file=a.getFile();
              if (file.exists()) {
synchronized (downloadedFiles) {
                  downloadedFiles.add(file);
switch (eachElement.type) {
case SOURCES:
                    result.resolvedSources.add(id);
                  result.unresolvedSources.remove(id);
                break;
case DOCS:
              result.resolvedDocs.add(id);
            result.unresolvedDocs.remove(id);
          break;
      }
    }
  }
}
 catch (MavenProcessCanceledException ignore) {
}
}
}
));
}
}
}
  finally {
for (Future each : futures) {
try {
each.get();
}
 catch (Exception e) {
MavenLog.LOG.error(e);
}
}
}
return result;
}
