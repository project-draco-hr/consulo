{
  int endDocumentOffset=myEditor.getDocument().getTextLength();
  if (region.getEndOffset() >= endDocumentOffset) {
    return advanceToOffset(endDocumentOffset).build();
  }
  if (region.getStartOffset() > context.offset) {
    Context newContext=advanceToOffset(region.getStartOffset());
    if (strategy.exceeds(newContext)) {
      return strategy.build(context);
    }
    context=newContext;
  }
  Document document=myEditor.getDocument();
  CharSequence text=document.getCharsSequence();
  int foldingStartLine=document.getLineNumber(region.getStartOffset());
  Context afterFolding=context.clone();
  afterFolding.logicalLine+=document.getLineNumber(region.getEndOffset()) - foldingStartLine;
  int visualColumnInc=region.getPlaceholderText().length();
  afterFolding.visualColumn+=visualColumnInc;
  int i=CharArrayUtil.shiftBackwardUntil(text,region.getEndOffset() - 1,"\n");
  if (i >= region.getStartOffset()) {
    int width=myTextRepresentationHelper.textWidth(text,i + 1,region.getEndOffset(),0);
    afterFolding.logicalColumn=myTextRepresentationHelper.toVisualColumnSymbolsNumber(width);
    afterFolding.x=width;
    afterFolding.softWrapLinesBefore+=afterFolding.softWrapLinesCurrent;
    afterFolding.softWrapLinesCurrent=0;
    afterFolding.softWrapColumnDiff=0;
    afterFolding.foldedLines+=document.getLineNumber(region.getEndOffset()) - foldingStartLine;
    afterFolding.foldingColumnDiff=afterFolding.visualColumn - afterFolding.logicalColumn;
  }
 else {
    int width=myTextRepresentationHelper.textWidth(text,region.getStartOffset(),region.getEndOffset(),context.x);
    int logicalColumnInc=myTextRepresentationHelper.toVisualColumnSymbolsNumber(width);
    afterFolding.logicalColumn+=logicalColumnInc;
    afterFolding.x+=width;
    afterFolding.foldingColumnDiff+=visualColumnInc - logicalColumnInc;
  }
  afterFolding.offset=region.getEndOffset();
  if (!strategy.exceeds(afterFolding)) {
    context=afterFolding;
    return null;
  }
  return strategy.build(context,region);
}
