{
  int offset=myEditor.logicalPositionToOffset(position);
  int foldedLines=0;
  int foldColumnDiff=0;
  int softWrapColumnDiff=position.softWrapColumnDiff;
  Document document=myEditor.getDocument();
  int targetLine=document.getLineNumber(offset);
  int lastFoldEndLogicalLine=-1;
  for (  FoldRegion foldRegion : foldingModel.getAllFoldRegions()) {
    if (foldRegion.getStartOffset() >= offset) {
      break;
    }
    if (foldRegion.isExpanded() || !foldRegion.isValid()) {
      continue;
    }
    int foldingStartLine=document.getLineNumber(foldRegion.getStartOffset());
    int foldingEndLine=document.getLineNumber(foldRegion.getEndOffset());
    foldedLines+=Math.min(targetLine,foldingEndLine) - foldingStartLine;
    if (offset >= foldRegion.getStartOffset()) {
      if (offset < foldRegion.getEndOffset()) {
        int visualFoldingStartColumn=calculateVisualFoldingStartColumn(foldRegion);
        int diff=visualFoldingStartColumn - position.column - softWrapColumnDiff;
        if (lastFoldEndLogicalLine == foldingStartLine) {
          foldColumnDiff+=diff;
        }
 else {
          foldColumnDiff=diff;
        }
        return new LogicalPosition(position.line,position.column,position.softWrapLinesBeforeCurrentLogicalLine,position.softWrapLinesOnCurrentLogicalLine,softWrapColumnDiff,foldedLines,foldColumnDiff);
      }
      int diff=getFoldColumnDiff(foldRegion);
      if (lastFoldEndLogicalLine == foldingStartLine) {
        foldColumnDiff+=diff;
      }
 else {
        foldColumnDiff=diff;
      }
      lastFoldEndLogicalLine=foldingEndLine;
    }
  }
  if (lastFoldEndLogicalLine != position.line) {
    foldColumnDiff=0;
  }
  return new LogicalPosition(position.line,position.column,position.softWrapLinesBeforeCurrentLogicalLine,position.softWrapLinesOnCurrentLogicalLine,softWrapColumnDiff,foldedLines,foldColumnDiff);
}
