{
  CharSequence text=myEditor.getDocument().getCharsSequence();
  int max=Math.min(offset,region.getEndOffset());
  boolean multilineFolding=false;
  for (int i=region.getStartOffset(); i < max; ) {
    int lineFeedOffset=CharArrayUtil.shiftForwardUntil(text,i,"\n");
    if (lineFeedOffset < max) {
      context.softWrapLinesBefore+=context.targetSoftWrapLines;
      context.targetSoftWrapLines=0;
      context.softWrapColumnDiff=0;
      context.foldedLines++;
      context.logicalColumn=0;
      context.foldingColumnDiff=context.visualColumn;
      context.logicalLine++;
      i=lineFeedOffset + 1;
      multilineFolding=true;
    }
 else {
      if (multilineFolding) {
        context.logicalColumn=myTextRepresentationHelper.toVisualColumnSymbolsNumber(text,i,max,0);
        context.foldingColumnDiff=context.visualColumn - context.logicalColumn;
        break;
      }
 else {
        int foldedColumns=myTextRepresentationHelper.toVisualColumnSymbolsNumber(text,region.getStartOffset(),max,context.x);
        context.logicalColumn+=foldedColumns;
        context.foldingColumnDiff-=foldedColumns;
        if (offset >= region.getEndOffset()) {
          context.foldingColumnDiff+=region.getPlaceholderText().length();
        }
        return;
      }
    }
  }
  if (offset >= region.getEndOffset()) {
    int foldPlaceholderColumns=region.getPlaceholderText().length();
    context.visualColumn+=foldPlaceholderColumns;
    context.foldingColumnDiff+=foldPlaceholderColumns;
    context.x+=foldPlaceholderColumns * myTextRepresentationHelper.charWidth(' ',context.x,Font.PLAIN);
  }
}
