{
  Document document=myEditor.getDocument();
  CharSequence chars=document.getCharsSequence();
  int targetLine=document.getLineNumber(offset);
  int targetLineStartOffset=document.getLineStartOffset(targetLine);
  int softWrapIntroducedLinesBefore=0;
  int softWrapsOnCurrentLogicalLine=0;
  int symbolsOnCurrentLogicalLine=0;
  int symbolsOnCurrentVisibleLine=0;
  List<TextChangeImpl> softWraps=myStorage.getSoftWraps();
  LogicalPosition rawLineStartLogicalPosition=myEditor.offsetToLogicalPosition(targetLineStartOffset);
  int index=myStorage.getSoftWrapIndex(targetLineStartOffset);
  if (index < 0) {
    index=-index - 1;
  }
  int max=Math.min(index,softWraps.size());
  for (int j=0; j < max; j++) {
    softWrapIntroducedLinesBefore+=StringUtil.countNewLines(softWraps.get(j).getText());
  }
  FoldingModel foldingModel=myEditor.getFoldingModel();
  if (max >= softWraps.size() || softWraps.get(max).getStart() > offset) {
    int column=toVisualColumnSymbolsNumber(chars,targetLineStartOffset,offset);
    LogicalPosition foldingUnawarePosition=new LogicalPosition(rawLineStartLogicalPosition.line,column,softWrapIntroducedLinesBefore,0,0,0,0);
    return adjustFoldingData(foldingModel,foldingUnawarePosition);
  }
  max=Math.min(chars.length(),offset + 1);
  for (int i=targetLineStartOffset; i < max; i++) {
    FoldRegion region=foldingModel.getCollapsedRegionAtOffset(i);
    if (region != null) {
      i=region.getEndOffset();
      symbolsOnCurrentVisibleLine+=region.getPlaceholderText().length();
      continue;
    }
    TextChange softWrap=myStorage.getSoftWrap(i);
    if (softWrap != null) {
      CharSequence softWrapText=softWrap.getText();
      for (int j=0; j < softWrapText.length(); j++) {
        if (softWrapText.charAt(j) == '\n') {
          softWrapsOnCurrentLogicalLine++;
          symbolsOnCurrentVisibleLine=0;
        }
 else {
          symbolsOnCurrentVisibleLine++;
        }
      }
      symbolsOnCurrentVisibleLine++;
    }
    if (i == offset) {
      break;
    }
    symbolsOnCurrentLogicalLine++;
    symbolsOnCurrentVisibleLine++;
  }
  LogicalPosition foldingUnawarePosition=new LogicalPosition(rawLineStartLogicalPosition.line,symbolsOnCurrentLogicalLine,softWrapIntroducedLinesBefore,softWrapsOnCurrentLogicalLine,symbolsOnCurrentVisibleLine - symbolsOnCurrentLogicalLine,0,0);
  return adjustFoldingData(foldingModel,foldingUnawarePosition);
}
