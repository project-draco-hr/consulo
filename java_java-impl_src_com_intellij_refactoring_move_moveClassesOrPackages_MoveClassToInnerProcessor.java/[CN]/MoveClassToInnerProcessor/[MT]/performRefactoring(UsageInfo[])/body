{
  if (!prepareWritable(usages))   return;
  final List<PsiElement> importStatements=new ArrayList<PsiElement>();
  if (!CodeStyleSettingsManager.getSettings(myProject).INSERT_INNER_CLASS_IMPORTS) {
    usages=filterUsagesInImportStatements(usages,importStatements);
  }
 else {
    Arrays.sort(usages,new Comparator<UsageInfo>(){
      public int compare(      UsageInfo o1,      UsageInfo o2){
        return PsiUtil.BY_POSITION.compare(o1.getElement(),o2.getElement());
      }
    }
);
  }
  saveNonCodeUsages(usages);
  final Map<PsiElement,PsiElement> oldToNewElementsMapping=new HashMap<PsiElement,PsiElement>();
  try {
    for (    PsiClass classToMove : myClassesToMove) {
      ChangeContextUtil.encodeContextInfo(classToMove,true);
      PsiClass newClass=(PsiClass)myTargetClass.addBefore(classToMove,myTargetClass.getRBrace());
      if (myTargetClass.isInterface()) {
        PsiUtil.setModifierProperty(newClass,PsiModifier.PACKAGE_LOCAL,true);
      }
 else {
        PsiUtil.setModifierProperty(newClass,PsiModifier.STATIC,true);
      }
      newClass=(PsiClass)ChangeContextUtil.decodeContextInfo(newClass,null,null);
      oldToNewElementsMapping.put(classToMove,newClass);
    }
    myNonCodeUsages=MoveClassesOrPackagesProcessor.retargetUsages(usages,oldToNewElementsMapping);
    retargetNonCodeUsages(oldToNewElementsMapping);
    retargetClassRefsInMoved(oldToNewElementsMapping);
    JavaCodeStyleManager.getInstance(myProject).removeRedundantImports((PsiJavaFile)myTargetClass.getContainingFile());
    for (    PsiClass classToMove : myClassesToMove) {
      classToMove.delete();
    }
    for (    PsiElement element : importStatements) {
      if (element.isValid()) {
        element.delete();
      }
    }
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
