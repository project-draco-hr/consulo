{
  if (!prepareWritable(usages))   return;
  MoveClassToInnerHandler[] handlers=MoveClassToInnerHandler.EP_NAME.getExtensions();
  ArrayList<UsageInfo> usageList=new ArrayList<UsageInfo>(Arrays.asList(usages));
  List<PsiElement> importStatements=new ArrayList<PsiElement>();
  for (  MoveClassToInnerHandler handler : handlers) {
    importStatements.addAll(handler.filterImports(usageList,myProject));
  }
  usages=usageList.toArray(new UsageInfo[usageList.size()]);
  saveNonCodeUsages(usages);
  final Map<PsiElement,PsiElement> oldToNewElementsMapping=new HashMap<PsiElement,PsiElement>();
  try {
    for (    PsiClass classToMove : myClassesToMove) {
      PsiClass newClass=null;
      for (      MoveClassToInnerHandler handler : handlers) {
        newClass=handler.moveClass(classToMove,myTargetClass);
        if (newClass != null)         break;
      }
      LOG.assertTrue(newClass != null,"There is no appropriate MoveClassToInnerHandler!");
      oldToNewElementsMapping.put(classToMove,newClass);
    }
    myNonCodeUsages=CommonMoveUtil.retargetUsages(usages,oldToNewElementsMapping);
    for (    MoveClassToInnerHandler handler : handlers) {
      handler.retargetNonCodeUsages(oldToNewElementsMapping,myNonCodeUsages);
    }
    for (    MoveClassToInnerHandler handler : handlers) {
      handler.retargetClassRefsInMoved(oldToNewElementsMapping);
    }
    for (    MoveClassToInnerHandler handler : handlers) {
      handler.removeRedundantImports(myTargetClass.getContainingFile());
    }
    for (    PsiClass classToMove : myClassesToMove) {
      classToMove.delete();
    }
    for (    PsiElement element : importStatements) {
      if (element.isValid()) {
        element.delete();
      }
    }
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
