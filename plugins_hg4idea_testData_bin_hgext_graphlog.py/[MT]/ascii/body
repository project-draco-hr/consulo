def ascii(ui, state, type, char, text, coldata):
    "prints an ASCII graph of the DAG\n\n    takes the following arguments (one call per node in the graph):\n\n      - ui to write to\n      - Somewhere to keep the needed state in (init to asciistate())\n      - Column of the current node in the set of ongoing edges.\n      - Type indicator of node data == ASCIIDATA.\n      - Payload: (char, lines):\n        - Character to use as node's symbol.\n        - List of lines to display as the node's text.\n      - Edges; a list of (col, next_col) indicating the edges between\n        the current node and its parents.\n      - Number of columns (ongoing edges) in the current revision.\n      - The difference between the number of columns (ongoing edges)\n        in the next revision and the number of columns (ongoing edges)\n        in the current revision. That is: -1 means one column removed;\n        0 means no columns added or removed; 1 means one column added.\n    "
    (idx, edges, ncols, coldiff) = coldata
    assert ((-2) < coldiff < 2)
    if (coldiff == (-1)):
        fix_long_right_edges(edges)
    add_padding_line = ((len(text) > 2) and (coldiff == (-1)) and [x for (x, y) in edges if ((x + 1) < y)])
    fix_nodeline_tail = ((len(text) <= 2) and (not add_padding_line))
    nodeline = (['|', ' '] * idx)
    nodeline.extend([char, ' '])
    nodeline.extend(get_nodeline_edges_tail(idx, state[1], ncols, coldiff, state[0], fix_nodeline_tail))
    shift_interline = (['|', ' '] * idx)
    if (coldiff == (-1)):
        n_spaces = 1
        edge_ch = '/'
    elif (coldiff == 0):
        n_spaces = 2
        edge_ch = '|'
    else:
        n_spaces = 3
        edge_ch = '\\'
    shift_interline.extend((n_spaces * [' ']))
    shift_interline.extend(([edge_ch, ' '] * ((ncols - idx) - 1)))
    draw_edges(edges, nodeline, shift_interline)
    lines = [nodeline]
    if add_padding_line:
        lines.append(get_padding_line(idx, ncols, edges))
    lines.append(shift_interline)
    while (len(text) < len(lines)):
        text.append('')
    if (len(lines) < len(text)):
        extra_interline = (['|', ' '] * (ncols + coldiff))
        while (len(lines) < len(text)):
            lines.append(extra_interline)
    indentation_level = max(ncols, (ncols + coldiff))
    for (line, logstr) in zip(lines, text):
        ln = ('%-*s %s' % ((2 * indentation_level), ''.join(line), logstr))
        ui.write((ln.rstrip() + '\n'))
    state[0] = coldiff
    state[1] = idx
