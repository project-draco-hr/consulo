{
  for (  GitCommit commit : commits) {
    GitSimpleEventDetector conflictDetector=new GitSimpleEventDetector(CHERRY_PICK_CONFLICT);
    GitSimpleEventDetector localChangesOverwrittenDetector=new GitSimpleEventDetector(LOCAL_CHANGES_OVERWRITTEN_BY_CHERRY_PICK);
    GitCommandResult result=myGit.cherryPick(repository,commit.getHash().getValue(),myAutoCommit,conflictDetector,localChangesOverwrittenDetector);
    if (result.success()) {
      if (myAutoCommit) {
        successfulCommits.add(commit);
      }
 else {
        boolean committed=updateChangeListManagerShowCommitDialogAndRemoveChangeListOnSuccess(repository,commit,successfulCommits);
        if (!committed) {
          return false;
        }
      }
    }
 else     if (conflictDetector.hasHappened()) {
      boolean mergeCompleted=new CherryPickConflictResolver(myProject,myGit,myPlatformFacade,repository.getRoot(),commit.getShortHash().getString(),commit.getAuthor(),commit.getSubject()).merge();
      NotificationListener resolveLinkListener=new ResolveLinkListener(myProject,myGit,myPlatformFacade,repository.getRoot(),commit.getShortHash().getString(),commit.getAuthor(),commit.getSubject());
      if (mergeCompleted) {
        boolean committed=updateChangeListManagerShowCommitDialogAndRemoveChangeListOnSuccess(repository,commit,successfulCommits);
        if (!committed) {
          notifyConflictWarning(commit,successfulCommits,resolveLinkListener);
          return false;
        }
      }
 else {
        updateChangeListManager(commit);
        notifyConflictWarning(commit,successfulCommits,resolveLinkListener);
        return false;
      }
    }
 else     if (localChangesOverwrittenDetector.hasHappened()) {
      notifyError("Your local changes would be overwritten by cherry-pick.<br/>Commit your changes or stash them to proceed.",commit,successfulCommits);
      return false;
    }
 else {
      notifyError(result.getErrorOutputAsHtmlString(),commit,successfulCommits);
      return false;
    }
  }
  return true;
}
