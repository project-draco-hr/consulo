{
  if (myAutoCommit) {
    GitSimpleEventDetector conflictDetector=new GitSimpleEventDetector(CHERRY_PICK_CONFLICT);
    GitSimpleEventDetector localChangesOverwrittenDetector=new GitSimpleEventDetector(LOCAL_CHANGES_OVERWRITTEN_BY_CHERRY_PICK);
    for (    GitCommit commit : commits) {
      GitCommandResult result=myGit.cherryPick(repository,commit.getHash().getValue(),true,conflictDetector,localChangesOverwrittenDetector);
      if (result.success()) {
        successfulCommits.add(commit);
      }
 else       if (conflictDetector.hasHappened()) {
        boolean mergeCompleted=new CherryPickConflictResolver(myProject,myGit,myPlatformFacade,repository.getRoot(),commit.getShortHash().getString(),commit.getAuthor(),commit.getSubject()).merge();
        if (mergeCompleted) {
          boolean committed=updateChangeListManagerAndShowCommitDialogIfNeeded(repository,commit,true);
          if (!committed) {
            notifyConflictWarning(commit,successfulCommits);
            return false;
          }
 else {
            successfulCommits.add(commit);
          }
        }
 else {
          updateChangeListManagerAndShowCommitDialogIfNeeded(repository,commit,false);
          notifyConflictWarning(commit,successfulCommits);
          return false;
        }
      }
 else       if (localChangesOverwrittenDetector.hasHappened()) {
        notifyError("Your local changes would be overwritten by cherry-pick.<br/>Commit your changes or stash them to proceed.",commit,successfulCommits);
        return false;
      }
 else {
        notifyError(result.getErrorOutputAsHtmlString(),commit,successfulCommits);
        return false;
      }
    }
  }
  return true;
}
