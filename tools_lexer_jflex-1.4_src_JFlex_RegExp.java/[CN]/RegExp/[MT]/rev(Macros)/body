{
  RegExp1 unary;
  RegExp2 binary;
  RegExp content;
switch (type) {
case sym.BAR:
    binary=(RegExp2)this;
  return new RegExp2(sym.BAR,binary.r1.rev(macros),binary.r2.rev(macros));
case sym.CONCAT:
binary=(RegExp2)this;
return new RegExp2(sym.CONCAT,binary.r2.rev(macros),binary.r1.rev(macros));
case sym.STAR:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.STAR,content.rev(macros));
case sym.PLUS:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.PLUS,content.rev(macros));
case sym.QUESTION:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.QUESTION,content.rev(macros));
case sym.BANG:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.BANG,content.rev(macros));
case sym.TILDE:
content=resolveTilde(macros);
return content.rev(macros);
case sym.STRING:
case sym.STRING_I:
unary=(RegExp1)this;
return new RegExp1(unary.type,revString((String)unary.content));
case sym.CHAR:
case sym.CHAR_I:
case sym.CCLASS:
case sym.CCLASSNOT:
unary=(RegExp1)this;
return new RegExp1(unary.type,unary.content);
case sym.MACROUSE:
unary=(RegExp1)this;
return macros.getDefinition((String)unary.content).rev(macros);
}
throw new Error("unknown regexp type " + type);
}
