{
  RegExp1 unary;
  RegExp2 binary;
  RegExp content;
switch (type) {
case sym.BAR:
    binary=(RegExp2)this;
  return new RegExp2(sym.BAR,binary.r1.resolveTilde(macros),binary.r2.resolveTilde(macros));
case sym.CONCAT:
binary=(RegExp2)this;
return new RegExp2(sym.CONCAT,binary.r1.resolveTilde(macros),binary.r2.resolveTilde(macros));
case sym.STAR:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.STAR,content.resolveTilde(macros));
case sym.PLUS:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.PLUS,content.resolveTilde(macros));
case sym.QUESTION:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.QUESTION,content.resolveTilde(macros));
case sym.BANG:
unary=(RegExp1)this;
content=(RegExp)unary.content;
return new RegExp1(sym.BANG,content.resolveTilde(macros));
case sym.TILDE:
unary=(RegExp1)this;
content=((RegExp)unary.content).resolveTilde(macros);
RegExp any_star=new RegExp1(sym.STAR,anyChar());
RegExp neg=new RegExp1(sym.BANG,new RegExp2(sym.CONCAT,any_star,new RegExp2(sym.CONCAT,content,any_star)));
return new RegExp2(sym.CONCAT,neg,content);
case sym.STRING:
case sym.STRING_I:
case sym.CHAR:
case sym.CHAR_I:
case sym.CCLASS:
case sym.CCLASSNOT:
unary=(RegExp1)this;
return new RegExp1(unary.type,unary.content);
case sym.MACROUSE:
unary=(RegExp1)this;
return macros.getDefinition((String)unary.content).resolveTilde(macros);
}
throw new Error("unknown regexp type " + type);
}
