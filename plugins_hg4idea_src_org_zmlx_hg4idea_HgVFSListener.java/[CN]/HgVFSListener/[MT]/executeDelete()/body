{
  final List<FilePath> filesToDelete=new ArrayList<FilePath>(myDeletedWithoutConfirmFiles);
  final List<FilePath> deletedFiles=new ArrayList<FilePath>(myDeletedFiles);
  myDeletedWithoutConfirmFiles.clear();
  myDeletedFiles.clear();
  final List<FilePath> unversionedFilePaths=new ArrayList<FilePath>();
  for (  VirtualFile vf : ChangeListManagerImpl.getInstanceImpl(myProject).getUnversionedFiles()) {
    unversionedFilePaths.add(VcsUtil.getFilePath(vf.getPath()));
  }
  skipUnversionedAndNotUnderHg(unversionedFilePaths,filesToDelete);
  skipUnversionedAndNotUnderHg(unversionedFilePaths,deletedFiles);
  for (Iterator<FilePath> it=deletedFiles.iterator(); it.hasNext(); ) {
    final FilePath filePath=it.next();
    final HgLogCommand logCommand=new HgLogCommand(myProject);
    logCommand.setLogFile(true);
    logCommand.setFollowCopies(false);
    logCommand.setIncludeRemoved(true);
    final VirtualFile repo=HgUtil.getHgRootOrNull(myProject,filePath);
    if (repo == null) {
      continue;
    }
    final HgFile hgFile=new HgFile(repo,filePath);
    final List<HgFileRevision> localRevisions=logCommand.execute(hgFile,-1,true);
    if (localRevisions == null || localRevisions.isEmpty() || localRevisions.get(0).getDeletedFiles().contains(hgFile.getRelativePath())) {
      it.remove();
      filesToDelete.add(filePath);
    }
  }
  if (myRemoveOption.getValue() != VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY) {
    if (myRemoveOption.getValue() == VcsShowConfirmationOption.Value.DO_ACTION_SILENTLY || deletedFiles.isEmpty()) {
      filesToDelete.addAll(deletedFiles);
    }
 else {
      Collection<FilePath> filePaths=selectFilePathsToDelete(deletedFiles);
      if (filePaths != null) {
        filesToDelete.addAll(filePaths);
      }
    }
  }
  if (!filesToDelete.isEmpty()) {
    performDeletion(filesToDelete);
  }
}
