{
  EditorImpl.assertIsDispatchThread();
  if (caretStates.isEmpty()) {
    throw new IllegalArgumentException("At least one caret should exist");
  }
  doWithCaretMerging(new Runnable(){
    @Override public void run(){
      int index=0;
      int oldCaretCount=myCarets.size();
      Iterator<CaretImpl> caretIterator=myCarets.iterator();
      for (      CaretState caretState : caretStates) {
        CaretImpl caret;
        boolean caretAdded;
        if (index++ < oldCaretCount) {
          caret=caretIterator.next();
          caretAdded=false;
        }
 else {
          caret=new CaretImpl(myEditor);
          if (caretState != null && caretState.getCaretPosition() != null) {
            caret.moveToLogicalPosition(caretState.getCaretPosition(),false,null,false);
          }
synchronized (myCarets) {
            myCarets.add(caret);
          }
          fireCaretAdded(caret);
          caretAdded=true;
        }
        if (caretState != null && caretState.getCaretPosition() != null && !caretAdded) {
          caret.moveToLogicalPosition(caretState.getCaretPosition());
        }
        if (caretState != null && caretState.getSelectionStart() != null && caretState.getSelectionEnd() != null) {
          caret.setSelection(myEditor.logicalToVisualPosition(caretState.getSelectionStart()),myEditor.logicalPositionToOffset(caretState.getSelectionStart()),myEditor.logicalToVisualPosition(caretState.getSelectionEnd()),myEditor.logicalPositionToOffset(caretState.getSelectionEnd()),updateSystemSelection);
        }
      }
      int caretsToRemove=myCarets.size() - caretStates.size();
      for (int i=0; i < caretsToRemove; i++) {
        CaretImpl caret;
synchronized (myCarets) {
          caret=myCarets.removeLast();
        }
        fireCaretRemoved(caret);
        Disposer.dispose(caret);
      }
    }
  }
);
}
