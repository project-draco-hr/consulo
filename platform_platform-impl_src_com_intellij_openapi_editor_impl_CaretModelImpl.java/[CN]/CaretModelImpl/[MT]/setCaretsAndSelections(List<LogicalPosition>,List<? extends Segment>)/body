{
  myEditor.assertIsDispatchThread();
  if (caretPositions.isEmpty()) {
    throw new IllegalArgumentException("At least one caret should exist");
  }
  if (caretPositions.size() != selections.size()) {
    throw new IllegalArgumentException("Position and selection lists are of different size");
  }
  doWithCaretMerging(new Runnable(){
    public void run(){
      int index=0;
      int oldCaretCount=myCarets.size();
      Iterator<CaretImpl> caretIterator=myCarets.iterator();
      Iterator<? extends Segment> selectionIterator=selections.iterator();
      for (      LogicalPosition caretPosition : caretPositions) {
        CaretImpl caret;
        boolean caretAdded;
        if (index++ < oldCaretCount) {
          caret=caretIterator.next();
          caretAdded=false;
        }
 else {
          caret=new CaretImpl(myEditor);
          if (caretPosition != null) {
            caret.moveToLogicalPosition(caretPosition,false,null,false);
          }
synchronized (myCarets) {
            myCarets.add(caret);
          }
          fireCaretAdded(caret);
          caretAdded=true;
        }
        if (caretPosition != null && !caretAdded) {
          caret.moveToLogicalPosition(caretPosition);
        }
        Segment selection=selectionIterator.next();
        if (selection != null) {
          caret.setSelection(selection.getStartOffset(),selection.getEndOffset());
        }
      }
      int caretsToRemove=myCarets.size() - caretPositions.size();
      for (int i=0; i < caretsToRemove; i++) {
        CaretImpl caret;
synchronized (myCarets) {
          caret=myCarets.removeLast();
        }
        fireCaretRemoved(caret);
        Disposer.dispose(caret);
      }
    }
  }
);
}
