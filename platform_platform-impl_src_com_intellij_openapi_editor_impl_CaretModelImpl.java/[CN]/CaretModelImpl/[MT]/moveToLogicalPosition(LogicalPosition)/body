{
  assertIsDispatchThread();
  validateCallContext();
  int column=pos.column;
  int line=pos.line;
  int softWrapLinesBefore=pos.softWrapLinesBeforeCurrentLogicalLine;
  int softWrapLinesCurrent=pos.softWrapLinesOnCurrentLogicalLine;
  int softWrapColumns=pos.softWrapColumnDiff;
  Document doc=myEditor.getDocument();
  if (column < 0) {
    column=0;
    softWrapColumns=0;
  }
  if (line < 0) {
    line=0;
    softWrapLinesBefore=0;
    softWrapLinesCurrent=0;
  }
  int lineCount=doc.getLineCount();
  if (lineCount == 0) {
    line=0;
  }
 else   if (line > lineCount - 1) {
    line=lineCount - 1;
    softWrapLinesBefore=0;
    softWrapLinesCurrent=0;
  }
  EditorSettings editorSettings=myEditor.getSettings();
  if (!editorSettings.isVirtualSpace() && line < lineCount) {
    int lineEndOffset=doc.getLineEndOffset(line);
    int lineEndColumnNumber=myEditor.offsetToLogicalPosition(lineEndOffset).column;
    if (column > lineEndColumnNumber) {
      column=lineEndColumnNumber;
      if (softWrapColumns != 0) {
        softWrapColumns-=column - lineEndColumnNumber;
      }
    }
  }
  ((FoldingModelImpl)myEditor.getFoldingModel()).flushCaretPosition();
  VerticalInfo oldInfo=myCaretInfo;
  LogicalPosition oldCaretPosition=myLogicalCaret;
  setCurrentLogicalCaret(new LogicalPosition(line,column,softWrapLinesBefore,softWrapLinesCurrent,softWrapColumns,pos.foldedLines,pos.foldingColumnDiff));
  final int offset=myEditor.logicalPositionToOffset(myLogicalCaret);
  FoldRegion collapsedAt=myEditor.getFoldingModel().getCollapsedRegionAtOffset(offset);
  if (collapsedAt != null && offset > collapsedAt.getStartOffset()) {
    Runnable runnable=new Runnable(){
      public void run(){
        FoldRegion[] allCollapsedAt=((FoldingModelImpl)myEditor.getFoldingModel()).fetchCollapsedAt(offset);
        for (        FoldRegion foldRange : allCollapsedAt) {
          foldRange.setExpanded(true);
        }
      }
    }
;
    myEditor.getFoldingModel().runBatchFoldingOperation(runnable);
  }
  myEditor.setLastColumnNumber(myLogicalCaret.column);
  myVisibleCaret=myEditor.logicalToVisualPosition(myLogicalCaret);
  myOffset=myEditor.logicalPositionToOffset(myLogicalCaret);
  LOG.assertTrue(myOffset >= 0 && myOffset <= myEditor.getDocument().getTextLength());
  int caretOffset=myEditor.logicalPositionToOffset(myEditor.visualToLogicalPosition(new VisualPosition(myVisibleCaret.line,0)));
  int caretLine=doc.getLineNumber(caretOffset);
  myVisualLineStart=doc.getLineStartOffset(caretLine);
  myVisualLineEnd=doc.getLineEndOffset(caretLine) + 1;
  myEditor.updateCaretCursor();
  requestRepaint(oldInfo);
  if (oldCaretPosition.column + oldCaretPosition.softWrapColumnDiff != myLogicalCaret.column + myLogicalCaret.softWrapColumnDiff || oldCaretPosition.line + oldCaretPosition.softWrapLinesBeforeCurrentLogicalLine != myLogicalCaret.line + myLogicalCaret.softWrapLinesBeforeCurrentLogicalLine) {
    CaretEvent event=new CaretEvent(myEditor,oldCaretPosition,myLogicalCaret);
    for (    CaretListener listener : myCaretListeners) {
      listener.caretPositionChanged(event);
    }
  }
}
