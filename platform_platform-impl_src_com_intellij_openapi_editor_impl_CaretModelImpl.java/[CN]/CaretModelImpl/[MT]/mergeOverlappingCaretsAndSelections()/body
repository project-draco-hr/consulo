{
  if (myCarets.size() <= 1) {
    return;
  }
  LinkedList<CaretImpl> carets=new LinkedList<>(myCarets);
  Collections.sort(carets,CaretPositionComparator.INSTANCE);
  ListIterator<CaretImpl> it=carets.listIterator();
  CaretImpl keepPrimary=getPrimaryCaret();
  while (it.hasNext()) {
    CaretImpl prevCaret=null;
    if (it.hasPrevious()) {
      prevCaret=it.previous();
      it.next();
    }
    CaretImpl currCaret=it.next();
    if (prevCaret != null && caretsOverlap(currCaret,prevCaret)) {
      int newSelectionStart=Math.min(currCaret.getSelectionStart(),prevCaret.getSelectionStart());
      int newSelectionEnd=Math.max(currCaret.getSelectionEnd(),prevCaret.getSelectionEnd());
      CaretImpl toRetain, toRemove;
      if (currCaret.getOffset() >= prevCaret.getSelectionStart() && currCaret.getOffset() <= prevCaret.getSelectionEnd()) {
        toRetain=prevCaret;
        toRemove=currCaret;
        it.remove();
        it.previous();
      }
 else {
        toRetain=currCaret;
        toRemove=prevCaret;
        it.previous();
        it.previous();
        it.remove();
      }
      if (toRemove == keepPrimary) {
        keepPrimary=toRetain;
      }
      removeCaret(toRemove);
      if (newSelectionStart < newSelectionEnd) {
        toRetain.setSelection(newSelectionStart,newSelectionEnd);
      }
    }
  }
  if (keepPrimary != getPrimaryCaret()) {
synchronized (myCarets) {
      myCarets.remove(keepPrimary);
      myCarets.add(keepPrimary);
    }
  }
}
