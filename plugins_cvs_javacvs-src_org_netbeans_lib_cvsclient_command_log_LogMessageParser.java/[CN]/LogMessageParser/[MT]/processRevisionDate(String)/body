{
  final StringTokenizer token=new StringTokenizer(line,";",false);
  if (token.hasMoreTokens()) {
    final String date=token.nextToken();
    final String dateString=date.substring(DATE.length());
    Date parsedDate=null;
    for (    SyncDateFormat expectedDateFormat : EXPECTED_DATE_FORMATS) {
      try {
        parsedDate=expectedDateFormat.parse(dateString);
      }
 catch (      ParseException e) {
      }
      if (parsedDate != null)       break;
    }
    if (parsedDate != null) {
      revision.setDate(parsedDate);
    }
 else {
      BugLog.getInstance().showException(new Exception(JavaCvsSrcBundle.message("line.could.not.be.parsed.error.message",line)));
    }
  }
  if (token.hasMoreTokens()) {
    final String author=token.nextToken();
    if (author.startsWith(AUTHOR)) {
      revision.setAuthor(author.substring(AUTHOR.length()));
    }
  }
  if (token.hasMoreTokens()) {
    final String state=token.nextToken();
    if (state.startsWith(STATE)) {
      revision.setState(state.substring(STATE.length()));
    }
  }
  if (token.hasMoreTokens()) {
    final String linesModified=token.nextToken();
    if (linesModified.startsWith(LINES)) {
      revision.setLines(linesModified.substring(LINES.length()));
    }
  }
  processingRevision=true;
  logMessageBuffer=new ArrayList<String>();
}
