{
  myTypeParameterReplacements=buildTypeParameterReplacements();
  List<PsiClass> inheritors=new ArrayList<PsiClass>();
  RefactoringUtil.sortDepthFirstRightLeftOrder(usages);
  for (  final UsageInfo usage : usages) {
    if (usage instanceof MethodCallUsageInfo) {
      processMethodCall((MethodCallUsageInfo)usage);
    }
 else     if (usage instanceof ParameterUsageInfo) {
      processParameterUsage((ParameterUsageInfo)usage);
    }
 else     if (usage instanceof ImplementingClassUsageInfo) {
      inheritors.add(((ImplementingClassUsageInfo)usage).getPsiClass());
    }
  }
  prepareTypeParameterReplacement();
  myTargetParameter.delete();
  ChangeContextUtil.encodeContextInfo(myMethod,true);
  if (!myTargetClass.isInterface()) {
    PsiMethod method=addMethodToClass(myTargetClass);
    fixVisibility(method,usages);
  }
 else {
    final PsiMethod interfaceMethod=addMethodToClass(myTargetClass);
    final PsiModifierList modifierList=interfaceMethod.getModifierList();
    modifierList.setModifierProperty(PsiModifier.PRIVATE,false);
    modifierList.setModifierProperty(PsiModifier.PUBLIC,false);
    modifierList.setModifierProperty(PsiModifier.PROTECTED,false);
    RefactoringUtil.makeMethodAbstract(myTargetClass,interfaceMethod);
    for (    final PsiClass psiClass : inheritors) {
      final PsiMethod newMethod=addMethodToClass(psiClass);
      PsiUtil.setModifierProperty(newMethod,myNewVisibility != null && !myNewVisibility.equals(VisibilityUtil.ESCALATE_VISIBILITY) ? myNewVisibility : PsiModifier.PUBLIC,true);
    }
  }
  myMethod.delete();
}
