{
  final PsiClass[] classes;
  final String className;
  if (contextMethod != null) {
    final PsiClass psiClass=contextMethod.getContainingClass();
    className=psiClass == null ? "" : StringUtil.notNullize(psiClass.getQualifiedName());
    classes=psiClass == null ? PsiClass.EMPTY_ARRAY : new PsiClass[]{psiClass};
  }
 else {
    String found=null;
    final Pattern pattern=Pattern.compile(".*definedInClass\\(\"([^\"]*)\"\\)+");
    for (    InjectionPlace place : injection.getInjectionPlaces()) {
      final Matcher matcher=pattern.matcher(place.getText());
      if (matcher.matches()) {
        found=matcher.group(1);
      }
    }
    if (found == null) {
      final Matcher matcher=ourPresentationPattern.matcher(injection.getDisplayName());
      if (matcher.matches()) {
        final String pkg=matcher.group(2);
        found=pkg.substring(1,pkg.length() - 1) + "." + matcher.group(1);
      }
    }
    classes=found != null && project.isInitialized() ? JavaPsiFacade.getInstance(project).findClasses(found,GlobalSearchScope.allScope(project)) : PsiClass.EMPTY_ARRAY;
    className=StringUtil.notNullize(classes.length == 0 ? found : classes[0].getQualifiedName());
  }
  final MethodParameterInjection result=new MethodParameterInjection();
  result.copyFrom(injection);
  result.setInjectionPlaces(InjectionPlace.EMPTY_ARRAY);
  result.setClassName(className);
  final ArrayList<MethodInfo> infos=new ArrayList<MethodInfo>();
  if (classes.length > 0) {
    final THashSet<String> visitedSignatures=new THashSet<String>();
    final PatternCompiler<PsiElement> compiler=injection.getCompiler();
    for (    PsiClass psiClass : classes) {
      for (      PsiMethod method : psiClass.getMethods()) {
        final PsiModifierList modifiers=method.getModifierList();
        if (modifiers.hasModifierProperty(PsiModifier.PRIVATE) || modifiers.hasModifierProperty(PsiModifier.PACKAGE_LOCAL))         continue;
        boolean add=false;
        final MethodInfo methodInfo=createMethodInfo(method);
        if (!visitedSignatures.add(methodInfo.getMethodSignature()))         continue;
        if (isInjectable(method.getReturnType(),method.getProject())) {
          final int parameterIndex=-1;
          int index=ArrayUtil.find(injection.getInjectionPlaces(),new InjectionPlace(compiler.compileElementPattern(getPatternStringForJavaPlace(method,parameterIndex)),true));
          final InjectionPlace place=index > -1 ? injection.getInjectionPlaces()[index] : null;
          methodInfo.setReturnFlag(place != null && place.isEnabled() || includeAllPlaces);
          add=true;
        }
        final PsiParameter[] parameters=method.getParameterList().getParameters();
        for (int i=0; i < parameters.length; i++) {
          final PsiParameter p=parameters[i];
          if (isInjectable(p.getType(),p.getProject())) {
            int index=ArrayUtil.find(injection.getInjectionPlaces(),new InjectionPlace(compiler.compileElementPattern(getPatternStringForJavaPlace(method,i)),true));
            final InjectionPlace place=index > -1 ? injection.getInjectionPlaces()[index] : null;
            methodInfo.getParamFlags()[i]=place != null && place.isEnabled() || includeAllPlaces;
            add=true;
          }
        }
        if (add) {
          infos.add(methodInfo);
        }
      }
    }
  }
 else {
  }
  result.setMethodInfos(infos);
  result.generatePlaces();
  return result;
}
