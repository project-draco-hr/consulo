def reposetup(ui, repo):
    if (not repo.local()):
        return


    class bookmark_repo(repo.__class__):

        @util.propertycache
        def _bookmarks(self):
            'Parse .hg/bookmarks file and return a dictionary\n\n            Bookmarks are stored as {HASH}\\s{NAME}\\n (localtags format) values\n            in the .hg/bookmarks file. They are read returned as a dictionary\n            with name => hash values.\n            '
            try:
                bookmarks = {}
                for line in self.opener('bookmarks'):
                    (sha, refspec) = line.strip().split(' ', 1)
                    bookmarks[refspec] = super(bookmark_repo, self).lookup(sha)
            except:
                pass
            return bookmarks

        @util.propertycache
        def _bookmarkcurrent(self):
            'Get the current bookmark\n\n            If we use gittishsh branches we have a current bookmark that\n            we are on. This function returns the name of the bookmark. It\n            is stored in .hg/bookmarks.current\n            '
            mark = None
            if os.path.exists(self.join('bookmarks.current')):
                file = self.opener('bookmarks.current')
                mark = (file.readlines() or [''])[0]
                if (mark == ''):
                    mark = None
                file.close()
            return mark

        def rollback(self):
            if os.path.exists(self.join('undo.bookmarks')):
                util.rename(self.join('undo.bookmarks'), self.join('bookmarks'))
            return super(bookmark_repo, self).rollback()

        def lookup(self, key):
            if (key in self._bookmarks):
                key = self._bookmarks[key]
            return super(bookmark_repo, self).lookup(key)

        def _bookmarksupdate(self, parents, node):
            marks = self._bookmarks
            update = False
            if ui.configbool('bookmarks', 'track.current'):
                mark = self._bookmarkcurrent
                if (mark and (marks[mark] in parents)):
                    marks[mark] = node
                    update = True
            else:
                for (mark, n) in marks.items():
                    if (n in parents):
                        marks[mark] = node
                        update = True
            if update:
                write(self)

        def commitctx(self, ctx, error=False):
            'Add a revision to the repository and\n            move the bookmark'
            wlock = self.wlock()
            try:
                node = super(bookmark_repo, self).commitctx(ctx, error)
                if (node is None):
                    return None
                parents = self.changelog.parents(node)
                if (parents[1] == nullid):
                    parents = (parents[0],)
                self._bookmarksupdate(parents, node)
                return node
            finally:
                wlock.release()

        def addchangegroup(self, source, srctype, url, emptyok=False):
            parents = self.dirstate.parents()
            result = super(bookmark_repo, self).addchangegroup(source, srctype, url, emptyok)
            if (result > 1):
                return result
            node = self.changelog.tip()
            self._bookmarksupdate(parents, node)
            return result

        def _findtags(self):
            'Merge bookmarks with normal tags'
            (tags, tagtypes) = super(bookmark_repo, self)._findtags()
            tags.update(self._bookmarks)
            return (tags, tagtypes)
        if hasattr(repo, 'invalidate'):

            def invalidate(self):
                super(bookmark_repo, self).invalidate()
                for attr in ('_bookmarks', '_bookmarkcurrent'):
                    if (attr in self.__dict__):
                        delattr(repo, attr)
    repo.__class__ = bookmark_repo
