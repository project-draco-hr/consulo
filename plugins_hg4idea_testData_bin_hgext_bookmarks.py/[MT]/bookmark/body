def bookmark(ui, repo, mark=None, rev=None, force=False, delete=False, rename=None):
    "track a line of development with movable markers\n\n    Bookmarks are pointers to certain commits that move when\n    committing. Bookmarks are local. They can be renamed, copied and\n    deleted. It is possible to use bookmark names in 'hg merge' and\n    'hg update' to merge and update respectively to a given bookmark.\n\n    You can use 'hg bookmark NAME' to set a bookmark on the working\n    directory's parent revision with the given name. If you specify\n    a revision using -r REV (where REV may be an existing bookmark),\n    the bookmark is assigned to that revision.\n    "
    hexfn = ((ui.debugflag and hex) or short)
    marks = repo._bookmarks
    cur = repo.changectx('.').node()
    if rename:
        if (rename not in marks):
            raise util.Abort(_('a bookmark of this name does not exist'))
        if ((mark in marks) and (not force)):
            raise util.Abort(_('a bookmark of the same name already exists'))
        if (mark is None):
            raise util.Abort(_('new bookmark name required'))
        marks[mark] = marks[rename]
        del marks[rename]
        if (repo._bookmarkcurrent == rename):
            setcurrent(repo, mark)
        write(repo)
        return
    if delete:
        if (mark is None):
            raise util.Abort(_('bookmark name required'))
        if (mark not in marks):
            raise util.Abort(_('a bookmark of this name does not exist'))
        if (mark == repo._bookmarkcurrent):
            setcurrent(repo, None)
        del marks[mark]
        write(repo)
        return
    if (mark != None):
        if ('\n' in mark):
            raise util.Abort(_('bookmark name cannot contain newlines'))
        mark = mark.strip()
        if ((mark in marks) and (not force)):
            raise util.Abort(_('a bookmark of the same name already exists'))
        if (((mark in repo.branchtags()) or (mark == repo.dirstate.branch())) and (not force)):
            raise util.Abort(_('a bookmark cannot have the name of an existing branch'))
        if rev:
            marks[mark] = repo.lookup(rev)
        else:
            marks[mark] = repo.changectx('.').node()
            setcurrent(repo, mark)
        write(repo)
        return
    if (mark is None):
        if rev:
            raise util.Abort(_('bookmark name required'))
        if (len(marks) == 0):
            ui.status(_('no bookmarks set\n'))
        else:
            for (bmark, n) in marks.iteritems():
                if ui.configbool('bookmarks', 'track.current'):
                    current = repo._bookmarkcurrent
                    prefix = ((((bmark == current) and (n == cur)) and '*') or ' ')
                else:
                    prefix = (((n == cur) and '*') or ' ')
                if ui.quiet:
                    ui.write(('%s\n' % bmark))
                else:
                    ui.write((' %s %-25s %d:%s\n' % (prefix, bmark, repo.changelog.rev(n), hexfn(n))))
        return
