{
  GenerationNode generationNode=this;
  for (  ZenCodingFilter filter : filters) {
    generationNode=filter.filterNode(generationNode);
  }
  if (generationNode != this) {
    return generationNode.generate(callback,surroundedText,generator,Collections.<ZenCodingFilter>emptyList());
  }
  LiveTemplateBuilder builder=new LiveTemplateBuilder();
  int end=-1;
  boolean hasChildren=myChildren.size() > 0;
  String txt=!hasChildren && myToInsertChildren ? surroundedText : null;
  TemplateImpl parentTemplate;
  Map<String,String> predefinedValues;
  if (myTemplateToken instanceof XmlTemplateToken) {
    XmlTemplateToken xmlTemplateToken=(XmlTemplateToken)myTemplateToken;
    List<Pair<String,String>> attr2value=new ArrayList<Pair<String,String>>(xmlTemplateToken.getAttribute2Value());
    parentTemplate=invokeXmlTemplate(xmlTemplateToken,callback,myNumberInIteration,generator,hasChildren,attr2value);
    predefinedValues=buildPredefinedValues(attr2value,myNumberInIteration,(XmlZenCodingGenerator)generator,hasChildren);
  }
 else {
    parentTemplate=invokeTemplate(myTemplateToken,hasChildren,callback,generator);
    predefinedValues=null;
  }
  String s=parentTemplate.getString();
  for (  ZenCodingFilter filter : filters) {
    s=filter.filterText(s,myTemplateToken);
  }
  parentTemplate=parentTemplate.copy();
  parentTemplate.setString(s);
  parentTemplate=expandTemplate(parentTemplate,predefinedValues,txt);
  int offset=builder.insertTemplate(0,parentTemplate,null);
  int newOffset=gotoChild(callback.getProject(),builder.getText(),offset,0,builder.length());
  if (offset < builder.length() && newOffset != offset) {
    end=offset;
  }
  offset=newOffset;
  if (end == -1 && offset < builder.length() && myChildren.size() == 0) {
    end=offset;
  }
  LiveTemplateBuilder.Marker marker=offset < builder.length() ? builder.createMarker(offset) : null;
  CodeStyleSettings settings=CodeStyleSettingsManager.getSettings(callback.getProject());
  String tabStr;
  if (callback.isInInjectedFragment()) {
    tabStr="";
  }
 else   if (settings.useTabCharacter(callback.getFileType())) {
    tabStr="\t";
  }
 else {
    StringBuilder tab=new StringBuilder();
    int tabSize=settings.getTabSize(callback.getFileType());
    while (tabSize-- > 0) {
      tab.append(' ');
    }
    tabStr=tab.toString();
  }
  for (int i=0, myChildrenSize=myChildren.size(); i < myChildrenSize; i++) {
    GenerationNode child=myChildren.get(i);
    TemplateImpl childTemplate=child.generate(callback,surroundedText,generator,filters);
    boolean blockTag=child.isBlockTag();
    if (blockTag && !isNewLineBefore(builder.getText(),offset)) {
      builder.insertText(offset,"\n" + tabStr);
      offset+=tabStr.length() + 1;
    }
    int e=builder.insertTemplate(offset,childTemplate,null);
    offset=marker != null ? marker.getEndOffset() : builder.length();
    if (blockTag && !isNewLineAfter(builder.getText(),offset)) {
      builder.insertText(offset,"\n" + tabStr);
      offset+=tabStr.length() + 1;
    }
    if (end == -1 && e < offset) {
      end=e;
    }
  }
  if (end != -1) {
    builder.insertVariableSegment(end,TemplateImpl.END);
  }
  return builder.buildTemplate();
}
