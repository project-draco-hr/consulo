{
  PsiBuilder.Marker internalTypeMarker=builder.mark();
  String lastIdentifier=builder.getTokenText();
  if (!ParserUtils.getToken(builder,mIDENT)) {
    internalTypeMarker.rollbackTo();
    return fail;
  }
  boolean hasTypeArguments=false;
  if (parseTypeArgs) {
    if (allowDiamond && ParserUtils.lookAhead(builder,mLT,mGT)) {
      builder.advanceLexer();
      builder.advanceLexer();
      hasTypeArguments=true;
    }
 else {
      hasTypeArguments=TypeArguments.parseTypeArguments(builder,expressionPossible);
    }
  }
  internalTypeMarker.done(REFERENCE_ELEMENT);
  internalTypeMarker=internalTypeMarker.precede();
  while (mDOT.equals(builder.getTokenType())) {
    if ((ParserUtils.lookAhead(builder,mDOT,mSTAR) || ParserUtils.lookAhead(builder,mDOT,mNLS,mSTAR)) && forImport) {
      internalTypeMarker.drop();
      return hasTypeArguments ? mustBeType : mayBeType;
    }
    ParserUtils.getToken(builder,mDOT);
    if (forImport) {
      ParserUtils.getToken(builder,mNLS);
    }
    lastIdentifier=builder.getTokenText();
    if (!ParserUtils.getToken(builder,mIDENT)) {
      internalTypeMarker.rollbackTo();
      return fail;
    }
    hasTypeArguments=TypeArguments.parseTypeArguments(builder,expressionPossible) || hasTypeArguments;
    internalTypeMarker.done(REFERENCE_ELEMENT);
    internalTypeMarker=internalTypeMarker.precede();
  }
  char firstChar;
  if (lastIdentifier != null)   firstChar=lastIdentifier.charAt(0);
 else   return fail;
  if (checkUpperCase && (!Character.isUpperCase(firstChar) || DUMMY_IDENTIFIER.equals(lastIdentifier))) {
    internalTypeMarker.rollbackTo();
    return fail;
  }
  internalTypeMarker.drop();
  return hasTypeArguments ? mustBeType : mayBeType;
}
