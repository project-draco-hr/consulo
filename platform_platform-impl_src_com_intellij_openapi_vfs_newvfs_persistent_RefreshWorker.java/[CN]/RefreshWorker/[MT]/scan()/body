{
  final NewVirtualFile root=(NewVirtualFile)myRefreshQueue.peekFirst();
  final boolean rootDirty=root.isDirty();
  debug(LOG,"root=%s dirty=%b",root,rootDirty);
  if (!rootDirty)   return;
  final long t=System.currentTimeMillis();
  NewVirtualFileSystem fs=root.getFileSystem();
  final FileAttributes rootAttributes=getAttributes(fs,root);
  if (rootAttributes == null) {
    scheduleDeletion(root);
    root.markClean();
    debug(LOG,"root=%s time=%d",root,System.currentTimeMillis() - t);
    return;
  }
  if (rootAttributes != null && rootAttributes.isDirectory()) {
    fs=PersistentFS.replaceWithNativeFS(fs);
  }
  final PersistentFS persistence=PersistentFS.getInstance();
  main:   while (!myRefreshQueue.isEmpty() && !myCancelled) {
    final VirtualFileSystemEntry file=(VirtualFileSystemEntry)myRefreshQueue.pullFirst();
    final boolean fileDirty=file.isDirty();
    debug(LOG,"file=%s dirty=%b",file,fileDirty);
    if (!fileDirty)     continue;
    final FileAttributes attributes=getAttributes(fs,file);
    if (attributes == null) {
      scheduleDeletion(file);
      continue;
    }
    boolean checkFurther=true;
    final VirtualFileSystemEntry parent=file.getParent();
    if (parent != null && (checkAndScheduleAttributesChange(parent,file,attributes) || checkAndScheduleSymLinkTargetChange(parent,file,attributes,fs))) {
      checkFurther=false;
    }
 else     if (file.isDirectory()) {
      final VirtualDirectoryImpl dir=(VirtualDirectoryImpl)file;
      final boolean fullSync=dir.allChildrenLoaded();
      if (fullSync) {
        final Set<String> currentNames=newHashSet(persistence.list(file));
        final Set<String> upToDateNames=newHashSet(VfsUtil.filterNames(fs.list(file)));
        final Set<String> newNames=newHashSet(upToDateNames);
        newNames.removeAll(currentNames);
        final Set<String> deletedNames=newHashSet(currentNames);
        deletedNames.removeAll(upToDateNames);
        debug(LOG,"current=%s +%s -%s",currentNames,newNames,deletedNames);
        for (        String name : deletedNames) {
          scheduleDeletion(file.findChild(name));
        }
        for (        String name : newNames) {
          if (myCancelled)           break main;
          final FileAttributes childAttributes=getAttributes(fs,new FakeVirtualFile(file,name));
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory());
          }
 else {
            LOG.warn("fs=" + fs + " dir="+ file+ " name="+ name);
          }
        }
        for (        VirtualFile child : file.getChildren()) {
          if (myCancelled)           break main;
          if (!deletedNames.contains(child.getName())) {
            final FileAttributes childAttributes=getAttributes(fs,child);
            if (childAttributes != null) {
              checkAndScheduleChildRefresh(file,child,childAttributes);
            }
 else {
              LOG.warn("fs=" + fs + " dir="+ file+ " name="+ child.getName());
              scheduleDeletion(child);
            }
          }
        }
      }
 else {
        final Collection<VirtualFile> cachedChildren=file.getCachedChildren();
        debug(LOG,"cached=%s",cachedChildren);
        for (        VirtualFile child : cachedChildren) {
          if (myCancelled)           break main;
          final FileAttributes childAttributes=getAttributes(fs,child);
          if (childAttributes != null) {
            checkAndScheduleChildRefresh(file,child,childAttributes);
          }
 else {
            scheduleDeletion(child);
          }
        }
        final List<String> names=dir.getSuspiciousNames();
        debug(LOG,"suspicious=%s",names);
        for (        String name : names) {
          if (myCancelled)           break main;
          if (name.isEmpty())           continue;
          final VirtualFile fake=new FakeVirtualFile(file,name);
          final FileAttributes childAttributes=getAttributes(fs,fake);
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory());
          }
        }
      }
    }
 else {
      final long currentTimestamp=persistence.getTimeStamp(file);
      final long upToDateTimestamp=attributes.lastModified;
      final long currentLength=persistence.getLength(file);
      final long upToDateLength=attributes.length;
      if (currentTimestamp != upToDateTimestamp || currentLength != upToDateLength) {
        scheduleUpdateContent(file);
      }
    }
    if (checkFurther) {
      final boolean currentWritable=persistence.isWritable(file);
      final boolean upToDateWritable=attributes.isWritable();
      if (currentWritable != upToDateWritable) {
        scheduleWritableAttributeChange(file,currentWritable,upToDateWritable);
      }
    }
    file.markClean();
  }
  myFsCache.clear();
  debug(LOG,"root=%s time=%d",root,System.currentTimeMillis() - t);
}
