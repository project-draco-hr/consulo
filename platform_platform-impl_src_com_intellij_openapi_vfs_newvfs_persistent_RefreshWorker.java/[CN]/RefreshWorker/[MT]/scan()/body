{
  final NewVirtualFile root=(NewVirtualFile)myRefreshQueue.peekFirst();
  if (!root.isDirty())   return;
  NewVirtualFileSystem fs=root.getFileSystem();
  final FileAttributes rootAttributes=fs.getAttributes(root);
  if (rootAttributes == null) {
    scheduleDeletion(root);
    root.markClean();
    return;
  }
  if (rootAttributes != null && rootAttributes.isDirectory()) {
    fs=PersistentFS.replaceWithNativeFS(fs);
  }
  final PersistentFS persistence=PersistentFS.getInstance();
  while (!myRefreshQueue.isEmpty()) {
    final VirtualFileSystemEntry file=(VirtualFileSystemEntry)myRefreshQueue.pullFirst();
    if (!file.isDirty())     continue;
    final FileAttributes attributes=Comparing.equal(file,root) ? rootAttributes : fs.getAttributes(file);
    if (attributes == null) {
      scheduleDeletion(file);
      continue;
    }
    boolean checkFurther=true;
    final VirtualFileSystemEntry parent=file.getParent();
    if (parent != null && checkAndScheduleAttributesChange(parent,file,attributes)) {
      checkFurther=false;
    }
 else     if (file.isDirectory()) {
      final VirtualDirectoryImpl dir=(VirtualDirectoryImpl)file;
      final boolean fullSync=dir.allChildrenLoaded();
      if (fullSync) {
        final Set<String> currentNames=new HashSet<String>(Arrays.asList(persistence.list(file)));
        final Set<String> upToDateNames=new HashSet<String>(Arrays.asList(VfsUtil.filterNames(fs.list(file))));
        final Set<String> newNames=new HashSet<String>(upToDateNames);
        newNames.removeAll(currentNames);
        final Set<String> deletedNames=new HashSet<String>(currentNames);
        deletedNames.removeAll(upToDateNames);
        for (        String name : deletedNames) {
          scheduleDeletion(file.findChild(name));
        }
        for (        String name : newNames) {
          final FileAttributes childAttributes=fs.getAttributes(new FakeVirtualFile(file,name));
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory());
          }
 else {
            LOG.warn("fs=" + fs + " dir="+ file+ " name="+ name);
          }
        }
        for (        VirtualFile child : file.getChildren()) {
          if (!deletedNames.contains(child.getName())) {
            final FileAttributes childAttributes=fs.getAttributes(child);
            if (attributes != null) {
              checkAndScheduleChildRefresh(file,child,childAttributes);
            }
 else {
              LOG.warn("fs=" + fs + " dir="+ file+ " name="+ child.getName());
              scheduleDeletion(child);
            }
          }
        }
      }
 else {
        for (        VirtualFile child : file.getCachedChildren()) {
          final FileAttributes childAttributes=fs.getAttributes(child);
          if (childAttributes != null) {
            checkAndScheduleChildRefresh(file,child,childAttributes);
          }
 else {
            scheduleDeletion(child);
          }
        }
        final List<String> names=dir.getSuspiciousNames();
        for (        String name : names) {
          if (name.isEmpty())           continue;
          final VirtualFile fake=new FakeVirtualFile(file,name);
          final FileAttributes childAttributes=fs.getAttributes(fake);
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory());
          }
        }
      }
    }
 else {
      final long currentTimestamp=persistence.getTimeStamp(file);
      final long upToDateTimestamp=attributes.lastModified;
      final long currentLength=persistence.getLengthNoFollow(file);
      final long upToDateLength=attributes.length;
      if (currentTimestamp != upToDateTimestamp || currentLength != upToDateLength) {
        scheduleUpdateContent(file);
      }
    }
    if (checkFurther) {
      final boolean currentWritable=persistence.isWritable(file);
      final boolean upToDateWritable=attributes.isWritable();
      if (currentWritable != upToDateWritable) {
        scheduleWritableAttributeChange(file,currentWritable,upToDateWritable);
      }
    }
    file.markClean();
  }
}
