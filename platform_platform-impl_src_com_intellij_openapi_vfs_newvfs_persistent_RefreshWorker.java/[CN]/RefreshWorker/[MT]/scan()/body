{
  final NewVirtualFile root=(NewVirtualFile)myRefreshRoot;
  NewVirtualFileSystem delegate=root.getFileSystem();
  final int rootAttributes=delegate.getBooleanAttributes(root,FileUtil.BA_EXISTS | FileUtil.BA_DIRECTORY);
  if (root.isDirty() && (rootAttributes & FileUtil.BA_EXISTS) == 0) {
    scheduleDeletion(root);
    root.markClean();
  }
 else {
    if ((rootAttributes & FileUtil.BA_DIRECTORY) != 0) {
      delegate=PersistentFS.replaceWithNativeFS(delegate);
    }
    final PersistentFS persistence=(PersistentFS)ManagingFS.getInstance();
    while (!myRefreshQueue.isEmpty()) {
      final VirtualFileSystemEntry file=(VirtualFileSystemEntry)myRefreshQueue.pullFirst();
      if (!file.isDirty())       continue;
      if (file instanceof SymlinkDirectory) {
        final int attributes=delegate.getBooleanAttributes(file,-1);
        scheduleChildRefresh(file.getParent(),file,delegate,attributes);
      }
 else       if (file.isDirectory()) {
        final VirtualDirectoryImpl dir=(VirtualDirectoryImpl)file;
        final boolean fullSync=dir.allChildrenLoaded();
        if (fullSync) {
          final Set<String> currentNames=new HashSet<String>(Arrays.asList(persistence.list(file)));
          final Set<String> upToDateNames=new HashSet<String>(Arrays.asList(VfsUtil.filterNames(delegate.list(file))));
          final Set<String> newNames=new HashSet<String>(upToDateNames);
          newNames.removeAll(currentNames);
          final Set<String> deletedNames=new HashSet<String>(currentNames);
          deletedNames.removeAll(upToDateNames);
          for (          String name : deletedNames) {
            scheduleDeletion(file.findChild(name));
          }
          for (          String name : newNames) {
            boolean isDirectory=delegate.isDirectory(new FakeVirtualFile(file,name));
            scheduleCreation(file,name,isDirectory);
          }
          for (          VirtualFile child : file.getChildren()) {
            if (!deletedNames.contains(child.getName())) {
              final int childAttributes=delegate.getBooleanAttributes(child,-1);
              scheduleChildRefresh(file,child,delegate,childAttributes);
            }
          }
        }
 else {
          for (          VirtualFile child : file.getCachedChildren()) {
            final int childAttributes=delegate.getBooleanAttributes(child,-1);
            if ((childAttributes & FileUtil.BA_EXISTS) != 0) {
              scheduleChildRefresh(file,child,delegate,childAttributes);
            }
 else {
              scheduleDeletion(child);
            }
          }
          final List<String> names=dir.getSuspiciousNames();
          for (          String name : names) {
            if (name.isEmpty())             continue;
            final VirtualFile fake=new FakeVirtualFile(file,name);
            final int attributes=delegate.getBooleanAttributes(fake,FileUtil.BA_EXISTS | FileUtil.BA_DIRECTORY);
            if ((attributes & FileUtil.BA_EXISTS) != 0) {
              final boolean isDir=(attributes & FileUtil.BA_DIRECTORY) != 0;
              scheduleCreation(file,name,isDir);
            }
          }
        }
      }
 else {
        long currentTimestamp=persistence.getTimeStamp(file);
        long upToDateTimestamp=delegate.getTimeStamp(file);
        long currentLength=SystemInfo.isUnix ? persistence.getLength(file) : -1;
        long upToDateLength=SystemInfo.isUnix ? delegate.getLength(file) : -1;
        if (currentTimestamp != upToDateTimestamp || currentLength != upToDateLength) {
          scheduleUpdateContent(file);
        }
      }
      boolean currentWritable=persistence.isWritable(file);
      boolean upToDateWritable=delegate.isWritable(file);
      if (currentWritable != upToDateWritable) {
        scheduleWritableAttributeChange(file,currentWritable,upToDateWritable);
      }
      file.markClean();
    }
  }
}
