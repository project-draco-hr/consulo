{
  final NewVirtualFile root=(NewVirtualFile)myRefreshRoot;
  NewVirtualFileSystem delegate=root.getFileSystem();
  int attributes=delegate.getBooleanAttributes(root,NewVirtualFileSystem.BA_EXISTS | NewVirtualFileSystem.BA_DIRECTORY);
  if (root.isDirty() && (attributes & NewVirtualFileSystem.BA_EXISTS) == 0) {
    scheduleDeletion(root);
    root.markClean();
  }
 else {
    boolean isDir=(attributes & NewVirtualFileSystem.BA_DIRECTORY) != 0;
    if (isDir) {
      delegate=PersistentFS.replaceWithNativeFS(delegate);
    }
    final PersistentFS persistence=(PersistentFS)ManagingFS.getInstance();
    while (!myRefreshQueue.isEmpty()) {
      final VirtualFileSystemEntry file=(VirtualFileSystemEntry)myRefreshQueue.pullFirst();
      if (!file.isDirty())       continue;
      if (file.isDirectory()) {
        VirtualDirectoryImpl dir=(VirtualDirectoryImpl)file;
        final boolean fullSync=dir.allChildrenLoaded();
        if (fullSync) {
          Set<String> currentNames=new HashSet<String>(Arrays.asList(persistence.list(file)));
          Set<String> upToDateNames=new HashSet<String>(Arrays.asList(VfsUtil.filterNames(delegate.list(file))));
          Set<String> newNames=new HashSet<String>(upToDateNames);
          newNames.removeAll(currentNames);
          Set<String> deletedNames=new HashSet<String>(currentNames);
          deletedNames.removeAll(upToDateNames);
          for (          String name : deletedNames) {
            scheduleDeletion(file.findChild(name));
          }
          for (          String name : newNames) {
            boolean isDirectory=delegate.isDirectory(new FakeVirtualFile(file,name));
            scheduleCreation(file,name,isDirectory);
          }
          for (          VirtualFile child : file.getChildren()) {
            if (!deletedNames.contains(child.getName())) {
              int childAttributes=delegate.getBooleanAttributes(child,-1);
              scheduleChildRefresh(file,child,delegate,childAttributes);
            }
          }
        }
 else {
          for (          VirtualFile child : file.getCachedChildren()) {
            int childAttributes=delegate.getBooleanAttributes(child,-1);
            if ((childAttributes & NewVirtualFileSystem.BA_EXISTS) != 0) {
              scheduleChildRefresh(file,child,delegate,childAttributes);
            }
 else {
              scheduleDeletion(child);
            }
          }
          final List<String> names=dir.getSuspiciousNames();
          for (          String name : names) {
            if (name.isEmpty())             continue;
            final VirtualFile fake=new FakeVirtualFile(file,name);
            int attrs=delegate.getBooleanAttributes(fake,NewVirtualFileSystem.BA_EXISTS | NewVirtualFileSystem.BA_DIRECTORY);
            if ((attrs & NewVirtualFileSystem.BA_EXISTS) != 0) {
              boolean isDira=(attrs & NewVirtualFileSystem.BA_DIRECTORY) != 0;
              scheduleCreation(file,name,isDira);
            }
          }
        }
      }
 else {
        long currentTimestamp=persistence.getTimeStamp(file);
        long upToDateTimestamp=delegate.getTimeStamp(file);
        long currentLength=SystemInfo.isUnix ? persistence.getLength(file) : -1;
        long upToDateLength=SystemInfo.isUnix ? delegate.getLength(file) : -1;
        if (currentTimestamp != upToDateTimestamp || currentLength != upToDateLength) {
          scheduleUpdateContent(file);
        }
      }
      boolean currentWritable=persistence.isWritable(file);
      boolean upToDateWritable=delegate.isWritable(file);
      if (currentWritable != upToDateWritable) {
        scheduleWritableAttributeChange(file,currentWritable,upToDateWritable);
      }
      file.markClean();
    }
  }
}
