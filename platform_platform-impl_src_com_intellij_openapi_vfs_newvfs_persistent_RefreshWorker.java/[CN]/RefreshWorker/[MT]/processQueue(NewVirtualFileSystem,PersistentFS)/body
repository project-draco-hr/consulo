{
  TObjectHashingStrategy<String> strategy=FilePathHashingStrategy.create(fs.isCaseSensitive());
  while (!myRefreshQueue.isEmpty()) {
    Pair<NewVirtualFile,FileAttributes> pair=myRefreshQueue.pullFirst();
    NewVirtualFile file=pair.first;
    boolean fileDirty=file.isDirty();
    debug(LOG,"file=%s dirty=%b",file,fileDirty);
    if (!fileDirty)     continue;
    checkCancelled(file);
    FileAttributes attributes=pair.second != null ? pair.second : fs.getAttributes(file);
    if (attributes == null) {
      scheduleDeletion(file);
      continue;
    }
    NewVirtualFile parent=file.getParent();
    if (parent != null && checkAndScheduleFileTypeChange(parent,file,attributes)) {
      file.markClean();
      continue;
    }
    if (file.isDirectory()) {
      VirtualDirectoryImpl dir=(VirtualDirectoryImpl)file;
      boolean fullSync=dir.allChildrenLoaded();
      if (fullSync) {
        String[] currentNames=persistence.list(file);
        String[] upToDateNames=VfsUtil.filterNames(fs.list(file));
        Set<String> newNames=newTroveSet(strategy,upToDateNames);
        ContainerUtil.removeAll(newNames,currentNames);
        Set<String> deletedNames=newTroveSet(strategy,currentNames);
        ContainerUtil.removeAll(deletedNames,upToDateNames);
        OpenTHashSet<String> actualNames=null;
        if (!fs.isCaseSensitive()) {
          actualNames=new OpenTHashSet<String>(strategy,upToDateNames);
        }
        debug(LOG,"current=%s +%s -%s",currentNames,newNames,deletedNames);
        for (        String name : deletedNames) {
          scheduleDeletion(file.findChild(name));
        }
        for (        String name : newNames) {
          checkCancelled(file);
          FileAttributes childAttributes=fs.getAttributes(new FakeVirtualFile(file,name));
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory(),false);
          }
 else {
            LOG.warn("[+] fs=" + fs + " dir="+ file+ " name="+ name);
          }
        }
        for (        VirtualFile child : file.getChildren()) {
          checkCancelled(file);
          if (!deletedNames.contains(child.getName())) {
            FileAttributes childAttributes=fs.getAttributes(child);
            if (childAttributes != null) {
              checkAndScheduleChildRefresh(file,child,childAttributes);
              checkAndScheduleFileNameChange(actualNames,child);
            }
 else {
              LOG.warn("[x] fs=" + fs + " dir="+ file+ " name="+ child.getName());
              scheduleDeletion(child);
            }
          }
        }
      }
 else {
        Collection<VirtualFile> cachedChildren=file.getCachedChildren();
        OpenTHashSet<String> actualNames=null;
        if (!fs.isCaseSensitive()) {
          actualNames=new OpenTHashSet<String>(strategy,VfsUtil.filterNames(fs.list(file)));
        }
        debug(LOG,"cached=%s actual=%s",cachedChildren,actualNames);
        for (        VirtualFile child : cachedChildren) {
          checkCancelled(file);
          FileAttributes childAttributes=fs.getAttributes(child);
          if (childAttributes != null) {
            checkAndScheduleChildRefresh(file,child,childAttributes);
            checkAndScheduleFileNameChange(actualNames,child);
          }
 else {
            scheduleDeletion(child);
          }
        }
        List<String> names=dir.getSuspiciousNames();
        debug(LOG,"suspicious=%s",names);
        for (        String name : names) {
          checkCancelled(file);
          if (name.isEmpty())           continue;
          VirtualFile fake=new FakeVirtualFile(file,name);
          FileAttributes childAttributes=fs.getAttributes(fake);
          if (childAttributes != null) {
            scheduleCreation(file,name,childAttributes.isDirectory(),false);
          }
        }
      }
    }
 else {
      long currentTimestamp=persistence.getTimeStamp(file);
      long upToDateTimestamp=attributes.lastModified;
      long currentLength=persistence.getLength(file);
      long upToDateLength=attributes.length;
      if (currentTimestamp != upToDateTimestamp || currentLength != upToDateLength) {
        scheduleUpdateContent(file);
      }
    }
    boolean currentWritable=persistence.isWritable(file);
    boolean upToDateWritable=attributes.isWritable();
    if (currentWritable != upToDateWritable) {
      scheduleAttributeChange(file,VirtualFile.PROP_WRITABLE,currentWritable,upToDateWritable);
    }
    if (SystemInfo.isWindows) {
      boolean currentHidden=file.is(VFileProperty.HIDDEN);
      boolean upToDateHidden=attributes.isHidden();
      if (currentHidden != upToDateHidden) {
        scheduleAttributeChange(file,VirtualFile.PROP_HIDDEN,currentHidden,upToDateHidden);
      }
    }
    if (attributes.isSymLink()) {
      String currentTarget=file.getCanonicalPath();
      String upToDateTarget=fs.resolveSymLink(file);
      String upToDateVfsTarget=upToDateTarget != null ? FileUtil.toSystemIndependentName(upToDateTarget) : null;
      if (!Comparing.equal(currentTarget,upToDateVfsTarget)) {
        scheduleAttributeChange(file,VirtualFile.PROP_SYMLINK_TARGET,currentTarget,upToDateVfsTarget);
      }
    }
    if (myIsRecursive || !file.isDirectory()) {
      file.markClean();
    }
  }
}
