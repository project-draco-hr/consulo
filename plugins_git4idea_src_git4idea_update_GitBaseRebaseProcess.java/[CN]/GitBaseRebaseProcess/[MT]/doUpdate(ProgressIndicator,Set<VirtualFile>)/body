{
  ProjectManagerEx projectManager=ProjectManagerEx.getInstanceEx();
  projectManager.blockReloadingProjectOnExternalChanges();
  this.myProgressIndicator=progressIndicator;
  try {
    if (areRootsUnderRebase(roots))     return;
    if (!saveProjectChangesBeforeUpdate())     return;
    try {
      for (      final VirtualFile root : roots) {
        List<GitRebaseUtils.CommitInfo> skippedCommits=null;
        try {
          final GitBranch branch=GitBranch.current(myProject,root);
          if (branch == null) {
            continue;
          }
          final String value=branch.getTrackedRemoteName(myProject,root);
          if (value == null || value.length() == 0) {
            continue;
          }
          final Ref<Boolean> cancelled=new Ref<Boolean>(false);
          final Ref<Throwable> ex=new Ref<Throwable>();
          saveRootChangesBeforeUpdate(root);
          try {
            markStart(root);
            try {
              GitLineHandler h=makeStartHandler(root);
              RebaseConflictDetector rebaseConflictDetector=new RebaseConflictDetector();
              h.addLineListener(rebaseConflictDetector);
              try {
                GitHandlerUtil.doSynchronouslyWithExceptions(h,progressIndicator,GitHandlerUtil.formatOperationName("Updating",root));
              }
  finally {
                if (!rebaseConflictDetector.isRebaseConflict()) {
                  myExceptions.addAll(h.errors());
                }
                cleanupHandler(root,h);
              }
              while (rebaseConflictDetector.isRebaseConflict() && !cancelled.get()) {
                mergeFiles(root,cancelled,ex,true);
                if (ex.get() != null) {
                  throw GitUtil.rethrowVcsException(ex.get());
                }
                checkLocallyModified(root,cancelled,ex);
                if (ex.get() != null) {
                  throw GitUtil.rethrowVcsException(ex.get());
                }
                if (cancelled.get()) {
                  break;
                }
                doRebase(progressIndicator,root,rebaseConflictDetector,"--continue");
                while (rebaseConflictDetector.isNoChange()) {
                  if (skippedCommits == null) {
                    skippedCommits=new ArrayList<GitRebaseUtils.CommitInfo>();
                    mySkippedCommits.put(root,skippedCommits);
                  }
                  skippedCommits.add(GitRebaseUtils.getCurrentRebaseCommit(root));
                  doRebase(progressIndicator,root,rebaseConflictDetector,"--skip");
                }
              }
              if (cancelled.get()) {
                myExceptions.add(new VcsException("The update process was cancelled for " + root.getPresentableUrl()));
                doRebase(progressIndicator,root,rebaseConflictDetector,"--abort");
              }
            }
  finally {
              markEnd(root,cancelled.get());
            }
          }
  finally {
            restoreRootChangesAfterUpdate(root,cancelled);
          }
        }
 catch (        VcsException ex) {
          myExceptions.add(ex);
        }
      }
    }
  finally {
      restoreProjectChangesAfterUpdate();
    }
  }
  finally {
    projectManager.unblockReloadingProjectOnExternalChanges();
  }
}
