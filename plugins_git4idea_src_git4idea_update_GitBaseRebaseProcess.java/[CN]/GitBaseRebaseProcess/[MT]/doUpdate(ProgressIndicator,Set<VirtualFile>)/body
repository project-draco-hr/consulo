{
  LOG.info("GitBaseRebaseProcess.doUpdate started");
  ProjectManagerEx projectManager=ProjectManagerEx.getInstanceEx();
  projectManager.blockReloadingProjectOnExternalChanges();
  myProgressIndicator=progressIndicator;
  try {
    if (isRebaseInProgressAndNotify(roots)) {
      return;
    }
    if (!saveProjectChangesBeforeUpdate()) {
      return;
    }
    if (!allTrackedBranchesConfigured(roots)) {
      return;
    }
    try {
      for (      final VirtualFile root : roots) {
        List<GitRebaseUtils.CommitInfo> skippedCommits=null;
        try {
          final Ref<Boolean> cancelled=new Ref<Boolean>(false);
          final Ref<Throwable> ex=new Ref<Throwable>();
          saveRootChangesBeforeUpdate(root);
          boolean hadAbortErrors=false;
          try {
            markStart(root);
            try {
              GitLineHandler h=makeStartHandler(root);
              RebaseConflictDetector rebaseConflictDetector=new RebaseConflictDetector();
              h.addLineListener(rebaseConflictDetector);
              try {
                GitHandlerUtil.doSynchronouslyWithExceptions(h,progressIndicator,GitHandlerUtil.formatOperationName("Updating",root));
              }
  finally {
                if (!rebaseConflictDetector.isRebaseConflict()) {
                  myExceptions.addAll(h.errors());
                }
                cleanupHandler(root,h);
              }
              while (rebaseConflictDetector.isRebaseConflict() && !cancelled.get() && !hadAbortErrors) {
                mergeFiles(root,cancelled,ex,true);
                if (ex.get() != null) {
                  throw GitUtil.rethrowVcsException(ex.get());
                }
                checkLocallyModified(root,cancelled,ex);
                if (ex.get() != null) {
                  throw GitUtil.rethrowVcsException(ex.get());
                }
                if (cancelled.get()) {
                  break;
                }
                Collection<VcsException> exceptions=doRebase(progressIndicator,root,rebaseConflictDetector,"--continue");
                while (rebaseConflictDetector.isNoChange() && !hasAbortExceptions(exceptions)) {
                  if (skippedCommits == null) {
                    skippedCommits=new ArrayList<GitRebaseUtils.CommitInfo>();
                    mySkippedCommits.put(root,skippedCommits);
                  }
                  skippedCommits.add(GitRebaseUtils.getCurrentRebaseCommit(root));
                  exceptions=doRebase(progressIndicator,root,rebaseConflictDetector,"--skip");
                }
                hadAbortErrors=hasAbortExceptions(exceptions);
              }
              if (cancelled.get() || hadAbortErrors) {
                myExceptions.add(new VcsException("The update process was " + (hadAbortErrors ? "aborted" : "cancelled") + " for "+ root.getPresentableUrl()));
                doRebase(progressIndicator,root,rebaseConflictDetector,"--abort");
                progressIndicator.setText2("Refreshing files for the root " + root.getPath());
                root.refresh(false,true);
              }
            }
  finally {
              markEnd(root,cancelled.get());
            }
          }
  finally {
            restoreRootChangesAfterUpdate(root,cancelled);
          }
        }
 catch (        VcsException ex) {
          myExceptions.add(ex);
        }
      }
    }
  finally {
      restoreProjectChangesAfterUpdate();
    }
  }
  finally {
    projectManager.unblockReloadingProjectOnExternalChanges();
  }
}
