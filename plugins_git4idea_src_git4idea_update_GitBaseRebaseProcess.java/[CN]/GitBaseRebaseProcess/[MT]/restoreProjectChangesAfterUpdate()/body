{
  LOG.info("GitBaseRebaseProcess.restoreProjectChangesAfterUpdate update policy: " + getUpdatePolicy() + " myShelvedChangeList: "+ myShelvedChangeList);
  if (mySkippedCommits.size() > 0) {
    GitSkippedCommits.showSkipped(myProject,mySkippedCommits);
  }
  if (getUpdatePolicy() == GitVcsSettings.UpdateChangesPolicy.SHELVE) {
    if (myShelvedChangeList != null) {
      myProgressIndicator.setText(GitBundle.getString("update.unshelving.changes"));
      GitStashUtils.doSystemUnshelve(myProject,myShelvedChangeList,myShelveManager,myChangeManager,myExceptions);
    }
  }
  if (getUpdatePolicy() == GitVcsSettings.UpdateChangesPolicy.SHELVE || getUpdatePolicy() == GitVcsSettings.UpdateChangesPolicy.STASH) {
    VcsDirtyScopeManager m=VcsDirtyScopeManager.getInstance(myProject);
    final boolean isStash=getUpdatePolicy() == GitVcsSettings.UpdateChangesPolicy.STASH;
    HashSet<File> filesToRefresh=isStash ? new HashSet<File>() : null;
    for (    LocalChangeList changeList : myListsCopy) {
      LOG.info("GitBaseRebaseProcess.restoreProjectChangesAfterUpdate refreshing files from changelist " + changeList);
      for (      Change c : changeList.getChanges()) {
        ContentRevision after=c.getAfterRevision();
        if (after != null) {
          m.fileDirty(after.getFile());
          if (isStash) {
            filesToRefresh.add(after.getFile().getIOFile());
          }
        }
        ContentRevision before=c.getBeforeRevision();
        if (before != null) {
          m.fileDirty(before.getFile());
          if (isStash) {
            filesToRefresh.add(before.getFile().getIOFile());
          }
        }
      }
    }
    if (isStash) {
      LocalFileSystem.getInstance().refreshIoFiles(filesToRefresh);
    }
    UIUtil.invokeLaterIfNeeded(new Runnable(){
      public void run(){
        myChangeManager.invokeAfterUpdate(new Runnable(){
          public void run(){
            for (            LocalChangeList changeList : myListsCopy) {
              final Collection<Change> changes=changeList.getChanges();
              LOG.debug("restoreProjectChangesAfterUpdate.invokeAfterUpdate changeList: " + changeList.getName() + " changes: "+ changes.size());
              if (!changes.isEmpty()) {
                LOG.debug("After restoring files: moving " + changes.size() + " changes to '"+ changeList.getName()+ "'");
                myChangeManager.moveChangesTo(changeList,changes.toArray(new Change[changes.size()]));
              }
            }
          }
        }
,InvokeAfterUpdateMode.BACKGROUND_NOT_CANCELLABLE,GitBundle.getString("update.restoring.change.lists"),ModalityState.NON_MODAL);
      }
    }
);
  }
}
