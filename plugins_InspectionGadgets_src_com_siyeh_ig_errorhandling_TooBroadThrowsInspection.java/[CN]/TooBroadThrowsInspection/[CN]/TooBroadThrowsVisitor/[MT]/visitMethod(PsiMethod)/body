{
  super.visitMethod(method);
  final PsiReferenceList throwsList=method.getThrowsList();
  final PsiJavaCodeReferenceElement[] throwsReferences=throwsList.getReferenceElements();
  if (throwsReferences.length == 0) {
    return;
  }
  final PsiCodeBlock body=method.getBody();
  if (body == null) {
    return;
  }
  final Set<PsiClassType> exceptionsThrown=ExceptionUtils.calculateExceptionsThrown(body);
  final PsiClassType[] referencedExceptions=throwsList.getReferencedTypes();
  final Set<PsiClassType> exceptionsDeclared=new HashSet(referencedExceptions.length);
  ContainerUtil.addAll(exceptionsDeclared,referencedExceptions);
  final int referencedExceptionsLength=referencedExceptions.length;
  for (int i=0; i < referencedExceptionsLength; i++) {
    final PsiClassType referencedException=referencedExceptions[i];
    if (onlyWarnOnRootExceptions) {
      if (!ExceptionUtils.isGenericExceptionClass(referencedException)) {
        continue;
      }
    }
    final List<SmartTypePointer> exceptionsMasked=new ArrayList();
    final SmartTypePointerManager pointerManager=SmartTypePointerManager.getInstance(body.getProject());
    for (    PsiClassType exceptionThrown : exceptionsThrown) {
      if (referencedException.isAssignableFrom(exceptionThrown) && !exceptionsDeclared.contains(exceptionThrown)) {
        exceptionsMasked.add(pointerManager.createSmartTypePointer(exceptionThrown));
      }
    }
    if (!exceptionsMasked.isEmpty()) {
      final PsiJavaCodeReferenceElement throwsReference=throwsReferences[i];
      final boolean originalNeeded=exceptionsThrown.contains(referencedException);
      registerError(throwsReference,exceptionsMasked,Boolean.valueOf(originalNeeded));
    }
  }
}
