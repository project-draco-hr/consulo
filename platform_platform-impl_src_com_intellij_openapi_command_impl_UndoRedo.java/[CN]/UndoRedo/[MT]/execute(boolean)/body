{
  if (!myUndoableGroup.isUndoable()) {
    reportCannotUndo(CommonBundle.message("cannot.undo.error.contains.nonundoable.changes.message"),myUndoableGroup.getAffectedDocuments());
    return false;
  }
  Set<DocumentReference> clashing=getStackHolder().collectClashingActions(myUndoableGroup);
  if (!clashing.isEmpty()) {
    reportCannotUndo(CommonBundle.message("cannot.undo.error.other.affected.files.changed.message"),clashing);
    return false;
  }
  if (myUndoableGroup.shouldAskConfirmation(isRedo())) {
    if (!askUser())     return false;
  }
 else {
    if (restore(getBeforeState())) {
      setBeforeState(new EditorAndState(myEditor,myEditor.getState(FileEditorStateLevel.UNDO)));
      return true;
    }
  }
  Collection<VirtualFile> readOnlyFiles=collectReadOnlyAffectedFiles();
  if (!readOnlyFiles.isEmpty()) {
    final Project project=myManager.getProject();
    final VirtualFile[] files=VfsUtil.toVirtualFileArray(readOnlyFiles);
    if (project == null) {
      return false;
    }
    final ReadonlyStatusHandler.OperationStatus operationStatus=ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(files);
    if (operationStatus.hasReadonlyFiles()) {
      return false;
    }
  }
  Collection<Document> readOnlyDocuments=collectReadOnlyDocuments();
  if (!readOnlyDocuments.isEmpty()) {
    for (    Document document : readOnlyDocuments) {
      document.fireReadOnlyModificationAttempt();
    }
    return false;
  }
  getStackHolder().removeFromStacks(myUndoableGroup);
  if (!drop) {
    getReverseStackHolder().addToStacks(myUndoableGroup);
  }
  performAction();
  restore(getAfterState());
  return true;
}
