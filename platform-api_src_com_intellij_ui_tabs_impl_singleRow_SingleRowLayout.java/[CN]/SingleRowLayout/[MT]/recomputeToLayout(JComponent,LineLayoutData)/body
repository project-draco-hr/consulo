{
  final int toolbarInset=myTabs.getToolbarInset();
  data.displayedHToolbar=myTabs.myHorizontalSide && selectedToolbar != null;
  data.toFitWidth=myTabs.getWidth() - data.insets.left - data.insets.right- (data.displayedHToolbar ? toolbarInset : 0);
  if (myTabs.isGhostsAlwaysVisible()) {
    data.toFitWidth-=myTabs.getGhostTabWidth() * 2;
  }
  for (  TabInfo eachInfo : myTabs.myVisibleInfos) {
    data.requiredWidth+=myTabs.myInfo2Label.get(eachInfo).getPreferredSize().width;
    data.toLayout.add(eachInfo);
  }
  while (true) {
    if (data.requiredWidth <= data.toFitWidth - data.eachX)     break;
    if (data.toLayout.size() == 0)     break;
    final TabInfo first=data.toLayout.get(0);
    final TabInfo last=data.toLayout.get(data.toLayout.size() - 1);
    if (myRowDropPolicy == RowDropPolicy.leftFirst) {
      if (first != myTabs.getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else       if (last != myTabs.getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else {
        break;
      }
    }
 else {
      if (last != myTabs.getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else       if (first != myTabs.getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else {
        break;
      }
    }
  }
  for (int i=1; i < myTabs.myVisibleInfos.size() - 1; i++) {
    final TabInfo each=myTabs.myVisibleInfos.get(i);
    final TabInfo prev=myTabs.myVisibleInfos.get(i - 1);
    final TabInfo next=myTabs.myVisibleInfos.get(i + 1);
    if (data.toLayout.contains(each) && data.toDrop.contains(prev)) {
      myLeftGhost.setInfo(prev);
    }
 else     if (data.toLayout.contains(each) && data.toDrop.contains(next)) {
      myRightGhost.setInfo(next);
    }
  }
}
