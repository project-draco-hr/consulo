{
  int y=data.insets.top;
  boolean reachedBounds=false;
  if (data.leftGhostVisible || myTabs.isGhostsAlwaysVisible()) {
    data.leftGhost=new Rectangle(data.eachX,y,myTabs.getGhostTabWidth(),myTabs.myHeaderFitSize.height);
    myTabs.layout(myLeftGhost,data.leftGhost);
    data.eachX+=data.leftGhost.width;
  }
  int deltaToFit=0;
  if (data.leftGhostVisible || data.rightGhostVisible) {
    if (data.requiredWidth < data.toFitWidth) {
      deltaToFit=(int)Math.floor((data.toFitWidth - data.requiredWidth) / (double)data.toLayout.size());
    }
  }
  int totalWidth=0;
  int leftX=data.eachX;
  for (  TabInfo eachInfo : data.toLayout) {
    final TabLabel label=myTabs.myInfo2Label.get(eachInfo);
    final Dimension eachSize=label.getPreferredSize();
    boolean isLast=data.toLayout.indexOf(eachInfo) == data.toLayout.size() - 1;
    if (!isLast || deltaToFit == 0) {
      myTabs.layout(label,data.eachX,y,eachSize.width + deltaToFit,myTabs.myHeaderFitSize.height);
    }
 else {
      int width=data.toFitWidth - totalWidth;
      myTabs.layout(label,data.eachX,y,width,myTabs.myHeaderFitSize.height);
    }
    label.setAligmentToCenter(deltaToFit > 0);
    data.eachX=(int)label.getBounds().getMaxX();
    data.eachX++;
    totalWidth=(int)(label.getBounds().getMaxX() - leftX);
  }
  for (  TabInfo eachInfo : data.toDrop) {
    myTabs.resetLayout(myTabs.myInfo2Label.get(eachInfo));
  }
  if (data.rightGhostVisible || myTabs.isGhostsAlwaysVisible()) {
    data.rightGhost=new Rectangle(data.eachX,y,myTabs.getGhostTabWidth(),myTabs.myHeaderFitSize.height);
    myTabs.layout(myRightGhost,data.rightGhost);
  }
}
