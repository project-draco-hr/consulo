{
  final Breakpoint[] selectedBreakpoints=getSelectedBreakpoints();
  if (selectedBreakpoints.length == 0) {
    return;
  }
  final boolean inTreeMode=isTreeShowing();
  final int minSelectionIndex;
  if (inTreeMode) {
    minSelectionIndex=Math.max(0,myTree.getSelectionModel().getMinSelectionRow());
  }
 else {
    minSelectionIndex=Math.max(0,myTable.getSelectionModel().getMinSelectionIndex());
  }
  myTree.removeBreakpoints(selectedBreakpoints);
  myTable.getModel().removeBreakpoints(selectedBreakpoints);
  myCurrentViewableBreakpoint=null;
  if (inTreeMode) {
    if (myTree.getRowCount() > 0) {
      int rowToSelect=minSelectionIndex >= myTree.getRowCount() ? myTree.getRowCount() - 1 : minSelectionIndex;
      final TreePath path=myTree.getPathForRow(rowToSelect);
      if (path != null) {
        TreeUtil.selectPath(myTree,path,true);
      }
    }
  }
 else {
    if (myTable.getRowCount() > 0) {
      int indexToSelect=minSelectionIndex >= myTable.getRowCount() ? myTable.getRowCount() - 1 : minSelectionIndex;
      TableUtil.selectRows(myTable,new int[]{indexToSelect});
    }
  }
  updateCurrentBreakpointPropertiesPanel();
}
