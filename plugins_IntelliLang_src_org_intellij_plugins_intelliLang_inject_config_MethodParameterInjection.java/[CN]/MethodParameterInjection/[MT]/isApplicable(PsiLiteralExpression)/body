{
  PsiElement e=element;
  while (!(e.getParent() instanceof PsiExpressionList)) {
    e=e.getParent();
    if (!(e instanceof PsiExpression)) {
      return false;
    }
  }
  final PsiParameter parameter=PsiUtilEx.getParameterForArgument((PsiExpression)e);
  if (parameter == null) {
    return false;
  }
  final PsiElement _parent=parameter.getParent();
  final PsiParameterList list;
  if (_parent instanceof PsiParameterList) {
    list=(PsiParameterList)_parent;
  }
 else {
    return false;
  }
  final PsiMethod method=PsiTreeUtil.getParentOfType(list,PsiMethod.class,true,true);
  if (method == null)   return false;
  final String methodName=method.getName();
  final int parameterIndex=list.getParameterIndex(parameter);
  boolean found=false;
  for (  MethodInfo info : myParameterMap.values()) {
    if (info.methodName.equals(methodName) && info.paramFlags.length == list.getParametersCount() && info.paramFlags[parameterIndex]) {
      found=true;
      break;
    }
  }
  if (!found)   return false;
  final PsiClass psiClass=method.getContainingClass();
  if (psiClass == null)   return false;
  if (myClassName.equals(psiClass.getQualifiedName()))   return true;
  if (myApplyInHierarchy) {
    final GlobalSearchScope scope=GlobalSearchScope.allScope(element.getProject());
    final PsiClass baseClass=JavaPsiFacade.getInstance(element.getProject()).findClass(myClassName,scope);
    if (baseClass != null && psiClass.isInheritor(baseClass,true)) {
      return true;
    }
  }
  return false;
}
