{
  Transferable content=CopyPasteManager.getInstance().getContents();
  if (content != null) {
    String text=null;
    try {
      text=(String)content.getTransferData(DataFlavor.stringFlavor);
    }
 catch (    Exception e) {
      editor.getComponent().getToolkit().beep();
    }
    if (text == null)     return;
    final CodeInsightSettings settings=CodeInsightSettings.getInstance();
    final Map<CopyPastePostProcessor,TextBlockTransferableData> extraData=new HashMap<CopyPastePostProcessor,TextBlockTransferableData>();
    for (    CopyPastePostProcessor processor : Extensions.getExtensions(CopyPastePostProcessor.EP_NAME)) {
      TextBlockTransferableData data=processor.extractTransferableData(content);
      if (data != null) {
        extraData.put(processor,data);
      }
    }
    text=TextBlockTransferable.convertLineSeparators(text,"\n",extraData.values());
    final CaretModel caretModel=editor.getCaretModel();
    final SelectionModel selectionModel=editor.getSelectionModel();
    final int col=caretModel.getLogicalPosition().column;
    final int blockIndentAnchorColumn;
    final int caretOffset=caretModel.getOffset();
    if (selectionModel.hasSelection() && caretOffset >= selectionModel.getSelectionStart() && caretOffset < selectionModel.getSelectionEnd()) {
      blockIndentAnchorColumn=editor.offsetToLogicalPosition(selectionModel.getSelectionStart()).column;
    }
 else {
      blockIndentAnchorColumn=col;
    }
    RawText rawText=RawText.fromTransferable(content);
    String newText=text;
    for (    CopyPastePreProcessor preProcessor : Extensions.getExtensions(CopyPastePreProcessor.EP_NAME)) {
      newText=preProcessor.preprocessOnPaste(project,file,editor,newText,rawText);
    }
    int indentOptions=text.equals(newText) ? settings.REFORMAT_ON_PASTE : CodeInsightSettings.REFORMAT_BLOCK;
    text=newText;
    if (LanguageFormatting.INSTANCE.forContext(file) == null && indentOptions != CodeInsightSettings.NO_REFORMAT) {
      indentOptions=CodeInsightSettings.INDENT_BLOCK;
    }
    int length=text.length();
    final String text1=text;
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      public void run(){
        EditorModificationUtil.insertStringAtCaret(editor,text1,false,true);
      }
    }
);
    int offset=caretModel.getOffset() - length;
    if (offset < 0) {
      length+=offset;
      offset=0;
    }
    final RangeMarker bounds=document.createRangeMarker(offset,offset + length);
    caretModel.moveToOffset(bounds.getEndOffset());
    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
    selectionModel.removeSelection();
    final Ref<Boolean> indented=new Ref<Boolean>(Boolean.FALSE);
    for (    Map.Entry<CopyPastePostProcessor,TextBlockTransferableData> e : extraData.entrySet()) {
      e.getKey().processTransferableData(project,editor,bounds,col,indented,e.getValue());
    }
    final int indentOptions1=indentOptions;
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      public void run(){
switch (indentOptions1) {
case CodeInsightSettings.INDENT_BLOCK:
          if (!indented.get()) {
            indentBlock(project,editor,bounds.getStartOffset(),bounds.getEndOffset(),blockIndentAnchorColumn);
          }
        break;
case CodeInsightSettings.INDENT_EACH_LINE:
      if (!indented.get()) {
        indentEachLine(project,editor,bounds.getStartOffset(),bounds.getEndOffset());
      }
    break;
case CodeInsightSettings.REFORMAT_BLOCK:
  indentEachLine(project,editor,bounds.getStartOffset(),bounds.getEndOffset());
reformatBlock(project,editor,bounds.getStartOffset(),bounds.getEndOffset());
break;
}
}
}
);
if (bounds.isValid()) {
caretModel.moveToOffset(bounds.getEndOffset());
editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
selectionModel.removeSelection();
editor.putUserData(EditorEx.LAST_PASTED_REGION,new TextRange(bounds.getStartOffset(),bounds.getEndOffset()));
}
}
}
