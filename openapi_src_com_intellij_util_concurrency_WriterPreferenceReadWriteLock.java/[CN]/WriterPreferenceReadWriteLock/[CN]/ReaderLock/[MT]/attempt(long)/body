{
  if (Thread.interrupted())   throw new InterruptedException();
  InterruptedException ie=null;
synchronized (this) {
    if (msecs <= 0)     return startRead();
 else     if (startReadFromNewReader())     return true;
 else {
      long waitTime=msecs;
      long start=System.currentTimeMillis();
      for (; ; ) {
        try {
          ReaderLock.this.wait(waitTime);
        }
 catch (        InterruptedException ex) {
          cancelledWaitingReader();
          ie=ex;
          break;
        }
        if (startReadFromWaitingReader())         return true;
 else {
          waitTime=msecs - (System.currentTimeMillis() - start);
          if (waitTime <= 0) {
            cancelledWaitingReader();
            break;
          }
        }
      }
    }
  }
  writerLock_.signalWaiters();
  if (ie != null)   throw ie;
 else   return false;
}
