{
  final String newTrunkUrl=SVNPathUtil.removeTail(trunkUrl).trim();
  if (newTrunkUrl.length() == 0 || "/".equals(newTrunkUrl)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  final String newPath=new File(path).getParent();
  if (newPath.length() < branchRootPath.length()) {
    if (targetRevision == -1) {
      return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
    }
    final SVNInfo svnInfo=getInfo(new File(branchRootPath));
    if (svnInfo == null || svnInfo.getRevision() == null || svnInfo.getURL() == null) {
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
    try {
      return goUpInRepo(revisionAsked,targetRevision,svnInfo.getURL().removePathTail(),newTrunkUrl);
    }
 catch (    SVNException e) {
      LOG.info(e);
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
  }
  return checkPathGoingUp(revisionAsked,targetRevision,branchRootPath,newPath,newTrunkUrl,false);
}
