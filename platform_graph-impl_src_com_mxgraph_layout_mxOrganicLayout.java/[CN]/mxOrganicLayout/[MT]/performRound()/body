{
  boolean energyHasChanged=false;
  for (int i=0; i < v.length; i++) {
    int index=i;
    double oldNodeDistribution=getNodeDistribution(index);
    double oldEdgeDistance=getEdgeDistanceFromNode(index);
    oldEdgeDistance+=getEdgeDistanceAffectedNodes(index);
    double oldEdgeCrossing=getEdgeCrossingAffectedEdges(index);
    double oldBorderLine=getBorderline(index);
    double oldEdgeLength=getEdgeLengthAffectedEdges(index);
    double oldAdditionFactors=getAdditionFactorsEnergy(index);
    for (int j=0; j < triesPerCell; j++) {
      double movex=moveRadius * xNormTry[j];
      double movey=moveRadius * yNormTry[j];
      double oldx=v[index].x;
      double oldy=v[index].y;
      v[index].x=v[index].x + movex;
      v[index].y=v[index].y + movey;
      double energyDelta=calcEnergyDelta(index,oldNodeDistribution,oldEdgeDistance,oldEdgeCrossing,oldBorderLine,oldEdgeLength,oldAdditionFactors);
      if (energyDelta < 0) {
        energyHasChanged=true;
        break;
      }
 else {
        v[index].x=oldx;
        v[index].y=oldy;
      }
    }
  }
  if (energyHasChanged) {
    unchangedEnergyRoundCount=0;
  }
 else {
    unchangedEnergyRoundCount++;
    moveRadius/=2.0;
  }
  if (unchangedEnergyRoundCount >= unchangedEnergyRoundTermination) {
    iteration=maxIterations;
  }
  double newMoveRadius=moveRadius * radiusScaleFactor;
  if (moveRadius - newMoveRadius < minMoveRadius) {
    newMoveRadius=moveRadius - minMoveRadius;
  }
  if (newMoveRadius <= minMoveRadius) {
    iteration=maxIterations;
  }
  if (newMoveRadius < fineTuningRadius) {
    isFineTuning=true;
  }
  moveRadius=newMoveRadius;
}
