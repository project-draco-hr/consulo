{
  int n=0;
  double minjX, minjY, miniX, miniY, maxjX, maxjY, maxiX, maxiY;
  if (isOptimizeEdgeCrossing) {
    double iP1X=v[e[i].source].x;
    double iP1Y=v[e[i].source].y;
    double iP2X=v[e[i].target].x;
    double iP2Y=v[e[i].target].y;
    for (int j=0; j < e.length; j++) {
      double jP1X=v[e[j].source].x;
      double jP1Y=v[e[j].source].y;
      double jP2X=v[e[j].target].x;
      double jP2Y=v[e[j].target].y;
      if (j != i) {
        if (iP1X < iP2X) {
          miniX=iP1X;
          maxiX=iP2X;
        }
 else {
          miniX=iP2X;
          maxiX=iP1X;
        }
        if (jP1X < jP2X) {
          minjX=jP1X;
          maxjX=jP2X;
        }
 else {
          minjX=jP2X;
          maxjX=jP1X;
        }
        if (maxiX < minjX || miniX > maxjX) {
          continue;
        }
        if (iP1Y < iP2Y) {
          miniY=iP1Y;
          maxiY=iP2Y;
        }
 else {
          miniY=iP2Y;
          maxiY=iP1Y;
        }
        if (jP1Y < jP2Y) {
          minjY=jP1Y;
          maxjY=jP2Y;
        }
 else {
          minjY=jP2Y;
          maxjY=jP1Y;
        }
        if (maxiY < minjY || miniY > maxjY) {
          continue;
        }
        if (((iP1X != jP1X) && (iP1Y != jP1Y)) && ((iP1X != jP2X) && (iP1Y != jP2Y)) && ((iP2X != jP1X) && (iP2Y != jP1Y))&& ((iP2X != jP2X) && (iP2Y != jP2Y))) {
          boolean intersects=((Line2D.relativeCCW(iP1X,iP1Y,iP2X,iP2Y,jP1X,jP1Y) != Line2D.relativeCCW(iP1X,iP1Y,iP2X,iP2Y,jP2X,jP2Y)) && (Line2D.relativeCCW(jP1X,jP1Y,jP2X,jP2Y,iP1X,iP1Y) != Line2D.relativeCCW(jP1X,jP1Y,jP2X,jP2Y,iP2X,iP2Y)));
          if (intersects) {
            n++;
          }
        }
      }
    }
  }
  return edgeCrossingCostFactor * n;
}
