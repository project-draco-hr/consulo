{
  ApplicationManager.getApplication().assertIsDispatchThread();
  if (VirtualFileManager.getInstance().findFileByUrl(file.getUrl()) == null)   return;
  final FileEditorManagerEx editorManager=FileEditorManagerEx.getInstanceEx(myProject);
  final Pair<FileEditor[],FileEditorProvider[]> editorsWithProviders=editorManager.getEditorsWithProviders(file);
  FileEditor[] editors=editorsWithProviders.getFirst();
  FileEditorProvider[] oldProviders=editorsWithProviders.getSecond();
  if (editors.length <= 0 && fallbackEditor != null) {
    editors=new FileEditor[]{fallbackEditor};
  }
  if (oldProviders.length <= 0 && fallbackProvider != null) {
    oldProviders=new FileEditorProvider[]{fallbackProvider};
  }
  if (editors.length <= 0) {
    LOG.error("No editors for file " + file.getPresentableUrl());
  }
  FileEditor selectedEditor=editorManager.getSelectedEditor(file);
  if (selectedEditor == null) {
    selectedEditor=fallbackEditor;
  }
  LOG.assertTrue(selectedEditor != null);
  final int selectedProviderIndex=ArrayUtilRt.find(editors,selectedEditor);
  LOG.assertTrue(selectedProviderIndex != -1);
  final HistoryEntry entry=getEntry(file);
  if (entry != null) {
    myEntriesList.remove(entry);
    myEntriesList.add(entry);
  }
 else {
    final FileEditorState[] states=new FileEditorState[editors.length];
    final FileEditorProvider[] providers=new FileEditorProvider[editors.length];
    for (int i=states.length - 1; i >= 0; i--) {
      final FileEditorProvider provider=oldProviders[i];
      LOG.assertTrue(provider != null);
      providers[i]=provider;
      states[i]=editors[i].getState(FileEditorStateLevel.FULL);
    }
    myEntriesList.add(new HistoryEntry(file,providers,states,providers[selectedProviderIndex]));
    trimToSize();
  }
}
