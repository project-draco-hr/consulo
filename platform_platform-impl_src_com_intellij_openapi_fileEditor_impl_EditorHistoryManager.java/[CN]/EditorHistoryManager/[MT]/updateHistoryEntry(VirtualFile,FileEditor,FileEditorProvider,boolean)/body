{
  if (file == null) {
    return;
  }
  final FileEditorManagerEx editorManager=FileEditorManagerEx.getInstanceEx(myProject);
  final Pair<FileEditor[],FileEditorProvider[]> editorsWithProviders=editorManager.getEditorsWithProviders(file);
  FileEditor[] editors=editorsWithProviders.getFirst();
  FileEditorProvider[] providers=editorsWithProviders.getSecond();
  if (editors.length <= 0 && fallbackEditor != null) {
    editors=new FileEditor[]{fallbackEditor};
    providers=new FileEditorProvider[]{fallbackProvider};
  }
  if (editors.length == 0) {
    return;
  }
  final HistoryEntry entry=getEntry(file);
  if (entry == null) {
    if (file.isValid()) {
      fileOpenedImpl(file,fallbackEditor,fallbackProvider);
    }
    return;
  }
  if (!changeEntryOrderOnly) {
    for (int i=editors.length - 1; i >= 0; i--) {
      final FileEditor editor=editors[i];
      final FileEditorProvider provider=providers[i];
      if (!editor.isValid()) {
        continue;
      }
      final FileEditorState oldState=entry.getState(provider);
      final FileEditorState newState=editor.getState(FileEditorStateLevel.FULL);
      if (!newState.equals(oldState)) {
        entry.putState(provider,newState);
      }
    }
  }
  final Pair<FileEditor,FileEditorProvider> selectedEditorWithProvider=editorManager.getSelectedEditorWithProvider(file);
  if (selectedEditorWithProvider != null) {
    entry.mySelectedProvider=selectedEditorWithProvider.getSecond();
    LOG.assertTrue(entry.mySelectedProvider != null);
    if (changeEntryOrderOnly) {
      myEntriesList.remove(entry);
      myEntriesList.add(entry);
    }
  }
}
