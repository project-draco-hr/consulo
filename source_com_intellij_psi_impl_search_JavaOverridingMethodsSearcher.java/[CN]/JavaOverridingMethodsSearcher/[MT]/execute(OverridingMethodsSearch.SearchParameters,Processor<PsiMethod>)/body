{
  final PsiMethod method=p.getMethod();
  final SearchScope scope=p.getScope();
  final PsiClass parentClass=method.getContainingClass();
  Processor<PsiClass> inheritorsProcessor=new Processor<PsiClass>(){
    public boolean process(    PsiClass inheritor){
      PsiSubstitutor substitutor=TypeConversionUtil.getSuperClassSubstitutor(parentClass,inheritor,PsiSubstitutor.EMPTY);
      MethodSignature signature=method.getSignature(substitutor);
      PsiMethod found=MethodSignatureUtil.findMethodBySuperSignature(inheritor,signature,false);
      if (found == null || !isAcceptable(found,method)) {
        if (parentClass.isInterface() && !inheritor.isInterface() && inheritor.isInheritor(parentClass,false)) {
          found=MethodSignatureUtil.findMethodInSuperClassBySignatureInDerived(inheritor,signature,true);
          if (found != null && isAcceptable(found,method)) {
            return consumer.process(found) && p.isCheckDeep();
          }
        }
        return true;
      }
      return consumer.process(found) && p.isCheckDeep();
    }
  }
;
  return ClassInheritorsSearch.search(parentClass,scope,true).forEach(inheritorsProcessor);
}
