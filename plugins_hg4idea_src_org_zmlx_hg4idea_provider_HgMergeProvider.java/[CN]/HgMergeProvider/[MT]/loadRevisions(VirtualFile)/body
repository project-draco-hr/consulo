{
  final MergeData mergeData=new MergeData();
  final VcsRunnable runnable=new VcsRunnable(){
    public void run() throws VcsException {
      final HgWorkingCopyRevisionsCommand command=new HgWorkingCopyRevisionsCommand(myProject);
      final VirtualFile repo=HgUtil.getHgRootOrThrow(myProject,file);
      final HgFile hgFile=new HgFile(myProject,file);
      HgRevisionNumber serverRevisionNumber, baseRevisionNumber, localRevisionNumber;
      if (wasFileCheckedIn(repo,file)) {
        final Pair<HgRevisionNumber,HgRevisionNumber> parents=command.parents(repo,file);
        serverRevisionNumber=parents.second;
        localRevisionNumber=parents.first;
        final HgContentRevision local=new HgContentRevision(myProject,hgFile,localRevisionNumber);
        mergeData.CURRENT=local.getContentAsBytes();
        baseRevisionNumber=command.parents(repo,file,localRevisionNumber).first;
      }
 else {
        serverRevisionNumber=command.parents(repo,file).first;
        baseRevisionNumber=command.parents(repo,file,serverRevisionNumber).first;
        final File origFile=new File(file.getPath() + ".orig");
        try {
          mergeData.CURRENT=VcsUtil.getFileByteContent(origFile);
        }
 catch (        IOException e) {
          LOG.info("Couldn't retrieve byte content of the file: " + origFile.getPath(),e);
        }
      }
      if (baseRevisionNumber != null) {
        final HgContentRevision base=new HgContentRevision(myProject,hgFile,baseRevisionNumber);
        mergeData.ORIGINAL=base.getContentAsBytes();
      }
 else {
        mergeData.ORIGINAL=new byte[0];
      }
      final HgContentRevision server=new HgContentRevision(myProject,hgFile,serverRevisionNumber);
      mergeData.LAST=server.getContentAsBytes();
      file.refresh(false,false);
    }
  }
;
  VcsUtil.runVcsProcessWithProgress(runnable,VcsBundle.message("multiple.file.merge.loading.progress.title"),false,myProject);
  return mergeData;
}
