{
  final MergeData mergeData=new MergeData();
  final VcsRunnable runnable=new VcsRunnable(){
    public void run() throws VcsException {
      final HgWorkingCopyRevisionsCommand command=new HgWorkingCopyRevisionsCommand(myProject);
      final VirtualFile repo=HgUtil.getHgRootOrThrow(myProject,file);
      final HgFile hgFile=new HgFile(myProject,file);
      HgRevisionNumber serverRevisionNumber;
      HgRevisionNumber localRevisionNumber;
      HgRevisionNumber baseRevisionNumber=null;
      if (wasFileCheckedIn(repo,file)) {
        final Pair<HgRevisionNumber,HgRevisionNumber> parents=command.parents(repo,file);
        serverRevisionNumber=parents.second;
        localRevisionNumber=parents.first;
        final HgContentRevision local=new HgContentRevision(myProject,hgFile,localRevisionNumber);
        mergeData.CURRENT=local.getContentAsBytes();
        List<String> arguments=new ArrayList<String>();
        arguments.add(localRevisionNumber.getRevision());
        arguments.add(serverRevisionNumber.getRevision());
        HgCommandResult result=new HgCommandExecutor(myProject).executeInCurrentThread(repo,"debugancestor",arguments);
        if (result != null) {
          String output=result.getRawOutput();
          final List<String> parts=StringUtil.split(output,":");
          if (parts.size() < 2) {
            LOG.info("Couldn't parse result of debugancestor command execution " + arguments);
            new HgCommandResultNotifier(myProject).notifyError(null,HgVcsMessages.message("hg4idea.error.debugancestor.command.execution"),HgVcsMessages.message("hg4idea.error.debugancestor.command.description"));
          }
 else {
            baseRevisionNumber=HgRevisionNumber.getInstance(parts.get(0),parts.get(1));
          }
        }
 else {
          LOG.info(HgVcsMessages.message("hg4idea.error.debugancestor.command.execution") + arguments);
          new HgCommandResultNotifier(myProject).notifyError(null,HgVcsMessages.message("hg4idea.error.debugancestor.command.execution"),HgVcsMessages.message("hg4idea.error.debugancestor.command.description"));
        }
      }
 else {
        serverRevisionNumber=command.parents(repo,file).first;
        baseRevisionNumber=command.parents(repo,file,serverRevisionNumber).first;
        final File origFile=new File(file.getPath() + ".orig");
        try {
          mergeData.CURRENT=VcsUtil.getFileByteContent(origFile);
        }
 catch (        IOException e) {
          LOG.info("Couldn't retrieve byte content of the file: " + origFile.getPath(),e);
        }
      }
      if (baseRevisionNumber != null) {
        final HgContentRevision base=new HgContentRevision(myProject,hgFile,baseRevisionNumber);
        mergeData.ORIGINAL=base.getContent() != null ? base.getContentAsBytes() : new byte[0];
      }
 else {
        mergeData.ORIGINAL=new byte[0];
      }
      final HgContentRevision server=new HgContentRevision(myProject,hgFile,serverRevisionNumber);
      mergeData.LAST=server.getContentAsBytes();
      file.refresh(false,false);
    }
  }
;
  VcsUtil.runVcsProcessWithProgress(runnable,VcsBundle.message("multiple.file.merge.loading.progress.title"),false,myProject);
  return mergeData;
}
