{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  myInitializer.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitReferenceExpression(    final PsiReferenceExpression expression){
      super.visitReferenceExpression(expression);
      final PsiElement element=expression.resolve();
      if (element instanceof PsiMethod || element instanceof PsiField) {
        if (!mySameClass && !((PsiModifierListOwner)element).hasModifierProperty(PsiModifier.STATIC)) {
          conflicts.putValue(expression,"Parameter initializer depend on non static member from some other class");
        }
      }
    }
    @Override public void visitThisExpression(    PsiThisExpression thisExpression){
      super.visitThisExpression(thisExpression);
      final PsiJavaCodeReferenceElement qualifier=thisExpression.getQualifier();
      PsiElement containingClass;
      if (qualifier != null) {
        containingClass=qualifier.resolve();
      }
 else {
        containingClass=PsiTreeUtil.getParentOfType(myMethodCall,PsiClass.class);
      }
      final PsiClass methodContainingClass=myMethod.getContainingClass();
      LOG.assertTrue(methodContainingClass != null);
      if (!PsiTreeUtil.isAncestor(containingClass,methodContainingClass,false)) {
        conflicts.putValue(thisExpression,"Parameter initializer depends on this which is not available inside the method and cannot be inlined");
      }
    }
    @Override public void visitNewExpression(    PsiNewExpression expression){
      super.visitNewExpression(expression);
      final PsiJavaCodeReferenceElement reference=expression.getClassOrAnonymousClassReference();
      if (reference != null) {
        final PsiElement resolved=reference.resolve();
        if (resolved instanceof PsiClass) {
          final PsiClass refClass=(PsiClass)resolved;
          final String classUnavailableMessage="Parameter initializer depends on " + RefactoringUIUtil.getDescription(refClass,true) + " which is not available inside method and cannot be inlined";
          if (!PsiUtil.isAccessible(refClass,myMethod,null)) {
            conflicts.putValue(expression,classUnavailableMessage);
          }
 else {
            final PsiClass methodContainingClass=myMethod.getContainingClass();
            LOG.assertTrue(methodContainingClass != null);
            if (!(refClass.getParent() instanceof PsiFile) && !PsiTreeUtil.isAncestor(methodContainingClass,refClass,false)) {
              conflicts.putValue(expression,classUnavailableMessage);
            }
          }
        }
      }
    }
  }
);
  return showConflicts(conflicts);
}
