{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final UsageInfo[] usages=refUsages.get();
  final InaccessibleExpressionsDetector detector=new InaccessibleExpressionsDetector(conflicts);
  myInitializer.accept(detector);
  for (  UsageInfo usage : usages) {
    if (usage instanceof LocalReplacementUsageInfo) {
      final PsiElement replacement=((LocalReplacementUsageInfo)usage).getReplacement();
      if (replacement != null) {
        replacement.accept(detector);
      }
    }
  }
  final Set<PsiVariable> vars=new HashSet<PsiVariable>();
  for (  UsageInfo usageInfo : usages) {
    if (usageInfo instanceof LocalReplacementUsageInfo) {
      final PsiVariable var=((LocalReplacementUsageInfo)usageInfo).getVariable();
      if (var != null) {
        vars.add(var);
      }
    }
  }
  for (  PsiVariable var : vars) {
    for (    PsiReference ref : ReferencesSearch.search(var)) {
      final PsiElement element=ref.getElement();
      if (element instanceof PsiExpression && isAccessedForWriting((PsiExpression)element)) {
        conflicts.putValue(element,"Parameter initializer depends on value which is not available inside method and cannot be inlined");
        break;
      }
    }
  }
  return showConflicts(conflicts);
}
