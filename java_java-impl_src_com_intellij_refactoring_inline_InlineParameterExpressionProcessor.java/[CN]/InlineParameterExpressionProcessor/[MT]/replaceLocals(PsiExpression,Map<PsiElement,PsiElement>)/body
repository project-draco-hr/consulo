{
  final Ref<Boolean> refCannotEvaluate=new Ref<Boolean>();
  expression.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitReferenceExpression(    final PsiReferenceExpression expression){
      super.visitReferenceExpression(expression);
      final PsiElement element=expression.resolve();
      if (!canEvaluate(expression,element,elementsToReplace)) {
        refCannotEvaluate.set(Boolean.TRUE);
      }
    }
    @Override public void visitThisExpression(    PsiThisExpression thisExpression){
      super.visitThisExpression(thisExpression);
      final PsiJavaCodeReferenceElement qualifier=thisExpression.getQualifier();
      PsiElement containingClass;
      if (qualifier != null) {
        containingClass=qualifier.resolve();
      }
 else {
        containingClass=PsiTreeUtil.getParentOfType(myMethodCall,PsiClass.class);
      }
      final PsiClass methodContainingClass=myMethod.getContainingClass();
      LOG.assertTrue(methodContainingClass != null);
      if (!PsiTreeUtil.isAncestor(containingClass,methodContainingClass,false)) {
        refCannotEvaluate.set(Boolean.TRUE);
      }
    }
  }
);
  return refCannotEvaluate.isNull();
}
