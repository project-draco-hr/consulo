{
  final PsiManager manager=PsiManager.getInstance(myProject);
  String newName=getNewName();
  try {
    PsiElementFactory factory=manager.getElementFactory();
    if (myPsiElement instanceof PsiMethod) {
      PsiMethod refactoredMethod=(PsiMethod)myPsiElement;
      if (newName.equals(refactoredMethod.getName())) {
        return true;
      }
      PsiMethod prototype=(PsiMethod)refactoredMethod.copy();
      prototype.getNameIdentifier().replace(factory.createIdentifier(newName));
      PsiClass aClass=refactoredMethod.getContainingClass();
      return RefactoringMessageUtil.checkMethodConflicts(aClass != null ? (PsiElement)aClass : (PsiElement)refactoredMethod.getContainingFile(),refactoredMethod,prototype);
    }
 else     if (myPsiElement instanceof PsiField) {
      PsiField refactoredField=(PsiField)myPsiElement;
      if (newName.equals(refactoredField.getName())) {
        return true;
      }
      PsiClass aClass=refactoredField.getContainingClass();
      return RefactoringMessageUtil.checkFieldConflicts(aClass != null ? (PsiElement)aClass : (PsiElement)refactoredField.getContainingFile(),newName);
    }
 else     if (myPsiElement instanceof PsiClass) {
      final PsiClass aClass=((PsiClass)myPsiElement);
      if (newName.equals(aClass.getName())) {
        return true;
      }
      if (myPsiElement.getParent() instanceof PsiClass) {
        PsiClass containingClass=(PsiClass)myPsiElement.getParent();
        PsiClass[] innerClasses=containingClass.getInnerClasses();
        for (int idx=0; idx < innerClasses.length; idx++) {
          PsiClass innerClass=innerClasses[idx];
          if (newName.equals(innerClass.getName())) {
            int ret=Messages.showYesNoDialog(myProject,"Inner class " + newName + " is already defined in class "+ containingClass.getQualifiedName()+ ".\nContinue anyway?","Warning",Messages.getWarningIcon());
            if (ret != 0) {
              return false;
            }
            break;
          }
        }
      }
 else {
        final String qualifiedNameAfterRename=RenameUtil.getQualifiedNameAfterRename(aClass,newName);
        final PsiClass conflictingClass=PsiManager.getInstance(myProject).findClass(qualifiedNameAfterRename);
        if (conflictingClass != null) {
          RefactoringMessageUtil.showErrorMessage("Error","Class " + qualifiedNameAfterRename + " already exists",null,myProject);
          return false;
        }
      }
    }
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
  return true;
}
