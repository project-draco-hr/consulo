{
  @NonNls final ParametersList parameters=cmdLine.getParametersList();
  if (LOCALE != null && LOCALE.length() > 0) {
    parameters.add("-locale");
    parameters.add(LOCALE);
  }
  if (OPTION_SCOPE != null) {
    parameters.add("-" + OPTION_SCOPE);
  }
  if (!OPTION_HIERARCHY) {
    parameters.add("-notree");
  }
  if (!OPTION_NAVIGATOR) {
    parameters.add("-nonavbar");
  }
  if (!OPTION_INDEX) {
    parameters.add("-noindex");
  }
 else   if (OPTION_SEPARATE_INDEX) {
    parameters.add("-splitindex");
  }
  if (OPTION_DOCUMENT_TAG_USE) {
    parameters.add("-use");
  }
  if (OPTION_DOCUMENT_TAG_AUTHOR) {
    parameters.add("-author");
  }
  if (OPTION_DOCUMENT_TAG_VERSION) {
    parameters.add("-version");
  }
  if (!OPTION_DOCUMENT_TAG_DEPRECATED) {
    parameters.add("-nodeprecated");
  }
 else   if (!OPTION_DEPRECATED_LIST) {
    parameters.add("-nodeprecatedlist");
  }
  parameters.addParametersString(OTHER_OPTIONS);
  final PathsList classPath;
  if (jdk.getSdkType() instanceof JavaSdk) {
    classPath=OrderEnumerator.orderEntries(myProject).withoutSdk().withoutModuleSourceEntries().getPathsList();
  }
 else {
    classPath=OrderEnumerator.orderEntries(myProject).withoutModuleSourceEntries().getPathsList();
  }
  final String classPathString=classPath.getPathsString();
  if (classPathString.length() > 0) {
    parameters.add("-classpath");
    parameters.add(classPathString);
  }
  if (OUTPUT_DIRECTORY != null) {
    parameters.add("-d");
    parameters.add(OUTPUT_DIRECTORY.replace('/',File.separatorChar));
  }
  try {
    final File sourcePathTempFile=FileUtil.createTempFile("javadoc","args.txt",true);
    parameters.add("@" + sourcePathTempFile.getCanonicalPath());
    final PrintWriter writer=new PrintWriter(new FileWriter(sourcePathTempFile));
    try {
      final Collection<String> packages=new HashSet<String>();
      final Collection<String> sources=new HashSet<String>();
      final Runnable findRunnable=new Runnable(){
        public void run(){
          myGenerationOptions.accept(new MyContentIterator(myProject,packages,sources));
        }
      }
;
      if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(findRunnable,"Search for sources to generate javadoc in...",false,myProject)) {
        return;
      }
      if (packages.size() + sources.size() == 0) {
        throw new CantRunException(JavadocBundle.message("javadoc.generate.no.classes.in.selected.packages.error"));
      }
      for (      String aPackage : packages) {
        writer.println(aPackage);
      }
      for (      String source : sources) {
        writer.println(source);
      }
      writer.println("-sourcepath");
      OrderEnumerator enumerator=OrderEnumerator.orderEntries(myProject);
      if (!OPTION_INCLUDE_LIBS) {
        enumerator=enumerator.withoutSdk().withoutLibraries();
      }
      final PathsList pathsList=enumerator.getSourcePathsList();
      final List<VirtualFile> files=pathsList.getRootDirs();
      final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(myProject).getFileIndex();
      final StringBuilder sourcePath=new StringBuilder();
      boolean start=true;
      for (      VirtualFile file : files) {
        if (!myGenerationOptions.isIncludeTestSource() && fileIndex.isInTestSourceContent(file))         continue;
        if (start) {
          start=false;
        }
 else {
          sourcePath.append(File.pathSeparator);
        }
        sourcePath.append(file.getPath());
      }
      writer.println(sourcePath.toString());
    }
  finally {
      writer.close();
    }
  }
 catch (  IOException e) {
    LOGGER.error(e);
  }
}
