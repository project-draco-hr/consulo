{
  final FileTemplate template=FileTemplateManager.getInstance().getPattern(FileTemplateManager.FILE_HEADER_TEMPLATE_NAME);
  final ReplaceWithFileTemplateFix replaceTemplateFix=new ReplaceWithFileTemplateFix(){
    public void applyFix(    Project project,    ProblemDescriptor descriptor){
      String newText;
      try {
        newText=template.getText(computeProperties(matcher,offsetToProperty));
      }
 catch (      IOException e) {
        LOG.error(e);
        return;
      }
      try {
        PsiDocComment newDoc=element.getManager().getElementFactory().createDocCommentFromText(newText,element);
        element.replace(newDoc);
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
catch (      IllegalStateException e) {
        LOG.error("Cannot create doc comment from text: '" + newText + "'",e);
      }
    }
    private Properties computeProperties(    final Matcher matcher,    final TIntObjectHashMap<String> offsetToProperty){
      Properties properties=new Properties(FileTemplateManager.getInstance().getDefaultProperties());
      int[] offsets=offsetToProperty.keys();
      Arrays.sort(offsets);
      for (int i=0; i < offsets.length; i++) {
        final int offset=offsets[i];
        String propName=offsetToProperty.get(offset);
        int groupNum=i + 2;
        String propValue=matcher.group(groupNum);
        properties.put(propName,propValue);
      }
      return properties;
    }
  }
;
  final LocalQuickFix editFileTemplateFix=DefaultFileTemplateUsageInspection.createEditFileTemplateFix(template,replaceTemplateFix);
  if (template.isDefault()) {
    return new LocalQuickFix[]{editFileTemplateFix};
  }
  return new LocalQuickFix[]{replaceTemplateFix,editFileTemplateFix};
}
