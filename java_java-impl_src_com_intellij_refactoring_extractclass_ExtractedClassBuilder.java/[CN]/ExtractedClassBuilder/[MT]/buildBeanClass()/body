{
  if (requiresBackPointer) {
    calculateBackpointerName();
  }
  @NonNls final StringBuffer out=new StringBuffer(1024);
  if (packageName.length() > 0)   out.append("package " + packageName + ';');
  out.append("public ");
  if (hasAbstractMethod()) {
    out.append("abstract ");
  }
  out.append("class ");
  out.append(className);
  if (!typeParams.isEmpty()) {
    out.append('<');
    boolean first=true;
    for (    PsiTypeParameter typeParam : typeParams) {
      if (!first) {
        out.append(',');
      }
      out.append(typeParam.getText());
      first=false;
    }
    out.append('>');
  }
  if (!interfaces.isEmpty()) {
    out.append(" implements ");
    boolean first=true;
    for (    PsiClass implemented : interfaces) {
      if (!first) {
        out.append(',');
      }
      out.append(implemented.getQualifiedName());
      first=false;
    }
  }
  out.append('{');
  if (requiresBackPointer) {
    out.append("private final " + originalClassName);
    if (!typeParams.isEmpty()) {
      out.append('<');
      boolean first=true;
      for (      PsiTypeParameter typeParam : typeParams) {
        if (!first) {
          out.append(',');
        }
        out.append(typeParam.getName());
        first=false;
      }
      out.append('>');
    }
    out.append(' ' + backPointerName + ";");
  }
  outputFieldsAndInitializers(out);
  if (needConstructor() || requiresBackPointer) {
    outputConstructor(out);
  }
  outputMethods(out);
  outputInnerClasses(out);
  out.append("}");
  return out.toString();
}
