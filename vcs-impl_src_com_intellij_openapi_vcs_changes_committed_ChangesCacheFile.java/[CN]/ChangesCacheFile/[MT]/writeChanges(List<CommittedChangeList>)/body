{
  List<CommittedChangeList> result=new ArrayList<CommittedChangeList>(changes.size());
  boolean wasEmpty=isEmpty();
  openStreams();
  try {
    if (wasEmpty) {
      myHeaderLoaded=true;
      writeHeader();
    }
    myStream.seek(myStream.length());
    IndexEntry[] entries=readLastIndexEntries(0,changes.size());
    Collections.sort(changes,new Comparator<CommittedChangeList>(){
      public int compare(      final CommittedChangeList o1,      final CommittedChangeList o2){
        return o1.getCommitDate().compareTo(o2.getCommitDate());
      }
    }
);
    for (    CommittedChangeList list : changes) {
      boolean duplicate=false;
      for (      IndexEntry entry : entries) {
        if (list.getCommitDate().getTime() == entry.date && list.getNumber() == entry.number) {
          duplicate=true;
          break;
        }
      }
      if (duplicate) {
        LOG.info("Skipping duplicate changelist " + list.getNumber());
        continue;
      }
      LOG.info("Writing incoming changelist " + list.getNumber());
      result.add(list);
      long position=myStream.getFilePointer();
      myChangesProvider.writeChangeList(myStream,list);
      updateCachedRange(list);
      writeIndexEntry(list.getNumber(),list.getCommitDate().getTime(),position,false);
      myIncomingCount++;
    }
    writeHeader();
    myHeaderLoaded=true;
  }
  finally {
    closeStreams();
  }
  return result;
}
