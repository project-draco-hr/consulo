{
  final ActionManagerEx actionManager=ActionManagerEx.getInstanceEx();
  actionManager.addAnActionListener(new AnActionListener.Adapter(){
    @Override public void afterActionPerformed(    AnAction action,    DataContext dataContext,    AnActionEvent event){
      if (event != null && GradleConstants.SYNC_TREE_FLOATING_TOOLBAR_PLACE.equals(event.getPlace())) {
        hideToolbar();
      }
    }
  }
,getProject());
  final ActionGroup actionGroup=(ActionGroup)actionManager.getAction(GradleConstants.ACTION_GROUP_SYNC_TREE);
  final ActionToolbar toolbar=actionManager.createActionToolbar(GradleConstants.SYNC_TREE_FLOATING_TOOLBAR_PLACE,actionGroup,true);
  toolbar.setTargetComponent(this);
  final JComponent toolbarComponent=toolbar.getComponent();
  toolbarComponent.setOpaque(true);
  final Color foreground=myTree.getForeground();
  toolbarComponent.setForeground(foreground);
  toolbarComponent.setBackground(myTree.getBackground());
  myTree.addMouseMotionListener(new MouseMotionAdapter(){
    @Override public void mouseMoved(    MouseEvent e){
      final TreePath path=myTree.getPathForLocation(e.getX(),e.getY());
      if (path == null) {
        return;
      }
      final GradleProjectStructureNode<?> node=(GradleProjectStructureNode<?>)path.getLastPathComponent();
      myNodeUnderMouse=node;
      scheduleToolbar(node,toolbar,toolbarComponent);
    }
  }
);
  getProject().getMessageBus().connect(getProject()).subscribe(GradleUiListener.TOPIC,new GradleUiListener(){
    @Override public void beforeConflictUiShown(){
      mySuppressToolbar=true;
      hideToolbar();
    }
    @Override public void afterConflictUiShown(){
      mySuppressToolbar=false;
      hideToolbar();
    }
  }
);
}
