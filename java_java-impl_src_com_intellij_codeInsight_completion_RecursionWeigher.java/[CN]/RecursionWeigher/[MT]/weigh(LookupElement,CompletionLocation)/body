{
  if (location.getCompletionType() != CompletionType.BASIC && location.getCompletionType() != CompletionType.SMART)   return Result.normal;
  final Object object=element.getObject();
  if (!(object instanceof PsiMethod || object instanceof PsiVariable || object instanceof PsiExpression))   return Result.normal;
  final PsiMethod positionMethod=JavaCompletionUtil.POSITION_METHOD.getValue(location);
  final PsiElement position=location.getCompletionParameters().getPosition();
  final ElementFilter filter=JavaCompletionUtil.recursionFilter(position);
  if (filter != null && !filter.isAcceptable(object,position)) {
    return Result.recursive;
  }
  final PsiMethodCallExpression expression=PsiTreeUtil.getParentOfType(position,PsiMethodCallExpression.class,true,PsiClass.class);
  final PsiReferenceExpression reference=expression != null ? expression.getMethodExpression() : PsiTreeUtil.getParentOfType(position,PsiReferenceExpression.class);
  if (reference == null)   return Result.normal;
  final PsiExpression qualifier=reference.getQualifierExpression();
  boolean isDelegate=qualifier != null && !(qualifier instanceof PsiThisExpression);
  if (isPassingObjectToItself(object,qualifier,isDelegate)) {
    return Result.passingObjectToItself;
  }
  if (expression != null && positionMethod != null) {
    final ExpectedTypeInfo[] expectedInfos=JavaCompletionUtil.EXPECTED_TYPES.getValue(location);
    if (expectedInfos != null) {
      final PsiType itemType=JavaCompletionUtil.getLookupElementType(element);
      if (itemType != null) {
        for (        final ExpectedTypeInfo expectedInfo : expectedInfos) {
          if (positionMethod.equals(expectedInfo.getCalledMethod()) && expectedInfo.getType().isAssignableFrom(itemType)) {
            return isDelegate ? Result.delegation : Result.recursive;
          }
        }
      }
    }
    return Result.normal;
  }
  if (object instanceof PsiMethod && positionMethod != null) {
    final PsiMethod method=(PsiMethod)object;
    if (PsiTreeUtil.isAncestor(reference,position,false) && Comparing.equal(method.getName(),positionMethod.getName())) {
      if (!isDelegate && findDeepestSuper(method).equals(findDeepestSuper(positionMethod))) {
        return Result.recursive;
      }
      return RecursionWeigher.Result.delegation;
    }
  }
  return Result.normal;
}
