{
  final GitVcs vcs=GitVcs.getInstance(myProject);
  if (vcs == null) {
    return;
  }
  boolean suspendable=false;
switch (myCommand.lockingPolicy()) {
case READ:
    break;
case WRITE_SUSPENDABLE:
  suspendable=true;
case WRITE:
vcs.getCommandLock().writeLock().lock();
break;
}
try {
if (suspendable) {
final Object EXIT=new Object();
final Object SUSPEND=new Object();
final Object RESUME=new Object();
final LinkedBlockingQueue<Object> queue=new LinkedBlockingQueue<Object>();
Runnable suspend=new Runnable(){
public void run(){
  queue.add(SUSPEND);
}
}
;
Runnable resume=new Runnable(){
public void run(){
  queue.add(RESUME);
}
}
;
setSuspendResume(suspend,resume);
start();
if (isStarted()) {
if (postStartAction != null) {
  postStartAction.run();
}
ApplicationManager.getApplication().executeOnPooledThread(new Runnable(){
  public void run(){
    waitFor();
    queue.add(EXIT);
  }
}
);
boolean suspended=false;
while (true) {
  Object action;
  while (true) {
    try {
      action=queue.take();
      break;
    }
 catch (    InterruptedException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("queue.take() is interrupted",e);
      }
    }
  }
  if (action == EXIT) {
    if (suspended) {
      LOG.error("Exiting while RW lock is suspended (reacquiring W-lock command)");
      vcs.getCommandLock().writeLock().lock();
    }
    break;
  }
 else   if (action == SUSPEND) {
    if (suspended) {
      LOG.error("Suspending suspended W-lock (ignoring command)");
    }
 else {
      vcs.getCommandLock().writeLock().unlock();
      suspended=true;
    }
  }
 else   if (action == RESUME) {
    if (!suspended) {
      LOG.error("Resuming not suspended W-lock (ignoring command)");
    }
 else {
      vcs.getCommandLock().writeLock().lock();
      suspended=false;
    }
  }
}
}
}
 else {
start();
if (isStarted()) {
if (postStartAction != null) {
  postStartAction.run();
}
waitFor();
}
}
}
  finally {
switch (myCommand.lockingPolicy()) {
case READ:
break;
case WRITE_SUSPENDABLE:
case WRITE:
vcs.getCommandLock().writeLock().unlock();
break;
}
}
}
