{
  parseParameterList(builder);
  eatBrackets(builder,constructor,"expected.semicolon");
  if (areTypeAnnotationsSupported(builder)) {
    final PsiBuilder.Marker receiver=builder.mark();
    final PsiBuilder.Marker annotations=parseAnnotations(builder);
    if (annotations != null) {
      done(receiver,JavaElementType.METHOD_RECEIVER);
    }
 else {
      receiver.drop();
    }
  }
  myReferenceParser.parseReferenceList(builder,JavaTokenType.THROWS_KEYWORD,JavaElementType.THROWS_LIST,JavaTokenType.COMMA);
  final boolean hasDefault=expect(builder,JavaTokenType.DEFAULT_KEYWORD);
  if (hasDefault && anno) {
    parseAnnotationValue(builder);
  }
  final IElementType tokenType=builder.getTokenType();
  final boolean hasError=tokenType != JavaTokenType.SEMICOLON && tokenType != JavaTokenType.LBRACE;
  if (hasError) {
    final PsiBuilder.Marker error=builder.mark();
    final CharSequence text=builder.getOriginalText();
    Loop:     while (true) {
      for (int i=builder.getCurrentOffset() - 1; i >= 0; i--) {
        final char ch=text.charAt(i);
        if (ch == '\n')         break Loop;
 else         if (ch != ' ' && ch != '\t')         break;
      }
      if (!expect(builder,APPEND_TO_METHOD_SET))       break;
    }
    error.error(JavaErrorMessages.message("expected.lbrace.or.semicolon"));
  }
  if (hasDefault && !anno && !hasError&& builder.getTokenType() != JavaTokenType.LBRACE) {
    error(builder,JavaErrorMessages.message("expected.lbrace"));
  }
  if (!expect(builder,JavaTokenType.SEMICOLON) && builder.getTokenType() == JavaTokenType.LBRACE) {
    myStatementParser.parseCodeBlock(builder);
  }
  done(declaration,anno ? JavaElementType.ANNOTATION_METHOD : JavaElementType.METHOD);
  return declaration;
}
