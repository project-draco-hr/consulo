{
  exits++;
  if (sizeAfter != progressMap.size()) {
    LOG.error("Map size changed: " + progressMap.size() + " "+ sizeAfter+ " "+ realKey.second);
  }
  if (depth != progressMap.size()) {
    LOG.error("Inconsistent depth after computation; depth=" + depth + "; map="+ progressMap);
  }
  Integer value=progressMap.remove(realKey);
  depth--;
  toMemoize.remove(realKey);
  key2ReentrancyDuringItsCalculation.remove(realKey);
  if (depth == 0) {
    intermediateCache.clear();
    LOG.assertTrue(key2ReentrancyDuringItsCalculation.isEmpty(),"non-empty key2ReentrancyDuringItsCalculation: " + new HashMap(key2ReentrancyDuringItsCalculation));
    LOG.assertTrue(toMemoize.isEmpty(),"non-empty toMemoize: " + new HashSet(toMemoize));
  }
  if (sizeBefore != progressMap.size()) {
    LOG.error("Map size doesn't decrease: " + progressMap.size() + " "+ sizeBefore+ " "+ realKey.second);
  }
  if (value == null) {
    LOG.error(realKey.second + " has changed its equals/hashCode");
  }
  reentrancyCount=value;
  checkZero();
}
