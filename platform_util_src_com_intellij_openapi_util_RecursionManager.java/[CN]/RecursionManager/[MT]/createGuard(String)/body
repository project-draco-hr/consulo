{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    @NotNull Object key,    boolean memoize,    Computable<T> computation){
      MyKey realKey=new MyKey(id,key);
      final CalculationStack stack=ourStack.get();
      if (stack.checkReentrancy(realKey)) {
        return null;
      }
      if (memoize) {
        Object o=stack.getMemoizedValue(realKey);
        if (o != null) {
          for (          MyKey noCacheUntil : stack.toProhibitCachingOnMemo.get(realKey)) {
            stack._prohibitResultCaching(noCacheUntil);
          }
          return o == NULL ? null : (T)o;
        }
      }
      final int sizeBefore=stack.progressMap.size();
      stack.beforeComputation(realKey);
      final int sizeAfter=stack.progressMap.size();
      int startStamp=stack.memoizationStamp;
      try {
        T result=computation.compute();
        if (memoize) {
          stack.maybeMemoize(realKey,result == null ? NULL : result,startStamp);
        }
        return result;
      }
  finally {
        stack.afterComputation(realKey,sizeBefore,sizeAfter);
      }
    }
    @Override public StackStamp markStack(){
      final int stamp=ourStack.get().reentrancyCount;
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return stamp == ourStack.get().reentrancyCount;
        }
      }
;
    }
    @Override public List<Object> currentStack(){
      ArrayList<Object> result=new ArrayList<Object>();
      LinkedHashMap<MyKey,Integer> map=ourStack.get().progressMap;
      for (      MyKey pair : map.keySet()) {
        if (pair.first.equals(id)) {
          result.add(pair.second);
        }
      }
      return result;
    }
    @Override public void prohibitResultCaching(    Object since){
      ourStack.get()._prohibitResultCaching(new MyKey(id,since));
      ourStack.get().memoizationStamp++;
    }
  }
;
}
