{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    @NotNull Object key,    boolean memoize,    Computable<T> computation){
      MyKey realKey=new MyKey(id,key);
      LinkedHashMap<MyKey,Integer> progressMap=ourProgress.get();
      if (progressMap.containsKey(realKey)) {
        _prohibitResultCaching(key);
        return null;
      }
      if (memoize) {
        SoftReference reference=ourIntermediateCache.get().get(realKey);
        if (reference != null) {
          Object o=reference.get();
          if (o != null) {
            return o == NULL ? null : (T)o;
          }
        }
      }
      progressMap.put(realKey,ourStamp.get());
      int startStamp=ourMemoizationStamp.get();
      try {
        T result=computation.compute();
        if (memoize && ourMemoizationStamp.get() == startStamp) {
          ourIntermediateCache.get().put(realKey,new SoftReference<Object>(result == null ? NULL : result));
        }
        return result;
      }
  finally {
        Integer value=progressMap.remove(realKey);
        if (value == null) {
          throw new AssertionError(key + " has changed its equals/hashCode");
        }
        ourStamp.set(value);
        if (value == 0) {
          ourIntermediateCache.get().clear();
        }
 else         if (progressMap.isEmpty()) {
          ourIntermediateCache.get().clear();
          throw new AssertionError("Non-zero stamp for empty progress map: " + key + ", "+ value);
        }
      }
    }
    @Override public StackStamp markStack(){
      final Integer stamp=ourStamp.get();
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return Comparing.equal(stamp,ourStamp.get());
        }
      }
;
    }
    @Override public List<Object> currentStack(){
      ArrayList<Object> result=new ArrayList<Object>();
      LinkedHashMap<MyKey,Integer> map=ourProgress.get();
      for (      MyKey pair : map.keySet()) {
        if (pair.first.equals(id)) {
          result.add(pair.second);
        }
      }
      return result;
    }
    @Override public void prohibitResultCaching(    Object since){
      ourMemoizationStamp.set(_prohibitResultCaching(since));
    }
    private int _prohibitResultCaching(    Object since){
      int stamp=ourStamp.get() + 1;
      ourStamp.set(stamp);
      boolean inLoop=false;
      for (      Map.Entry<MyKey,Integer> entry : ourProgress.get().entrySet()) {
        if (inLoop) {
          entry.setValue(stamp);
        }
 else         if (entry.getKey().first.equals(id) && entry.getKey().second.equals(since)) {
          inLoop=true;
        }
      }
      return stamp;
    }
  }
;
}
