{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    @NotNull Object key,    boolean memoize,    Computable<T> computation){
      MyKey realKey=new MyKey(id,key);
      final CalculationStack stack=ourStack.get();
      if (stack.checkReentrancy(realKey)) {
        return null;
      }
      if (memoize) {
        Object o=stack.getMemoizedValue(realKey);
        if (o != null) {
          SoftHashMap<MyKey,SoftReference> map=stack.intermediateCache.get(realKey);
          if (map != null) {
            for (            MyKey noCacheUntil : map.keySet()) {
              stack.prohibitResultCaching(noCacheUntil);
            }
          }
          return o == NULL ? null : (T)o;
        }
      }
      int oldHash=realKey.hashCode();
      final int sizeBefore=stack.progressMap.size();
      stack.beforeComputation(realKey);
      final int sizeAfter=stack.progressMap.size();
      int startStamp=stack.memoizationStamp;
      try {
        T result=computation.compute();
        if (memoize) {
          stack.maybeMemoize(realKey,result == null ? NULL : result,startStamp);
        }
        return result;
      }
  finally {
        try {
          stack.afterComputation(realKey,sizeBefore,sizeAfter);
        }
 catch (        Throwable e) {
          throw new RuntimeException("Throwable in afterComputation",e);
        }
        stack.checkDepth("4");
        if (oldHash != realKey.hashCode()) {
          throw new AssertionError("Object has changed its hashCode: " + key);
        }
      }
    }
    @Override public StackStamp markStack(){
      final int stamp=ourStack.get().reentrancyCount;
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return stamp == ourStack.get().reentrancyCount;
        }
      }
;
    }
    @Override public List<Object> currentStack(){
      ArrayList<Object> result=new ArrayList<Object>();
      LinkedHashMap<MyKey,Integer> map=ourStack.get().progressMap;
      for (      MyKey pair : map.keySet()) {
        if (pair.first.equals(id)) {
          result.add(pair.second);
        }
      }
      return result;
    }
    @Override public void prohibitResultCaching(    Object since){
      MyKey realKey=new MyKey(id,since);
      final CalculationStack stack=ourStack.get();
      stack.enableMemoization(realKey,stack.prohibitResultCaching(realKey));
      stack.memoizationStamp++;
    }
  }
;
}
