{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    @NotNull Object key,    boolean memoize,    Computable<T> computation){
      MyKey realKey=new MyKey(id,key);
      LinkedHashMap<MyKey,Integer> progressMap=ourProgress.get();
      if (progressMap.containsKey(realKey)) {
        _prohibitResultCaching(key);
        return null;
      }
      if (memoize) {
        SoftReference reference=ourIntermediateCache.get().get(realKey);
        if (reference != null) {
          if (ourDepth.get() == 0) {
            throw new AssertionError("Memoized values with empty stack");
          }
          Object o=reference.get();
          if (o != null) {
            return o == NULL ? null : (T)o;
          }
        }
      }
      if (progressMap.isEmpty() && ourStamp.get() != 0) {
        throw new AssertionError("Non-zero stamp with empty stack: " + ourStamp.get());
      }
      checkDepth("1");
      int sizeBefore=progressMap.size();
      progressMap.put(realKey,ourStamp.get());
      ourDepth.set(ourDepth.get() + 1);
      checkDepth("2");
      int sizeAfter=progressMap.size();
      if (sizeAfter != sizeBefore + 1) {
        LOG.error("Key doesn't lead to the map size increase: " + sizeBefore + " "+ sizeAfter+ " "+ key);
      }
      int startStamp=ourMemoizationStamp.get();
      try {
        T result=computation.compute();
        if (memoize && ourMemoizationStamp.get() == startStamp) {
          ourIntermediateCache.get().put(realKey,new SoftReference<Object>(result == null ? NULL : result));
        }
        return result;
      }
  finally {
        if (sizeAfter != progressMap.size()) {
          LOG.error("Map size changed: " + progressMap.size() + " "+ sizeAfter+ " "+ key);
        }
        ourDepth.set(ourDepth.get() - 1);
        Integer value=progressMap.remove(realKey);
        if (sizeBefore != progressMap.size()) {
          LOG.error("Map size doesn't decrease: " + progressMap.size() + " "+ sizeBefore+ " "+ key);
        }
        if (value == null) {
          throw new AssertionError(key + " has changed its equals/hashCode");
        }
        ourStamp.set(value);
        if (value == 0) {
          ourIntermediateCache.get().clear();
        }
 else         if (progressMap.isEmpty()) {
          ourIntermediateCache.get().clear();
          throw new AssertionError("Non-zero stamp for empty progress map: " + key + ", "+ value);
        }
 else {
          checkZero();
        }
        checkDepth("3");
      }
    }
    @Override public StackStamp markStack(){
      final Integer stamp=ourStamp.get();
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return Comparing.equal(stamp,ourStamp.get());
        }
      }
;
    }
    @Override public List<Object> currentStack(){
      ArrayList<Object> result=new ArrayList<Object>();
      LinkedHashMap<MyKey,Integer> map=ourProgress.get();
      for (      MyKey pair : map.keySet()) {
        if (pair.first.equals(id)) {
          result.add(pair.second);
        }
      }
      return result;
    }
    @Override public void prohibitResultCaching(    Object since){
      _prohibitResultCaching(since);
      ourMemoizationStamp.set(ourMemoizationStamp.get() + 1);
    }
    private void _prohibitResultCaching(    Object since){
      int stamp=ourStamp.get() + 1;
      ourStamp.set(stamp);
      checkZero();
      boolean inLoop=false;
      for (      Map.Entry<MyKey,Integer> entry : ourProgress.get().entrySet()) {
        if (inLoop) {
          entry.setValue(stamp);
        }
 else         if (entry.getKey().first.equals(id) && entry.getKey().second.equals(since)) {
          inLoop=true;
        }
      }
      checkZero();
    }
  }
;
}
