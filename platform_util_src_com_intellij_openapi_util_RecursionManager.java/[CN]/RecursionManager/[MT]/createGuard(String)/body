{
  return new RecursionGuard(){
    @Override public <T>T doPreventingRecursion(    Object key,    Computable<T> computation){
      Pair<String,Object> realKey=Pair.create(id,key);
      LinkedHashMap<Pair<String,Object>,Integer> progressMap=ourProgress.get();
      if (progressMap.containsKey(realKey)) {
        prohibitResultCaching(key);
        return null;
      }
      progressMap.put(realKey,ourStamp.get());
      try {
        return computation.compute();
      }
  finally {
        ourStamp.set(progressMap.remove(realKey));
      }
    }
    @Override public StackStamp markStack(){
      final Integer stamp=ourStamp.get();
      return new StackStamp(){
        @Override public boolean mayCacheNow(){
          return Comparing.equal(stamp,ourStamp.get());
        }
      }
;
    }
    @Override public List<Object> currentStack(){
      ArrayList<Object> result=new ArrayList<Object>();
      LinkedHashMap<Pair<String,Object>,Integer> map=ourProgress.get();
      for (      Pair<String,Object> pair : map.keySet()) {
        if (pair.first == id) {
          result.add(pair.second);
        }
      }
      return result;
    }
    @Override public void prohibitResultCaching(    Object since){
      int stamp=ourStamp.get() + 1;
      ourStamp.set(stamp);
      boolean inLoop=false;
      for (      Map.Entry<Pair<String,Object>,Integer> entry : ourProgress.get().entrySet()) {
        if (inLoop) {
          entry.setValue(stamp);
        }
 else         if (entry.getKey().first.equals(id) && entry.getKey().second.equals(since)) {
          inLoop=true;
        }
      }
    }
  }
;
}
