{
  byte[] buf=new byte[4];
  try {
    CoderResult coderResult=doFlush(out);
    if (coderResult == CoderResult.OVERFLOW)     return CoderResult.OVERFLOW;
    while (in.position() < in.limit()) {
      in.mark();
      final byte b=in.get();
      if (b == '\\') {
        byte next=in.get();
        if (next == 'u') {
          buf[0]=in.get();
          buf[1]=in.get();
          buf[2]=in.get();
          buf[3]=in.get();
          char decoded=unicode(buf);
          if (decoded == INVALID_CHAR) {
            myOutBuffer.append("\\u");
            myOutBuffer.append((char)buf[0]);
            myOutBuffer.append((char)buf[1]);
            myOutBuffer.append((char)buf[2]);
            myOutBuffer.append((char)buf[3]);
          }
 else {
            myOutBuffer.append(decoded);
          }
        }
 else {
          myOutBuffer.append("\\");
          myOutBuffer.append((char)next);
        }
      }
 else {
        buf[0]=b;
        ByteBuffer byteBuffer=ByteBuffer.wrap(buf,0,1);
        CharBuffer charBuffer=Native2AsciiCharset.DEFAULT_CHARSET.decode(byteBuffer);
        myOutBuffer.append(charBuffer);
      }
    }
  }
 catch (  BufferUnderflowException e) {
    in.reset();
  }
  return doFlush(out);
}
