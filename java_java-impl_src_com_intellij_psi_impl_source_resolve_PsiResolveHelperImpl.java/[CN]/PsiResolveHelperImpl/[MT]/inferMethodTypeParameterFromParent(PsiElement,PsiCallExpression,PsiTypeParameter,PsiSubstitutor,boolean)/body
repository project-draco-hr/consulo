{
  Pair<PsiType,ConstraintType> constraint=null;
  PsiType expectedType=null;
  if (parent instanceof PsiVariable && methodCall.equals(((PsiVariable)parent).getInitializer())) {
    expectedType=((PsiVariable)parent).getType();
  }
 else   if (parent instanceof PsiAssignmentExpression && methodCall.equals(((PsiAssignmentExpression)parent).getRExpression())) {
    expectedType=((PsiAssignmentExpression)parent).getLExpression().getType();
  }
 else   if (parent instanceof PsiReturnStatement) {
    PsiMethod method=PsiTreeUtil.getParentOfType(parent,PsiMethod.class);
    if (method != null) {
      expectedType=method.getReturnType();
    }
  }
 else   if (parent instanceof PsiExpressionList && forCompletion) {
    final PsiElement pParent=parent.getParent();
    if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {
      constraint=inferTypeForCompletionFromCallContext(methodCall,(PsiExpressionList)parent,(PsiCallExpression)pParent,typeParameter);
    }
  }
  final PsiManager manager=typeParameter.getManager();
  final GlobalSearchScope scope=parent.getResolveScope();
  PsiType returnType=null;
  if (constraint == null) {
    if (expectedType == null) {
      expectedType=forCompletion ? PsiType.NULL : PsiType.getJavaLangObject(manager,scope);
    }
    returnType=((PsiMethod)typeParameter.getOwner()).getReturnType();
    constraint=getSubstitutionForTypeParameterConstraint(typeParameter,returnType,expectedType,false,PsiUtil.getLanguageLevel(parent));
    if (constraint != null) {
      PsiType guess=constraint.getFirst();
      if (guess != null && !guess.equals(PsiType.NULL) && constraint.getSecond() == ConstraintType.SUPERTYPE && guess instanceof PsiIntersectionType) {
        for (        PsiType conjuct : ((PsiIntersectionType)guess).getConjuncts()) {
          if (!conjuct.isAssignableFrom(expectedType)) {
            return FAILED_INFERENCE;
          }
        }
      }
    }
  }
  final Pair<PsiType,ConstraintType> result;
  if (constraint == null) {
    final PsiSubstitutor finalSubstitutor=substitutor.put(typeParameter,null);
    PsiClassType[] superTypes=typeParameter.getSuperTypes();
    if (superTypes.length == 0)     return null;
    PsiType superType=finalSubstitutor.substitute(superTypes[0]);
    if (superType == null)     superType=PsiType.getJavaLangObject(manager,scope);
    if (superType == null)     return null;
    if (forCompletion && !(superType instanceof PsiWildcardType)) {
      result=new Pair<PsiType,ConstraintType>(PsiWildcardType.createExtends(manager,superType),ConstraintType.EQUALS);
    }
 else {
      result=new Pair<PsiType,ConstraintType>(superType,ConstraintType.SUBTYPE);
    }
  }
 else {
    PsiType guess=constraint.getFirst();
    if (forCompletion && guess != null && !(guess instanceof PsiWildcardType)) {
      if (constraint.getSecond() == ConstraintType.SUPERTYPE)       guess=PsiWildcardType.createExtends(manager,guess);
 else       if (constraint.getSecond() == ConstraintType.SUBTYPE)       guess=PsiWildcardType.createSuper(manager,guess);
    }
    if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {
      PsiClassType[] extendsTypes=typeParameter.getExtendsListTypes();
      PsiSubstitutor newSubstitutor=substitutor.put(typeParameter,guess);
      for (      PsiClassType extendsType1 : extendsTypes) {
        PsiType extendsType=newSubstitutor.substitute(extendsType1);
        if (guess != null && !extendsType.isAssignableFrom(guess)) {
          if (guess.isAssignableFrom(extendsType)) {
            guess=extendsType;
            newSubstitutor=substitutor.put(typeParameter,guess);
          }
 else {
            break;
          }
        }
      }
    }
    result=new Pair<PsiType,ConstraintType>(guess,constraint.getSecond());
  }
  return result;
}
