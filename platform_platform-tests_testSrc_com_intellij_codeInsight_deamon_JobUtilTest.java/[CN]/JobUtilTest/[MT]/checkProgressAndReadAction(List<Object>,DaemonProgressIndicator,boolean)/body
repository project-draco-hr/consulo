{
  final AtomicReference<Throwable> exception=new AtomicReference<Throwable>();
  JobLauncher.getInstance().invokeConcurrentlyUnderProgress(objects,progress,runInReadAction,new Processor<Object>(){
    @Override public boolean process(    Object o){
      try {
        if (objects.size() <= 1 || JobSchedulerImpl.CORES_COUNT <= 2) {
          assertTrue(ApplicationManager.getApplication().isDispatchThread());
        }
 else {
        }
        ProgressIndicator actualIndicator=ProgressManager.getInstance().getProgressIndicator();
        assertTrue(actualIndicator instanceof SensitiveProgressWrapper);
        actualIndicator=((SensitiveProgressWrapper)actualIndicator).getOriginalProgressIndicator();
        if (progress != null) {
          assertSame(progress,actualIndicator);
        }
 else {
          assertNotNull(actualIndicator);
        }
        assertTrue(!runInReadAction || ApplicationManager.getApplication().isReadAccessAllowed());
      }
 catch (      Throwable e) {
        exception.set(e);
      }
      return true;
    }
  }
);
  if (exception.get() != null)   throw exception.get();
}
