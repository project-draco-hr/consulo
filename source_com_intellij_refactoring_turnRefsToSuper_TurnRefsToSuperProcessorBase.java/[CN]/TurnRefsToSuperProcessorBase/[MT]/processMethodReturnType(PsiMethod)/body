{
  final PsiTypeElement returnType=method.getReturnTypeElement();
  final PsiReference[] calls=mySearchHelper.findReferences(method,GlobalSearchScope.projectScope(myProject),false);
  for (int i=0; i < calls.length; i++) {
    final PsiElement ref=calls[i].getElement();
    if (PsiTreeUtil.getParentOfType(ref,PsiDocComment.class) != null)     continue;
    final PsiMethodCallExpression methodCall=(PsiMethodCallExpression)ref.getParent();
    addLink(methodCall,returnType);
  }
  final PsiReturnStatement[] returnStatements=RefactoringUtil.findReturnStatements(method);
  for (int idx=0; idx < returnStatements.length; idx++) {
    final PsiReturnStatement returnStatement=returnStatements[idx];
    final PsiExpression returnValue=returnStatement.getReturnValue();
    if (returnValue != null) {
      addLink(returnType,returnValue);
    }
  }
  final PsiMethod[] superMethods=PsiSuperMethodUtil.findSuperMethods(method);
final class Inner {
    public void linkInheritors(    final PsiMethod[] methods){
      for (int i=0; i < methods.length; i++) {
        final PsiMethod superMethod=methods[i];
        final PsiTypeElement superType=superMethod.getReturnTypeElement();
        addLink(superType,returnType);
        addLink(returnType,superType);
      }
    }
  }
  ;
  new Inner().linkInheritors(superMethods);
  final PsiClass[] subClasses=mySearchHelper.findInheritors(method.getContainingClass(),GlobalSearchScope.projectScope(myProject),false);
  for (int i1=0; i1 != subClasses.length; ++i1) {
    final PsiMethod[] mBSs=subClasses[i1].findMethodsBySignature(method,true);
    new Inner().linkInheritors(mBSs);
  }
}
