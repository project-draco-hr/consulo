{
  myMockery=new JUnit4Mockery(){
{
      setImposteriser(ClassImposteriser.INSTANCE);
    }
  }
;
  myEditor=myMockery.mock(EditorEx.class);
  myDocument=myMockery.mock(Document.class);
  myStorage=new SoftWrapsStorage(myDocument);
  myFoldingModel=myMockery.mock(FoldingModel.class);
  final EditorSettings settings=myMockery.mock(EditorSettings.class);
  final Project project=myMockery.mock(Project.class);
  myMockery.checking(new Expectations(){
{
      allowing(myEditor).getDocument();
      will(returnValue(myDocument));
      allowing(myDocument).getLineCount();
      will(new CustomAction("getLineCount()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myLineRanges.size();
        }
      }
);
      allowing(myDocument).getLineNumber(with(any(int.class)));
      will(new CustomAction("getLineNumber()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineNumber((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineStartOffset(with(any(int.class)));
      will(new CustomAction("getLineStart()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineStartOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineEndOffset(with(any(int.class)));
      will(new CustomAction("getLineEnd()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineEndOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).getSettings();
      will(returnValue(settings));
      allowing(settings).isUseSoftWraps();
      will(returnValue(true));
      allowing(settings).getTabSize(project);
      will(returnValue(TAB_SIZE));
      allowing(myEditor).getProject();
      will(returnValue(project));
      allowing(myEditor).getFoldingModel();
      will(returnValue(myFoldingModel));
      allowing(myFoldingModel).isOffsetCollapsed(with(any(int.class)));
      will(new CustomAction("isOffsetCollapsed()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myFoldedOffsets.contains((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myFoldingModel).getCollapsedRegionAtOffset(with(any(int.class)));
      will(new CustomAction("getCollapsedRegionAtOffset()"){
        @Nullable @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getCollapsedFoldRegion((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myFoldingModel).getAllFoldRegions();
      will(new CustomAction("getAllFoldRegions()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myFoldRegions.toArray(new FoldRegion[myFoldRegions.size()]);
        }
      }
);
      allowing(myEditor).logicalToVisualPosition(with(any(LogicalPosition.class)));
      will(new CustomAction("logical2visual()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return logicalToVisual((LogicalPosition)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).logicalPositionToOffset(with(any(LogicalPosition.class)));
      will(new CustomAction("logical2offset()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return logicalToOffset((LogicalPosition)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).offsetToLogicalPosition(with(any(int.class)));
      will(new CustomAction("offset2logical()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return offsetToLogical((Integer)invocation.getParameter(0));
        }
      }
);
    }
  }
);
  myAdjuster=new SoftWrapDataMapper(myEditor,myStorage);
}
