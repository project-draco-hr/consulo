{
  super(method.getProject());
  myMoveDestination=moveDestination;
  this.method=method;
  this.className=className;
  this.packageName=packageName;
  this.keepMethodAsDelegate=keepMethodAsDelegate;
  myUseExistingClass=useExistingClass;
  myCreateInnerClass=createInnerClass;
  myNewVisibility=newVisibility;
  myGenerateAccessors=generateAccessors;
  this.parameters=new ArrayList<ParameterChunk>();
  for (  ParameterTablePanel.VariableData parameter : parameters) {
    this.parameters.add(new ParameterChunk(parameter));
  }
  final PsiParameterList parameterList=method.getParameterList();
  final PsiParameter[] methodParams=parameterList.getParameters();
  paramsToMerge=new int[parameters.length];
  for (int p=0; p < parameters.length; p++) {
    ParameterTablePanel.VariableData parameter=parameters[p];
    for (int i=0; i < methodParams.length; i++) {
      final PsiParameter methodParam=methodParams[i];
      if (parameter.variable.equals(methodParam)) {
        paramsToMerge[p]=i;
        break;
      }
    }
  }
  final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
  final PsiTypeVisitor<Object> typeParametersVisitor=new PsiTypeVisitor<Object>(){
    @Override public Object visitClassType(    PsiClassType classType){
      final PsiClass referent=classType.resolve();
      if (referent instanceof PsiTypeParameter) {
        typeParamSet.add((PsiTypeParameter)referent);
      }
      return super.visitClassType(classType);
    }
  }
;
  for (  ParameterTablePanel.VariableData parameter : parameters) {
    parameter.type.accept(typeParametersVisitor);
  }
  typeParams=new ArrayList<PsiTypeParameter>(typeParamSet);
  final String qualifiedName=StringUtil.getQualifiedName(packageName,className);
  final GlobalSearchScope scope=GlobalSearchScope.allScope(myProject);
  existingClass=JavaPsiFacade.getInstance(myProject).findClass(qualifiedName,scope);
}
