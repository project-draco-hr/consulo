{
  listener.indeterminate();
  final SvnChangeProvider changeProvider=(SvnChangeProvider)mySvnVcs.getChangeProvider();
  final UnversionedFilesGroupCollector collector=new UnversionedFilesGroupCollector();
  final Set<String> files=new HashSet<String>();
  for (  Change change : changes) {
    final ContentRevision beforeRevision=change.getBeforeRevision();
    if (beforeRevision != null) {
      files.add(beforeRevision.getFile().getIOFile().getAbsolutePath());
    }
    final ContentRevision afterRevision=change.getAfterRevision();
    if (afterRevision != null) {
      final String afterPath=afterRevision.getFile().getIOFile().getAbsolutePath();
      files.add(afterPath);
      if ((beforeRevision != null) && (!afterPath.equals(beforeRevision.getFile().getIOFile().getAbsolutePath()))) {
        collector.setBefore(beforeRevision.getFile().getIOFile(),afterRevision.getFile().getIOFile());
        try {
          changeProvider.getChanges(afterRevision.getFile(),false,collector);
        }
 catch (        SVNException e) {
          exceptions.add(new VcsException(e));
        }
      }
    }
  }
  final File[] filesArr=new File[files.size()];
  int i=0;
  for (  String file : files) {
    filesArr[i]=new File(file);
    ++i;
  }
  try {
    final SVNWCClient client=mySvnVcs.createWCClient();
    client.setEventHandler(new ISVNEventHandler(){
      public void handleEvent(      SVNEvent event,      double progress){
        if (event.getAction() == SVNEventAction.REVERT) {
          final File file=event.getFile();
          if (file != null) {
            listener.accept(file);
          }
        }
        if (event.getAction() == SVNEventAction.FAILED_REVERT) {
          exceptions.add(new VcsException("Revert failed"));
        }
      }
      public void checkCancelled(){
        listener.checkCanceled();
      }
    }
);
    client.doRevert(filesArr,SVNDepth.EMPTY,null);
  }
 catch (  SVNException e) {
    if (e.getErrorMessage().getErrorCode() != SVNErrorCode.WC_NOT_DIRECTORY) {
      exceptions.add(new VcsException(e));
    }
  }
  final List<Trinity<File,File,File>> fromTo=collector.getFromTo();
  for (  Trinity<File,File,File> trinity : fromTo) {
    if (trinity.getFirst().exists()) {
      trinity.getSecond().renameTo(trinity.getThird());
    }
  }
  final List<Pair<File,File>> toBeDeleted=collector.getToBeDeleted();
  for (  Pair<File,File> pair : toBeDeleted) {
    if (pair.getFirst().exists()) {
      FileUtil.delete(pair.getSecond());
    }
  }
}
