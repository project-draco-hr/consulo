{
  final Map<File,ThroughRenameInfo> fromTo=collector.getFromTo();
  try {
    final File tmp=FileUtil.createTempDirectory("forRename","");
    final SVNWCClient client=mySvnVcs.createWCClient();
    final ISVNPropertyHandler handler=new ISVNPropertyHandler(){
      @Override public void handleProperty(      File path,      SVNPropertyData property) throws SVNException {
        final ThroughRenameInfo info=collector.findToFile(new FilePathImpl(path,path.isDirectory()),null);
        if (info != null) {
          properties.putValue(info.getTo(),property);
        }
      }
      @Override public void handleProperty(      SVNURL url,      SVNPropertyData property) throws SVNException {
      }
      @Override public void handleProperty(      long revision,      SVNPropertyData property) throws SVNException {
      }
    }
;
    for (    Map.Entry<File,ThroughRenameInfo> entry : fromTo.entrySet()) {
      final File source=entry.getKey();
      final ThroughRenameInfo info=entry.getValue();
      if (info.isVersioned()) {
        client.doGetProperty(source,null,SVNRevision.UNDEFINED,SVNRevision.WORKING,SVNDepth.EMPTY,handler,null);
      }
      if (source.isDirectory()) {
        if (!FileUtil.filesEqual(info.getTo(),info.getFirstTo())) {
          fromToModified.add(new CopiedAsideInfo(info.getParentImmediateReverted(),info.getTo(),info.getFirstTo(),null));
        }
        continue;
      }
      final File tmpFile=FileUtil.createTempFile(tmp,source.getName(),"",false);
      tmpFile.mkdirs();
      FileUtil.delete(tmpFile);
      FileUtil.copy(source,tmpFile);
      fromToModified.add(new CopiedAsideInfo(info.getParentImmediateReverted(),info.getTo(),info.getFirstTo(),tmpFile));
    }
  }
 catch (  IOException e) {
    exceptions.add(new VcsException(e));
  }
catch (  SVNException e) {
    exceptions.add(new VcsException(e));
  }
}
