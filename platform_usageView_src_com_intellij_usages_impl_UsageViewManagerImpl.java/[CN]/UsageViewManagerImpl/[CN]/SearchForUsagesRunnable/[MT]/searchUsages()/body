{
  UsageSearcher usageSearcher=mySearcherFactory.create();
  final AtomicInteger tooManyUsages=new AtomicInteger();
  final CountDownLatch waitWhileUserClick=new CountDownLatch(1);
  usageSearcher.generate(new Processor<Usage>(){
    @Override public boolean process(    final Usage usage){
      final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
      if (searchHasBeenCancelled() || indicator != null && indicator.isCanceled())       return false;
      if (tooManyUsages.get() == 1) {
        try {
          waitWhileUserClick.await(1,TimeUnit.SECONDS);
        }
 catch (        InterruptedException ignored) {
        }
      }
      boolean incrementCounter=!isSelfUsage(usage,mySearchFor);
      if (incrementCounter) {
        final int usageCount=myUsageCountWithoutDefinition.incrementAndGet();
        if (usageCount == 1 && !myProcessPresentation.isShowPanelIfOnlyOneUsage()) {
          myFirstUsage.compareAndSet(null,usage);
        }
        if (usageCount > UsageLimitUtil.USAGES_LIMIT && tooManyUsages.get() == 0 && tooManyUsages.compareAndSet(0,1)) {
          showTooManyUsagesWarning(indicator,waitWhileUserClick,myUsageCountWithoutDefinition.get());
        }
        UsageViewImpl usageView=getUsageView();
        if (usageView != null) {
          usageView.appendUsageLater(usage);
        }
      }
      return indicator == null || !indicator.isCanceled();
    }
  }
);
  if (getUsageView() != null) {
    ApplicationManager.getApplication().invokeLater(new Runnable(){
      @Override public void run(){
        showToolWindow(true);
      }
    }
,myProject.getDisposed());
  }
}
