{
  return new Runnable(){
    @Override public void run(){
      XmlFile xmlFile=(XmlFile)file;
      Project project=xmlFile.getProject();
      ProblemsHolder holder=new ProblemsHolder(InspectionManager.getInstance(project),xmlFile,false);
      final XmlElementVisitor visitor=(XmlElementVisitor)myInspection.buildVisitor(holder,false);
      new PsiRecursiveElementVisitor(){
        @Override public void visitElement(        PsiElement element){
          if (element instanceof XmlAttribute) {
            visitor.visitXmlAttribute((XmlAttribute)element);
          }
 else {
            super.visitElement(element);
          }
        }
      }
.visitFile(xmlFile);
      ProblemDescriptor[] results=holder.getResultsArray();
      ArrayUtil.reverseArray(results);
      Map<XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix,ProblemDescriptor> fixes=new LinkedHashMap<XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix,ProblemDescriptor>();
      for (      ProblemDescriptor result : results) {
        for (        QuickFix fix : result.getFixes()) {
          if (fix instanceof XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix) {
            fixes.put((XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix)fix,result);
          }
        }
      }
      SmartPsiElementPointer<XmlTag> pointer=null;
      for (      Map.Entry<XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix,ProblemDescriptor> fix : fixes.entrySet()) {
        pointer=fix.getKey().doFix(project,fix.getValue(),false);
      }
      if (pointer != null) {
        XmlUnusedNamespaceInspection.RemoveNamespaceDeclarationFix.reformatStartTag(project,pointer);
      }
    }
  }
;
}
