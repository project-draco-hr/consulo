{
  if (indentShift == 0)   return element;
  final CharTable charTableByTree=SharedImplUtil.findCharTableByTree(element);
  String text=element.getText();
  for (int offset=0; offset < text.length(); offset++) {
    char c=text.charAt(offset);
    if (c == '\n' || c == '\r') {
      int offset1;
      for (offset1=offset + 1; offset1 < text.length(); offset1++) {
        c=text.charAt(offset1);
        if (c != ' ' && c != '\t')         break;
      }
      if (c == '\n' || c == '\r')       continue;
      String space=text.substring(offset + 1,offset1);
      int indent=myIndentIndentHelper.getIndent(space,true);
      int newIndent=indent + indentShift;
      newIndent=Math.max(newIndent,0);
      String newSpace=myIndentIndentHelper.fillIndent(newIndent);
      ASTNode leaf=element.findLeafElementAt(offset);
      if (!mayShiftIndentInside(leaf)) {
        LOG.error("Error",leaf.getElementType().toString(),"Type: " + leaf.getElementType() + " text: "+ leaf.getText());
      }
      if (offset1 < text.length()) {
        ASTNode next=element.findLeafElementAt(offset1);
        if ((next.getElementType() == ElementType.END_OF_LINE_COMMENT || next.getElementType() == ElementType.C_STYLE_COMMENT || next.getElementType() == JspElementType.JSP_COMMENT) && next != element) {
          if (mySettings.KEEP_FIRST_COLUMN_COMMENT) {
            int commentIndent=myIndentIndentHelper.getIndent(next,true);
            if (commentIndent == 0)             continue;
          }
        }
 else         if (next.getElementType() == XmlElementType.XML_DATA_CHARACTERS) {
          continue;
        }
      }
      int leafOffset=getStartOffset(element,leaf);
      if (leaf.getElementType() == ElementType.DOC_COMMENT_DATA && leafOffset + leaf.getTextLength() == offset + 1) {
        ASTNode next=element.findLeafElementAt(offset + 1);
        if (next.getElementType() == TokenType.WHITE_SPACE) {
          leaf=next;
          leafOffset=getStartOffset(element,leaf);
        }
 else {
          if (newSpace.length() > 0) {
            LeafElement newLeaf=ASTFactory.leaf(TokenType.WHITE_SPACE,newSpace,charTableByTree);
            next.getTreeParent().addChild(newLeaf,next);
          }
          text=text.substring(0,offset + 1) + newSpace + text.substring(offset1);
          continue;
        }
      }
      int startOffset=offset + 1 - leafOffset;
      int endOffset=offset1 - leafOffset;
      if (!LOG.assertTrue(0 <= startOffset && startOffset <= endOffset && endOffset <= leaf.getTextLength())) {
        continue;
      }
      String leafText=leaf.getText();
      String newLeafText=leafText.substring(0,startOffset) + newSpace + leafText.substring(endOffset);
      if (newLeafText.length() > 0) {
        LeafElement newLeaf=Factory.createSingleLeafElement(leaf.getElementType(),newLeafText,charTableByTree,SharedImplUtil.getManagerByTree(leaf));
        if (leaf.getTreeParent() != null) {
          leaf.getTreeParent().replaceChild(leaf,newLeaf);
        }
        if (leaf == element) {
          element=newLeaf;
        }
      }
 else {
        ASTNode parent=leaf.getTreeParent();
        if (parent != null) {
          parent.removeChild(leaf);
        }
      }
      text=text.substring(0,offset + 1) + newSpace + text.substring(offset1);
    }
  }
  return element;
}
