{
  MethodSignatureBackedByPsiMethod toCheck=toCheckSubsignature.get(signatureToCheck);
  final PsiMethod checkMethod=toCheck.getMethod();
  if (checkMethod.isConstructor()) {
    if (!superMethod.isConstructor() || !checkMethod.getContainingClass().equals(superMethod.getContainingClass()))     return null;
  }
 else   if (superMethod.isConstructor())   return null;
  if (checkMethod.hasModifierProperty(PsiModifier.STATIC)) {
    if (!checkMethod.getContainingClass().equals(superMethod.getContainingClass()))     return null;
  }
  if (!MethodSignatureUtil.isSubsignature(superSignature,toCheck)) {
    PsiMethod method1=signatureToCheck.getMethod();
    if (aClass.equals(method1.getContainingClass())) {
      boolean sameClass=method1.getContainingClass().equals(superMethod.getContainingClass());
      methodHighlights.add(getSameErasureMessage(sameClass,method1,superMethod));
    }
 else     if (classHighliht == null) {
      final String descr=JavaErrorMessages.message("generics.methods.have.same.erasure.override",HighlightMethodUtil.createClashMethodMessage(method1,superMethod,true));
      TextRange textRange=com.intellij.codeInsight.ClassUtil.getClassDeclarationTextRange(aClass);
      classHighliht=HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,textRange,descr);
    }
  }
  return classHighliht;
}
