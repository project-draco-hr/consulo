{
  if (refMethod.isLibraryOverride())   return null;
  if (refMethod.getSuperMethods().size() > 0)   return null;
  PsiClassType[] unThrown=refMethod.getUnThrownExceptions();
  if (unThrown == null)   return null;
  PsiMethod psiMethod=(PsiMethod)refMethod.getElement();
  PsiClassType[] throwsList=psiMethod.getThrowsList().getReferencedTypes();
  PsiJavaCodeReferenceElement[] throwsRefs=psiMethod.getThrowsList().getReferenceElements();
  ArrayList<ProblemDescriptor> problems=null;
  for (int i=0; i < throwsList.length; i++) {
    PsiClassType throwsType=throwsList[i];
    PsiJavaCodeReferenceElement throwsRef=throwsRefs[i];
    if (ExceptionUtil.isUncheckedException(throwsType))     continue;
    for (int j=0; j < unThrown.length; j++) {
      PsiClassType s=unThrown[j];
      if (s.equals(throwsType)) {
        if (problems == null)         problems=new ArrayList<ProblemDescriptor>(1);
        final String message;
        if (refMethod.isAbstract() || refMethod.getOwnerClass().isInterface()) {
          message=" in method implementations";
        }
 else         if (refMethod.getDerivedMethods().size() > 0) {
          message=" in this method, nor in its derivables.";
        }
 else {
          message=".";
        }
        problems.add(getManager().createProblemDescriptor(throwsRef,"The declared exception <code>#ref</code> is never thrown" + message,getFix(),ProblemHighlightType.LIKE_UNUSED_SYMBOL));
      }
    }
  }
  if (problems != null) {
    return problems.toArray(new ProblemDescriptorImpl[problems.size()]);
  }
  return null;
}
