{
  if (settings != null) {
    if (settings.getDistributionType() == DistributionType.WRAPPED) {
      myHelper.ensureInstalledWrapper(id,projectPath,settings,listener);
    }
    List<ClassHolder<? extends GradleProjectResolverExtension>> extensionClasses=settings.getResolverExtensions();
    if (myCachedExtensions == null || !myCachedExtensions.first.equals(extensionClasses)) {
      List<GradleProjectResolverExtension> extensions=ContainerUtilRt.newArrayList();
      for (      ClassHolder<? extends GradleProjectResolverExtension> holder : extensionClasses) {
        try {
          final GradleProjectResolverExtension extension=holder.getTargetClass().newInstance();
          extensions.add(extension);
        }
 catch (        Throwable e) {
          throw new IllegalArgumentException(String.format("Can't instantiate project resolve extension for class '%s'",holder.getTargetClassName()),e);
        }
      }
      List<ClassHolder<? extends GradleProjectResolverExtension>> key=ContainerUtilRt.newArrayList(extensionClasses);
      myCachedExtensions=Pair.create(key,extensions);
    }
    for (    GradleProjectResolverExtension extension : myCachedExtensions.second) {
      DataNode<ProjectData> result=extension.resolveProjectInfo(id,projectPath,downloadLibraries,settings,listener);
      if (result != null) {
        return result;
      }
    }
  }
  return myHelper.execute(projectPath,settings,new Function<ProjectConnection,DataNode<ProjectData>>(){
    @Override public DataNode<ProjectData> fun(    ProjectConnection connection){
      return doResolveProjectInfo(id,projectPath,settings,connection,listener,downloadLibraries);
    }
  }
);
}
