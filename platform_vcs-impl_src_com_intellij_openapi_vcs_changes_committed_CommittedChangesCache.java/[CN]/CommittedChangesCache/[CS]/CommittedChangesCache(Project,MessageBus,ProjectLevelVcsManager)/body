{
  myProject=project;
  myBus=bus;
  myConnection=myBus.connect();
  final VcsListener vcsListener=new VcsListener(){
    @Override public void directoryMappingChanged(){
      myLocationCache.reset();
      refreshAllCachesAsync(false,true);
      refreshIncomingChangesAsync();
      myTaskQueue.run(new Runnable(){
        @Override public void run(){
          final List<ChangesCacheFile> files=myCachesHolder.getAllCaches();
          for (          ChangesCacheFile file : files) {
            final RepositoryLocation location=file.getLocation();
            fireChangesLoaded(location,Collections.<CommittedChangeList>emptyList());
          }
          fireIncomingReloaded();
        }
      }
);
    }
  }
;
  myLocationCache=new RepositoryLocationCache(project);
  myCachesHolder=new CachesHolder(project,myLocationCache);
  myTaskQueue=new ProgressManagerQueue(project,VcsBundle.message("committed.changes.refresh.progress"));
  ((ProjectLevelVcsManagerImpl)vcsManager).addInitializationRequest(VcsInitObject.COMMITTED_CHANGES_CACHE,new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          if (myProject.isDisposed())           return;
          myTaskQueue.start();
          myConnection.subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED,vcsListener);
          myConnection.subscribe(ProjectLevelVcsManager.VCS_CONFIGURATION_CHANGED_IN_PLUGIN,vcsListener);
        }
      }
);
    }
  }
);
  myVcsManager=vcsManager;
  Disposer.register(project,new Disposable(){
    @Override public void dispose(){
      cancelRefreshTimer();
      myConnection.disconnect();
    }
  }
);
  myExternallyLoadedChangeLists=new ConcurrentHashMap<String,Pair<Long,List<CommittedChangeList>>>();
}
