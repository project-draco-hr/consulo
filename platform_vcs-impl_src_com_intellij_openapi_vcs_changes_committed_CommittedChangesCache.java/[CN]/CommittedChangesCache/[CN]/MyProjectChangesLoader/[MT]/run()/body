{
  for (  AbstractVcs vcs : myVcsManager.getAllActiveVcss()) {
    final CommittedChangesProvider provider=vcs.getCommittedChangesProvider();
    if (provider == null)     continue;
    final VcsCommittedListsZipper vcsZipper=provider.getZipper();
    CommittedListsSequencesZipper zipper=null;
    if (vcsZipper != null) {
      zipper=new CommittedListsSequencesZipper(vcsZipper);
    }
    boolean zipSupported=zipper != null;
    final List<VirtualFile> roots=myCachesHolder.getAllRootsUnderVcs(vcs);
    for (    VirtualFile root : roots) {
      if (myProject.isDisposed())       return;
      final RepositoryLocation location=myLocationCache.getLocation(vcs,new FilePathImpl(root),false);
      if (location == null)       continue;
      try {
        final List<CommittedChangeList> lists=getChanges(mySettings,root,vcs,myMaxCount,myCacheOnly,provider,location);
        if (lists != null) {
          if (zipSupported) {
            zipper.add(location,lists);
          }
 else {
            myResult.addAll(lists);
          }
        }
      }
 catch (      VcsException e) {
        myExceptions.add(e);
      }
catch (      ProcessCanceledException e) {
        myDisposed=true;
      }
    }
    if (zipSupported) {
      myResult.addAll(zipper.execute());
    }
  }
  ApplicationManager.getApplication().invokeLater(new Runnable(){
    public void run(){
      LOG.info("FINISHED CommittedChangesCache.getProjectChangesAsync - execution in queue");
      if (myProject.isDisposed()) {
        return;
      }
      if (myExceptions.size() > 0) {
        myErrorConsumer.consume(myExceptions);
      }
 else       if (!myDisposed) {
        myConsumer.consume(new ArrayList<CommittedChangeList>(myResult));
      }
    }
  }
,ModalityState.NON_MODAL);
}
