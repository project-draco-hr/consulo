{
  final List<SmartPsiElementPointer> toInvert=new ArrayList<SmartPsiElementPointer>();
  addRefsToInvert(toInvert,myElement);
  if (myElement instanceof PsiMethod) {
    final Collection<PsiMethod> overriders=OverridingMethodsSearch.search((PsiMethod)myElement).findAll();
    for (    PsiMethod overrider : overriders) {
      myRenameProcessor.addElement(overrider,myNewName);
    }
    Collection<PsiMethod> allMethods=new HashSet<PsiMethod>(overriders);
    allMethods.add((PsiMethod)myElement);
    for (    PsiMethod method : allMethods) {
      method.accept(new JavaRecursiveElementWalkingVisitor(){
        @Override public void visitReturnStatement(        PsiReturnStatement statement){
          final PsiExpression returnValue=statement.getReturnValue();
          if (returnValue != null && PsiType.BOOLEAN.equals(returnValue.getType())) {
            toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(returnValue));
          }
        }
      }
);
    }
  }
 else   if (myElement instanceof PsiParameter && ((PsiParameter)myElement).getDeclarationScope() instanceof PsiMethod) {
    final PsiMethod method=(PsiMethod)((PsiParameter)myElement).getDeclarationScope();
    int index=method.getParameterList().getParameterIndex((PsiParameter)myElement);
    LOG.assertTrue(index >= 0);
    final Query<PsiReference> methodQuery=MethodReferencesSearch.search(method);
    final Collection<PsiReference> methodRefs=methodQuery.findAll();
    for (    PsiReference ref : methodRefs) {
      if (ref.getElement().getParent() instanceof PsiCall) {
        final PsiCall call=(PsiCall)ref.getElement().getParent();
        final PsiReferenceExpression methodExpression=call instanceof PsiMethodCallExpression ? ((PsiMethodCallExpression)call).getMethodExpression() : null;
        final PsiExpressionList argumentList=call.getArgumentList();
        if (argumentList != null) {
          final PsiExpression[] args=argumentList.getExpressions();
          if (index < args.length) {
            if (methodExpression == null || methodExpression.getQualifier() == null || !"super".equals(methodExpression.getQualifierExpression().getText())) {
              toInvert.add(mySmartPointerManager.createSmartPsiElementPointer(args[index]));
            }
          }
        }
      }
    }
    final Collection<PsiMethod> overriders=OverridingMethodsSearch.search(method).findAll();
    for (    PsiMethod overrider : overriders) {
      final PsiParameter overriderParameter=overrider.getParameterList().getParameters()[index];
      myRenameProcessor.addElement(overriderParameter,myNewName);
      addRefsToInvert(toInvert,overriderParameter);
    }
  }
  final UsageInfo[] renameUsages=myRenameProcessor.findUsages();
  final SmartPsiElementPointer[] usagesToInvert=toInvert.toArray(new SmartPsiElementPointer[toInvert.size()]);
  Map<PsiElement,UsageInfo> expressionsToUsages=new HashMap<PsiElement,UsageInfo>();
  List<UsageInfo> result=new ArrayList<UsageInfo>();
  for (  UsageInfo renameUsage : renameUsages) {
    expressionsToUsages.put(renameUsage.getElement(),renameUsage);
    result.add(renameUsage);
  }
  for (  SmartPsiElementPointer pointer : usagesToInvert) {
    final PsiExpression expression=(PsiExpression)pointer.getElement();
    if (!expressionsToUsages.containsKey(expression)) {
      final UsageInfo usageInfo=new UsageInfo(expression);
      expressionsToUsages.put(expression,usageInfo);
      result.add(usageInfo);
      myToInvert.put(usageInfo,pointer);
    }
 else {
      myToInvert.put(expressionsToUsages.get(expression),pointer);
    }
  }
  return result.toArray(new UsageInfo[result.size()]);
}
