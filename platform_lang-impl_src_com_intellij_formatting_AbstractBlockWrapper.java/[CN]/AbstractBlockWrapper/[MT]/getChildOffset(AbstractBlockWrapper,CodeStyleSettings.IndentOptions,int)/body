{
  final boolean childOnNewLine=child.getWhiteSpace().containsLineFeeds();
  IndentImpl.Type childIndentType=child.getIndent().getType();
  final IndentData childIndent;
  if (childOnNewLine || (!getWhiteSpace().containsLineFeeds() && RELATIVE_INDENT_TYPES.contains(childIndentType) && indentAlreadyUsedBefore(child))) {
    childIndent=getIndent(options,child,targetBlockStartOffset);
  }
 else {
    childIndent=new IndentData(0);
  }
  if (childOnNewLine) {
    if (child.getIndent().isAbsolute()) {
      myFlags&=~CAN_USE_FIRST_CHILD_INDENT_AS_BLOCK_INDENT;
      AbstractBlockWrapper current=this;
      while (current != null && current.getStartOffset() == getStartOffset()) {
        current.myFlags&=~CAN_USE_FIRST_CHILD_INDENT_AS_BLOCK_INDENT;
        current=current.myParent;
      }
      return childIndent;
    }
 else     if (options.USE_RELATIVE_INDENTS && child.getStartOffset() > getStartOffset() && (CONTINUATION_INDENT_TYPES.contains(childIndentType))) {
      return childIndent.add(getNumberOfSymbolsBeforeBlock());
    }
  }
  if (child.getStartOffset() == getStartOffset()) {
    final boolean newValue=(myFlags & CAN_USE_FIRST_CHILD_INDENT_AS_BLOCK_INDENT) != 0 && (child.myFlags & CAN_USE_FIRST_CHILD_INDENT_AS_BLOCK_INDENT) != 0 && childIndent.isEmpty();
    setCanUseFirstChildIndentAsBlockIndent(newValue);
  }
  if (getStartOffset() == targetBlockStartOffset) {
    if (myParent == null) {
      return childIndent;
    }
 else {
      return childIndent.add(myParent.getChildOffset(this,options,targetBlockStartOffset));
    }
  }
 else   if (!getWhiteSpace().containsLineFeeds()) {
    if (isIndentAffectedAlignment(child)) {
      return createAlignmentIndent(childIndent,child);
    }
 else {
      return childIndent.add(myParent.getChildOffset(this,options,targetBlockStartOffset));
    }
  }
 else {
    if (myParent == null)     return childIndent.add(getWhiteSpace());
    if (getIndent().isAbsolute()) {
      if (myParent.myParent != null) {
        return childIndent.add(myParent.myParent.getChildOffset(myParent,options,targetBlockStartOffset));
      }
 else {
        return childIndent.add(getWhiteSpace());
      }
    }
    if ((myFlags & CAN_USE_FIRST_CHILD_INDENT_AS_BLOCK_INDENT) != 0) {
      if (isIndentAffectedAlignment(child)) {
        return createAlignmentIndent(childIndent,child);
      }
 else {
        return childIndent.add(getWhiteSpace());
      }
    }
 else {
      return childIndent.add(myParent.getChildOffset(this,options,targetBlockStartOffset));
    }
  }
}
