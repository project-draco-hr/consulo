{
  if (DO_OUTPUT) {
    System.out.println("CodeEditUtil.removeChildrenBefore\n" + parent.getPsi().getContainingFile().getText());
  }
  checkAllWhiteSpaces(parent);
  boolean doNotAdjust=first == parent.getFirstChildNode();
  ASTNode lastChild=last == null ? null : last.getTreeNext();
  ASTNode prevElement=TreeUtil.prevLeaf(first);
  ASTNode nextElement=findElementAfter(last == null ? parent : last,false);
  if (nextElement != null) {
    saveIndents(nextElement);
  }
  boolean adjustWSBefore=containLineBreaks(first,lastChild);
  if (!isWS(prevElement) || (prevElement != null && !prevElement.textContains('\n'))) {
    adjustWSBefore=true;
  }
  parent.removeRange(first,lastChild);
  final PsiFile file=parent.getPsi().getContainingFile();
  final CodeStyleSettings.IndentOptions options=CodeStyleSettingsManager.getSettings(file.getProject()).getIndentOptions(file.getFileType());
  if (nextElement != null) {
    ASTNode elementBeforeNext=TreeUtil.prevLeaf(nextElement);
    if (prevElement != null && isWS(prevElement) && isWS(elementBeforeNext) && prevElement != elementBeforeNext) {
      if (!elementBeforeNext.textContains('\n') && prevElement.textContains('\n')) {
        delete(elementBeforeNext);
      }
 else {
        String text=composeNewWS(prevElement.getText(),elementBeforeNext.getText(),options);
        delete(prevElement);
        if (!text.equals(elementBeforeNext.getText())) {
          final CharTable charTable=SharedImplUtil.findCharTableByTree(elementBeforeNext);
          LeafElement newWhiteSpace=Factory.createSingleLeafElement(elementBeforeNext.getElementType(),text.toCharArray(),0,text.length(),charTable,SharedImplUtil.getManagerByTree(elementBeforeNext));
          elementBeforeNext.getTreeParent().replaceChild(elementBeforeNext,newWhiteSpace);
        }
      }
    }
    elementBeforeNext=TreeUtil.prevLeaf(nextElement);
    if (isWS(elementBeforeNext) && whiteSpaceHasInvalidPosition(elementBeforeNext)) {
      final String text=elementBeforeNext.getText();
      delete(elementBeforeNext);
      FormatterUtil.replaceWhiteSpace(text,nextElement,ElementType.WHITE_SPACE);
    }
    final boolean keepFormatting=parent.getFirstChildNode() != null;
    if (!keepFormatting) {
      doNotAdjust=false;
    }
    if (adjustWSBefore) {
      adjustWhiteSpaceBefore(nextElement,keepFormatting,keepFormatting,true,!doNotAdjust);
    }
  }
 else {
    final ASTNode fileNode=SourceTreeToPsiMap.psiElementToTree(parent.getPsi().getContainingFile());
    ASTNode lastLeaf=TreeUtil.findLastLeaf(fileNode);
    if (isWS(lastLeaf)) {
      delete(lastLeaf);
    }
  }
  checkAllWhiteSpaces(parent);
  if (DO_OUTPUT) {
    System.out.println("CodeEditUtil.removeChildren\n" + parent.getPsi().getContainingFile().getText());
  }
}
