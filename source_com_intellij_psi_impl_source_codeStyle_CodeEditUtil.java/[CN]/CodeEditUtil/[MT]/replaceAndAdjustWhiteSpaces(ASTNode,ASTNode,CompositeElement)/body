{
  final ASTNode elementAfter=findElementAfter(oldChild,true);
  boolean changeFirstWS=newChild.textContains('\n') || oldChild.textContains('\n');
  ASTNode firstNonEmpty=findFirstNonEmpty(newChild,newChild.getTreeNext(),parent,newChild.getTreeNext());
  if (!canStickChildrenTogether(TreeUtil.prevLeaf(oldChild),firstNonEmpty)) {
    changeFirstWS=true;
  }
  Collection<PsiElement> dirtyElements=new ArrayList<PsiElement>();
  if (changeFirstWS) {
    saveIndents(newChild,dirtyElements);
  }
  if (elementAfter != null && !isWS(elementAfter)) {
    saveIndents(elementAfter,dirtyElements);
  }
  try {
    boolean checkWhiteSpaces=oldChild.getTextLength() > 0 && newChild.getTextLength() == 0;
    parent.replaceChild(oldChild,newChild);
    adjustWSPositionsAfterReplacement(checkWhiteSpaces,newChild,parent);
    final List<ASTNode> treePrev=getPreviousElements(newChild);
    adjustWhiteSpaceBefore(newChild,true,false,changeFirstWS,false);
    if (elementAfter != null && !isWS(elementAfter)) {
      adjustWhiteSpaceBefore(elementAfter,true,true,true,false);
    }
    checkAllWhiteSpaces(parent);
    return returnFirstChangedNode(treePrev,parent);
  }
  finally {
    clearIndentInfo(dirtyElements);
  }
}
