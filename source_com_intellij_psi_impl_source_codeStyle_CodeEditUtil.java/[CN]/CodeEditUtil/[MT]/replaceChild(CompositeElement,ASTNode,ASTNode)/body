{
  final PsiManager manager=parent.getManager();
  final Project project=manager.getProject();
  final CharTable treeCharTab=SharedImplUtil.findCharTableByTree(parent);
  CodeStyleSettings settings=CodeStyleSettingsManager.getSettings(project);
  final PsiFile file=SourceTreeToPsiMap.treeElementToPsi(parent).getContainingFile();
  FileType fileType=file.getFileType();
  Helper helper=new Helper(fileType,project);
  IndentAdjusterFacade indentAdjuster=new IndentAdjusterFacade(settings,helper);
  int oldIndent=helper.getIndent(newChild);
  parent.replaceChild(oldChild,newChild);
  if (fileType == StdFileTypes.XHTML)   return newChild;
  ASTNode prevNonSpace=Helper.shiftBackwardToNonSpace(newChild.getTreePrev());
  ASTNode nextNonSpace=Helper.shiftForwardToNonSpace(newChild.getTreeNext());
  if (newChild instanceof CompositeElement && newChild.getTextLength() == 0) {
    normalizeSpace(helper,parent,prevNonSpace,nextNonSpace,treeCharTab);
  }
 else {
    normalizeSpace(helper,parent,prevNonSpace,newChild,treeCharTab);
    normalizeSpace(helper,parent,newChild,nextNonSpace,treeCharTab);
  }
  String newChildText=newChild.getText();
  boolean isMultiline=newChildText.indexOf('\n') >= 0 || newChildText.indexOf('\r') >= 0;
  if (isMultiline) {
    String spaceText=helper.getSpaceText(parent,prevNonSpace,newChild);
    int index=Math.max(spaceText.lastIndexOf('\n'),spaceText.lastIndexOf('\r'));
    if (index >= 0 || (parent.getTreeParent() == null && prevNonSpace == null && newChild.getTextRange().getStartOffset() == spaceText.length())) {
      spaceText=spaceText.substring(0,index + 1) + helper.fillIndent(oldIndent);
      newChild=helper.makeSpace(parent,prevNonSpace,newChild,spaceText,false);
    }
  }
  indentAdjuster.adjustNormalizeIndent(newChild);
  return newChild;
}
