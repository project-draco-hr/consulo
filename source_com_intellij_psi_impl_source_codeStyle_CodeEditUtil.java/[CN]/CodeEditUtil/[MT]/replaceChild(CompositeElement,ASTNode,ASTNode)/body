{
  checkAllWhiteSpaces(parent);
  final ASTNode elementAfter=findElementAfter(oldChild,true);
  boolean changeFirstWS=newChild.textContains('\n') || oldChild.textContains('\n');
  ASTNode firstNonEmpty=findFirstNonEmpty(newChild,newChild.getTreeNext(),parent,newChild.getTreeNext());
  if (!canStickChildrenTogether(TreeUtil.prevLeaf(oldChild),firstNonEmpty)) {
    changeFirstWS=true;
  }
  if (changeFirstWS) {
    saveIndents(newChild);
  }
  if (elementAfter != null && !isWS(elementAfter)) {
    saveIndents(elementAfter);
  }
  parent.replaceChild(oldChild,newChild);
  final List<ASTNode> treePrev=getPreviousElements(newChild);
  adjustWhiteSpaceBefore(newChild,true,false,changeFirstWS,false);
  if (elementAfter != null && !isWS(elementAfter)) {
    adjustWhiteSpaceBefore(elementAfter,true,true,true,false);
  }
  checkAllWhiteSpaces(parent);
  if (treePrev == null) {
    return (TreeElement)parent.getFirstChildNode();
  }
 else {
    ASTNode firstValid=findFirstValid(treePrev);
    if (firstValid == null) {
      return (TreeElement)parent.getFirstChildNode();
    }
 else {
      return (TreeElement)firstValid.getTreeNext();
    }
  }
}
