{
  final Project project=parent.getManager().getProject();
  final PsiFile file=SourceTreeToPsiMap.treeElementToPsi(parent).getContainingFile();
  FileType fileType=file.getFileType();
  if (first.getElementType() == ElementType.WHITE_SPACE) {
    if (first == last)     return null;
    first=first.getTreeNext();
  }
  if (last.getElementType() == ElementType.WHITE_SPACE) {
    if (first == last)     return null;
    last=last.getTreePrev();
  }
  boolean oneElement=first == last;
  boolean adjustSelf=parent.getTreeParent() != null && parent.getTextLength() == 0;
  final Helper helper=new Helper(fileType,project);
  final CodeStyleSettings settings=CodeStyleSettingsManager.getSettings(project);
  final CodeFormatterFacade codeLayouter=new CodeFormatterFacade(settings,helper);
  final IndentAdjusterFacade indentAdjuster=new IndentAdjusterFacade(settings,helper);
  final int oldIndent=helper.getIndent(first);
  TreeElement afterLast=last.getTreeNext();
  TreeElement next;
  for (TreeElement child=first; child != afterLast; child=next) {
    next=child.getTreeNext();
    ChangeUtil.addChild(parent,child,anchorBefore);
  }
  if (fileType == StdFileTypes.XHTML)   return first;
  if (adjustSelf) {
    TreeElement elementBefore=Helper.shiftBackwardToNonSpace(parent.getTreePrev());
    parent=(CompositeElement)codeLayouter.processSpace(elementBefore,parent);
    parent=(CompositeElement)indentAdjuster.adjustFirstLineIndent(parent);
    TreeElement elementAfter=Helper.shiftForwardToNonSpace(parent.getTreeNext());
    elementAfter=codeLayouter.processSpace(parent,elementAfter);
    if (elementAfter != null) {
      elementAfter=indentAdjuster.adjustFirstLineIndent(elementAfter);
    }
  }
  TreeElement elementBefore=Helper.shiftBackwardToNonSpace(first.getTreePrev());
  if (needSeparateLines(first) && helper.getLineBreakCount(parent,elementBefore,first) == 0) {
    helper.makeVerticalSpace(parent,elementBefore,first,0);
  }
  first=codeLayouter.processSpace(elementBefore,first);
  TreeElement prev=Helper.shiftBackwardToNonSpace(first.getTreePrev());
  String spaceText=Helper.getSpaceText(parent,prev,first);
  int index=Math.max(spaceText.lastIndexOf('\n'),spaceText.lastIndexOf('\r'));
  if (index >= 0 || (parent.getTreeParent() == null && prev == null && first.getTextRange().getStartOffset() == spaceText.length())) {
    spaceText=spaceText.substring(0,index + 1) + helper.fillIndent(oldIndent);
    first=helper.makeSpace(parent,prev,first,spaceText,false);
  }
  if (oneElement) {
    last=first;
  }
  TreeElement elementAfter=Helper.shiftForwardToNonSpace(last.getTreeNext());
  if (elementAfter != null && needSeparateLines(last) && helper.getLineBreakCount(parent,last,elementAfter) == 0) {
    helper.makeVerticalSpace(parent,last,elementAfter,0);
  }
  elementAfter=codeLayouter.processSpace(last,elementAfter);
  if (elementAfter != null) {
    elementAfter=indentAdjuster.adjustFirstLineIndent(elementAfter);
  }
  afterLast=last.getTreeNext();
  for (TreeElement child=first; child != afterLast; child=child.getTreeNext()) {
    child=indentAdjuster.adjustNormalizeIndent(child);
    if (child.getElementType() == ElementType.CODE_BLOCK) {
      PsiElement[] children=SourceTreeToPsiMap.treeElementToPsi(child).getChildren();
      for (int i=0; i < children.length; i++) {
        PsiElement element=children[i];
        TreeElement child1=SourceTreeToPsiMap.psiElementToTree(element);
        if (Helper.isNonSpace(child1)) {
          child1=indentAdjuster.adjustIndent(child1);
        }
      }
    }
  }
  return first;
}
