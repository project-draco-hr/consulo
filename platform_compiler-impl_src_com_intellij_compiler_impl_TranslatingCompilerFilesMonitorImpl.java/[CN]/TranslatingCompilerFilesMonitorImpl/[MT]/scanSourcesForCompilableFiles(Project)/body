{
  final int projectId=getProjectId(project);
  if (isSuspended(projectId)) {
    return;
  }
  startAsyncScan(projectId);
  StartupManager.getInstance(project).runWhenProjectIsInitialized(new Runnable(){
    @Override public void run(){
      new Task.Backgroundable(project,CompilerBundle.message("compiler.initial.scanning.progress.text"),false){
        @Override public void run(        @NotNull final ProgressIndicator indicator){
          final ProjectRef projRef=new ProjectRef(project);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Initial sources scan for project hash=" + projectId + "; url="+ projRef.get().getPresentableUrl());
          }
          try {
            final IntermediateOutputCompiler[] compilers=CompilerManager.getInstance(projRef.get()).getCompilers(IntermediateOutputCompiler.class);
            final Set<VirtualFile> intermediateRoots=new HashSet<VirtualFile>();
            if (compilers.length > 0) {
              final Module[] modules=ModuleManager.getInstance(projRef.get()).getModules();
              for (              IntermediateOutputCompiler compiler : compilers) {
                for (                Module module : modules) {
                  if (module.isDisposed() || module.getModuleDirUrl() == null) {
                    continue;
                  }
                  final VirtualFile outputRoot=LocalFileSystem.getInstance().refreshAndFindFileByPath(CompilerPaths.getGenerationOutputPath(compiler,module,false));
                  if (outputRoot != null) {
                    intermediateRoots.add(outputRoot);
                  }
                  final VirtualFile testsOutputRoot=LocalFileSystem.getInstance().refreshAndFindFileByPath(CompilerPaths.getGenerationOutputPath(compiler,module,true));
                  if (testsOutputRoot != null) {
                    intermediateRoots.add(testsOutputRoot);
                  }
                }
              }
            }
            final List<VirtualFile> projectRoots=Arrays.asList(getRootsForScan(projRef.get()));
            final int totalRootsCount=projectRoots.size() + intermediateRoots.size();
            scanSourceContent(projRef,projectRoots,totalRootsCount,true);
            if (!intermediateRoots.isEmpty()) {
              final FileProcessor processor=new FileProcessor(){
                @Override public void execute(                final VirtualFile file){
                  if (!isMarkedForRecompilation(projectId,Math.abs(getFileId(file)))) {
                    final SourceFileInfo srcInfo=loadSourceInfo(file);
                    if (srcInfo == null || srcInfo.getTimestamp(projectId) != file.getTimeStamp()) {
                      addSourceForRecompilation(projectId,file,srcInfo);
                    }
                  }
                }
              }
;
              int processed=projectRoots.size();
              for (              VirtualFile root : intermediateRoots) {
                projRef.get();
                indicator.setText2(root.getPresentableUrl());
                indicator.setFraction(++processed / (double)totalRootsCount);
                processRecursively(root,false,processor);
              }
            }
            markOldOutputRoots(projRef,buildOutputRootsLayout(projRef));
          }
 catch (          ProjectRef.ProjectClosedException swallowed) {
          }
 finally {
            terminateAsyncScan(projectId,false);
          }
        }
      }
.queue();
    }
  }
);
}
