{
  try {
    file.getViewProvider().beforeContentsSynchronized();
    final PsiFileImpl fileImpl=(PsiFileImpl)file;
    Project project=fileImpl.getProject();
    final CharTable charTable=fileImpl.getTreeElement().getCharTable();
    final int textLength=file.getTextLength() + lengthShift;
    final FileElement treeFileElement=fileImpl.getTreeElement();
    final ASTNode leafAtStart=treeFileElement.findLeafElementAt(startOffset);
    final ASTNode leafAtEnd=treeFileElement.findLeafElementAt(endOffset);
    ASTNode parent=leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart,leafAtEnd) : treeFileElement;
    int minErrorLevel=Integer.MAX_VALUE;
    ASTNode bestReparseable=null;
    ASTNode prevReparseable=null;
    boolean theOnlyReparseable=false;
    while (parent != null && !(parent instanceof FileElement)) {
      if (parent.getElementType() instanceof IChameleonElementType) {
        final TextRange textRange=parent.getTextRange();
        final IChameleonElementType reparseable=(IChameleonElementType)parent.getElementType();
        boolean languageChanged=false;
        if (prevReparseable != null) {
          languageChanged=prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();
        }
        final String newTextStr=StringFactory.createStringFromConstantArray(newFileText,textRange.getStartOffset(),textRange.getLength() + lengthShift);
        if (reparseable.isParsable(newTextStr,project)) {
          final ChameleonElement chameleon=(ChameleonElement)Factory.createSingleLeafElement(reparseable,newFileText,textRange.getStartOffset(),textRange.getEndOffset() + lengthShift,charTable,file.getManager(),fileImpl);
          mergeTrees(fileImpl,parent,reparseable.parseContents(chameleon).getTreeParent());
          return;
        }
 else         if (reparseable instanceof IErrorCounterChameleonElementType) {
          int currentErrorLevel=((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr,project);
          if (currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR) {
            prevReparseable=parent;
          }
 else           if (Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)) {
            theOnlyReparseable=bestReparseable == null;
            bestReparseable=parent;
            minErrorLevel=currentErrorLevel;
            if (languageChanged)             break;
          }
        }
      }
      parent=parent.getTreeParent();
    }
    if (bestReparseable != null && !theOnlyReparseable) {
      final ASTNode treeElement=bestReparseable;
      final TextRange textRange=treeElement.getTextRange();
      final ChameleonElement chameleon=(ChameleonElement)Factory.createLeafElement(bestReparseable.getElementType(),newFileText,textRange.getStartOffset(),textRange.getEndOffset() + lengthShift,-1,treeFileElement.getCharTable());
      chameleon.putUserData(CharTable.CHAR_TABLE_KEY,treeFileElement.getCharTable());
      chameleon.setTreeParent((CompositeElement)parent);
      treeElement.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable(),fileImpl.createLexer(),project).getTreeParent());
    }
 else {
      FileType fileType=file.getFileType();
      if (file instanceof PsiPlainTextFile) {
        fileType=StdFileTypes.PLAIN_TEXT;
      }
      final Grammar grammarByFileType=GrammarUtil.getGrammarByFileType(fileType);
      if (grammarByFileType != null && file.getLanguage() != StdLanguages.JSP && file.getLanguage() != StdLanguages.JSPX) {
        ParsingUtil.reparse(grammarByFileType,treeFileElement.getCharTable(),treeFileElement,newFileText,startOffset,endOffset,lengthShift,file.getViewProvider());
      }
 else {
        makeFullParse(parent,newFileText,textLength,fileImpl,fileType);
      }
    }
  }
  finally {
    file.getViewProvider().contentsSynchronized();
  }
}
