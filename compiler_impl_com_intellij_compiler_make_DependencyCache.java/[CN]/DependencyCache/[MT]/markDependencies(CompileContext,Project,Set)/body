{
  try {
    if (LOG.isDebugEnabled()) {
      LOG.debug("====================Marking dependent files=====================");
    }
    int[] qNamesToUpdate=myTraverseRoots.toArray();
    final SourceFileFinder sourceFileFinder=new SourceFileFinder(project,context);
    final CachingSearcher searcher=new CachingSearcher(project);
    final ChangedRetentionPolicyDependencyProcessor changedRetentionPolicyDependencyProcessor=new ChangedRetentionPolicyDependencyProcessor(project,searcher,this);
    for (    int qName : qNamesToUpdate) {
      final int oldInfoId=getCache().getClassId(qName);
      if (oldInfoId == Cache.UNKNOWN) {
        continue;
      }
      final int newInfoId=getNewClassesCache().getClassId(qName);
      if (newInfoId != Cache.UNKNOWN) {
        new DependencyProcessor(project,this,qName).run();
        ArrayList<ChangedConstantsDependencyProcessor.FieldChangeInfo> changed=new ArrayList<ChangedConstantsDependencyProcessor.FieldChangeInfo>();
        ArrayList<ChangedConstantsDependencyProcessor.FieldChangeInfo> removed=new ArrayList<ChangedConstantsDependencyProcessor.FieldChangeInfo>();
        findModifiedConstants(qName,changed,removed);
        if (!changed.isEmpty() || !removed.isEmpty()) {
          new ChangedConstantsDependencyProcessor(project,searcher,this,qName,changed.toArray(new ChangedConstantsDependencyProcessor.FieldChangeInfo[changed.size()]),removed.toArray(new ChangedConstantsDependencyProcessor.FieldChangeInfo[removed.size()])).run();
        }
        changedRetentionPolicyDependencyProcessor.checkAnnotationRetentionPolicyChanges(qName);
      }
 else {
        boolean isSourceDeleted=false;
        if (myClassesWithSourceRemoved.contains(qName)) {
          isSourceDeleted=true;
        }
 else         if (!new File(getCache().getPath(oldInfoId)).exists()) {
          final String qualifiedName=resolve(qName);
          final String sourceFileName=getCache().getSourceFileName(oldInfoId);
          final boolean markAsRemovedSource=ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
            public Boolean compute(){
              VirtualFile sourceFile=sourceFileFinder.findSourceFile(qualifiedName,sourceFileName);
              return sourceFile == null || successfullyCompiled.contains(sourceFile) ? Boolean.TRUE : Boolean.FALSE;
            }
          }
).booleanValue();
          if (markAsRemovedSource) {
            isSourceDeleted=true;
            markSourceRemoved(qName);
            myMarkedInfos.remove(qName);
          }
        }
        if (isSourceDeleted) {
          Dependency[] backDependencies=getCache().getBackDependencies(qName);
          for (          Dependency backDependency : backDependencies) {
            if (markTargetClassInfo(backDependency)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + backDependency.getClassQualifiedName() + "; reason: no class file found for "+ qName);
              }
            }
          }
        }
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("================================================================");
    }
  }
 catch (  ProcessCanceledException ignored) {
  }
}
