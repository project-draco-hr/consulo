{
  if (myToUpdate.isEmpty()) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final Cache newCache=getNewClassesCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  final TIntHashSet toClean=new TIntHashSet();
  toClean.addAll(namesToUpdate);
  toClean.addAll(myClassesWithSourceRemoved.toArray());
  for (  final int qName : toClean.toArray()) {
    final int oldClassId=cache.getClassId(qName);
    if (oldClassId == Cache.UNKNOWN) {
      continue;
    }
    final int[] referencedClasses=cache.getReferencedClassQNames(oldClassId);
    for (    int referencedClassQName : referencedClasses) {
      final int referencedClassDeclarationId=cache.getClassDeclarationId(referencedClassQName);
      if (referencedClassDeclarationId == Cache.UNKNOWN) {
        continue;
      }
      cache.removeClassReferencer(referencedClassDeclarationId,qName);
      final int[] fieldIds=cache.getFieldIds(referencedClassDeclarationId);
      for (      int fieldId : fieldIds) {
        cache.removeFieldReferencer(fieldId,qName);
      }
      final int[] methodIds=cache.getMethodIds(referencedClassDeclarationId);
      for (      int methodId : methodIds) {
        cache.removeMethodReferencer(methodId,qName);
      }
    }
    navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
      public boolean process(      int classQName) throws CacheCorruptedException {
        final int classId=cache.getClassId(classQName);
        cache.removeSubclass(classId,qName);
        return true;
      }
    }
);
  }
  for (  final int qName : namesToUpdate) {
    final int newInfoId=newCache.getClassId(qName);
    if (newInfoId == Cache.UNKNOWN) {
      continue;
    }
    cache.importClassInfo(newCache,qName);
  }
  final SymbolTable symbolTable=getSymbolTable();
  for (  final int qName : namesToUpdate) {
    final int newClassId=newCache.getClassId(qName);
    if (newClassId == Cache.UNKNOWN) {
      continue;
    }
    buildForwardDependencies(qName,newCache.getReferences(newClassId));
    boolean isRemote=false;
    final int classId=cache.getClassId(qName);
    final int[] superInterfaces=cache.getSuperInterfaces(classId);
    if (superInterfaces.length > 0) {
      final int remoteInterfaceName=symbolTable.getId(REMOTE_INTERFACE_NAME);
      for (      int superInterface : superInterfaces) {
        if (isRemoteInterface(cache,superInterface,remoteInterfaceName)) {
          isRemote=true;
          break;
        }
      }
    }
    final boolean wasRemote=cache.isRemote(classId);
    if (wasRemote && !isRemote) {
synchronized (myPreviouslyRemoteClasses) {
        myPreviouslyRemoteClasses.add(qName);
      }
    }
    cache.setRemote(classId,isRemote);
  }
  for (  final int qName : namesToUpdate) {
    final int classId=cache.getClassId(qName);
    buildSubclassDependencies(getCache(),qName,classId);
  }
  myToUpdate=new TIntHashSet();
}
