{
  if (myToUpdate.isEmpty()) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final Cache newCache=getNewClassesCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  for (  final int qName : namesToUpdate) {
    for (    int referencedClassQName : cache.getReferencedClassQNames(qName)) {
      if (!cache.containsClass(referencedClassQName)) {
        continue;
      }
      cache.removeClassReferencer(referencedClassQName,qName);
      for (      FieldInfo fieldId : cache.getFields(referencedClassQName)) {
        cache.removeFieldReferencer(referencedClassQName,fieldId.getName(),qName);
      }
      for (      MethodInfo methodId : cache.getMethods(referencedClassQName)) {
        cache.removeMethodReferencer(referencedClassQName,methodId.getName(),methodId.getDescriptor(),qName);
      }
    }
    navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
      public boolean process(      int classQName) throws CacheCorruptedException {
        cache.removeSubclass(classQName,qName);
        return true;
      }
    }
);
  }
  for (  final int qName : namesToUpdate) {
    cache.importClassInfo(newCache,qName);
  }
  final SymbolTable symbolTable=getSymbolTable();
  for (  final int qName : namesToUpdate) {
    if (!newCache.containsClass(qName)) {
      continue;
    }
    buildForwardDependencies(qName,newCache.getReferences(qName));
    boolean isRemote=false;
    final int[] superInterfaces=cache.getSuperInterfaces(qName);
    if (superInterfaces.length > 0) {
      final int remoteInterfaceName=symbolTable.getId(REMOTE_INTERFACE_NAME);
      for (      int superInterface : superInterfaces) {
        if (isRemoteInterface(cache,superInterface,remoteInterfaceName)) {
          isRemote=true;
          break;
        }
      }
    }
    final boolean wasRemote=cache.isRemote(qName);
    if (wasRemote && !isRemote) {
synchronized (myPreviouslyRemoteClasses) {
        myPreviouslyRemoteClasses.add(qName);
      }
    }
    cache.setRemote(qName,isRemote);
  }
  for (  final int qName : namesToUpdate) {
    final int classId=qName;
    buildSubclassDependencies(getCache(),qName,classId);
  }
  for (  final int qName : myClassesWithSourceRemoved.toArray()) {
    cache.removeClass(qName);
  }
  myToUpdate=new TIntHashSet();
}
