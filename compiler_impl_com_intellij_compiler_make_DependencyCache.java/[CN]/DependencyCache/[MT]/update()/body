{
  if (myToUpdate.size() == 0) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  for (  final int qName : namesToUpdate) {
    final int oldClassId=cache.getClassId(qName);
    if (oldClassId != Cache.UNKNOWN) {
      final int[] referencedClasses=cache.getReferencedClasses(oldClassId);
      for (      int referencedClass : referencedClasses) {
        final int referencedClassDeclarationId=cache.getClassDeclarationId(referencedClass);
        if (referencedClassDeclarationId == Cache.UNKNOWN) {
          continue;
        }
        cache.removeClassReferencer(referencedClassDeclarationId,qName);
        final int[] fieldIds=cache.getFieldIds(referencedClassDeclarationId);
        for (        int fieldId : fieldIds) {
          cache.removeFieldReferencer(fieldId,qName);
        }
        final int[] methodIds=cache.getMethodIds(referencedClassDeclarationId);
        for (        int methodId : methodIds) {
          cache.removeMethodReferencer(methodId,qName);
        }
      }
      navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
        public boolean process(        int classQName) throws CacheCorruptedException {
          final int classId=cache.getClassId(classQName);
          cache.removeSubclass(classId,qName);
          return true;
        }
      }
);
    }
  }
  for (  final int qName : namesToUpdate) {
    final int newInfoId=getNewClassesCache().getClassId(qName);
    if (newInfoId == Cache.UNKNOWN) {
      continue;
    }
    cache.importClassInfo(getNewClassesCache(),qName);
  }
  final SymbolTable symbolTable=getSymbolTable();
  for (  final int qName : namesToUpdate) {
    final int newClassId=getNewClassesCache().getClassId(qName);
    if (newClassId == Cache.UNKNOWN) {
      continue;
    }
    buildForwardDependencies(qName,getNewClassesCache().getReferences(newClassId));
    boolean isRemote=false;
    final int classId=cache.getClassId(qName);
    final int[] superInterfaces=cache.getSuperInterfaces(classId);
    if (superInterfaces.length > 0) {
      final int remoteInterfaceName=symbolTable.getId(REMOTE_INTERFACE_NAME);
      for (      int superInterface : superInterfaces) {
        if (isRemoteInterface(cache,superInterface,remoteInterfaceName)) {
          isRemote=true;
          break;
        }
      }
    }
    final boolean wasRemote=cache.isRemote(classId);
    if (wasRemote && !isRemote) {
      myPreviouslyRemoteClasses.add(qName);
    }
    cache.setRemote(classId,isRemote);
  }
  for (  final int qName : namesToUpdate) {
    final int classId=cache.getClassId(qName);
    buildSubclassDependencies(qName,classId);
  }
  final int[] classesToRemove=myClassesWithSourceRemoved.toArray();
  for (  final int qName : classesToRemove) {
    cache.removeClass(qName);
  }
  myToUpdate=new TIntHashSet();
}
