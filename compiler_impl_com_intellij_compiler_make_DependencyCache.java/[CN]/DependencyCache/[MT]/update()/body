{
  if (myToUpdate.isEmpty()) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final Cache newCache=getNewClassesCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  final Job<Object> cleanJob=JobScheduler.getInstance().createJob("cleaning stuff",Job.DEFAULT_PRIORITY);
  final CacheCorruptedException[] exception=new CacheCorruptedException[]{null};
  final TIntHashSet toClean=new TIntHashSet();
  toClean.addAll(namesToUpdate);
  toClean.addAll(myClassesWithSourceRemoved.toArray());
  for (  final int qName : toClean.toArray()) {
    final int oldClassId=cache.getClassId(qName);
    if (oldClassId == Cache.UNKNOWN) {
      continue;
    }
    Runnable runnable=new Runnable(){
      public void run(){
        try {
          final int[] referencedClasses=cache.getReferencedClassQNames(oldClassId);
          for (          int referencedClassQName : referencedClasses) {
            final int referencedClassDeclarationId=cache.getClassDeclarationId(referencedClassQName);
            if (referencedClassDeclarationId == Cache.UNKNOWN) {
              continue;
            }
            cache.removeClassReferencer(referencedClassDeclarationId,qName);
            final int[] fieldIds=cache.getFieldIds(referencedClassDeclarationId);
            for (            int fieldId : fieldIds) {
              cache.removeFieldReferencer(fieldId,qName);
            }
            final int[] methodIds=cache.getMethodIds(referencedClassDeclarationId);
            for (            int methodId : methodIds) {
              cache.removeMethodReferencer(methodId,qName);
            }
          }
          navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
            public boolean process(            int classQName) throws CacheCorruptedException {
              final int classId=cache.getClassId(classQName);
              cache.removeSubclass(classId,qName);
              return true;
            }
          }
);
        }
 catch (        CacheCorruptedException e) {
          exception[0]=e;
        }
      }
    }
;
    cleanJob.addTask(runnable);
  }
  scheduleNow(cleanJob,exception);
  for (  final int qName : namesToUpdate) {
    final int newInfoId=newCache.getClassId(qName);
    if (newInfoId == Cache.UNKNOWN) {
      continue;
    }
    cache.importClassInfo(newCache,qName);
  }
  final SymbolTable symbolTable=getSymbolTable();
  final Job<Object> forwardJob=JobScheduler.getInstance().createJob("building forward deps",Job.DEFAULT_PRIORITY);
  for (  final int qName : namesToUpdate) {
    final int newClassId=newCache.getClassId(qName);
    if (newClassId == Cache.UNKNOWN) {
      continue;
    }
    forwardJob.addTask(new Runnable(){
      public void run(){
        try {
          if (exception[0] != null) {
            return;
          }
          buildForwardDependencies(qName,newCache.getReferences(newClassId));
          boolean isRemote=false;
          final int classId=cache.getClassId(qName);
          final int[] superInterfaces=cache.getSuperInterfaces(classId);
          if (superInterfaces.length > 0) {
            final int remoteInterfaceName=symbolTable.getId(REMOTE_INTERFACE_NAME);
            for (            int superInterface : superInterfaces) {
              if (isRemoteInterface(cache,superInterface,remoteInterfaceName)) {
                isRemote=true;
                break;
              }
            }
          }
          final boolean wasRemote=cache.isRemote(classId);
          if (wasRemote && !isRemote) {
synchronized (myPreviouslyRemoteClasses) {
              myPreviouslyRemoteClasses.add(qName);
            }
          }
          cache.setRemote(classId,isRemote);
        }
 catch (        CacheCorruptedException e) {
          if (exception[0] == null) {
            exception[0]=e;
            forwardJob.cancel();
          }
        }
      }
    }
);
  }
  scheduleNow(forwardJob,exception);
  final Job<Object> subclassJob=JobScheduler.getInstance().createJob("building subclass deps",Job.DEFAULT_PRIORITY);
  for (  final int qName : namesToUpdate) {
    final int classId=cache.getClassId(qName);
    subclassJob.addTask(new Runnable(){
      public void run(){
        try {
          if (exception[0] != null) {
            return;
          }
          buildSubclassDependencies(getCache(),qName,classId);
        }
 catch (        CacheCorruptedException e) {
          if (exception[0] == null) {
            exception[0]=e;
            subclassJob.cancel();
          }
        }
      }
    }
);
  }
  scheduleNow(subclassJob,exception);
  myToUpdate=new TIntHashSet();
}
