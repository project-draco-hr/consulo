{
  if (myToUpdate.size() == 0) {
    return;
  }
  final int[] namesToUpdate=myToUpdate.toArray();
  final Cache cache=getCache();
  final DependencyCacheNavigator navigator=getCacheNavigator();
  for (  final int qName : namesToUpdate) {
    final int oldClassId=cache.getClassId(qName);
    if (oldClassId != Cache.UNKNOWN) {
      final int[] referencedClasses=cache.getReferencedClasses(oldClassId);
      for (      int referencedClass : referencedClasses) {
        final int referencedClassDeclarationId=cache.getClassDeclarationId(referencedClass);
        if (referencedClassDeclarationId == Cache.UNKNOWN) {
          continue;
        }
        cache.removeClassReferencer(referencedClassDeclarationId,qName);
        final int[] fieldIds=cache.getFieldIds(referencedClassDeclarationId);
        for (        int fieldId : fieldIds) {
          cache.removeFieldReferencer(fieldId,qName);
        }
        final int[] methodIds=cache.getMethodIds(referencedClassDeclarationId);
        for (        int methodId : methodIds) {
          cache.removeMethodReferencer(methodId,qName);
        }
      }
      navigator.walkSuperClasses(qName,new ClassInfoProcessor(){
        public boolean process(        int classQName) throws CacheCorruptedException {
          final int classId=cache.getClassId(classQName);
          cache.removeSubclass(classId,qName);
          return true;
        }
      }
);
    }
  }
  for (  final int qName : namesToUpdate) {
    final int newInfoId=getNewClassesCache().getClassId(qName);
    if (newInfoId == Cache.UNKNOWN) {
      continue;
    }
    cache.importClassInfo(getNewClassesCache(),qName);
  }
  final SymbolTable symbolTable=getSymbolTable();
  final WorkerArray workers=new WorkerArray(3);
  try {
    final CountDownLatch forwardDependenciesBuildtask=new CountDownLatch(namesToUpdate.length);
    final CacheCorruptedException[] exception=new CacheCorruptedException[]{null};
    for (    final int qName : namesToUpdate) {
      final int newClassId=getNewClassesCache().getClassId(qName);
      if (newClassId == Cache.UNKNOWN) {
        forwardDependenciesBuildtask.countDown();
        continue;
      }
      workers.submit(new Runnable(){
        public void run(){
          try {
            if (exception[0] != null) {
              return;
            }
            buildForwardDependencies(qName,getNewClassesCache().getReferences(newClassId));
            boolean isRemote=false;
            final int classId=cache.getClassId(qName);
            final int[] superInterfaces=cache.getSuperInterfaces(classId);
            if (superInterfaces.length > 0) {
              final int remoteInterfaceName=symbolTable.getId(REMOTE_INTERFACE_NAME);
              for (              int superInterface : superInterfaces) {
                if (isRemoteInterface(cache,superInterface,remoteInterfaceName)) {
                  isRemote=true;
                  break;
                }
              }
            }
            final boolean wasRemote=cache.isRemote(classId);
            if (wasRemote && !isRemote) {
synchronized (myPreviouslyRemoteClasses) {
                myPreviouslyRemoteClasses.add(qName);
              }
            }
            cache.setRemote(classId,isRemote);
          }
 catch (          CacheCorruptedException e) {
            if (exception[0] == null) {
              exception[0]=e;
            }
          }
 finally {
            forwardDependenciesBuildtask.countDown();
          }
        }
      }
);
    }
    try {
      forwardDependenciesBuildtask.await();
    }
 catch (    InterruptedException e) {
    }
    if (exception[0] != null) {
      throw exception[0];
    }
    final CountDownLatch subclassDependenciesBuildtask=new CountDownLatch(namesToUpdate.length);
    for (    final int qName : namesToUpdate) {
      final int classId=cache.getClassId(qName);
      workers.submit(new Runnable(){
        public void run(){
          try {
            if (exception[0] != null) {
              return;
            }
            buildSubclassDependencies(qName,classId);
          }
 catch (          CacheCorruptedException e) {
            if (exception[0] == null) {
              exception[0]=e;
            }
          }
 finally {
            subclassDependenciesBuildtask.countDown();
          }
        }
      }
);
    }
    try {
      subclassDependenciesBuildtask.await();
    }
 catch (    InterruptedException ignored) {
    }
    if (exception[0] != null) {
      throw exception[0];
    }
  }
  finally {
    workers.stop();
  }
  final int[] classesToRemove=myClassesWithSourceRemoved.toArray();
  for (  final int qName : classesToRemove) {
    cache.removeClass(qName);
  }
  myToUpdate=new TIntHashSet();
}
