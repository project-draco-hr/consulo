{
  Application application=ApplicationManager.getApplication();
  final Set<VirtualFile> allDependent=new HashSet<VirtualFile>();
  COMPILE:   try {
    if (!myFilesToCompile.isEmpty()) {
      if (application.isUnitTestMode()) {
        saveTestData();
      }
      final Map<Module,List<VirtualFile>> moduleToFilesMap=CompilerUtil.buildModuleToFilesMap(myCompileContext,myFilesToCompile);
      compileModules(moduleToFilesMap);
    }
    Collection<VirtualFile> dependentFiles;
    do {
      dependentFiles=findDependentFiles();
      if (!dependentFiles.isEmpty()) {
        myFilesToRecompile.addAll(dependentFiles);
        allDependent.addAll(dependentFiles);
        if (myCompileContext.getProgressIndicator().isCanceled() || myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
          break COMPILE;
        }
        final List<VirtualFile> filesInScope=getFilesInScope(dependentFiles);
        if (filesInScope.isEmpty()) {
          break;
        }
        final Map<Module,List<VirtualFile>> moduleToFilesMap=CompilerUtil.buildModuleToFilesMap(myCompileContext,filesInScope);
        myCompileContext.getDependencyCache().clearTraverseRoots();
        compileModules(moduleToFilesMap);
      }
    }
 while (!dependentFiles.isEmpty() && myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) == 0);
  }
 catch (  SecurityException e) {
    throw new CompilerException(CompilerBundle.message("error.compiler.process.not.started",e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw new CompilerException(e.getMessage(),e);
  }
 finally {
    CompilerUtil.logDuration(myCompiler.getId() + " running",myCompilationDuration);
    for (    final VirtualFile file : myModuleToTempDirMap.values()) {
      if (file != null) {
        final File ioFile=new File(file.getPath());
        FileUtil.asyncDelete(ioFile);
      }
    }
    myModuleToTempDirMap.clear();
  }
  if (myCompileContext.getProgressIndicator().isCanceled()) {
    myFilesToRecompile.clear();
    return Collections.emptyList();
  }
  if (CompilerConfiguration.MAKE_ENABLED) {
    ProgressIndicator indicator=myCompileContext.getProgressIndicator();
    final DependencyCache cache=myCompileContext.getDependencyCache();
    indicator.setText(CompilerBundle.message("progress.updating.caches"));
    indicator.setText2("");
    cache.update(indicator);
    indicator.setText(CompilerBundle.message("progress.saving.caches"));
    cache.resetState();
    indicator.setText("");
  }
  myFilesToRecompile.removeAll(mySuccesfullyCompiledJavaFiles);
  if (myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) != 0) {
    myFilesToRecompile.addAll(allDependent);
  }
  final List<TranslatingCompiler.OutputItem> outputs=processPackageInfoFiles();
  if (myFilesToRecompile.size() > 0 || outputs.size() > 0) {
    mySink.add(null,outputs,myFilesToRecompile.toArray(new VirtualFile[myFilesToRecompile.size()]));
  }
  return null;
}
