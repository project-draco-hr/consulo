{
  HashMap<PsiMethod,Collection<PsiReference>> constructorsToRefs=new HashMap<PsiMethod,Collection<PsiReference>>();
  HashSet<PsiMethod> newConstructors=new HashSet<PsiMethod>();
  if (isTheOnlyEmptyDefaultConstructor(constructor))   return null;
  newConstructors.add(constructor);
  constructorsToRefs.put(constructor,originalReferences);
  HashSet<PsiMethod> passConstructors=new HashSet<PsiMethod>();
  do {
    passConstructors.clear();
    for (    PsiMethod method : newConstructors) {
      final Collection<PsiReference> references=constructorsToRefs.get(method);
      for (      PsiReference reference : references) {
        PsiMethod overridingConstructor=getOverridingConstructorOfSuperCall(reference.getElement());
        if (overridingConstructor != null && !constructorsToRefs.containsKey(overridingConstructor)) {
          Collection<PsiReference> overridingConstructorReferences=ReferencesSearch.search(overridingConstructor).findAll();
          constructorsToRefs.put(overridingConstructor,overridingConstructorReferences);
          passConstructors.add(overridingConstructor);
        }
      }
    }
    newConstructors.clear();
    newConstructors.addAll(passConstructors);
  }
 while (!newConstructors.isEmpty());
  final Set<PsiMethod> validOverriding=validateOverridingMethods(constructor,originalReferences,constructorsToRefs.keySet(),constructorsToRefs,usages,allElementsToDelete);
  return new Condition<PsiElement>(){
    public boolean value(    PsiElement usage){
      if (usage instanceof PsiFile)       return false;
      return isInside(usage,allElementsToDelete) || isInside(usage,validOverriding);
    }
  }
;
}
