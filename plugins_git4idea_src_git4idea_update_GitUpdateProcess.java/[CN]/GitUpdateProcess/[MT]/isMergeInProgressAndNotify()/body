{
  final GitMerger merger=new GitMerger(myProject);
  final Collection<VirtualFile> mergingRoots=merger.getMergingRoots();
  if (mergingRoots.isEmpty()) {
    return false;
  }
  try {
    Collection<VirtualFile> unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,mergingRoots);
    if (unmergedFiles.isEmpty()) {
      return false;
    }
 else {
      final Collection<VirtualFile> finalUnmergedFiles=unmergedFiles;
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          myVcsHelper.showMergeDialog(new ArrayList<VirtualFile>(finalUnmergedFiles),myVcs.getReverseMergeProvider());
        }
      }
);
      unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,mergingRoots);
      if (unmergedFiles.isEmpty()) {
        merger.mergeCommit(mergingRoots);
        return false;
      }
 else {
        Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't update","Resolve all conflicts and commit the result",NotificationType.WARNING),myProject);
      }
    }
  }
 catch (  VcsException e) {
    Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't update","Be sure to resolve all conflicts and commit the result. <br/>" + e.getLocalizedMessage(),NotificationType.WARNING),myProject);
  }
  return true;
}
