{
  LOG.info("update started");
  if (isRebaseInProgressAndNotify() || isMergeInProgressAndNotify()) {
    return false;
  }
  if (!allTrackedBranchesConfigured()) {
    return false;
  }
  final GitChangesSaver saver=GitChangesSaver.getSaver(myProject,myProgressIndicator,"Uncommitted changes before update operation at " + DateFormatUtil.formatDateTime(Clock.getTime()));
  myProjectManager.blockReloadingProjectOnExternalChanges();
  try {
    saver.saveLocalChanges();
    boolean incomplete=false;
    boolean success=true;
    for (    final VirtualFile root : myRoots) {
      try {
        final GitUpdater updater=GitUpdater.getUpdater(myProject,root,myProgressIndicator,myUpdatedFiles);
        GitUpdateResult res=updater.update();
        if (res == GitUpdateResult.INCOMPLETE) {
          incomplete=true;
        }
        success&=res.isSuccess();
      }
 catch (      VcsException e) {
        LOG.info("Error updating changes for root " + root,e);
        notifyImportantError(myProject,"Error updating " + root.getName(),"Updating " + root.getName() + " failed with an error: "+ e.getLocalizedMessage());
      }
 finally {
        try {
          if (!incomplete) {
            saver.restoreLocalChanges();
          }
 else {
            saver.notifyLocalChangesAreNotRestored();
          }
        }
 catch (        VcsException e) {
          LOG.info("Couldn't restore local changes after update",e);
          notifyImportantError(myProject,"Couldn't restore local changes after update","Restoring changes saved before update failed with an error.<br/>" + e.getLocalizedMessage());
        }
      }
    }
    return success;
  }
 catch (  VcsException e) {
    LOG.info("Couldn't save local changes",e);
    notifyImportantError(myProject,"Couldn't save local changes","Saving uncommitted changes before update failed with an error.<br/>" + "Update cancelled.<br/>" + e.getLocalizedMessage());
  }
 finally {
    myProjectManager.unblockReloadingProjectOnExternalChanges();
  }
  return false;
}
