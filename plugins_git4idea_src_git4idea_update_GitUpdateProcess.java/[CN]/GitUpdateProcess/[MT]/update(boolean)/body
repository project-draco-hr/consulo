{
  LOG.info("update started|" + (forceRebase ? " force rebase" : ""));
  final boolean saveOnFrameDeactivation=myGeneralSettings.isSaveOnFrameDeactivation();
  final boolean syncOnFrameDeactivation=myGeneralSettings.isSyncOnFrameActivation();
  myProjectManager.blockReloadingProjectOnExternalChanges();
  UIUtil.invokeAndWaitIfNeeded(new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().runWriteAction(new Runnable(){
        @Override public void run(){
          FileDocumentManager.getInstance().saveAllDocuments();
          myGeneralSettings.setSaveOnFrameDeactivation(false);
          myGeneralSettings.setSyncOnFrameActivation(false);
        }
      }
);
    }
  }
);
  try {
    if (checkRebaseInProgress() || checkMergeInProgress() || checkUnmergedFiles()) {
      return false;
    }
    if (!checkTrackedBranchesConfigured()) {
      return false;
    }
    final Map<VirtualFile,GitUpdater> updaters=new HashMap<VirtualFile,GitUpdater>();
    for (    VirtualFile root : myRoots) {
      final GitUpdater updater=forceRebase ? new GitRebaseUpdater(myProject,root,this,myProgressIndicator,myUpdatedFiles) : GitUpdater.getUpdater(myProject,this,root,myProgressIndicator,myUpdatedFiles);
      updaters.put(root,updater);
      LOG.info("update| root=" + root + " ,updater="+ updater);
    }
    final Collection<VirtualFile> rootsToSave=new HashSet<VirtualFile>(1);
    for (    Map.Entry<VirtualFile,GitUpdater> entry : updaters.entrySet()) {
      VirtualFile root=entry.getKey();
      GitUpdater updater=entry.getValue();
      if (updater.isSaveNeeded()) {
        rootsToSave.add(root);
        LOG.info("update| root " + root + " needs save");
      }
    }
    mySaver.saveLocalChanges(rootsToSave);
    boolean incomplete=false;
    boolean success=true;
    VirtualFile currentlyUpdatedRoot=null;
    try {
      for (      Map.Entry<VirtualFile,GitUpdater> entry : updaters.entrySet()) {
        currentlyUpdatedRoot=entry.getKey();
        GitUpdater updater=entry.getValue();
        GitUpdateResult res=updater.update();
        LOG.info("updating root " + currentlyUpdatedRoot + " finished: "+ res);
        if (res == GitUpdateResult.INCOMPLETE) {
          incomplete=true;
        }
        success&=res.isSuccess();
      }
    }
 catch (    VcsException e) {
      String rootName=(currentlyUpdatedRoot == null) ? "" : currentlyUpdatedRoot.getName();
      LOG.info("Error updating changes for root " + currentlyUpdatedRoot,e);
      notifyImportantError(myProject,"Error updating " + rootName,"Updating " + rootName + " failed with an error: "+ e.getLocalizedMessage());
    }
 finally {
      try {
        if (!incomplete) {
          mySaver.restoreLocalChanges();
        }
 else {
          mySaver.notifyLocalChangesAreNotRestored();
        }
      }
 catch (      VcsException e) {
        LOG.info("Couldn't restore local changes after update",e);
        notifyImportantError(myProject,"Couldn't restore local changes after update","Restoring changes saved before update failed with an error.<br/>" + e.getLocalizedMessage());
      }
    }
    return success;
  }
 catch (  VcsException e) {
    LOG.info("Couldn't save local changes",e);
    notifyError(myProject,"Couldn't save local changes","Tried to save uncommitted changes in " + mySaver.getSaverName() + " before update, but failed with an error.<br/>"+ "Update was cancelled.",true,e);
  }
 finally {
    myProjectManager.unblockReloadingProjectOnExternalChanges();
    myGeneralSettings.setSaveOnFrameDeactivation(saveOnFrameDeactivation);
    myGeneralSettings.setSyncOnFrameActivation(syncOnFrameDeactivation);
  }
  return false;
}
