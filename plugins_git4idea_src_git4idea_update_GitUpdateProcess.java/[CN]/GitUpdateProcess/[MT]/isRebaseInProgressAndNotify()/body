{
  final GitRebaser rebaser=new GitRebaser(myProject);
  final Collection<VirtualFile> rebasingRoots=rebaser.getRebasingRoots();
  if (rebasingRoots.isEmpty()) {
    return false;
  }
  try {
    Collection<VirtualFile> unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,rebasingRoots);
    if (unmergedFiles.isEmpty()) {
      return rebaser.continueRebase(rebasingRoots);
    }
 else {
      final Collection<VirtualFile> finalUnmergedFiles=unmergedFiles;
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          myVcsHelper.showMergeDialog(new ArrayList<VirtualFile>(finalUnmergedFiles),myVcs.getReverseMergeProvider());
        }
      }
);
      unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,rebasingRoots);
      if (unmergedFiles.isEmpty()) {
        return rebaser.continueRebase(rebasingRoots);
      }
 else {
        Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't continue rebase","You must resolve all conflicts first. <br/>" + "Then you may continue or abort rebase.",NotificationType.WARNING),myProject);
      }
    }
  }
 catch (  VcsException e) {
    Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,"Can't continue rebase","Be sure to resolve all conflicts first. <br/>" + "Then you may continue or abort rebase.<br/>" + e.getLocalizedMessage(),NotificationType.WARNING),myProject);
  }
  return true;
}
