{
  while (true) {
    long delay;
    long requestId=-1;
synchronized (LOCK) {
      long minTime=Long.MAX_VALUE;
      long minRequestId=-1;
      for (int i=0; i < myRequests.size(); i++) {
        Boolean isEnqueued=myRequestEnqueuedFlags.get(i);
        if (isEnqueued.booleanValue())         continue;
        long time=myRequestTimes.get(i);
        if (time < minTime) {
          minTime=time;
          minRequestId=myRequestIds.get(i);
        }
      }
      if (minTime == Long.MAX_VALUE) {
        try {
          LOCK.wait();
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
      long time=System.currentTimeMillis();
      delay=minTime - time;
      if (delay <= 0) {
        requestId=minRequestId;
      }
    }
    if (requestId >= 0) {
      final long _requestId=requestId;
      Runnable runnable=new Runnable(){
        public void run(){
          boolean isCanceled;
          Runnable request=null;
synchronized (LOCK) {
            int index=myRequestIds.indexOf(_requestId);
            isCanceled=index < 0;
            if (!isCanceled) {
              myRequestIds.remove(index);
              request=myRequests.remove(index);
              myRequestTimes.remove(index);
              myRequestEnqueuedFlags.remove(index);
              myRequestModalityStates.remove(index);
            }
          }
          if (!isCanceled) {
            try {
              request.run();
            }
 catch (            Throwable e) {
              LOG.error(e);
            }
          }
        }
      }
;
      if (myUseSwingThread) {
synchronized (LOCK) {
          int index=myRequestIds.indexOf(requestId);
          if (index >= 0) {
            ModalityState modalityState=myRequestModalityStates.get(index);
            myRequestEnqueuedFlags.set(index,Boolean.TRUE);
            ApplicationManager.getApplication().invokeLater(runnable,modalityState);
          }
        }
      }
 else {
        runnable.run();
      }
    }
 else {
      if (delay > 0) {
synchronized (LOCK) {
          try {
            LOCK.wait(delay);
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
  }
}
