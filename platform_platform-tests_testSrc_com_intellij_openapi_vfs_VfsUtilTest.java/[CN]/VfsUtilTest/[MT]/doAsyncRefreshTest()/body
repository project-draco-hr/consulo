{
  final int N=1000;
  final byte[] data="xxx".getBytes();
  File temp=new WriteAction<File>(){
    @Override protected void run(    Result<File> result) throws Throwable {
      File res=createTempDirectory();
      result.setResult(res);
    }
  }
.execute().getResultObject();
  LocalFileSystem fs=LocalFileSystem.getInstance();
  VirtualFile vTemp=fs.findFileByIoFile(temp);
  assertNotNull(vTemp);
  VirtualFile[] children=new VirtualFile[N];
  long[] timestamp=new long[N];
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    FileUtil.writeToFile(file,data);
    VirtualFile child=fs.refreshAndFindFileByIoFile(file);
    assertNotNull(child);
    children[i]=child;
    timestamp[i]=file.lastModified();
  }
  vTemp.refresh(false,true);
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    assertEquals(timestamp[i],file.lastModified());
    VirtualFile child=fs.findFileByIoFile(file);
    assertNotNull(child);
    IoTestUtil.assertTimestampsEqual(timestamp[i],child.getTimeStamp());
  }
  for (int i=0; i < N; i++) {
    File file=new File(temp,i + ".txt");
    FileUtil.writeToFile(file,"xxx".getBytes());
    assertTrue(file.setLastModified(timestamp[i] - 2000));
    long modified=file.lastModified();
    assertTrue("File:" + file.getPath() + "; time:"+ modified,timestamp[i] != modified);
    timestamp[i]=modified;
    IoTestUtil.assertTimestampsNotEqual(children[i].getTimeStamp(),modified);
  }
  final CountDownLatch latch=new CountDownLatch(N);
  for (  final VirtualFile child : children) {
    child.refresh(true,true,new Runnable(){
      @Override public void run(){
        latch.countDown();
      }
    }
);
  }
  while (true) {
    latch.await(100,TimeUnit.MILLISECONDS);
    UIUtil.pump();
    if (latch.getCount() == 0)     break;
  }
  for (int i=0; i < N; i++) {
    VirtualFile child=children[i];
    IoTestUtil.assertTimestampsEqual(timestamp[i],child.getTimeStamp());
  }
}
