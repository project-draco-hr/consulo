{
  super(method.getProject());
  this.method=method;
  this.className=className;
  this.packageName=packageName;
  this.getterNames=getterNames;
  this.keepMethodAsDelegate=keepMethodAsDelegate;
  myUseExistingClass=useExistingClass;
  myCreateInnerClass=createInnerClass;
  this.parameters=new ArrayList<PsiParameter>(parameters);
  final PsiParameterList parameterList=method.getParameterList();
  final PsiParameter[] methodParams=parameterList.getParameters();
  paramsToMerge=new int[parameters.size()];
  for (int p=0; p < parameters.size(); p++) {
    PsiParameter parameter=parameters.get(p);
    for (int i=0; i < methodParams.length; i++) {
      final PsiParameter methodParam=methodParams[i];
      if (parameter.equals(methodParam)) {
        paramsToMerge[p]=i;
        break;
      }
    }
  }
  final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
  final JavaRecursiveElementVisitor visitor=new TypeParametersVisitor(typeParamSet);
  for (  PsiParameter parameter : parameters) {
    parameter.accept(visitor);
  }
  typeParams=new ArrayList<PsiTypeParameter>(typeParamSet);
  final String qualifiedName=StringUtil.getQualifiedName(packageName,className);
  final GlobalSearchScope scope=GlobalSearchScope.allScope(myProject);
  existingClass=JavaPsiFacade.getInstance(myProject).findClass(qualifiedName,scope);
}
