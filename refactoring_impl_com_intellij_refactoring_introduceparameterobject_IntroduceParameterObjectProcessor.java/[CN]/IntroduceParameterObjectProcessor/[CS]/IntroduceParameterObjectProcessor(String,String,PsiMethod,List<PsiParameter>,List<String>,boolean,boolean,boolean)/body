{
  super(method.getProject());
  this.method=method;
  this.className=className;
  this.packageName=packageName;
  this.getterNames=getterNames;
  this.keepMethodAsDelegate=keepMethodAsDelegate;
  myUseExistingClass=useExistingClass;
  this.parameters=new ArrayList<PsiParameter>(parameters);
  final PsiParameterList parameterList=method.getParameterList();
  final PsiParameter[] methodParams=parameterList.getParameters();
  paramsToMerge=new int[parameters.size()];
  int paramsToMergeCount=0;
  for (int i=0; i < methodParams.length; i++) {
    final PsiParameter methodParam=methodParams[i];
    if (parameters.contains(methodParam)) {
      paramsToMerge[paramsToMergeCount]=i;
      paramsToMergeCount++;
    }
  }
  final Set<PsiTypeParameter> typeParamSet=new HashSet<PsiTypeParameter>();
  final JavaRecursiveElementVisitor visitor=new TypeParametersVisitor(typeParamSet);
  for (  PsiParameter parameter : parameters) {
    parameter.accept(visitor);
  }
  typeParams=new ArrayList<PsiTypeParameter>(typeParamSet);
  final String qualifiedName=StringUtil.getQualifiedName(packageName,className);
  final GlobalSearchScope scope=GlobalSearchScope.allScope(myProject);
  existingClass=JavaPsiFacade.getInstance(myProject).findClass(qualifiedName,scope);
}
