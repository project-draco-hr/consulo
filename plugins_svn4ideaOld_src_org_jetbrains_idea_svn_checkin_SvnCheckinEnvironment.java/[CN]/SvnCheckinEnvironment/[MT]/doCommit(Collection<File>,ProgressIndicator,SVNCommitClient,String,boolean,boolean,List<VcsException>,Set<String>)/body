{
  if (committables.isEmpty()) {
    return;
  }
  File[] pathsToCommit=committables.toArray(new File[committables.size()]);
  boolean keepLocks=SvnConfiguration.getInstance(mySvnVcs.getProject()).isKeepLocks();
  SVNCommitPacket[] commitPackets=null;
  SVNCommitInfo[] results;
  try {
    commitPackets=committer.doCollectCommitItems(pathsToCommit,keepLocks,force,recursive,true);
    results=committer.doCommit(commitPackets,keepLocks,comment);
    commitPackets=null;
  }
 catch (  SVNException e) {
    exception.add(new VcsException(e));
    LOG.info(e);
    return;
  }
 finally {
    if (commitPackets != null) {
      for (int i=0; i < commitPackets.length; i++) {
        SVNCommitPacket commitPacket=commitPackets[i];
        try {
          commitPacket.dispose();
        }
 catch (        SVNException e) {
        }
      }
    }
  }
  final StringBuffer committedRevisions=new StringBuffer();
  for (  SVNCommitInfo result : results) {
    if (result.getErrorMessage() != null) {
      exception.add(new VcsException(result.getErrorMessage().getFullMessage()));
    }
 else     if (result != SVNCommitInfo.NULL && result.getNewRevision() > 0) {
      if (committedRevisions.length() > 0) {
        committedRevisions.append(", ");
      }
      committedRevisions.append(result.getNewRevision());
    }
  }
  if (committedRevisions.length() > 0) {
    final Project project=mySvnVcs.getProject();
    final String message=SvnBundle.message("status.text.comitted.revision",committedRevisions);
    if (feedback == null) {
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        public void run(){
          new VcsBalloonProblemNotifier(project,message,MessageType.INFO).run();
        }
      }
,new Condition<Object>(){
        @Override public boolean value(        Object o){
          return (!project.isOpen()) || project.isDisposed();
        }
      }
);
    }
 else {
      feedback.add("Subversion: " + message);
    }
  }
}
