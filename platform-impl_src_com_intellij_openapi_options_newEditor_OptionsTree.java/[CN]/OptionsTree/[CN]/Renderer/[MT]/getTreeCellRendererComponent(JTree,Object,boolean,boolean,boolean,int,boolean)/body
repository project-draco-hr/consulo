{
  JComponent result;
  Color fg=UIUtil.getTreeTextForeground();
  final Base base=extractNode(value);
  if (base instanceof EditorNode) {
    final EditorNode editor=(EditorNode)base;
    ConfigurableGroup group=null;
    if (editor.getParent() == myRoot) {
      final DefaultMutableTreeNode prevValue=((DefaultMutableTreeNode)value).getPreviousSibling();
      if (prevValue == null || prevValue instanceof LoadingNode) {
        group=editor.getGroup();
      }
 else {
        final Base prevBase=extractNode(prevValue);
        if (prevBase instanceof EditorNode) {
          final EditorNode prevEditor=(EditorNode)prevBase;
          if (prevEditor.getGroup() != editor.getGroup()) {
            group=editor.getGroup();
          }
        }
      }
    }
    int forcedWidth=-1;
    if (group != null && tree.isVisible()) {
      final Rectangle bounds=tree.getVisibleRect();
      forcedWidth=bounds.width > 0 ? bounds.width - 2 : forcedWidth;
    }
    result=configureComponent(base.getText(),base.getText(),null,null,selected,group != null,group != null ? group.getDisplayName() : null,forcedWidth);
    if (base.isError()) {
      fg=Color.red;
    }
 else     if (base.isModified()) {
      fg=Color.blue;
    }
  }
 else {
    result=configureComponent(value.toString(),null,null,null,selected,false,null,-1);
  }
  final Font font=myTextLabel.getFont();
  myTextLabel.setFont(font.deriveFont(myContext.isHoldingFilter() ? Font.BOLD : Font.PLAIN));
  myTextLabel.setForeground(selected ? UIUtil.getTreeSelectionForeground() : fg);
  return result;
}
