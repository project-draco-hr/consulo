{
  if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myTargetClass))   return;
  PsiMethod patternMethod=createMethodToAdd();
  final List<PsiReference> docRefs=new ArrayList<PsiReference>();
  for (  UsageInfo usage : usages) {
    if (usage instanceof InheritorUsageInfo) {
      final PsiClass inheritor=((InheritorUsageInfo)usage).getInheritor();
      addMethodToClass(inheritor,patternMethod,true);
    }
 else     if (usage instanceof MethodCallUsageInfo && !((MethodCallUsageInfo)usage).isInternal()) {
      final PsiElement expression=((MethodCallUsageInfo)usage).getMethodCallExpression();
      if (expression instanceof PsiMethodCallExpression) {
        correctMethodCall((PsiMethodCallExpression)expression,false);
      }
 else       if (expression instanceof PsiMethodReferenceExpression) {
        PsiExpression newQualifier=JavaPsiFacade.getInstance(myProject).getElementFactory().createExpressionFromText(myTargetVariable.getType().getCanonicalText(),null);
        ((PsiMethodReferenceExpression)expression).setQualifierExpression(newQualifier);
      }
    }
 else     if (usage instanceof JavadocUsageInfo) {
      docRefs.add(usage.getElement().getReference());
    }
  }
  try {
    if (myTargetClass.isInterface())     patternMethod.getBody().delete();
    final PsiMethod method=addMethodToClass(myTargetClass,patternMethod,false);
    myMethod.delete();
    for (    PsiReference reference : docRefs) {
      reference.bindToElement(method);
    }
    VisibilityUtil.fixVisibility(usages,method,myNewVisibility);
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
  }
}
