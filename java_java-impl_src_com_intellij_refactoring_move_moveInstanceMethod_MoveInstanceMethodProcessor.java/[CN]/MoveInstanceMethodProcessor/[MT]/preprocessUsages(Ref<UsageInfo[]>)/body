{
  final UsageInfo[] usages=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final Set<PsiMember> members=new HashSet<PsiMember>();
  members.add(myMethod);
  if (myTargetVariable instanceof PsiField)   members.add((PsiMember)myTargetVariable);
  if (!myTargetClass.isInterface()) {
    RefactoringConflictsUtil.analyzeAccessibilityConflicts(members,myTargetClass,conflicts,myNewVisibility);
  }
 else {
    for (    final UsageInfo usage : usages) {
      if (usage instanceof InheritorUsageInfo) {
        RefactoringConflictsUtil.analyzeAccessibilityConflicts(members,((InheritorUsageInfo)usage).getInheritor(),conflicts,myNewVisibility);
      }
    }
  }
  if (myTargetVariable instanceof PsiParameter) {
    PsiParameter parameter=(PsiParameter)myTargetVariable;
    for (    final UsageInfo usageInfo : usages) {
      if (usageInfo instanceof MethodCallUsageInfo) {
        final PsiElement methodCall=((MethodCallUsageInfo)usageInfo).getMethodCallExpression();
        if (methodCall instanceof PsiMethodCallExpression) {
          final PsiExpression[] expressions=((PsiMethodCallExpression)methodCall).getArgumentList().getExpressions();
          final int index=myMethod.getParameterList().getParameterIndex(parameter);
          if (index < expressions.length) {
            PsiExpression instanceValue=expressions[index];
            instanceValue=RefactoringUtil.unparenthesizeExpression(instanceValue);
            if (instanceValue instanceof PsiLiteralExpression && ((PsiLiteralExpression)instanceValue).getValue() == null) {
              String message=RefactoringBundle.message("0.contains.call.with.null.argument.for.parameter.1",RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(methodCall),true),CommonRefactoringUtil.htmlEmphasize(parameter.getName()));
              conflicts.putValue(instanceValue,message);
            }
          }
        }
 else         if (methodCall instanceof PsiMethodReferenceExpression) {
          conflicts.putValue(methodCall,"Method reference would be broken after move");
        }
      }
    }
  }
  try {
    ConflictsUtil.checkMethodConflicts(myTargetClass,myMethod,getPatternMethod(),conflicts);
  }
 catch (  IncorrectOperationException e) {
  }
  return showConflicts(conflicts,usages);
}
