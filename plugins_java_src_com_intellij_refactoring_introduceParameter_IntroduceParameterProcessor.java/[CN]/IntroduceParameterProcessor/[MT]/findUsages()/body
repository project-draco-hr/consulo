{
  ArrayList<UsageInfo> result=new ArrayList<UsageInfo>();
  PsiMethod[] overridingMethods=OverridingMethodsSearch.search(myMethodToSearchFor,true).toArray(PsiMethod.EMPTY_ARRAY);
  for (  PsiMethod overridingMethod : overridingMethods) {
    result.add(new UsageInfo(overridingMethod));
  }
  if (!myGenerateDelegate) {
    PsiReference[] refs=MethodReferencesSearch.search(myMethodToSearchFor,GlobalSearchScope.projectScope(myProject),true).toArray(PsiReference.EMPTY_ARRAY);
    for (    PsiReference ref1 : refs) {
      PsiElement ref=ref1.getElement();
      if (ref instanceof PsiMethod && ((PsiMethod)ref).isConstructor()) {
        DefaultConstructorImplicitUsageInfo implicitUsageInfo=new DefaultConstructorImplicitUsageInfo((PsiMethod)ref,((PsiMethod)ref).getContainingClass(),myMethodToSearchFor);
        result.add(implicitUsageInfo);
      }
 else       if (ref instanceof PsiClass) {
        result.add(new NoConstructorClassUsageInfo((PsiClass)ref));
      }
 else       if (!IntroduceParameterUtil.insideMethodToBeReplaced(ref,myMethodToReplaceIn)) {
        result.add(new ExternalUsageInfo(ref));
      }
 else {
        result.add(new ChangedMethodCallInfo(ref));
      }
    }
  }
  if (myReplaceAllOccurences) {
    for (    PsiElement expr : getOccurrences()) {
      result.add(new InternalUsageInfo(expr));
    }
  }
 else {
    if (myExpressionToSearch != null && myExpressionToSearch.isValid()) {
      result.add(new InternalUsageInfo(myExpressionToSearch));
    }
  }
  final UsageInfo[] usageInfos=result.toArray(new UsageInfo[result.size()]);
  return UsageViewUtil.removeDuplicatedUsages(usageInfos);
}
