{
  return new SLRUCache<Key,BufferExposingByteArrayOutputStream>(16 * 1024,4 * 1024,keyDescriptor){
    @Override @NotNull public BufferExposingByteArrayOutputStream createValue(    final Key key){
      return myStreamPool.alloc();
    }
    @Override protected void onDropFromCache(    final Key key,    @NotNull final BufferExposingByteArrayOutputStream bytes){
      myEnumerator.lockStorage();
      try {
        long previousRecord;
        final int id;
        if (myDirectlyStoreLongFileOffsetMode) {
          previousRecord=((PersistentBTreeEnumerator<Key>)myEnumerator).getNonnegativeValue(key);
          id=-1;
        }
 else {
          id=enumerate(key);
          previousRecord=readValueId(id);
        }
        long headerRecord=myValueStorage.appendBytes(bytes.getInternalBuffer(),0,bytes.size(),previousRecord);
        if (myDirectlyStoreLongFileOffsetMode) {
          ((PersistentBTreeEnumerator<Key>)myEnumerator).putNonnegativeValue(key,headerRecord);
        }
 else {
          updateValueId(id,headerRecord,previousRecord,key,0);
        }
        if (previousRecord == NULL_ADDR) {
          myLiveAndGarbageKeysCounter+=LIVE_KEY_MASK;
        }
        myStreamPool.recycle(bytes);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
 finally {
        myEnumerator.unlockStorage();
      }
    }
  }
;
}
