{
  final HashingStrategy<Key> hashingStrategy=new HashingStrategy<Key>(){
    @Override public int computeHashCode(    Key object){
      return keyDescriptor.getHashCode(object);
    }
    @Override public boolean equals(    Key o1,    Key o2){
      return keyDescriptor.isEqual(o1,o2);
    }
  }
;
  return new SLRUCache<Key,BufferExposingByteArrayOutputStream>(16 * 1024,4 * 1024,hashingStrategy){
    @Override @NotNull public BufferExposingByteArrayOutputStream createValue(    final Key key){
      return myStreamPool.alloc();
    }
    @Override protected void onDropFromCache(    final Key key,    @NotNull final BufferExposingByteArrayOutputStream bytes){
      myEnumerator.lockStorage();
      try {
        final int id=enumerate(key);
        long oldHeaderRecord=readValueId(id);
        long headerRecord=myValueStorage.appendBytes(bytes.getInternalBuffer(),0,bytes.size(),oldHeaderRecord);
        updateValueId(id,headerRecord,oldHeaderRecord,key,0);
        if (oldHeaderRecord == NULL_ADDR) {
          myLiveAndGarbageKeysCounter+=LIVE_KEY_MASK;
        }
        myStreamPool.recycle(bytes);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
 finally {
        myEnumerator.unlockStorage();
      }
    }
  }
;
}
