{
  final long valueOffset;
  final int id;
  myEnumerator.lockStorage();
  try {
    myAppendCache.remove(key);
    if (myDirectlyStoreLongFileOffsetMode) {
      valueOffset=((PersistentBTreeEnumerator<Key>)myEnumerator).getNonnegativeValue(key);
      if (myIntMapping) {
        return (Value)(Integer)(int)valueOffset;
      }
      id=-1;
    }
 else {
      id=tryEnumerate(key);
      if (id == PersistentEnumerator.NULL_ID) {
        return null;
      }
      if (myIntMapping) {
        return (Value)(Integer)myEnumerator.myStorage.getInt(id + myParentValueRefOffset);
      }
      valueOffset=readValueId(id);
    }
    if (valueOffset == NULL_ADDR) {
      return null;
    }
  }
  finally {
    myEnumerator.unlockStorage();
  }
  final PersistentHashMapValueStorage.ReadResult readResult=myValueStorage.readBytes(valueOffset);
  DataInputStream input=new DataInputStream(new UnsyncByteArrayInputStream(readResult.buffer));
  final Value valueRead;
  try {
    valueRead=myValueExternalizer.read(input);
  }
  finally {
    input.close();
  }
  if (myValueStorage.performChunksCompaction(readResult.chunksCount,readResult.buffer.length)) {
    long newValueOffset=myValueStorage.compactChunks(new ValueDataAppender(){
      @Override public void append(      DataOutput out) throws IOException {
        myValueExternalizer.save(out,valueRead);
      }
    }
,readResult);
    myEnumerator.lockStorage();
    try {
      myEnumerator.markDirty(true);
      if (myDirectlyStoreLongFileOffsetMode) {
        ((PersistentBTreeEnumerator<Key>)myEnumerator).putNonnegativeValue(key,newValueOffset);
      }
 else {
        updateValueId(id,newValueOffset,valueOffset,key,0);
      }
      myLiveAndGarbageKeysCounter++;
      myReadCompactionGarbageSize+=readResult.buffer.length;
    }
  finally {
      myEnumerator.unlockStorage();
    }
  }
  return valueRead;
}
