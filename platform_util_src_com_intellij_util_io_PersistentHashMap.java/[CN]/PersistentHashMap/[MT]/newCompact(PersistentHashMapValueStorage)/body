{
  long started=System.currentTimeMillis();
  final List<CompactionRecordInfo> infos=new ArrayList<CompactionRecordInfo>(10000);
  traverseAllRecords(new PersistentEnumerator.RecordsProcessor(){
    @Override public boolean process(    final int keyId) throws IOException {
      final long record=readValueId(keyId);
      if (record != NULL_ADDR) {
        infos.add(new CompactionRecordInfo(getCurrentKey(),record,keyId));
      }
      return true;
    }
  }
);
  LOG.info("Loaded mappings:" + (System.currentTimeMillis() - started) + "ms, keys:"+ infos.size());
  started=System.currentTimeMillis();
  int fragments=0;
  if (infos.size() > 0) {
    try {
      fragments=myValueStorage.compactValues(infos,newStorage);
    }
 catch (    Throwable t) {
      if (!(t instanceof IOException))       throw new IOException("Compaction failed",t);
      throw (IOException)t;
    }
  }
  LOG.info("Compacted values for:" + (System.currentTimeMillis() - started) + "ms fragments:"+ fragments);
  started=System.currentTimeMillis();
  try {
    myEnumerator.lockStorage();
    for (int i=0; i < infos.size(); ++i) {
      CompactionRecordInfo info=infos.get(i);
      updateValueId(info.address,info.newValueAddress,info.valueAddress,null,info.key);
      myLiveAndGarbageKeysCounter+=LIVE_KEY_MASK;
    }
  }
  finally {
    myEnumerator.unlockStorage();
  }
  LOG.info("Updated mappings:" + (System.currentTimeMillis() - started) + " ms");
}
