{
  super(checkDataFiles(file),keyDescriptor,initialSize);
  myStorageFile=file;
  myKeyDescriptor=keyDescriptor;
  myAppendCache=createAppendCache(keyDescriptor);
  final PersistentEnumeratorBase.RecordBufferHandler<PersistentEnumeratorBase> recordHandler=myEnumerator.getRecordHandler();
  myParentValueRefOffset=recordHandler.getRecordBuffer(myEnumerator).length;
  myIntMapping=valueExternalizer instanceof IntInlineKeyDescriptor && wantNonnegativeIntegralValues();
  myDirectlyStoreLongFileOffsetMode=keyDescriptor instanceof InlineKeyDescriptor && myEnumerator instanceof PersistentBTreeEnumerator;
  myRecordBuffer=myDirectlyStoreLongFileOffsetMode ? new byte[0] : new byte[myParentValueRefOffset + 8];
  mySmallRecordBuffer=myDirectlyStoreLongFileOffsetMode ? new byte[0] : new byte[myParentValueRefOffset + 4];
  myEnumerator.setRecordHandler(new PersistentEnumeratorBase.RecordBufferHandler<PersistentEnumeratorBase>(){
    @Override int recordWriteOffset(    PersistentEnumeratorBase enumerator,    byte[] buf){
      return recordHandler.recordWriteOffset(enumerator,buf);
    }
    @NotNull @Override byte[] getRecordBuffer(    PersistentEnumeratorBase enumerator){
      return myIntAddressForNewRecord ? mySmallRecordBuffer : myRecordBuffer;
    }
    @Override void setupRecord(    PersistentEnumeratorBase enumerator,    int hashCode,    int dataOffset,    @NotNull byte[] buf){
      recordHandler.setupRecord(enumerator,hashCode,dataOffset,buf);
      for (int i=myParentValueRefOffset; i < buf.length; i++) {
        buf[i]=0;
      }
    }
  }
);
  myEnumerator.setMarkCleanCallback(new Flushable(){
    @Override public void flush() throws IOException {
      myEnumerator.putMetaData(myLiveAndGarbageKeysCounter);
      myEnumerator.putMetaData2(myLargeIndexWatermarkId | ((long)myReadCompactionGarbageSize << 32));
    }
  }
);
  try {
    myValueExternalizer=valueExternalizer;
    myValueStorage=PersistentHashMapValueStorage.create(getDataFile(file).getPath());
    myLiveAndGarbageKeysCounter=myEnumerator.getMetaData();
    long data2=myEnumerator.getMetaData2();
    myLargeIndexWatermarkId=(int)(data2 & DEAD_KEY_NUMBER_MASK);
    myReadCompactionGarbageSize=(int)(data2 >>> 32);
    myCanReEnumerate=myEnumerator.canReEnumerate();
    if (makesSenseToCompact()) {
      compact();
    }
  }
 catch (  IOException e) {
    try {
      close();
    }
 catch (    Throwable ignored) {
    }
    throw e;
  }
catch (  Throwable t) {
    LOG.error(t);
    try {
      close();
    }
 catch (    Throwable ignored) {
    }
    throw new PersistentEnumerator.CorruptedException(file);
  }
}
