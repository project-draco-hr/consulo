{
  super(checkDataFiles(file),keyDescriptor,initialSize);
  final PersistentEnumeratorBase.RecordBufferHandler<PersistentEnumeratorBase> recordHandler=myEnumerator.getRecordHandler();
  myParentValueRefOffset=recordHandler.getRecordBuffer(myEnumerator).length;
  myRecordBuffer=new byte[myParentValueRefOffset + 8];
  mySmallRecordBuffer=new byte[myParentValueRefOffset + 4];
  myEnumerator.setRecordHandler(new PersistentEnumeratorBase.RecordBufferHandler<PersistentEnumeratorBase>(){
    @Override int recordWriteOffset(    PersistentEnumeratorBase enumerator,    byte[] buf){
      return recordHandler.recordWriteOffset(enumerator,buf);
    }
    @NotNull @Override byte[] getRecordBuffer(    PersistentEnumeratorBase enumerator){
      return myIntAddressForNewRecord ? mySmallRecordBuffer : myRecordBuffer;
    }
    @Override void setupRecord(    PersistentEnumeratorBase enumerator,    int hashCode,    int dataOffset,    @NotNull byte[] buf){
      recordHandler.setupRecord(enumerator,hashCode,dataOffset,buf);
      for (int i=myParentValueRefOffset; i < buf.length; i++) {
        buf[i]=0;
      }
    }
  }
);
  myEnumerator.setMarkCleanCallback(new Flushable(){
    @Override public void flush() throws IOException {
      myEnumerator.putMetaData(myLiveAndGarbageKeysCounter);
      myEnumerator.putMetaData2(myWatermarkId);
    }
  }
);
  try {
    myValueExternalizer=valueExternalizer;
    myValueStorage=PersistentHashMapValueStorage.create(getDataFile(file).getPath());
    myLiveAndGarbageKeysCounter=myEnumerator.getMetaData();
    myWatermarkId=(int)myEnumerator.getMetaData2();
    myCanReEnumerate=myEnumerator.canReEnumerate();
    if (makesSenseToCompact()) {
      compact();
    }
  }
 catch (  IOException e) {
    throw e;
  }
catch (  Throwable t) {
    LOG.error(t);
    throw new PersistentEnumerator.CorruptedException(file);
  }
}
