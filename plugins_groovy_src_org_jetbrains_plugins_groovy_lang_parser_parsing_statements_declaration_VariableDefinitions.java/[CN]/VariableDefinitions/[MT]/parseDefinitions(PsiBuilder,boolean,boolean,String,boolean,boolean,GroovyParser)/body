{
  boolean isLParenth=builder.getTokenType() == mLPAREN;
  boolean isStringName=builder.getTokenType() == mSTRING_LITERAL || builder.getTokenType() == mGSTRING_LITERAL;
  if (builder.getTokenType() != mIDENT && !isStringName && !isLParenth) {
    builder.error(GroovyBundle.message("indentifier.or.string.or.left.parenth.literal.expected"));
    return WRONGWAY;
  }
  if (isLParenth && !canBeTuple) {
    builder.error(GroovyBundle.message("indentifier.or.string.or.left.parenth.literal.expected"));
    return WRONGWAY;
  }
  if (isInAnnotation && isStringName) {
    builder.error(GroovyBundle.message("string.name.unexpected"));
  }
  if (!isLParenth) {
    PsiBuilder.Marker varMarker=builder.mark();
    final boolean isConstructor=isInClass && !isInAnnotation && typeDefinitionName != null && builder.getTokenType() == mIDENT && typeDefinitionName.equals(builder.getTokenText());
    builder.advanceLexer();
    if (mLPAREN != builder.getTokenType()) {
      varMarker.rollbackTo();
    }
 else {
      varMarker.drop();
      return parseMethod(builder,isInAnnotation,hasModifiers,parser,isConstructor);
    }
  }
  return parseVar(builder,isInClass,hasModifiers,parser,isLParenth);
}
