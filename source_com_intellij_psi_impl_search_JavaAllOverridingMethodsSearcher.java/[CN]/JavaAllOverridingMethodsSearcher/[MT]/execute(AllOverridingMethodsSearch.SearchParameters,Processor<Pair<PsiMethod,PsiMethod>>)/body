{
  final PsiClass psiClass=p.getPsiClass();
  PsiMethod[] methodsArray=psiClass.getMethods();
  final List<PsiMethod> methods=new ArrayList<PsiMethod>(methodsArray.length);
  for (  PsiMethod method : methodsArray) {
    if (PsiUtil.canBeOverriden(method))     methods.add(method);
  }
  final SearchScope scope=p.getScope();
  Processor<PsiClass> inheritorsProcessor=new Processor<PsiClass>(){
    public boolean process(    PsiClass inheritor){
      PsiSubstitutor substitutor=TypeConversionUtil.getClassSubstitutor(psiClass,inheritor,PsiSubstitutor.EMPTY);
      if (substitutor == null)       return true;
      for (      PsiMethod method : methods) {
        if (method.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) && !inheritor.getManager().arePackagesTheSame(psiClass,inheritor))         continue;
        MethodSignature signature=method.getSignature(substitutor);
        PsiMethod inInheritor=MethodSignatureUtil.findMethodBySuperSignature(inheritor,signature,false);
        if (inInheritor == null || inInheritor.hasModifierProperty(PsiModifier.STATIC)) {
          if (psiClass.isInterface() && !inheritor.isInterface()) {
            final PsiClass superClass=inheritor.getSuperClass();
            if (superClass != null && !superClass.isInheritor(psiClass,true)) {
              inInheritor=MethodSignatureUtil.findMethodInSuperClassBySignatureInDerived(inheritor,superClass,signature,true);
              if (inInheritor != null && !inInheritor.hasModifierProperty(PsiModifier.STATIC)) {
                if (!consumer.process(new Pair<PsiMethod,PsiMethod>(method,inInheritor)))                 return false;
              }
            }
          }
          continue;
        }
        if (!consumer.process(new Pair<PsiMethod,PsiMethod>(method,inInheritor)))         return false;
      }
      return true;
    }
  }
;
  return ClassInheritorsSearch.search(psiClass,scope,true).forEach(inheritorsProcessor);
}
