{
  final PsiClass psiClass=p.getPsiClass();
  final List<PsiMethod> methods=new ArrayList<PsiMethod>(Arrays.asList(psiClass.getMethods()));
  for (Iterator<PsiMethod> it=methods.iterator(); it.hasNext(); ) {
    PsiMethod method=it.next();
    if (!PsiUtil.canBeOverriden(method))     it.remove();
  }
  final SearchScope scope=p.getScope();
  Processor<PsiClass> inheritorsProcessor=new Processor<PsiClass>(){
    public boolean process(    PsiClass inheritor){
      PsiSubstitutor substitutor=TypeConversionUtil.getClassSubstitutor(psiClass,inheritor,PsiSubstitutor.EMPTY);
      if (substitutor == null)       return true;
      for (      PsiMethod method : methods) {
        if (method.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) && !inheritor.getManager().arePackagesTheSame(psiClass,inheritor))         continue;
        MethodSignature signature=method.getSignature(substitutor);
        PsiMethod inInheritor=MethodSignatureUtil.findMethodBySuperSignature(inheritor,signature,false);
        if (inInheritor == null || inInheritor.hasModifierProperty(PsiModifier.STATIC)) {
          if (psiClass.isInterface() && !inheritor.isInterface() && inheritor.isInheritor(psiClass,false)) {
            inInheritor=MethodSignatureUtil.findMethodInSuperClassBySignatureInDerived(inheritor,signature,true);
            if (inInheritor != null && !inInheritor.hasModifierProperty(PsiModifier.STATIC)) {
              if (!consumer.process(new Pair<PsiMethod,PsiMethod>(method,inInheritor)))               return false;
            }
          }
          continue;
        }
        if (!consumer.process(new Pair<PsiMethod,PsiMethod>(method,inInheritor)))         return false;
      }
      return true;
    }
  }
;
  return ClassInheritorsSearch.search(psiClass,scope,true).forEach(inheritorsProcessor);
}
