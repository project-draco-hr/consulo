{
  if (!(element instanceof PsiClass))   return true;
  final PsiClass aClass=(PsiClass)element;
  final String name=aClass.getName();
  if (!myClassName.equals(name)) {
    return true;
  }
  boolean accessible=myPlace == null || checkAccessibility(aClass);
  if (myCandidates == null) {
    myCandidates=new SmartList<ClassCandidateInfo>();
  }
 else {
    String fqName=aClass.getQualifiedName();
    if (fqName != null) {
      for (int i=myCandidates.size() - 1; i >= 0; i--) {
        ClassCandidateInfo info=myCandidates.get(i);
        Domination domination=dominates(aClass,accessible && isAccessible(aClass),fqName,info);
        if (domination == Domination.DOMINATED_BY) {
          return true;
        }
 else         if (domination == Domination.DOMINATES) {
          myCandidates.remove(i);
        }
      }
    }
  }
  myHasAccessibleCandidate|=accessible;
  myHasInaccessibleCandidate|=!accessible;
  myCandidates.add(new ClassCandidateInfo(aClass,state.get(PsiSubstitutor.KEY),!accessible,myCurrentFileContext));
  myResult=null;
  if (!accessible)   return true;
  if (aClass.hasModifierProperty(PsiModifier.PRIVATE)) {
    final PsiClass containingPlaceClass=PsiTreeUtil.getParentOfType(myPlace,PsiClass.class,false);
    if (containingPlaceClass != null && !PsiTreeUtil.isAncestor(containingPlaceClass,aClass,false)) {
      return true;
    }
  }
  return myCurrentFileContext instanceof PsiImportStatementBase;
}
