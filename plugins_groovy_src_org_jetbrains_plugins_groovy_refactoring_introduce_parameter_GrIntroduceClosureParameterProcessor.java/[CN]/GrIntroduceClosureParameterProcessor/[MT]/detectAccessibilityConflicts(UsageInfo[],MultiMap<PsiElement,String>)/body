{
  final GrExpression expression=mySettings.getExpression();
  if (expression == null)   return;
  final ReferencedElementsCollector collector=new ReferencedElementsCollector();
  expression.accept(collector);
  final List<PsiElement> result=collector.getResult();
  if (result.isEmpty())   return;
  for (  final UsageInfo usageInfo : usageArray) {
    if (!(usageInfo instanceof ExternalUsageInfo) || !IntroduceParameterUtil.isMethodUsage(usageInfo))     continue;
    final PsiElement place=usageInfo.getElement();
    for (    PsiElement element : result) {
      if (element instanceof PsiField && mySettings.replaceFieldsWithGetters() != IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE) {
        final PsiClass psiClass=((PsiField)element).getContainingClass();
        LOG.assertTrue(psiClass != null);
        final PsiMethod method=GroovyPropertyUtils.findGetterForField((PsiField)element);
        if (method != null) {
          element=method;
        }
      }
      if (element instanceof PsiMember && !JavaPsiFacade.getInstance(myProject).getResolveHelper().isAccessible((PsiMember)element,place,null)) {
        String message=RefactoringBundle.message("0.is.not.accessible.from.1.value.for.introduced.parameter.in.that.method.call.will.be.incorrect",RefactoringUIUtil.getDescription(element,true),RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(place),true));
        conflicts.putValue(element,message);
      }
    }
  }
}
