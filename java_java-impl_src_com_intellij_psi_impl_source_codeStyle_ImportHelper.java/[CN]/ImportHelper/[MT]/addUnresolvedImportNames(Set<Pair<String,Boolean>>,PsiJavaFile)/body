{
  final PsiImportList importList=file.getImportList();
  PsiImportStatementBase[] imports=importList == null ? PsiImportStatementBase.EMPTY_ARRAY : importList.getAllImportStatements();
  final Map<String,Pair<String,Boolean>> unresolvedNames=new THashMap<String,Pair<String,Boolean>>();
  @NotNull Set<Pair<String,Boolean>> unresolvedOnDemand=new THashSet<Pair<String,Boolean>>();
  for (  PsiImportStatementBase anImport : imports) {
    PsiJavaCodeReferenceElement ref=anImport.getImportReference();
    if (ref == null)     continue;
    JavaResolveResult[] results=ref.multiResolve(false);
    if (results.length == 0) {
      String text=ref.getCanonicalText();
      if (anImport.isOnDemand()) {
        text+=".*";
      }
      Pair<String,Boolean> pair=Pair.create(text,anImport instanceof PsiImportStaticStatement);
      if (anImport.isOnDemand()) {
        unresolvedOnDemand.add(pair);
      }
 else {
        unresolvedNames.put(ref.getReferenceName(),pair);
      }
    }
  }
  if (file.getViewProvider().getLanguages().size() > 1 && file.getViewProvider().getBaseLanguage() != JavaLanguage.INSTANCE) {
    namesToImport.addAll(unresolvedOnDemand);
    namesToImport.addAll(unresolvedNames.values());
    return;
  }
  final boolean[] hasResolveProblem={false};
  for (  PsiClass aClass : file.getClasses()) {
    aClass.accept(new JavaRecursiveElementWalkingVisitor(){
      @Override public void visitReferenceElement(      PsiJavaCodeReferenceElement reference){
        String name=reference.getReferenceName();
        Pair<String,Boolean> pair=unresolvedNames.get(name);
        if (reference.multiResolve(false).length == 0) {
          hasResolveProblem[0]=true;
          if (pair != null) {
            namesToImport.add(pair);
            unresolvedNames.remove(name);
          }
        }
        super.visitReferenceElement(reference);
      }
    }
);
  }
  if (hasResolveProblem[0]) {
    namesToImport.addAll(unresolvedOnDemand);
  }
}
