{
  List<Pair<String,Boolean>> names=new ArrayList<Pair<String,Boolean>>(collectNamesToImport(file));
  Collections.sort(names,new Comparator<Pair<String,Boolean>>(){
    public int compare(    Pair<String,Boolean> o1,    Pair<String,Boolean> o2){
      return o1.getFirst().compareTo(o2.getFirst());
    }
  }
);
  int[] entryForName=ArrayUtil.newIntArray(names.size());
  PackageEntry[] entries=mySettings.IMPORT_LAYOUT_TABLE.getEntries();
  for (int i=0; i < names.size(); i++) {
    Pair<String,Boolean> pair=names.get(i);
    String packageName=pair.getFirst();
    Boolean isStatic=pair.getSecond();
    entryForName[i]=findEntryIndex(packageName,isStatic,entries);
  }
  List<Pair<String,Boolean>> resultList=new ArrayList<Pair<String,Boolean>>(names.size());
  for (int i=0; i < entries.length; i++) {
    for (int j=0; j < names.size(); j++) {
      if (entryForName[j] == i) {
        resultList.add(names.get(j));
        names.set(j,null);
      }
    }
  }
  for (  Pair<String,Boolean> name : names) {
    if (name != null)     resultList.add(name);
  }
  TObjectIntHashMap<String> packageToCountMap=new TObjectIntHashMap<String>();
  TObjectIntHashMap<String> classToCountMap=new TObjectIntHashMap<String>();
  for (  Pair<String,Boolean> pair : resultList) {
    String name=pair.getFirst();
    Boolean isStatic=pair.getSecond();
    String packageOrClassName=getPackageOrClassName(name);
    if (packageOrClassName.length() == 0)     continue;
    if (isStatic) {
      int count=classToCountMap.get(packageOrClassName);
      classToCountMap.put(packageOrClassName,count + 1);
    }
 else {
      int count=packageToCountMap.get(packageOrClassName);
      packageToCountMap.put(packageOrClassName,count + 1);
    }
  }
  final Set<String> classesOrPackagesToImportOnDemand=new THashSet<String>();
class MyVisitorProcedure implements TObjectIntProcedure<String> {
    private final boolean myIsVisitingPackages;
    MyVisitorProcedure(    boolean isVisitingPackages){
      myIsVisitingPackages=isVisitingPackages;
    }
    public boolean execute(    final String packageOrClassName,    final int count){
      if (isToUseImportOnDemand(packageOrClassName,count,!myIsVisitingPackages)) {
        classesOrPackagesToImportOnDemand.add(packageOrClassName);
      }
      return true;
    }
  }
  classToCountMap.forEachEntry(new MyVisitorProcedure(false));
  packageToCountMap.forEachEntry(new MyVisitorProcedure(true));
  Set<String> classesToUseSingle=findSingleImports(file,resultList,classesOrPackagesToImportOnDemand);
  Set<String> toReimport=new THashSet<String>();
  calcClassesConflictingViaOnDemandImports(file,classesOrPackagesToImportOnDemand,file.getResolveScope(),toReimport);
  classesToUseSingle.addAll(toReimport);
  try {
    StringBuilder text=buildImportListText(resultList,classesOrPackagesToImportOnDemand,classesToUseSingle);
    String ext=StdFileTypes.JAVA.getDefaultExtension();
    PsiFileFactory factory=PsiFileFactory.getInstance(file.getProject());
    final PsiJavaFile dummyFile=(PsiJavaFile)factory.createFileFromText("_Dummy_." + ext,StdFileTypes.JAVA,text);
    CodeStyleManager codeStyleManager=CodeStyleManager.getInstance(file.getProject());
    codeStyleManager.reformat(dummyFile);
    PsiImportList result=dummyFile.getImportList();
    PsiImportList oldList=file.getImportList();
    if (oldList.isReplaceEquivalent(result))     return null;
    return result;
  }
 catch (  IncorrectOperationException e) {
    LOG.error(e);
    return null;
  }
}
