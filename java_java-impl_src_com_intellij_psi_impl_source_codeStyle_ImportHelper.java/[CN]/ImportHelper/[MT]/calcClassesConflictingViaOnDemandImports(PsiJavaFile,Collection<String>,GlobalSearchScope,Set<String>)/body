{
  List<String> onDemands=new ArrayList<String>(Arrays.asList(file.getImplicitlyImportedPackages()));
  for (  String onDemand : onDemands) {
    if (!onDemands.contains(onDemand)) {
      onDemands.add(onDemand);
    }
  }
  if (onDemands.size() < 2)   return;
  Map<String,Set<String>> classNames=new THashMap<String,Set<String>>();
  JavaPsiFacade facade=JavaPsiFacade.getInstance(file.getProject());
  for (int i=onDemands.size() - 1; i >= 0; i--) {
    String onDemand=onDemands.get(i);
    PsiPackage aPackage=facade.findPackage(onDemand);
    if (aPackage == null) {
      onDemands.remove(i);
      continue;
    }
    PsiClass[] psiClasses=aPackage.getClasses(resolveScope);
    Set<String> set=new THashSet<String>(psiClasses.length);
    for (    PsiClass psiClass : psiClasses) {
      set.add(psiClass.getName());
    }
    classNames.put(onDemand,set);
  }
  final Set<String> conflicts=new THashSet<String>();
  for (int i=0; i < onDemands.size(); i++) {
    String on1=onDemands.get(i);
    for (int j=i + 1; j < onDemands.size(); j++) {
      String on2=onDemands.get(j);
      Set<String> inter=new THashSet<String>(classNames.get(on1));
      inter.retainAll(classNames.get(on2));
      conflicts.addAll(inter);
    }
  }
  if (!conflicts.isEmpty()) {
    file.accept(new JavaRecursiveElementVisitor(){
      @Override public void visitReferenceElement(      PsiJavaCodeReferenceElement reference){
        if (reference.getQualifier() != null)         return;
        PsiElement element=reference.resolve();
        if (element instanceof PsiClass && conflicts.contains(((PsiClass)element).getName())) {
          String fqn=((PsiClass)element).getQualifiedName();
          namesToUseSingle.add(fqn);
        }
      }
    }
);
  }
}
