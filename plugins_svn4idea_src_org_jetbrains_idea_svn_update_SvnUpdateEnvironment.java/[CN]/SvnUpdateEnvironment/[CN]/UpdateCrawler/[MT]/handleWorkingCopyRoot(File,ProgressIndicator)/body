{
  final Collection result=new HashSet();
  SvnSimpleUpdateConfigurable simpleConfig=(SvnSimpleUpdateConfigurable)(myConfigurable instanceof SvnSimpleUpdateConfigurable ? myConfigurable : null);
  SvnUpdateConfigurable config=(SvnUpdateConfigurable)(myConfigurable instanceof SvnUpdateConfigurable ? myConfigurable : null);
  SVNRevision revision=config != null ? config.getTargetRevision() : SVNRevision.HEAD;
  String url=config != null ? config.getTargetURL() : null;
  long rev;
  boolean recursive=config != null ? config.isRecursive() : (simpleConfig == null || simpleConfig.isRecursive());
  boolean merge=config != null && config.isMerge();
  boolean dryRun=config != null && config.isDryRun();
  if (progress != null) {
    if (merge) {
      if (dryRun) {
        progress.setText(SvnBundle.message("progress.text.merging.dry.run..changes",root.getAbsolutePath()));
      }
 else {
        progress.setText(SvnBundle.message("progress.text.merging.changes",root.getAbsolutePath()));
      }
    }
 else {
      progress.setText(SvnBundle.message("progress.text.updating",root.getAbsolutePath()));
    }
  }
  try {
    SVNUpdateClient client=myVcs.createUpdateClient();
    client.setEventHandler(myHandler);
    if (merge) {
      String url1=config.getMergeURL1();
      String url2=config.getMergeURL2();
      SVNRevision rev1=config.getMergeRevision1();
      SVNRevision rev2=config.getMergeRevision2();
      rev1=rev1 == null ? SVNRevision.HEAD : rev1;
      rev2=rev2 == null ? SVNRevision.HEAD : rev2;
      rev=0;
      SVNDiffClient diffClient=myVcs.createDiffClient();
      diffClient.setEventHandler(myHandler);
      SVNURL svnURL1=SVNURL.parseURIEncoded(url1);
      SVNURL svnURL2=SVNURL.parseURIEncoded(url2);
      diffClient.doMerge(svnURL1,rev1,svnURL2,rev2,root,recursive,true,false,dryRun);
    }
 else     if (config != null && !config.isUpdate() && url != null) {
      rev=client.doSwitch(root,SVNURL.parseURIEncoded(url),revision,recursive);
    }
 else {
      rev=client.doUpdate(root,revision,recursive);
    }
    if (rev < 0) {
      throw new SVNException(SvnBundle.message("exception.text.root.was.not.properly.updated",root));
    }
  }
 catch (  SVNException e) {
    myExceptions.add(new VcsException(e));
  }
  boolean runStatus=config != null ? config.isRunStatus() : (simpleConfig != null && simpleConfig.isRunStatus());
  if (!runStatus) {
    return result;
  }
  try {
    SVNStatusClient statusClient=myVcs.createStatusClient();
    statusClient.setIgnoreExternals(false);
    if (progress != null) {
      progress.setText(SvnBundle.message("progress.text.update.computing.post.update.status",root.getAbsolutePath()));
    }
    statusClient.doStatus(root,true,false,false,false,new ISVNStatusHandler(){
      public void handleStatus(      SVNStatus status){
        if (status.getFile() == null) {
          return;
        }
        if (myIsTotalUpdate && status.getContentsStatus() == SVNStatusType.STATUS_UNVERSIONED && status.getFile().isDirectory()) {
          result.add(status.getFile());
        }
        if (status.getContentsStatus() == SVNStatusType.STATUS_EXTERNAL || status.getContentsStatus() == SVNStatusType.STATUS_IGNORED || status.getContentsStatus() == SVNStatusType.STATUS_MISSING || status.getContentsStatus() == SVNStatusType.STATUS_INCOMPLETE || status.getContentsStatus() == SVNStatusType.STATUS_MISSING) {
        }
 else         if (status.getContentsStatus() != SVNStatusType.STATUS_NONE || status.getPropertiesStatus() == SVNStatusType.STATUS_NONE) {
          String path=status.getFile().getAbsolutePath();
          if (status.getContentsStatus() == SVNStatusType.STATUS_ADDED) {
            myPostUpdateFiles.getGroupById(FileGroup.LOCALLY_ADDED_ID).add(path);
          }
 else           if (status.getContentsStatus() == SVNStatusType.STATUS_CONFLICTED) {
            FileGroup group=myPostUpdateFiles.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID);
            if (group != null && (group.getFiles() == null || !group.getFiles().contains(path))) {
              group.add(path);
            }
          }
 else           if (status.getContentsStatus() == SVNStatusType.STATUS_DELETED) {
            myPostUpdateFiles.getGroupById(FileGroup.LOCALLY_REMOVED_ID).add(path);
          }
 else           if (status.getContentsStatus() == SVNStatusType.STATUS_REPLACED) {
            myPostUpdateFiles.getGroupById(FileGroup.LOCALLY_ADDED_ID).add(path);
          }
 else           if (status.getContentsStatus() == SVNStatusType.STATUS_MODIFIED || status.getPropertiesStatus() == SVNStatusType.STATUS_MODIFIED) {
            myPostUpdateFiles.getGroupById(FileGroup.MODIFIED_ID).add(path);
          }
 else           if (status.getContentsStatus() == SVNStatusType.STATUS_UNVERSIONED || status.getContentsStatus() == SVNStatusType.STATUS_OBSTRUCTED) {
            if (status.getFile().isFile() || !SVNWCUtil.isVersionedDirectory(status.getFile())) {
              myPostUpdateFiles.getGroupById(FileGroup.UNKNOWN_ID).add(path);
            }
          }
        }
      }
    }
);
  }
 catch (  SVNException e) {
    myExceptions.add(new VcsException(e));
  }
  return result;
}
