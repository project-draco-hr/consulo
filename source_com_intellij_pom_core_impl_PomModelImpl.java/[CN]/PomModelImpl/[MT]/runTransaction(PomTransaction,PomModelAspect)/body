{
synchronized (PsiLock.LOCK) {
    startTransaction(transaction);
    try {
      final PomModelEvent event;
      myBlockedAspects.push(new Pair<PomModelAspect,PomTransaction>(aspect,transaction));
      try {
        transaction.run();
        event=transaction.getAccumulatedEvent();
      }
 catch (      IncorrectOperationException ioe) {
        return;
      }
 finally {
        myBlockedAspects.pop();
      }
      final Pair<PomModelAspect,PomTransaction> block=getBlockingTransaction(aspect,transaction);
      if (block != null) {
        final PomModelEvent currentEvent=block.getSecond().getAccumulatedEvent();
        currentEvent.merge(event);
        return;
      }
{
        final Set<PomModelAspect> changedAspects=event.getChangedAspects();
        final Set<PomModelAspect> dependants=new HashSet<PomModelAspect>();
        final Iterator<PomModelAspect> changedIterator=changedAspects.iterator();
        while (changedIterator.hasNext()) {
          final PomModelAspect pomModelAspect=changedIterator.next();
          dependants.addAll(getAllDependants(pomModelAspect));
        }
        final Iterator<PomModelAspect> depsIter=dependants.iterator();
        while (depsIter.hasNext()) {
          final PomModelAspect modelAspect=depsIter.next();
          if (myBlockedAspects.contains(modelAspect) || changedAspects.contains(modelAspect))           continue;
          modelAspect.update(event);
        }
      }
{
        final PomModelListener[] listeners=getListeners();
        for (int i=0; i < listeners.length; i++)         listeners[i].modelChanged(event);
      }
    }
  finally {
      commitTransaction(transaction);
    }
  }
}
