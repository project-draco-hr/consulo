{
  List<Throwable> throwables=new ArrayList<Throwable>(0);
synchronized (PsiLock.LOCK) {
    final PomModelAspect aspect=transaction.getTransactionAspect();
    startTransaction(transaction);
    try {
      myBlockedAspects.push(new Pair<PomModelAspect,PomTransaction>(aspect,transaction));
      final PomModelEvent event;
      try {
        transaction.run();
        event=transaction.getAccumulatedEvent();
      }
 catch (      Exception e) {
        LOG.error(e);
        return;
      }
 finally {
        myBlockedAspects.pop();
      }
      final Pair<PomModelAspect,PomTransaction> block=getBlockingTransaction(aspect,transaction);
      if (block != null) {
        final PomModelEvent currentEvent=block.getSecond().getAccumulatedEvent();
        currentEvent.merge(event);
        return;
      }
{
        final Set<PomModelAspect> changedAspects=event.getChangedAspects();
        final Set<PomModelAspect> dependants=new LinkedHashSet<PomModelAspect>();
        for (        final PomModelAspect pomModelAspect : changedAspects) {
          dependants.addAll(getAllDependants(pomModelAspect));
        }
        for (        final PomModelAspect modelAspect : dependants) {
          if (!changedAspects.contains(modelAspect)) {
            modelAspect.update(event);
          }
        }
      }
      final PomModelListener[] listeners=getListeners();
      for (      final PomModelListener listener : listeners) {
        final Set<PomModelAspect> changedAspects=event.getChangedAspects();
        for (        PomModelAspect modelAspect : changedAspects) {
          if (listener.isAspectChangeInteresting(modelAspect)) {
            listener.modelChanged(event);
            break;
          }
        }
      }
    }
 catch (    Throwable t) {
      throwables.add(t);
    }
 finally {
      try {
        commitTransaction(transaction);
      }
 catch (      Throwable t) {
        throwables.add(t);
      }
    }
  }
  if (!throwables.isEmpty())   throw new CompoundRuntimeException(throwables);
}
