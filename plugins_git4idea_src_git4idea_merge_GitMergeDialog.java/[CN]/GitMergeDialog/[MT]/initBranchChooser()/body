{
  myBranchChooser=new ElementsChooser<String>(true);
  myBranchChooser.setToolTipText(GitBundle.getString("merge.branches.tooltip"));
  GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(0,0,0,0);
  c.gridx=0;
  c.gridy=0;
  c.weightx=1;
  c.weighty=1;
  c.fill=GridBagConstraints.BOTH;
  myBranchToMergeContainer.add(myBranchChooser,c);
  myBranchChooser.addElementsMarkListener(new ElementsChooser.ElementsMarkListener<String>(){
    private void updateStrategies(    final List<String> elements){
      myStrategy.removeAllItems();
      for (      String s : GitMergeUtil.getMergeStrategies(elements.size())) {
        myStrategy.addItem(s);
      }
      myStrategy.setSelectedItem(GitMergeUtil.DEFAULT_STRATEGY);
    }
    public void elementMarkChanged(    final String element,    final boolean isMarked){
      final List<String> elements=myBranchChooser.getMarkedElements();
      if (elements.size() == 0) {
        setOKActionEnabled(false);
        myStrategy.setEnabled(false);
        updateStrategies(elements);
      }
 else       if (elements.size() == 1) {
        setOKActionEnabled(true);
        myStrategy.setEnabled(true);
        updateStrategies(elements);
        myNoCommitCheckBox.setEnabled(true);
        myNoCommitCheckBox.setSelected(false);
      }
 else {
        setOKActionEnabled(true);
        myStrategy.setEnabled(true);
        updateStrategies(elements);
        myNoCommitCheckBox.setEnabled(false);
        myNoCommitCheckBox.setSelected(false);
      }
    }
  }
);
}
