{
  if (exitValue != 0 && !myCompileContext.getProgressIndicator().isCanceled() && myCompileContext.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
    myCompileContext.addMessage(CompilerMessageCategory.ERROR,"Compiler internal error. Process terminated with exit code " + exitValue,null,-1,-1);
  }
  myCompiler.processTerminated();
  final VirtualFile[] sourceRoots=chunk.getSourceRoots();
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      final Set<VirtualFile> compiledWithErrors=getFilesCompiledWithErrors();
      final FileTypeManager typeManager=FileTypeManager.getInstance();
      final String outputDirPath=outputDir.replace(File.separatorChar,'/');
      for (int idx=0; idx < sourceRoots.length; idx++) {
        final VirtualFile root=sourceRoots[idx];
        buildOutputItemsList(outputDirPath,root,typeManager,compiledWithErrors,root,myProjectFileIndex.getPackageNameByDirectory(root));
      }
    }
  }
);
  CompilerUtil.refreshIOFiles(myFilesToRefresh.toArray(new File[myFilesToRefresh.size()]));
  myFileNameToSourceMap.clear();
  myFilesToRefresh.clear();
}
