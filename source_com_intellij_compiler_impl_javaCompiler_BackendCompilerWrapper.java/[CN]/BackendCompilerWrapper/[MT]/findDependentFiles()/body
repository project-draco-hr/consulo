{
  myCompileContext.getProgressIndicator().setText("Checking dependencies...");
  final int[] dependentClassInfos=myCompileContext.getDependencyCache().findDependentClasses(myCompileContext,myProject,mySuccesfullyCompiledJavaFiles);
  final Set<VirtualFile> dependentFiles=new HashSet<VirtualFile>();
  final CacheCorruptedException[] _ex=new CacheCorruptedException[]{null};
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        CompilerConfiguration compilerConfiguration=CompilerConfiguration.getInstance(myProject);
        SourceFileFinder sourceFileFinder=new SourceFileFinder(myProject,myCompileContext);
        final Cache cache=myCompileContext.getDependencyCache().getCache();
        for (int idx=0; idx < dependentClassInfos.length; idx++) {
          final int infoQName=dependentClassInfos[idx];
          final String qualifiedName=myCompileContext.getDependencyCache().resolve(infoQName);
          final VirtualFile file=sourceFileFinder.findSourceFile(qualifiedName,cache.getSourceFileName(cache.getClassId(infoQName)));
          if (file != null) {
            if (!compilerConfiguration.isExcludedFromCompilation(file)) {
              dependentFiles.add(file);
              if (ApplicationManager.getApplication().isUnitTestMode()) {
                CompilerManagerImpl.addRecompiledPath(file.getPath());
              }
            }
          }
 else {
            if (LOG.isDebugEnabled()) {
              LOG.debug("No source file for " + myCompileContext.getDependencyCache().resolve(infoQName) + " found");
            }
          }
        }
      }
 catch (      CacheCorruptedException e) {
        _ex[0]=e;
      }
    }
  }
);
  if (_ex[0] != null) {
    throw _ex[0];
  }
  myCompileContext.getProgressIndicator().setText("Found " + dependentFiles.size() + " dependent files");
  VirtualFile[] dependent=dependentFiles.toArray(new VirtualFile[dependentFiles.size()]);
  return dependent;
}
