{
  if (type instanceof PsiClassReferenceType) {
    PsiJavaCodeReferenceElement reference=((PsiClassReferenceType)type).getReference();
    ConcurrencyUtil.cacheOrGet(myCachedReferencesInPsiTypes,reference,type);
synchronized (myCachedReferenceIn_PsiClassReferenceType_To_ListOfReferencesOfThisType_CachedHere) {
      WeakList<PsiElement> refsTo=myCachedReferenceIn_PsiClassReferenceType_To_ListOfReferencesOfThisType_CachedHere.get(reference);
      if (refsTo == null) {
        refsTo=new WeakList<PsiElement>();
        myCachedReferenceIn_PsiClassReferenceType_To_ListOfReferencesOfThisType_CachedHere.put(reference,refsTo);
      }
      refsTo.add(expr);
    }
    final PsiFile dummyHolder=reference.getContainingFile();
    if (dummyHolder != null && !dummyHolder.isPhysical()) {
      PsiElement physicalContext=dummyHolder.getContext();
      PsiFile physicalFile;
      if (physicalContext != null && (physicalFile=physicalContext.getContainingFile()) != null && physicalFile.getVirtualFile() != null && !((PsiManagerEx)PsiManager.getInstance(dummyHolder.getProject())).isAssertOnFileLoading(physicalFile.getVirtualFile())) {
        DebugUtil.trackInvalidation(physicalContext,"dummy holder was invalidated",new Processor<PsiElement>(){
          @Override public boolean process(          PsiElement element){
            DebugUtil.onInvalidated((TreeElement)dummyHolder.getNode());
            return true;
          }
        }
);
      }
    }
    DebugUtil.trackInvalidation(reference,"Reference inside PsiClassReferenceType was invalidated",new Processor<PsiElement>(){
      @Override public boolean process(      PsiElement element){
        PsiType cached=myCalculatedTypes.get(element);
        if (cached != null) {
          LOG.error(element + " (inside ref) is invalid and yet it is still cached: " + cached);
        }
        PsiType cachedRef=myCachedReferencesInPsiTypes.get(element);
        if (cachedRef != null) {
          LOG.error(element + " (inside ref) is invalid and yet it is still cached in ref cache: " + cachedRef);
        }
synchronized (myCachedReferenceIn_PsiClassReferenceType_To_ListOfReferencesOfThisType_CachedHere) {
          WeakList<PsiElement> refsTo=myCachedReferenceIn_PsiClassReferenceType_To_ListOfReferencesOfThisType_CachedHere.get(element);
          if (refsTo != null) {
            for (            PsiElement ref : refsTo) {
              PsiType cachedT=myCalculatedTypes.get(ref);
              if (cachedT != null && !cachedT.isValid()) {
                LOG.error("During invalidation of " + element + " ("+ element.getClass()+ ")"+ " cached type "+ cachedT+ " of the ref "+ ref+ " ("+ ref.getClass()+ ")"+ " became invalid and yet it is still cached");
              }
            }
          }
        }
        return true;
      }
    }
);
  }
  DebugUtil.trackInvalidation(expr,"Expression invalidated",new Processor<PsiElement>(){
    @Override public boolean process(    PsiElement element){
      PsiType cached=myCalculatedTypes.get(element);
      if (cached != null) {
        LOG.error(element + " is invalid and yet it is still cached: " + cached);
      }
      PsiType cachedRef=myCachedReferencesInPsiTypes.get(element);
      if (cachedRef != null) {
        LOG.error(element + " is invalid and yet it is still cached (inside PsiType): " + cachedRef);
      }
      return true;
    }
  }
);
}
