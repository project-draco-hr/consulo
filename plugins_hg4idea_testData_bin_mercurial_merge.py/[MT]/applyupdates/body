def applyupdates(repo, action, wctx, mctx):
    'apply the merge action list to the working directory'
    (updated, merged, removed, unresolved) = (0, 0, 0, 0)
    ms = mergestate(repo)
    ms.reset(wctx.parents()[0].node())
    moves = []
    action.sort(key=actionkey)
    substate = wctx.substate
    u = repo.ui
    for a in action:
        (f, m) = a[:2]
        if (m == 'm'):
            (f2, fd, flags, move) = a[2:]
            if (f == '.hgsubstate'):
                continue
            repo.ui.debug(('preserving %s for resolve of %s\n' % (f, fd)))
            fcl = wctx[f]
            fco = mctx[f2]
            fca = (fcl.ancestor(fco) or repo.filectx(f, fileid=nullrev))
            ms.add(fcl, fco, fca, fd, flags)
            if ((f != fd) and move):
                moves.append(f)
    for f in moves:
        if util.lexists(repo.wjoin(f)):
            repo.ui.debug(('removing %s\n' % f))
            os.unlink(repo.wjoin(f))
    audit_path = util.path_auditor(repo.root)
    numupdates = len(action)
    for (i, a) in enumerate(action):
        (f, m) = a[:2]
        u.progress('update', (i + 1), item=f, total=numupdates, unit='files')
        if (f and (f[0] == '/')):
            continue
        if (m == 'r'):
            repo.ui.note((_('removing %s\n') % f))
            audit_path(f)
            if (f == '.hgsubstate'):
                subrepo.submerge(repo, wctx, mctx, wctx)
            try:
                util.unlink(repo.wjoin(f))
            except OSError as inst:
                if (inst.errno != errno.ENOENT):
                    repo.ui.warn((_('update failed to remove %s: %s!\n') % (f, inst.strerror)))
            removed += 1
        elif (m == 'm'):
            if (f == '.hgsubstate'):
                subrepo.submerge(repo, wctx, mctx, wctx.ancestor(mctx))
                continue
            (f2, fd, flags, move) = a[2:]
            r = ms.resolve(fd, wctx, mctx)
            if ((r is not None) and (r > 0)):
                unresolved += 1
            elif (r is None):
                updated += 1
            else:
                merged += 1
            util.set_flags(repo.wjoin(fd), ('l' in flags), ('x' in flags))
            if ((f != fd) and move and util.lexists(repo.wjoin(f))):
                repo.ui.debug(('removing %s\n' % f))
                os.unlink(repo.wjoin(f))
        elif (m == 'g'):
            flags = a[2]
            repo.ui.note((_('getting %s\n') % f))
            t = mctx.filectx(f).data()
            repo.wwrite(f, t, flags)
            updated += 1
            if (f == '.hgsubstate'):
                subrepo.submerge(repo, wctx, mctx, wctx)
        elif (m == 'd'):
            (f2, fd, flags) = a[2:]
            if f:
                repo.ui.note((_('moving %s to %s\n') % (f, fd)))
                t = wctx.filectx(f).data()
                repo.wwrite(fd, t, flags)
                util.unlink(repo.wjoin(f))
            if f2:
                repo.ui.note((_('getting %s to %s\n') % (f2, fd)))
                t = mctx.filectx(f2).data()
                repo.wwrite(fd, t, flags)
            updated += 1
        elif (m == 'dr'):
            fl = a[2]
            repo.ui.warn((_('warning: detected divergent renames of %s to:\n') % f))
            for nf in fl:
                repo.ui.warn((' %s\n' % nf))
        elif (m == 'e'):
            flags = a[2]
            util.set_flags(repo.wjoin(f), ('l' in flags), ('x' in flags))
    u.progress('update', None, total=numupdates, unit='files')
    return (updated, merged, removed, unresolved)
