def manifestmerge(repo, p1, p2, pa, overwrite, partial):
    '\n    Merge p1 and p2 with ancestor ma and generate merge action list\n\n    overwrite = whether we clobber working files\n    partial = function to filter file lists\n    '

    def fmerge(f, f2, fa):
        'merge flags'
        (a, m, n) = (ma.flags(fa), m1.flags(f), m2.flags(f2))
        if (m == n):
            return m
        if (m and n and (not a)):
            r = repo.ui.promptchoice((_(' conflicting flags for %s\n(n)one, e(x)ec or sym(l)ink?') % f), (_('&None'), _('E&xec'), _('Sym&link')), 0)
            if (r == 1):
                return 'x'
            if (r == 2):
                return 'l'
            return ''
        if (m and (m != a)):
            return m
        if (n and (n != a)):
            return n
        return ''

    def act(msg, m, f, *args):
        repo.ui.debug((' %s: %s -> %s\n' % (f, msg, m)))
        action.append(((f, m) + args))
    (action, copy) = ([], {})
    if overwrite:
        pa = p1
    elif (pa == p2):
        pa = p1.p1()
    elif (pa and repo.ui.configbool('merge', 'followcopies', True)):
        dirs = repo.ui.configbool('merge', 'followdirs', True)
        (copy, diverge) = copies.copies(repo, p1, p2, pa, dirs)
        for (of, fl) in diverge.iteritems():
            act('divergent renames', 'dr', of, fl)
    repo.ui.note(_('resolving manifests\n'))
    repo.ui.debug((' overwrite %s partial %s\n' % (overwrite, bool(partial))))
    repo.ui.debug((' ancestor %s local %s remote %s\n' % (pa, p1, p2)))
    (m1, m2, ma) = (p1.manifest(), p2.manifest(), pa.manifest())
    copied = set(copy.values())
    if ((not overwrite) and ('.hgsubstate' in m1)):
        for s in p1.substate:
            if p1.sub(s).dirty():
                m1['.hgsubstate'] += '+'
                break
    for (f, n) in m1.iteritems():
        if (partial and (not partial(f))):
            continue
        if (f in m2):
            rflags = fmerge(f, f, f)
            a = ma.get(f, nullid)
            if ((n == m2[f]) or (m2[f] == a)):
                if (m1.flags(f) != rflags):
                    act('update permissions', 'e', f, rflags)
            elif (n == a):
                act('remote is newer', 'g', f, rflags)
            else:
                act('versions differ', 'm', f, f, f, rflags, False)
        elif (f in copied):
            pass
        elif (f in copy):
            f2 = copy[f]
            if (f2 not in m2):
                act(('remote renamed directory to ' + f2), 'd', f, None, f2, m1.flags(f))
            else:
                act(('local copied/moved to ' + f2), 'm', f, f2, f, fmerge(f, f2, f2), False)
        elif (f in ma):
            if (n != ma[f]):
                if repo.ui.promptchoice((_(' local changed %s which remote deleted\nuse (c)hanged version or (d)elete?') % f), (_('&Changed'), _('&Delete')), 0):
                    act('prompt delete', 'r', f)
                else:
                    act('prompt keep', 'a', f)
            elif (n[20:] == 'a'):
                act('remote deleted', 'f', f)
            elif (n[20:] != 'u'):
                act('other deleted', 'r', f)
    for (f, n) in m2.iteritems():
        if (partial and (not partial(f))):
            continue
        if ((f in m1) or (f in copied)):
            continue
        if (f in copy):
            f2 = copy[f]
            if (f2 not in m1):
                act(('local renamed directory to ' + f2), 'd', None, f, f2, m2.flags(f))
            elif (f2 in m2):
                act(('remote copied to ' + f), 'm', f2, f, f, fmerge(f2, f, f2), False)
            else:
                act(('remote moved to ' + f), 'm', f2, f, f, fmerge(f2, f, f2), True)
        elif (f not in ma):
            act('remote created', 'g', f, m2.flags(f))
        elif (n != ma[f]):
            if (repo.ui.promptchoice((_('remote changed %s which local deleted\nuse (c)hanged version or leave (d)eleted?') % f), (_('&Changed'), _('&Deleted')), 0) == 0):
                act('prompt recreating', 'g', f, m2.flags(f))
    return action
