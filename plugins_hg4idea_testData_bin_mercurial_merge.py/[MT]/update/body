def update(repo, node, branchmerge, force, partial):
    "\n    Perform a merge between the working directory and the given node\n\n    node = the node to update to, or None if unspecified\n    branchmerge = whether to merge between branches\n    force = whether to force branch merging or file overwriting\n    partial = a function to filter file lists (dirstate not updated)\n\n    The table below shows all the behaviors of the update command\n    given the -c and -C or no options, whether the working directory\n    is dirty, whether a revision is specified, and the relationship of\n    the parent rev to the target rev (linear, on the same named\n    branch, or on another named branch).\n\n    This logic is tested by test-update-branches.\n\n    -c  -C  dirty  rev  |  linear   same  cross\n     n   n    n     n   |    ok     (1)     x\n     n   n    n     y   |    ok     ok     ok\n     n   n    y     *   |   merge   (2)    (2)\n     n   y    *     *   |    ---  discard  ---\n     y   n    y     *   |    ---    (3)    ---\n     y   n    n     *   |    ---    ok     ---\n     y   y    *     *   |    ---    (4)    ---\n\n    x = can't happen\n    * = don't-care\n    1 = abort: crosses branches (use 'hg merge' or 'hg update -c')\n    2 = abort: crosses branches (use 'hg merge' to merge or\n                 use 'hg update -C' to discard changes)\n    3 = abort: uncommitted local changes\n    4 = incompatible options (checked in commands.py)\n    "
    onode = node
    wlock = repo.wlock()
    try:
        wc = repo[None]
        if (node is None):
            try:
                node = repo.branchtags()[wc.branch()]
            except KeyError:
                if (wc.branch() == 'default'):
                    node = repo.lookup('tip')
                else:
                    raise util.Abort((_('branch %s not found') % wc.branch()))
        overwrite = (force and (not branchmerge))
        pl = wc.parents()
        (p1, p2) = (pl[0], repo[node])
        pa = p1.ancestor(p2)
        (fp1, fp2, xp1, xp2) = (p1.node(), p2.node(), str(p1), str(p2))
        fastforward = False
        if ((not overwrite) and (len(pl) > 1)):
            raise util.Abort(_('outstanding uncommitted merges'))
        if branchmerge:
            if (pa == p2):
                raise util.Abort(_("can't merge with ancestor"))
            elif (pa == p1):
                if (p1.branch() != p2.branch()):
                    fastforward = True
                else:
                    raise util.Abort(_("nothing to merge (use 'hg update' or check 'hg heads')"))
            if ((not force) and (wc.files() or wc.deleted())):
                raise util.Abort(_("outstanding uncommitted changes (use 'hg status' to list changes)"))
        elif (not overwrite):
            if ((pa == p1) or (pa == p2)):
                pass
            elif (wc.files() or wc.deleted()):
                raise util.Abort(_("crosses branches (use 'hg merge' to merge or use 'hg update -C' to discard changes)"))
            elif (onode is None):
                raise util.Abort(_("crosses branches (use 'hg merge' or use 'hg update -c')"))
            else:
                overwrite = True
        action = []
        if (not force):
            _checkunknown(wc, p2)
        if (not util.checkcase(repo.path)):
            _checkcollision(p2)
        action += _forgetremoved(wc, p2, branchmerge)
        action += manifestmerge(repo, wc, p2, pa, overwrite, partial)
        if (not branchmerge):
            (fp1, fp2, xp1, xp2) = (fp2, nullid, xp2, '')
        if (not partial):
            repo.hook('preupdate', throw=True, parent1=xp1, parent2=xp2)
        stats = applyupdates(repo, action, wc, p2)
        if (not partial):
            recordupdates(repo, action, branchmerge)
            repo.dirstate.setparents(fp1, fp2)
            if ((not branchmerge) and (not fastforward)):
                repo.dirstate.setbranch(p2.branch())
    finally:
        wlock.release()
    if (not partial):
        repo.hook('update', parent1=xp1, parent2=xp2, error=stats[3])
    return stats
