{
  final ArrayList<ExpectedTypeInfo[]> expectedTypesFromAll=new ArrayList<ExpectedTypeInfo[]>();
  for (int i=0; i < myOccurences.length; i++) {
    final ExpectedTypeInfo[] expectedTypes=myExpectedTypesProvider.getExpectedTypes(myOccurences[i],false,myOccurrenceClassProvider);
    if (expectedTypes.length > 0) {
      expectedTypesFromAll.add(expectedTypes);
    }
  }
  final ArrayList<PsiType> allowedTypes=new ArrayList<PsiType>();
  RefactoringHierarchyUtil.processSuperTypes(myDefaultType,new RefactoringHierarchyUtil.SuperTypeVisitor(){
    public void visitType(    PsiType aType){
      checkIfAllowed(aType);
    }
    public void visitClass(    PsiClass aClass){
      checkIfAllowed(myFactory.createType(aClass));
    }
    private void checkIfAllowed(    PsiType type){
      final ExpectedTypeInfo typeInfo=myExpectedTypesProvider.createInfo(type,ExpectedTypeInfo.TYPE_STRICTLY,type,TailType.NONE);
      for (Iterator<ExpectedTypeInfo[]> iterator=expectedTypesFromAll.iterator(); iterator.hasNext(); ) {
        ExpectedTypeInfo[] expectedTypes=iterator.next();
        boolean validFound=false;
        for (int i=0; i < expectedTypes.length; i++) {
          ExpectedTypeInfo expectedType=expectedTypes[i];
          if (expectedType.intersect(typeInfo).length != 0) {
            validFound=true;
            break;
          }
        }
        if (!validFound)         return;
      }
      allowedTypes.add(type);
    }
  }
);
  final ArrayList<PsiType> result=normalizeTypeList(allowedTypes);
  return result.toArray(new PsiType[result.size()]);
}
