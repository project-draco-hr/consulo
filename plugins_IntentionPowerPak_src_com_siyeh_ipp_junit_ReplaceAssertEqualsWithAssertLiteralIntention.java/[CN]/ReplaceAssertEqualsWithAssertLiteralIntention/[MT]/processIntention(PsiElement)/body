{
  final PsiMethodCallExpression call=(PsiMethodCallExpression)element;
  final PsiReferenceExpression expression=call.getMethodExpression();
  final PsiExpressionList argumentList=call.getArgumentList();
  final PsiExpression[] args=argumentList.getExpressions();
  final String assertString;
  final String actualArgumentText;
  if (args.length == 2) {
    @NonNls final String argText=args[0].getText();
    final PsiExpression otherArg;
    if ("true".equals(argText) || "false".equals(argText) || "null".equals(argText)) {
      otherArg=args[1];
    }
 else {
      otherArg=args[0];
    }
    actualArgumentText=otherArg.getText();
    assertString=getAssertString(argText);
  }
 else {
    @NonNls final String argText=args[1].getText();
    final PsiExpression otherArg;
    if ("true".equals(argText) || "false".equals(argText) || "null".equals(argText)) {
      otherArg=args[2];
    }
 else {
      otherArg=args[1];
    }
    actualArgumentText=args[0].getText() + ", " + otherArg.getText();
    assertString=getAssertString(argText);
  }
  final PsiElement qualifier=expression.getQualifier();
  @NonNls final StringBuilder newExpression=new StringBuilder();
  if (qualifier == null) {
    final PsiMethod containingMethod=PsiTreeUtil.getParentOfType(call,PsiMethod.class);
    if (containingMethod != null && AnnotationUtil.isAnnotated(containingMethod,"org.junit.Test",true)) {
      if (!ImportUtils.addStaticImport("org.junit.Assert",assertString,element)) {
        newExpression.append("org.junit.Assert.");
      }
    }
  }
 else {
    newExpression.append(qualifier.getText()).append('.');
  }
  newExpression.append(assertString).append('(').append(actualArgumentText).append(')');
  replaceExpression(newExpression.toString(),call);
}
