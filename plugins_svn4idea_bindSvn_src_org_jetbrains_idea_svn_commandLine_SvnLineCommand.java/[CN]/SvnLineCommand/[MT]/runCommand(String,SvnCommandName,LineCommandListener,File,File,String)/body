{
  final SvnLineCommand command=new SvnLineCommand(base,commandName,exePath,configDir){
    int myErrCnt=0;
    @Override protected void onTextAvailable(    String text,    Key outputType){
      if (ProcessOutputTypes.STDERR.equals(outputType)) {
        ++myErrCnt;
        if (text.trim().startsWith(PASSPHRASE_FOR) || myErrCnt >= 2) {
          destroyProcess();
        }
      }
      super.onTextAvailable(text,outputType);
    }
  }
;
  command.addParameters(parameters);
  final AtomicReference<Throwable> exceptionRef=new AtomicReference<Throwable>();
  command.addListener(new LineProcessEventListener(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (SvnCommand.LOG.isDebugEnabled()) {
        SvnCommand.LOG.debug("==> " + line);
      }
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        System.out.println("==> " + line);
      }
      listener.onLineAvailable(line,outputType);
      if (listener.isCanceled()) {
        command.destroyProcess();
        return;
      }
      if (ProcessOutputTypes.STDERR.equals(outputType)) {
        if (command.myErr.length() > 0) {
          command.myErr.append('\n');
        }
        command.myErr.append(line);
      }
    }
    @Override public void processTerminated(    int exitCode){
      listener.processTerminated(exitCode);
      command.myExitCode.set(exitCode);
    }
    @Override public void startFailed(    Throwable exception){
      listener.startFailed(exception);
      exceptionRef.set(exception);
    }
  }
);
  command.start();
  command.waitFor();
  if (exceptionRef.get() != null) {
    throw new SvnBindException(exceptionRef.get());
  }
  return command;
}
