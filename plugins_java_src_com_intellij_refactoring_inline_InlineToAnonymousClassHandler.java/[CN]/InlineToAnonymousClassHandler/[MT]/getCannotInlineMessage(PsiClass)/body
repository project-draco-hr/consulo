{
  if (psiClass.isAnnotationType()) {
    return "Annotation types cannot be inlined";
  }
  if (psiClass.isInterface()) {
    return "Interfaces cannot be inlined";
  }
  if (psiClass.isEnum()) {
    return "Enums cannot be inlined";
  }
  if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
    return RefactoringBundle.message("inline.to.anonymous.no.abstract");
  }
  if (!psiClass.getManager().isInProject(psiClass)) {
    return "Library classes cannot be inlined";
  }
  PsiClassType[] classTypes=psiClass.getExtendsListTypes();
  for (  PsiClassType classType : classTypes) {
    PsiClass superClass=classType.resolve();
    if (superClass == null) {
      return "Class cannot be inlined because its superclass cannot be resolved";
    }
  }
  final PsiClassType[] interfaces=psiClass.getImplementsListTypes();
  if (interfaces.length > 1) {
    return RefactoringBundle.message("inline.to.anonymous.no.multiple.interfaces");
  }
  if (interfaces.length == 1) {
    if (interfaces[0].resolve() == null) {
      return "Class cannot be inlined because an interface implemented by it cannot be resolved";
    }
    final PsiClass superClass=psiClass.getSuperClass();
    if (superClass != null && !CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) {
      PsiClassType interfaceType=interfaces[0];
      if (!isRedundantImplements(superClass,interfaceType)) {
        return RefactoringBundle.message("inline.to.anonymous.no.superclass.and.interface");
      }
    }
  }
  final PsiMethod[] methods=psiClass.getMethods();
  for (  PsiMethod method : methods) {
    if (method.isConstructor()) {
      PsiReturnStatement stmt=findReturnStatement(method);
      if (stmt != null) {
        return "Class cannot be inlined because its constructor contains 'return' statements";
      }
    }
 else     if (method.findSuperMethods().length == 0) {
      if (!ReferencesSearch.search(method).forEach(new AllowedUsagesProcessor(psiClass))) {
        return "Class cannot be inlined because it has usages of methods not inherited from its superclass or interface";
      }
    }
    if (method.hasModifierProperty(PsiModifier.STATIC)) {
      return "Class cannot be inlined because it has static methods";
    }
  }
  final PsiClass[] innerClasses=psiClass.getInnerClasses();
  for (  PsiClass innerClass : innerClasses) {
    PsiModifierList classModifiers=innerClass.getModifierList();
    if (classModifiers.hasModifierProperty(PsiModifier.STATIC)) {
      return "Class cannot be inlined because it has static inner classes";
    }
    if (!ReferencesSearch.search(innerClass).forEach(new AllowedUsagesProcessor(psiClass))) {
      return "Class cannot be inlined because it has usages of its inner classes";
    }
  }
  final PsiField[] fields=psiClass.getFields();
  for (  PsiField field : fields) {
    final PsiModifierList fieldModifiers=field.getModifierList();
    if (fieldModifiers != null && fieldModifiers.hasModifierProperty(PsiModifier.STATIC)) {
      if (!fieldModifiers.hasModifierProperty(PsiModifier.FINAL)) {
        return "Class cannot be inlined because it has static non-final fields";
      }
      Object initValue=null;
      final PsiExpression initializer=field.getInitializer();
      if (initializer != null) {
        initValue=JavaPsiFacade.getInstance(psiClass.getProject()).getConstantEvaluationHelper().computeConstantExpression(initializer);
      }
      if (initValue == null) {
        return "Class cannot be inlined because it has static fields with non-constant initializers";
      }
    }
    if (!ReferencesSearch.search(field).forEach(new AllowedUsagesProcessor(psiClass))) {
      return "Class cannot be inlined because it has usages of fields not inherited from its superclass";
    }
  }
  final PsiClassInitializer[] initializers=psiClass.getInitializers();
  for (  PsiClassInitializer initializer : initializers) {
    final PsiModifierList modifiers=initializer.getModifierList();
    if (modifiers != null && modifiers.hasModifierProperty(PsiModifier.STATIC)) {
      return "Class cannot be inlined because it has static initializers";
    }
  }
  return getCannotInlineDueToUsagesMessage(psiClass);
}
