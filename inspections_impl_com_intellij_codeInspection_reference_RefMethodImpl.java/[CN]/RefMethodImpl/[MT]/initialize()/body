{
  myDerivedMethods=new ArrayList<RefMethod>(0);
  final PsiMethod method=(PsiMethod)getElement();
  setConstructor(method.isConstructor());
  setFlag(method.getReturnType() == null || PsiType.VOID == method.getReturnType(),IS_RETURN_VALUE_USED_MASK);
  if (!isReturnValueUsed()) {
    myReturnValueTemplate=RETURN_VALUE_UNDEFINED;
  }
  if (isConstructor()) {
    addReference(getOwnerClass(),getOwnerClass().getElement(),method,false,true,null);
  }
  if (getOwnerClass().isInterface()) {
    setAbstract(false);
  }
 else {
    setAbstract(method.hasModifierProperty(PsiModifier.ABSTRACT));
  }
  setAppMain(isAppMain(method,this));
  setLibraryOverride(method.hasModifierProperty(PsiModifier.NATIVE));
  mySuperMethods=new ArrayList<RefMethod>(0);
  initializeSuperMethods(method);
  if (isExternalOverride()) {
    ((RefClassImpl)getOwnerClass()).addLibraryOverrideMethod(this);
  }
  @NonNls final String name=method.getName();
  if (getOwnerClass().isTestCase() && name.startsWith("test")) {
    setTestMethod(true);
  }
  PsiParameter[] paramList=method.getParameterList().getParameters();
  myParameters=new RefParameterImpl[paramList.length];
  for (int i=0; i < paramList.length; i++) {
    PsiParameter parameter=paramList[i];
    myParameters[i]=getRefManager().getParameterReference(parameter,i);
  }
  if (method.hasModifierProperty(PsiModifier.NATIVE)) {
    updateReturnValueTemplate(null);
    updateThrowsList(null);
  }
  collectUncaughtExceptions(method);
  ((RefManagerImpl)getRefManager()).fireNodeInitialized(this);
}
