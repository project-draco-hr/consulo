{
  final Project project=method.getProject();
  if (method.isConstructor()) {
    String message=GroovyRefactoringBundle.message("refactoring.cannot.be.applied.to.constructors",REFACTORING_NAME);
    showErrorMessage(message,project,editor);
    return null;
  }
  if (invokedOnReference) {
    PsiReference reference=editor != null ? TargetElementUtil.findReference(editor,editor.getCaretModel().getOffset()) : null;
    if (reference == null)     return null;
    PsiElement element=reference.getElement();
    if (element.getContainingFile() instanceof GroovyFile) {
      if (!(isStaticMethod(method) || areInSameClass(element,method))) {
      }
    }
    if (!(element instanceof GrExpression && element.getParent() instanceof GrCallExpression)) {
      String message=GroovyRefactoringBundle.message("refactoring.is.available.only.for.method.calls",REFACTORING_NAME);
      showErrorMessage(message,project,editor);
      return null;
    }
    GrCallExpression call=(GrCallExpression)element.getParent();
    if (PsiTreeUtil.getParentOfType(element,GrParameter.class) != null) {
      String message=GroovyRefactoringBundle.message("refactoring.is.not.supported.in.parameter.initializers",REFACTORING_NAME);
      showErrorMessage(message,project,editor);
      return null;
    }
    GroovyRefactoringUtil.highlightOccurrences(project,editor,new GrExpression[]{call});
    if (hasBadReturns(method) && !isTailMethodCall(call)) {
      String message=GroovyRefactoringBundle.message("refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow",REFACTORING_NAME);
      showErrorMessage(message,project,editor);
      return null;
    }
  }
  if (method.getBlock() == null) {
    String message;
    if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {
      message=GroovyRefactoringBundle.message("refactoring.cannot.be.applied.to.abstract.methods",REFACTORING_NAME);
    }
 else {
      message=GroovyRefactoringBundle.message("refactoring.cannot.be.applied.no.sources.attached",REFACTORING_NAME);
    }
    showErrorMessage(message,project,editor);
    return null;
  }
  return inlineMethodDialogResult(method,project,invokedOnReference);
}
