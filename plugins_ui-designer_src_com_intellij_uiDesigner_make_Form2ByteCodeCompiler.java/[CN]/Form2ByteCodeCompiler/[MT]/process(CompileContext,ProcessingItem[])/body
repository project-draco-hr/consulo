{
  final ArrayList<ProcessingItem> compiledItems=new ArrayList<ProcessingItem>();
  context.getProgressIndicator().pushState();
  context.getProgressIndicator().setText(UIDesignerBundle.message("progress.compiling.ui.forms"));
  final Project project=context.getProject();
  final HashMap<Module,ArrayList<MyInstrumentationItem>> module2itemsList=sortByModules(project,items);
  List<File> filesToRefresh=new ArrayList<File>();
  for (  final Module module : module2itemsList.keySet()) {
    final String classPath=OrderEnumerator.orderEntries(module).recursively().getPathsList().getPathsString();
    final InstrumentationClassFinder finder=createClassFinder(classPath);
    try {
      if (GuiDesignerConfiguration.getInstance(project).COPY_FORMS_RUNTIME_TO_OUTPUT) {
        final String moduleOutputPath=CompilerPaths.getModuleOutputPath(module,false);
        try {
          if (moduleOutputPath != null) {
            filesToRefresh.addAll(CopyResourcesUtil.copyFormsRuntime(moduleOutputPath,false));
          }
          final String testsOutputPath=CompilerPaths.getModuleOutputPath(module,true);
          if (testsOutputPath != null && !testsOutputPath.equals(moduleOutputPath)) {
            filesToRefresh.addAll(CopyResourcesUtil.copyFormsRuntime(testsOutputPath,false));
          }
        }
 catch (        IOException e) {
          addMessage(context,UIDesignerBundle.message("error.cannot.copy.gui.designer.form.runtime",module.getName(),ExceptionUtil.getThrowableText(e)),null,CompilerMessageCategory.ERROR);
        }
      }
      final ArrayList<MyInstrumentationItem> list=module2itemsList.get(module);
      for (      final MyInstrumentationItem item : list) {
        final VirtualFile formFile=item.getFormFile();
        context.getProgressIndicator().setText2(formFile.getPresentableUrl());
        final String text=ApplicationManager.getApplication().runReadAction(new Computable<String>(){
          @Override public String compute(){
            if (!belongsToCompileScope(context,formFile,item.getClassToBindFQname())) {
              return null;
            }
            Document document=FileDocumentManager.getInstance().getDocument(formFile);
            return document == null ? null : document.getText();
          }
        }
);
        if (text == null) {
          continue;
        }
        final LwRootContainer rootContainer;
        try {
          rootContainer=Utils.getRootContainer(text,new CompiledClassPropertiesProvider(finder.getLoader()));
        }
 catch (        Exception e) {
          addMessage(context,UIDesignerBundle.message("error.cannot.process.form.file",ExceptionUtil.getThrowableText(e)),formFile,CompilerMessageCategory.ERROR);
          continue;
        }
        final File classFile=VfsUtil.virtualToIoFile(item.getFile());
        LOG.assertTrue(classFile.exists(),classFile.getPath());
        final AsmCodeGenerator codeGenerator=new AsmCodeGenerator(rootContainer,finder,new PsiNestedFormLoader(module),false,new PsiClassWriter(module));
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          @Override public void run(){
            codeGenerator.patchFile(classFile);
          }
        }
);
        final FormErrorInfo[] errors=codeGenerator.getErrors();
        final FormErrorInfo[] warnings=codeGenerator.getWarnings();
        for (        FormErrorInfo warning : warnings) {
          addMessage(context,warning,formFile,CompilerMessageCategory.WARNING);
        }
        for (        FormErrorInfo error : errors) {
          addMessage(context,error,formFile,CompilerMessageCategory.ERROR);
        }
        if (errors.length == 0) {
          compiledItems.add(item);
        }
      }
    }
  finally {
      finder.releaseResources();
    }
  }
  CompilerUtil.refreshIOFiles(filesToRefresh);
  context.getProgressIndicator().popState();
  return compiledItems.toArray(new ProcessingItem[compiledItems.size()]);
}
