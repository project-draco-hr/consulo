{
  final List<PsiClass> localClasses=new ArrayList<PsiClass>();
  container.accept(new PsiRecursiveElementVisitor(){
    public void visitClass(    final PsiClass aClass){
      localClasses.add(aClass);
    }
    public void visitAnonymousClass(    final PsiAnonymousClass aClass){
      visitElement(aClass);
    }
  }
);
  for (  PsiClass localClass : localClasses) {
    final boolean classExtracted=isExtractedElement(localClass);
    final List<PsiElement> extractedReferences=new ArrayList<PsiElement>();
    final List<PsiElement> remainingReferences=new ArrayList<PsiElement>();
    ReferencesSearch.search(localClass).forEach(new Processor<PsiReference>(){
      public boolean process(      final PsiReference psiReference){
        final PsiElement element=psiReference.getElement();
        final boolean elementExtracted=isExtractedElement(element);
        if (elementExtracted && !classExtracted) {
          extractedReferences.add(element);
          return false;
        }
        if (!elementExtracted && classExtracted) {
          remainingReferences.add(element);
          return false;
        }
        return true;
      }
    }
);
    if (!extractedReferences.isEmpty()) {
      throw new PrepareFailedException("Cannot extract method because the selected code fragment uses local classes defined outside of the fragment",extractedReferences.get(0));
    }
    if (!remainingReferences.isEmpty()) {
      throw new PrepareFailedException("Cannot extract method because the selected code fragment defines local classes used outside of the fragment",remainingReferences.get(0));
    }
  }
}
