{
  List<PsiElement> elements=new ArrayList<PsiElement>();
  for (  PsiElement element : myElements) {
    if (!(element instanceof PsiWhiteSpace || element instanceof PsiComment)) {
      elements.add(element);
    }
  }
  if (myExpression != null) {
    myDuplicatesFinder=new DuplicatesFinder(elements.toArray(new PsiElement[elements.size()]),myInputVariables.copy(),new ArrayList<PsiVariable>());
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
 else   if (elements.size() > 0) {
    myDuplicatesFinder=new DuplicatesFinder(elements.toArray(new PsiElement[elements.size()]),myInputVariables.copy(),myOutputVariable != null ? new VariableReturnValue(myOutputVariable) : null,Arrays.asList(myOutputVariables));
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
 else {
    myDuplicates=new ArrayList<Match>();
  }
  chooseAnchor();
  int col=myEditor.getCaretModel().getLogicalPosition().column;
  int line=myEditor.getCaretModel().getLogicalPosition().line;
  LogicalPosition pos=new LogicalPosition(0,0);
  myEditor.getCaretModel().moveToLogicalPosition(pos);
  SearchScope processConflictsScope=myMethodVisibility.equals(PsiModifier.PRIVATE) ? new LocalSearchScope(myTargetClass) : GlobalSearchScope.projectScope(myProject);
  final Map<PsiMethodCallExpression,PsiMethod> overloadsResolveMap=ExtractMethodUtil.encodeOverloadTargets(myTargetClass,processConflictsScope,myMethodName,myCodeFragmentMember);
  doExtract();
  ExtractMethodUtil.decodeOverloadTargets(overloadsResolveMap,myExtractedMethod,myCodeFragmentMember);
  LogicalPosition pos1=new LogicalPosition(line,col);
  myEditor.getCaretModel().moveToLogicalPosition(pos1);
  int offset=myMethodCall.getMethodExpression().getTextRange().getStartOffset();
  myEditor.getCaretModel().moveToOffset(offset);
  myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);
  myEditor.getSelectionModel().removeSelection();
  myEditor.getSelectionModel().removeSelection();
}
