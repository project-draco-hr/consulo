{
  myExpression=null;
  if (myElements.length == 1 && myElements[0] instanceof PsiExpression) {
    final PsiExpression expression=(PsiExpression)myElements[0];
    if (expression.getParent() instanceof PsiExpressionStatement) {
      myElements[0]=expression.getParent();
    }
 else {
      myExpression=expression;
    }
  }
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(myElements[0]);
  myCodeFragmentMember=codeFragment.getUserData(ElementToWorkOn.PARENT);
  if (myCodeFragmentMember == null) {
    myCodeFragmentMember=codeFragment.getParent();
  }
  if (myCodeFragmentMember == null) {
    myCodeFragmentMember=ControlFlowUtil.findCodeFragment(codeFragment.getContext()).getParent();
  }
  myControlFlowWrapper=new ControlFlowWrapper(myProject,codeFragment,myElements);
  try {
    myExitStatements=myControlFlowWrapper.prepareExitStatements(myElements);
    if (myControlFlowWrapper.isGenerateConditionalExit()) {
      myGenerateConditionalExit=true;
    }
 else {
      myHasReturnStatement=myExpression == null && myControlFlowWrapper.isReturnPresentBetween();
    }
    myFirstExitStatementCopy=myControlFlowWrapper.getFirstExitStatementCopy();
  }
 catch (  ControlFlowWrapper.ExitStatementsNotSameException e) {
    myExitStatements=myControlFlowWrapper.getExitStatements();
    showMultipleExitPointsMessage();
    return false;
  }
  myOutputVariables=myControlFlowWrapper.getOutputVariables();
  final List<PsiVariable> inputVariables=myControlFlowWrapper.getInputVariables(codeFragment);
  chooseTargetClass(inputVariables);
  myInputVariables=new InputVariables(inputVariables,myProject,new LocalSearchScope(myElements),true);
  PsiType expressionType=null;
  if (myExpression != null) {
    if (myForcedReturnType != null) {
      expressionType=myForcedReturnType;
    }
 else {
      expressionType=RefactoringUtil.getTypeByExpressionWithExpectedType(myExpression);
    }
  }
  if (expressionType == null) {
    expressionType=PsiType.VOID;
  }
  myHasExpressionOutput=expressionType != PsiType.VOID;
  PsiType returnStatementType=null;
  if (myHasReturnStatement) {
    returnStatementType=myCodeFragmentMember instanceof PsiMethod ? ((PsiMethod)myCodeFragmentMember).getReturnType() : null;
  }
  myHasReturnStatementOutput=returnStatementType != null && returnStatementType != PsiType.VOID;
  if (myGenerateConditionalExit && myOutputVariables.length == 1) {
    if (!(myOutputVariables[0].getType() instanceof PsiPrimitiveType)) {
      myNullConditionalCheck=true;
      for (      PsiStatement exitStatement : myExitStatements) {
        if (exitStatement instanceof PsiReturnStatement) {
          final PsiExpression returnValue=((PsiReturnStatement)exitStatement).getReturnValue();
          myNullConditionalCheck&=returnValue == null || returnValue instanceof PsiLiteralExpression && PsiType.NULL.equals(returnValue.getType());
        }
      }
      myNullConditionalCheck&=isNotNull(myOutputVariables[0]);
    }
  }
  if (!myHasReturnStatementOutput && checkOutputVariablesCount() && !myNullConditionalCheck) {
    showMultipleOutputMessage(expressionType);
    return false;
  }
  myOutputVariable=myOutputVariables.length > 0 ? myOutputVariables[0] : null;
  if (myHasReturnStatementOutput) {
    myReturnType=returnStatementType;
  }
 else   if (myOutputVariable != null) {
    myReturnType=myOutputVariable.getType();
  }
 else   if (myGenerateConditionalExit) {
    myReturnType=PsiType.BOOLEAN;
  }
 else {
    myReturnType=expressionType;
  }
  PsiElement container=PsiTreeUtil.getParentOfType(myElements[0],PsiClass.class,PsiMethod.class);
  if (container instanceof PsiMethod) {
    PsiElement[] elements=myElements;
    if (myExpression == null) {
      if (myOutputVariable != null) {
        elements=ArrayUtil.append(myElements,myOutputVariable,PsiElement.class);
      }
      if (myCodeFragmentMember != null) {
        elements=ArrayUtil.append(myElements,((PsiMethod)myCodeFragmentMember).getReturnTypeElement(),PsiElement.class);
      }
    }
    myTypeParameterList=RefactoringUtil.createTypeParameterListWithUsedTypeParameters(((PsiMethod)container).getTypeParameterList(),elements);
  }
  List<PsiClassType> exceptions=ExceptionUtil.getThrownCheckedExceptions(myElements);
  myThrownExceptions=exceptions.toArray(new PsiClassType[exceptions.size()]);
  myStatic=shouldBeStatic();
  if (myTargetClass.getContainingClass() == null || myTargetClass.hasModifierProperty(PsiModifier.STATIC)) {
    ElementNeedsThis needsThis=new ElementNeedsThis(myTargetClass);
    for (int i=0; i < myElements.length && !needsThis.usesMembers(); i++) {
      PsiElement element=myElements[i];
      element.accept(needsThis);
    }
    myCanBeStatic=!needsThis.usesMembers();
  }
 else {
    myCanBeStatic=false;
  }
  if (container instanceof PsiMethod) {
    checkLocalClasses((PsiMethod)container);
  }
  checkCanBeChainedConstructor();
  List<PsiElement> elements=new ArrayList<PsiElement>();
  for (  PsiElement element : myElements) {
    if (!(element instanceof PsiWhiteSpace || element instanceof PsiComment)) {
      elements.add(element);
    }
  }
  if (myExpression != null) {
    myDuplicatesFinder=new DuplicatesFinder(elements.toArray(new PsiElement[elements.size()]),myInputVariables.copy(),new ArrayList<PsiVariable>());
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
 else   if (elements.size() > 0) {
    myDuplicatesFinder=new DuplicatesFinder(elements.toArray(new PsiElement[elements.size()]),myInputVariables.copy(),myOutputVariable != null ? new VariableReturnValue(myOutputVariable) : null,Arrays.asList(myOutputVariables));
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
 else {
    myDuplicates=new ArrayList<Match>();
  }
  return true;
}
