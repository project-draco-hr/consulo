{
  myExpression=null;
  if (myElements.length == 1 && myElements[0] instanceof PsiExpression) {
    final PsiExpression expression=(PsiExpression)myElements[0];
    if (expression.getParent() instanceof PsiExpressionStatement) {
      myElements[0]=expression.getParent();
    }
 else {
      myExpression=expression;
    }
  }
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(myElements[0]);
  myCodeFragmentMember=codeFragment.getParent();
  try {
    myControlFlow=ControlFlowFactory.getInstance(myProject).getControlFlow(codeFragment,new LocalsControlFlowPolicy(codeFragment),false,false);
  }
 catch (  AnalysisCanceledException e) {
    throw new PrepareFailedException(RefactoringBundle.message("extract.method.control.flow.analysis.failed"),e.getErrorElement());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(myControlFlow.toString());
  }
  calculateFlowStartAndEnd();
  IntArrayList exitPoints=new IntArrayList();
  myExitStatements=new ArrayList<PsiStatement>();
  ControlFlowUtil.findExitPointsAndStatements(myControlFlow,myFlowStart,myFlowEnd,exitPoints,myExitStatements,ControlFlowUtil.DEFAULT_EXIT_STATEMENTS_CLASSES);
  if (LOG.isDebugEnabled()) {
    LOG.debug("exit points:");
    for (int i=0; i < exitPoints.size(); i++) {
      LOG.debug("  " + exitPoints.get(i));
    }
    LOG.debug("exit statements:");
    for (    PsiStatement exitStatement : myExitStatements) {
      LOG.debug("  " + exitStatement);
    }
  }
  if (exitPoints.isEmpty()) {
    exitPoints.add(myControlFlow.getEndOffset(myElements[myElements.length - 1]));
  }
  if (exitPoints.size() != 1) {
    if (!areExitStatementsTheSame()) {
      showMultipleExitPointsMessage();
      return false;
    }
    myGenerateConditionalExit=true;
  }
 else {
    myHasReturnStatement=myExpression == null && ControlFlowUtil.returnPresentBetween(myControlFlow,myFlowStart,myFlowEnd);
  }
  myOutputVariables=ControlFlowUtil.getOutputVariables(myControlFlow,myFlowStart,myFlowEnd,exitPoints.toArray());
  if (myGenerateConditionalExit) {
    final Set<PsiVariable> outputVariables=new HashSet<PsiVariable>(Arrays.asList(myOutputVariables));
    for (    PsiStatement statement : myExitStatements) {
      statement.accept(new PsiRecursiveElementVisitor(){
        public void visitReferenceExpression(        PsiReferenceExpression expression){
          super.visitReferenceExpression(expression);
          final PsiElement resolved=expression.resolve();
          if (resolved instanceof PsiVariable) {
            final PsiVariable variable=(PsiVariable)resolved;
            if (isWrittenInside(variable)) {
              outputVariables.add(variable);
            }
          }
        }
        private boolean isWrittenInside(        final PsiVariable variable){
          final List<Instruction> instructions=myControlFlow.getInstructions();
          for (int i=myFlowStart; i < myFlowEnd; i++) {
            Instruction instruction=instructions.get(i);
            if (instruction instanceof WriteVariableInstruction && variable.equals(((WriteVariableInstruction)instruction).variable))             return true;
          }
          return false;
        }
      }
);
    }
    myOutputVariables=outputVariables.toArray(new PsiVariable[outputVariables.size()]);
  }
  final PsiVariable[] inputVariables=ControlFlowUtil.getInputVariables(myControlFlow,myFlowStart,myFlowEnd);
  if (myGenerateConditionalExit) {
    List<PsiVariable> inputVariableList=new ArrayList<PsiVariable>(Arrays.asList(inputVariables));
    removeParametersUsedInExitsOnly(codeFragment,myExitStatements,myControlFlow,myFlowStart,myFlowEnd,inputVariableList);
    myInputVariables=inputVariableList.toArray(new PsiVariable[inputVariableList.size()]);
  }
 else {
    myInputVariables=inputVariables;
  }
  Arrays.sort(myInputVariables,new Comparator<PsiVariable>(){
    public int compare(    final PsiVariable v1,    final PsiVariable v2){
      if (v1.getType() instanceof PsiEllipsisType) {
        return 1;
      }
      if (v2.getType() instanceof PsiEllipsisType) {
        return -1;
      }
      return v1.getTextOffset() - v2.getTextOffset();
    }
  }
);
  chooseTargetClass();
  PsiType expressionType=null;
  if (myExpression != null) {
    if (myForcedReturnType != null) {
      expressionType=myForcedReturnType;
    }
 else {
      expressionType=RefactoringUtil.getTypeByExpressionWithExpectedType(myExpression);
    }
  }
  if (expressionType == null) {
    expressionType=PsiType.VOID;
  }
  myHasExpressionOutput=expressionType != PsiType.VOID;
  PsiType returnStatementType=null;
  if (myHasReturnStatement) {
    returnStatementType=myCodeFragmentMember instanceof PsiMethod ? ((PsiMethod)myCodeFragmentMember).getReturnType() : null;
  }
  myHasReturnStatementOutput=returnStatementType != null && returnStatementType != PsiType.VOID;
  if (!myHasReturnStatementOutput) {
    int outputCount=(myHasExpressionOutput ? 1 : 0) + (myGenerateConditionalExit ? 1 : 0) + myOutputVariables.length;
    if (outputCount > 1) {
      showMultipleOutputMessage(expressionType);
      return false;
    }
  }
  myOutputVariable=myOutputVariables.length > 0 ? myOutputVariables[0] : null;
  if (myHasReturnStatementOutput) {
    myReturnType=returnStatementType;
  }
 else   if (myOutputVariable != null) {
    myReturnType=myOutputVariable.getType();
  }
 else   if (myGenerateConditionalExit) {
    myReturnType=PsiType.BOOLEAN;
  }
 else {
    myReturnType=expressionType;
  }
  PsiElement container=PsiTreeUtil.getParentOfType(myElements[0],PsiClass.class,PsiMethod.class);
  if (container instanceof PsiMethod) {
    myTypeParameterList=((PsiMethod)container).getTypeParameterList();
  }
  myThrownExceptions=ExceptionUtil.getThrownCheckedExceptions(myElements);
  myStatic=shouldBeStatic();
  if (myTargetClass.getContainingClass() == null || myTargetClass.hasModifierProperty(PsiModifier.STATIC)) {
    ElementNeedsThis needsThis=new ElementNeedsThis(myTargetClass);
    for (int i=0; i < myElements.length && !needsThis.usesMembers(); i++) {
      PsiElement element=myElements[i];
      element.accept(needsThis);
    }
    myCanBeStatic=!needsThis.usesMembers();
  }
 else {
    myCanBeStatic=false;
  }
  if (myExpression != null) {
    myDuplicatesFinder=new DuplicatesFinder(myElements,Arrays.asList(myInputVariables),new ArrayList<PsiVariable>());
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
 else {
    myDuplicatesFinder=new DuplicatesFinder(myElements,Arrays.asList(myInputVariables),Arrays.asList(myOutputVariables));
    myDuplicates=myDuplicatesFinder.findDuplicates(myTargetClass);
  }
  return true;
}
