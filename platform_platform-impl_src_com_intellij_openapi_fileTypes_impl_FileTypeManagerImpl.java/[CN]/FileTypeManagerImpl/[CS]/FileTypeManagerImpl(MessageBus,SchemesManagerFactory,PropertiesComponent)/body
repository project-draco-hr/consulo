{
  int fileTypeChangedCounter=StringUtilRt.parseInt(propertiesComponent.getValue("fileTypeChangedCounter"),0);
  fileTypeChangedCount=new AtomicInteger(fileTypeChangedCounter);
  autoDetectedAttribute=new FileAttribute("AUTO_DETECTION_CACHE_ATTRIBUTE",fileTypeChangedCounter,true);
  myMessageBus=bus;
  mySchemesManager=schemesManagerFactory.createSchemesManager(FILE_SPEC,new BaseSchemeProcessor<AbstractFileType>(){
    @NotNull @Override public AbstractFileType readScheme(    @NotNull Element element,    boolean duringLoad){
      if (!duringLoad) {
        fireBeforeFileTypesChanged();
      }
      AbstractFileType type=(AbstractFileType)loadFileType(element,false);
      if (!duringLoad) {
        fireFileTypesChanged();
      }
      return type;
    }
    @NotNull @Override public State getState(    @NotNull AbstractFileType fileType){
      if (!shouldSave(fileType)) {
        return State.NON_PERSISTENT;
      }
      if (!myDefaultTypes.contains(fileType)) {
        return State.POSSIBLY_CHANGED;
      }
      return fileType.isModified() ? State.POSSIBLY_CHANGED : State.NON_PERSISTENT;
    }
    @Override public Element writeScheme(    @NotNull AbstractFileType fileType){
      Element root=new Element(ELEMENT_FILETYPE);
      root.setAttribute("binary",String.valueOf(fileType.isBinary()));
      if (!StringUtil.isEmpty(fileType.getDefaultExtension())) {
        root.setAttribute("default_extension",fileType.getDefaultExtension());
      }
      root.setAttribute(ATTRIBUTE_DESCRIPTION,fileType.getDescription());
      root.setAttribute(ATTRIBUTE_NAME,fileType.getName());
      fileType.writeExternal(root);
      Element map=new Element(AbstractFileType.ELEMENT_EXTENSION_MAP);
      writeExtensionsMap(map,fileType,false);
      if (!map.getChildren().isEmpty()) {
        root.addContent(map);
      }
      return root;
    }
    @Override public void onSchemeDeleted(    @NotNull final AbstractFileType scheme){
      GuiUtils.invokeLaterIfNeeded(new Runnable(){
        @Override public void run(){
          Application app=ApplicationManager.getApplication();
          app.runWriteAction(new Runnable(){
            @Override public void run(){
              fireBeforeFileTypesChanged();
            }
          }
);
          myPatternsTable.removeAllAssociations(scheme);
          app.runWriteAction(new Runnable(){
            @Override public void run(){
              fireFileTypesChanged();
            }
          }
);
        }
      }
,ModalityState.NON_MODAL);
    }
  }
,RoamingType.PER_USER);
  bus.connect().subscribe(VirtualFileManager.VFS_CHANGES,new BulkFileListener.Adapter(){
    @Override public void after(    @NotNull List<? extends VFileEvent> events){
      Collection<VirtualFile> files=ContainerUtil.map2Set(events,new Function<VFileEvent,VirtualFile>(){
        @Override public VirtualFile fun(        VFileEvent event){
          VirtualFile file=event instanceof VFileCreateEvent ? null : event.getFile();
          VirtualFile filtered=file != null && wasAutoDetectedBefore(file) && isDetectable(file) ? file : null;
          if (toLog()) {
            log("F: after() VFS event " + event + "; filtered file: "+ filtered+ " (file: "+ file+ "; wasAutoDetectedBefore(file): "+ (file == null ? null : wasAutoDetectedBefore(file))+ "; isDetectable(file): "+ (file == null ? null : isDetectable(file))+ "; file.getLength(): "+ (file == null ? null : file.getLength())+ "; file.isValid(): "+ (file == null ? null : file.isValid())+ "; file.is(VFileProperty.SPECIAL): "+ (file == null ? null : file.is(VFileProperty.SPECIAL))+ "; packedFlags.get(id): "+ (file instanceof VirtualFileWithId ? readableFlags(packedFlags.get(((VirtualFileWithId)file).getId())) : null)+ "; file.getFileSystem():"+ (file == null ? null : file.getFileSystem())+ ")");
          }
          return filtered;
        }
      }
);
      files.remove(null);
      if (toLog()) {
        log("F: after() VFS events: " + events + "; files: "+ files);
      }
      if (!files.isEmpty() && RE_DETECT_ASYNC) {
        if (toLog()) {
          log("F: after() queued to redetect: " + files);
        }
        if (filesToRedetect.addAll(files)) {
          awakeReDetectExecutor();
        }
      }
    }
  }
);
  myIgnoredPatterns.setIgnoreMasks(DEFAULT_IGNORED);
  initStandardFileTypes();
}
