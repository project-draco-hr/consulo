{
  final PsiElement element=node.getPsi();
  if (!(element instanceof PsiJavaFile)) {
    return FoldingDescriptor.EMPTY;
  }
  final PsiJavaFile file=(PsiJavaFile)element;
  final List<FoldingDescriptor> result=new ArrayList<FoldingDescriptor>();
  file.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitLiteralExpression(    PsiLiteralExpression expression){
      if (isI18nProperty(expression)) {
        final String msg=getI18nMessage(expression);
        final PsiElement parent=expression.getParent();
        if (!msg.equals(expression.getText()) && parent instanceof PsiExpressionList && ((PsiExpressionList)parent).getExpressions()[0] == expression) {
          final PsiExpressionList expressions=(PsiExpressionList)parent;
          final int count=I18nUtil.getPropertyValueParamsMaxCount(expression);
          final PsiExpression[] args=expressions.getExpressions();
          if (args.length == 1 + count && parent.getParent() instanceof PsiMethodCallExpression) {
            boolean ok=true;
            for (int i=1; i < count + 1; i++) {
              Object value=ConstantExpressionEvaluator.computeConstantExpression(args[i],false);
              if (value == null) {
                if (!(args[i] instanceof PsiReferenceExpression)) {
                  ok=false;
                  break;
                }
              }
            }
            if (ok) {
              result.add(new FoldingDescriptor(parent.getParent().getNode(),parent.getParent().getTextRange()));
              return;
            }
          }
        }
        result.add(new FoldingDescriptor(expression.getNode(),expression.getTextRange()));
      }
    }
  }
);
  return result.toArray(new FoldingDescriptor[result.size()]);
}
