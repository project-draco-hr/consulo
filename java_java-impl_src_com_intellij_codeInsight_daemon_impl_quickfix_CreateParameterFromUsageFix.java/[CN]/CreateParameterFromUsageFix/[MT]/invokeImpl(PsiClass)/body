{
  if (CreateFromUsageUtils.isValidReference(myReferenceExpression,true))   return;
  final Project project=myReferenceExpression.getProject();
  PsiType[] expectedTypes=CreateFromUsageUtils.guessType(myReferenceExpression,false);
  PsiType type=expectedTypes[0];
  String varName=myReferenceExpression.getReferenceName();
  PsiMethod method=PsiTreeUtil.getParentOfType(myReferenceExpression,PsiMethod.class);
  LOG.assertTrue(method != null);
  method=IntroduceParameterHandler.chooseEnclosingMethod(method);
  if (method == null)   return;
  method=SuperMethodWarningUtil.checkSuperMethod(method,RefactoringBundle.message("to.refactor"));
  if (method == null)   return;
  final List<ParameterInfoImpl> parameterInfos=new ArrayList<ParameterInfoImpl>(Arrays.asList(ParameterInfoImpl.fromMethod(method)));
  ParameterInfoImpl parameterInfo=new ParameterInfoImpl(-1,varName,type,PsiTypesUtil.getDefaultValueOfType(type),false);
  if (!method.isVarArgs()) {
    parameterInfos.add(parameterInfo);
  }
 else {
    parameterInfos.add(parameterInfos.size() - 1,parameterInfo);
  }
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    ParameterInfoImpl[] array=parameterInfos.toArray(new ParameterInfoImpl[parameterInfos.size()]);
    String modifier=PsiUtil.getAccessModifier(PsiUtil.getAccessLevel(method.getModifierList()));
    ChangeSignatureProcessor processor=new ChangeSignatureProcessor(project,method,false,modifier,method.getName(),method.getReturnType(),array);
    processor.run();
  }
 else {
    final PsiMethod finalMethod=method;
    ApplicationManager.getApplication().invokeLater(new Runnable(){
      @Override public void run(){
        if (project.isDisposed())         return;
        try {
          JavaChangeSignatureDialog dialog=new JavaChangeSignatureDialog(project,finalMethod,false,myReferenceExpression);
          dialog.setParameterInfos(parameterInfos);
          dialog.show();
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
      }
    }
);
  }
}
