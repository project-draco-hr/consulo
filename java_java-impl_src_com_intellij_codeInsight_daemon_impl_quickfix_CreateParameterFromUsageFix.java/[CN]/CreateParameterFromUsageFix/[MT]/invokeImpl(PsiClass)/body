{
  if (CreateFromUsageUtils.isValidReference(myReferenceExpression,true))   return;
  final Project project=myReferenceExpression.getProject();
  PsiType[] expectedTypes=CreateFromUsageUtils.guessType(myReferenceExpression,false);
  PsiType type=expectedTypes[0];
  String varName=myReferenceExpression.getReferenceName();
  PsiMethod method=PsiTreeUtil.getParentOfType(myReferenceExpression,PsiMethod.class);
  LOG.assertTrue(method != null);
  method=IntroduceParameterHandler.chooseEnclosingMethod(method);
  if (method == null)   return;
  method=SuperMethodWarningUtil.checkSuperMethod(method,RefactoringBundle.message("to.refactor"));
  if (method == null)   return;
  List<ParameterInfoImpl> parameterInfos=new ArrayList<ParameterInfoImpl>(Arrays.asList(ParameterInfoImpl.fromMethod(method)));
  ParameterInfoImpl parameterInfo=new ParameterInfoImpl(-1,varName,type,PsiTypesUtil.getDefaultValueOfType(type),false);
  if (!method.isVarArgs()) {
    parameterInfos.add(parameterInfo);
  }
 else {
    parameterInfos.add(parameterInfos.size() - 1,parameterInfo);
  }
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    ParameterInfoImpl[] array=parameterInfos.toArray(new ParameterInfoImpl[parameterInfos.size()]);
    @Modifier String modifier=PsiUtil.getAccessModifier(PsiUtil.getAccessLevel(method.getModifierList()));
    ChangeSignatureProcessor processor=new ChangeSignatureProcessor(project,method,false,modifier,method.getName(),method.getReturnType(),array);
    processor.run();
  }
 else {
    JavaChangeSignatureDialog dialog=new JavaChangeSignatureDialog(project,method,false,myReferenceExpression);
    dialog.setParameterInfos(parameterInfos);
    dialog.show();
  }
}
