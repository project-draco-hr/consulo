{
  final ProgressIndicator progress=ProgressManager.getInstance().getProgressIndicator();
  if (progress != null) {
    progress.setText(SvnBundle.message("progress.text.changes.collecting.changes"));
    progress.setText2(SvnBundle.message("progress.text2.changes.establishing.connection",url));
  }
  try {
    SVNLogClient logger=myVcs.createLogClient();
    final String author=settings.getUserFilter();
    final Date dateFrom=settings.getDateAfterFilter();
    final Long changeFrom=settings.getChangeAfterFilter();
    final Date dateTo=settings.getDateBeforeFilter();
    final Long changeTo=settings.getChangeBeforeFilter();
    final SVNRevision revisionBefore;
    if (dateTo != null) {
      revisionBefore=SVNRevision.create(dateTo);
    }
 else     if (changeTo != null) {
      revisionBefore=SVNRevision.create(changeTo.longValue());
    }
 else {
      revisionBefore=SVNRevision.HEAD;
    }
    final SVNRevision revisionAfter;
    if (dateFrom != null) {
      revisionAfter=SVNRevision.create(dateFrom);
    }
 else     if (changeFrom != null) {
      revisionAfter=SVNRevision.create(changeFrom.longValue());
    }
 else {
      revisionAfter=SVNRevision.create(1);
    }
    logger.doLog(SVNURL.parseURIEncoded(url),filterUrls,revisionBefore,revisionBefore,revisionAfter,settings.STOP_ON_COPY,true,maxCount,new ISVNLogEntryHandler(){
      public void handleLogEntry(      SVNLogEntry logEntry){
        if (myProject.isDisposed())         throw new ProcessCanceledException();
        if (progress != null) {
          progress.setText2(SvnBundle.message("progress.text2.processing.revision",logEntry.getRevision()));
          progress.checkCanceled();
        }
        if (logEntry.getDate() == null) {
          return;
        }
        if (author == null || author.equalsIgnoreCase(logEntry.getAuthor())) {
          resultConsumer.consume(logEntry);
        }
      }
    }
);
  }
 catch (  SVNException e) {
    throw new VcsException(e);
  }
}
