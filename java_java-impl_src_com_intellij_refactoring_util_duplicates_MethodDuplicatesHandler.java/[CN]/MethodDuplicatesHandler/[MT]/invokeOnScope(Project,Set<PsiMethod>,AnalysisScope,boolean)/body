{
  final Map<PsiMethod,List<Match>> duplicates=new HashMap<PsiMethod,List<Match>>();
  scope.accept(new PsiRecursiveElementVisitor(){
    @Override public void visitFile(    final PsiFile file){
      final ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
      if (progressIndicator != null && progressIndicator.isCanceled())       return;
      for (      PsiMethod method : methods) {
        final List<Match> matchList=hasDuplicates(file,method);
        for (Iterator<Match> iterator=matchList.iterator(); iterator.hasNext(); ) {
          Match match=iterator.next();
          final PsiElement matchStart=match.getMatchStart();
          final PsiElement matchEnd=match.getMatchEnd();
          for (          PsiMethod psiMethod : methods) {
            if (PsiTreeUtil.isAncestor(psiMethod,matchStart,false) || PsiTreeUtil.isAncestor(psiMethod,matchEnd,false)) {
              iterator.remove();
              break;
            }
          }
        }
        if (!matchList.isEmpty()) {
          List<Match> matches=duplicates.get(method);
          if (matches == null) {
            matches=new ArrayList<Match>();
            duplicates.put(method,matches);
          }
          matches.addAll(matchList);
        }
      }
    }
  }
);
  replaceDuplicate(project,duplicates,methods);
  if (!silent) {
    final Runnable nothingFoundRunnable=new Runnable(){
      @Override public void run(){
        if (duplicates.isEmpty()) {
          final String message=RefactoringBundle.message("idea.has.not.found.any.code.that.can.be.replaced.with.method.call",ApplicationNamesInfo.getInstance().getProductName());
          Messages.showInfoMessage(project,message,REFACTORING_NAME);
        }
      }
    }
;
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      nothingFoundRunnable.run();
    }
 else {
      ApplicationManager.getApplication().invokeLater(nothingFoundRunnable,ModalityState.NON_MODAL);
    }
  }
}
