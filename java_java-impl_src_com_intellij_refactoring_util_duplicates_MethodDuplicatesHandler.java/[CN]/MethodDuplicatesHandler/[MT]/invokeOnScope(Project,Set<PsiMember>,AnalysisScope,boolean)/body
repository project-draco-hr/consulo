{
  final Map<PsiMember,List<Match>> duplicates=new HashMap<PsiMember,List<Match>>();
  final int fileCount=scope.getFileCount();
  final ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
  if (progressIndicator != null) {
    progressIndicator.setIndeterminate(false);
  }
  final Map<PsiMember,Set<Module>> memberWithModulesMap=new HashMap<PsiMember,Set<Module>>();
  for (  PsiMember member : members) {
    final Module module=ModuleUtil.findModuleForPsiElement(member);
    if (module != null) {
      final HashSet<Module> dependencies=new HashSet<Module>();
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        public void run(){
          ModuleUtil.collectModulesDependsOn(module,dependencies);
        }
      }
);
      memberWithModulesMap.put(member,dependencies);
    }
  }
  scope.accept(new PsiRecursiveElementVisitor(){
    private int myFileCount=0;
    @Override public void visitFile(    final PsiFile file){
      if (progressIndicator != null) {
        if (progressIndicator.isCanceled())         return;
        progressIndicator.setFraction(((double)myFileCount++) / fileCount);
        final VirtualFile virtualFile=file.getVirtualFile();
        if (virtualFile != null) {
          progressIndicator.setText2(ProjectUtil.calcRelativeToProjectPath(virtualFile,project));
        }
      }
      final Module targetModule=ModuleUtil.findModuleForPsiElement(file);
      if (targetModule == null)       return;
      for (      Map.Entry<PsiMember,Set<Module>> entry : memberWithModulesMap.entrySet()) {
        final Set<Module> dependencies=entry.getValue();
        if (dependencies == null || !dependencies.contains(targetModule))         continue;
        final PsiMember method=entry.getKey();
        final List<Match> matchList=hasDuplicates(file,method);
        for (Iterator<Match> iterator=matchList.iterator(); iterator.hasNext(); ) {
          Match match=iterator.next();
          final PsiElement matchStart=match.getMatchStart();
          final PsiElement matchEnd=match.getMatchEnd();
          for (          PsiMember psiMember : members) {
            if (PsiTreeUtil.isAncestor(psiMember,matchStart,false) || PsiTreeUtil.isAncestor(psiMember,matchEnd,false)) {
              iterator.remove();
              break;
            }
          }
        }
        if (!matchList.isEmpty()) {
          List<Match> matches=duplicates.get(method);
          if (matches == null) {
            matches=new ArrayList<Match>();
            duplicates.put(method,matches);
          }
          matches.addAll(matchList);
        }
      }
    }
  }
);
  replaceDuplicate(project,duplicates,members);
  if (!silent) {
    final Runnable nothingFoundRunnable=new Runnable(){
      @Override public void run(){
        if (duplicates.isEmpty()) {
          final String message=RefactoringBundle.message("idea.has.not.found.any.code.that.can.be.replaced.with.method.call",ApplicationNamesInfo.getInstance().getProductName());
          Messages.showInfoMessage(project,message,REFACTORING_NAME);
        }
      }
    }
;
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      nothingFoundRunnable.run();
    }
 else {
      ApplicationManager.getApplication().invokeLater(nothingFoundRunnable,ModalityState.NON_MODAL);
    }
  }
}
