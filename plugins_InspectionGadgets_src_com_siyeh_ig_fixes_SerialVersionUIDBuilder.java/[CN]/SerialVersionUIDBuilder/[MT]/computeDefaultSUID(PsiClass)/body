{
  final Project project=psiClass.getProject();
  final GlobalSearchScope scope=GlobalSearchScope.allScope(project);
  final PsiClass serializable=JavaPsiFacade.getInstance(project).findClass(SERIALIZABLE_CLASS_NAME,scope);
  if (serializable == null) {
    return -1L;
  }
  final boolean isSerializable=psiClass.isInheritor(serializable,true);
  if (!isSerializable) {
    return 0L;
  }
  final SerialVersionUIDBuilder serialVersionUIDBuilder=new SerialVersionUIDBuilder(psiClass);
  try {
    final ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
    final DataOutputStream dataOutputStream=new DataOutputStream(byteArrayOutputStream);
    final String className=PsiFormatUtil.getExternalName(psiClass);
    dataOutputStream.writeUTF(className);
    final PsiModifierList classModifierList=psiClass.getModifierList();
    int classModifiers=classModifierList != null ? MemberSignature.calculateModifierBitmap(classModifierList) : 0;
    final MemberSignature[] methodSignatures=serialVersionUIDBuilder.getNonPrivateMethodSignatures();
    if (psiClass.isInterface()) {
      classModifiers|=Modifier.INTERFACE;
      if (methodSignatures.length == 0) {
        classModifiers&=~Modifier.ABSTRACT;
      }
    }
    dataOutputStream.writeInt(classModifiers);
    final PsiClass[] interfaces=psiClass.getInterfaces();
    Arrays.sort(interfaces,INTERFACE_COMPARATOR);
    for (    PsiClass aInterfaces : interfaces) {
      final String name=aInterfaces.getQualifiedName();
      dataOutputStream.writeUTF(name);
    }
    final MemberSignature[] fields=serialVersionUIDBuilder.getNonPrivateFields();
    Arrays.sort(fields);
    for (    final MemberSignature field : fields) {
      dataOutputStream.writeUTF(field.getName());
      dataOutputStream.writeInt(field.getModifiers());
      dataOutputStream.writeUTF(field.getSignature());
    }
    final MemberSignature[] staticInitializers=serialVersionUIDBuilder.getStaticInitializers();
    for (    final MemberSignature staticInitializer : staticInitializers) {
      dataOutputStream.writeUTF(staticInitializer.getName());
      dataOutputStream.writeInt(staticInitializer.getModifiers());
      dataOutputStream.writeUTF(staticInitializer.getSignature());
    }
    final MemberSignature[] constructors=serialVersionUIDBuilder.getNonPrivateConstructors();
    Arrays.sort(constructors);
    for (    final MemberSignature constructor : constructors) {
      dataOutputStream.writeUTF(constructor.getName());
      dataOutputStream.writeInt(constructor.getModifiers());
      dataOutputStream.writeUTF(constructor.getSignature());
    }
    Arrays.sort(methodSignatures);
    for (    final MemberSignature methodSignature : methodSignatures) {
      dataOutputStream.writeUTF(methodSignature.getName());
      dataOutputStream.writeInt(methodSignature.getModifiers());
      dataOutputStream.writeUTF(methodSignature.getSignature());
    }
    dataOutputStream.flush();
    @NonNls final String algorithm="SHA";
    final MessageDigest digest=MessageDigest.getInstance(algorithm);
    final byte[] digestBytes=digest.digest(byteArrayOutputStream.toByteArray());
    long serialVersionUID=0L;
    for (int i=Math.min(digestBytes.length,8) - 1; i >= 0; i--) {
      serialVersionUID=serialVersionUID << 8 | digestBytes[i] & 0xFF;
    }
    return serialVersionUID;
  }
 catch (  IOException exception) {
    final InternalError internalError=new InternalError(exception.getMessage());
    internalError.initCause(exception);
    throw internalError;
  }
catch (  NoSuchAlgorithmException exception) {
    final SecurityException securityException=new SecurityException(exception.getMessage());
    securityException.initCause(exception);
    throw securityException;
  }
}
