{
  checkCanPaint(g);
  int xOffset=0;
  final Icon icon=myIcon;
  if (icon != null) {
    final Container parent=getParent();
    Color iconBackgroundColor=null;
    if (isIconOpaque()) {
      if (parent != null && !myFocusBorderAroundIcon && !UIUtil.isFullRowSelectionLAF()) {
        iconBackgroundColor=parent.getBackground();
      }
 else {
        iconBackgroundColor=getBackground();
      }
    }
    if (iconBackgroundColor != null) {
      g.setColor(iconBackgroundColor);
      g.fillRect(0,0,icon.getIconWidth() + myIpad.left + myIconTextGap,getHeight());
    }
    icon.paintIcon(this,g,myIpad.left,(getHeight() - icon.getIconHeight()) / 2);
    xOffset+=myIpad.left + icon.getIconWidth() + myIconTextGap;
  }
  if (isOpaque()) {
    g.setColor(getBackground());
    g.fillRect(xOffset,0,getWidth() - xOffset,getHeight());
  }
  if (xOffset == 0) {
    xOffset=myIpad.left;
  }
  int textStart=xOffset;
  xOffset+=myBorder.getBorderInsets(this).left;
  final List<Object[]> searchMatches=new ArrayList<Object[]>();
  UIUtil.applyRenderingHints(g);
  for (int i=0; i < myFragments.size(); i++) {
    final SimpleTextAttributes attributes=myAttributes.get(i);
    Font font=g.getFont();
    if (font.getStyle() != attributes.getFontStyle()) {
      font=font.deriveFont(attributes.getFontStyle());
    }
    g.setFont(font);
    final FontMetrics metrics=g.getFontMetrics(font);
    final String fragment=myFragments.get(i);
    final int fragmentWidth=metrics.stringWidth(fragment);
    final Color bgColor=attributes.getBgColor();
    if (isOpaque() && bgColor != null) {
      g.setColor(bgColor);
      g.fillRect(xOffset,0,fragmentWidth,getHeight());
    }
    Color color=attributes.getFgColor();
    if (color == null) {
      color=getForeground();
    }
    if (!isEnabled()) {
      color=UIUtil.getInactiveTextColor();
    }
    g.setColor(color);
    final int textBaseline=(getHeight() - metrics.getHeight()) / 2 + metrics.getAscent();
    if (!attributes.isSearchMatch())     g.drawString(fragment,xOffset,textBaseline);
    if (attributes.isStrikeout()) {
      final int strikeOutAt=textBaseline + (metrics.getDescent() - metrics.getAscent()) / 2;
      UIUtil.drawLine(g,xOffset,strikeOutAt,xOffset + fragmentWidth,strikeOutAt);
    }
    if (attributes.isWaved()) {
      if (attributes.getWaveColor() != null) {
        g.setColor(attributes.getWaveColor());
      }
      final int wavedAt=textBaseline + 1;
      for (int x=xOffset; x <= xOffset + fragmentWidth; x+=4) {
        UIUtil.drawLine(g,x,wavedAt,x + 2,wavedAt + 2);
        UIUtil.drawLine(g,x + 3,wavedAt + 1,x + 4,wavedAt);
      }
    }
    if (attributes.isUnderline()) {
      final int underlineAt=textBaseline + 1;
      UIUtil.drawLine(g,xOffset,underlineAt,xOffset + fragmentWidth,underlineAt);
    }
    if (attributes.isBoldDottedLine()) {
      final int dottedAt=SystemInfo.isMac ? textBaseline : textBaseline + 1;
      final Color lineColor=attributes.getWaveColor();
      UIUtil.drawBoldDottedLine((Graphics2D)g,xOffset,xOffset + fragmentWidth,dottedAt,bgColor,lineColor,isOpaque());
    }
    if (attributes.isSearchMatch()) {
      searchMatches.add(new Object[]{xOffset,xOffset + fragmentWidth,textBaseline,fragment,g.getFont()});
    }
    final Integer fixedWidth=myAligns.get(i);
    if (fixedWidth != null && fragmentWidth < fixedWidth.intValue()) {
      xOffset+=fixedWidth.intValue();
    }
 else {
      xOffset+=fragmentWidth;
    }
  }
  if (myPaintFocusBorder) {
    if (myFocusBorderAroundIcon || icon == null) {
      myBorder.paintBorder(this,g,0,0,getWidth(),getHeight());
    }
 else {
      myBorder.paintBorder(this,g,textStart,0,getWidth() - textStart,getHeight());
    }
  }
  for (  final Object[] info : searchMatches) {
    UIUtil.drawSearchMatch((Graphics2D)g,(Integer)info[0],(Integer)info[1],getHeight());
    g.setFont((Font)info[4]);
    g.setColor(new Color(50,50,50));
    g.drawString((String)info[3],(Integer)info[0],(Integer)info[2]);
  }
}
