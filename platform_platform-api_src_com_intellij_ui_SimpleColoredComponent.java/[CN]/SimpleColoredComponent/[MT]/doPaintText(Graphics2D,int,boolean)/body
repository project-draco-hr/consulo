{
  if (offset == 0) {
    offset=myIpad.left;
  }
  int textStart=offset;
  if (myBorder != null) {
    offset+=myBorder.getBorderInsets(this).left;
  }
  final List<Object[]> searchMatches=new ArrayList<Object[]>();
  UIUtil.applyRenderingHints(g);
  applyAdditionalHints(g);
  final Font ownFont=getFont();
  if (ownFont != null) {
    offset+=computeTextAlignShift(ownFont);
  }
  int baseSize=ownFont != null ? ownFont.getSize() : g.getFont().getSize();
  boolean wasSmaller=false;
  for (int i=0; i < myFragments.size(); i++) {
    final SimpleTextAttributes attributes=myAttributes.get(i);
    Font font=g.getFont();
    boolean isSmaller=attributes.isSmaller();
    if (font.getStyle() != attributes.getFontStyle() || isSmaller != wasSmaller) {
      font=font.deriveFont(attributes.getFontStyle(),isSmaller ? UIUtil.getFontSize(UIUtil.FontSize.SMALL) : baseSize);
    }
    wasSmaller=isSmaller;
    g.setFont(font);
    final FontMetrics metrics=g.getFontMetrics(font);
    final String fragment=myFragments.get(i);
    final int fragmentWidth=computeStringWidth(fragment,font);
    final int fragmentPadding=myFragmentPadding.get(i);
    final Color bgColor=attributes.isSearchMatch() ? null : attributes.getBgColor();
    if ((attributes.isOpaque() || isOpaque()) && bgColor != null) {
      g.setColor(bgColor);
      g.fillRect(offset,0,fragmentWidth,getHeight());
    }
    Color color=attributes.getFgColor();
    if (color == null) {
      color=getForeground();
    }
    if (!isEnabled()) {
      color=UIUtil.getInactiveTextColor();
    }
    g.setColor(color);
    final int textBaseline=getTextBaseLine(metrics,getHeight());
    final int fragmentAlignment=myFragmentAlignment.get(i);
    final int endOffset;
    if (fragmentPadding > 0 && fragmentPadding > fragmentWidth) {
      endOffset=fragmentPadding;
      if (fragmentAlignment == SwingConstants.RIGHT || fragmentAlignment == SwingConstants.TRAILING) {
        offset=(fragmentPadding - fragmentWidth);
      }
    }
 else {
      endOffset=offset + fragmentWidth;
    }
    if (!attributes.isSearchMatch()) {
      if (shouldDrawMacShadow()) {
        g.setColor(SHADOW_COLOR);
        doDrawString(g,fragment,offset,textBaseline + 1);
      }
      if (shouldDrawDimmed()) {
        color=ColorUtil.dimmer(color);
      }
      g.setColor(color);
      doDrawString(g,fragment,offset,textBaseline);
    }
    g.setStroke(g.getStroke());
    if (attributes.isStrikeout()) {
      final int strikeOutAt=textBaseline + (metrics.getDescent() - metrics.getAscent()) / 2;
      UIUtil.drawLine(g,offset,strikeOutAt,offset + fragmentWidth,strikeOutAt);
    }
    if (attributes.isWaved()) {
      if (attributes.getWaveColor() != null) {
        g.setColor(attributes.getWaveColor());
      }
      UIUtil.drawWave(g,new Rectangle(offset,textBaseline + 1,fragmentWidth,Math.max(2,metrics.getDescent())));
    }
    if (attributes.isUnderline()) {
      final int underlineAt=textBaseline + 1;
      UIUtil.drawLine(g,offset,underlineAt,offset + fragmentWidth,underlineAt);
    }
    if (attributes.isBoldDottedLine()) {
      final int dottedAt=SystemInfo.isMac ? textBaseline : textBaseline + 1;
      final Color lineColor=attributes.getWaveColor();
      UIUtil.drawBoldDottedLine(g,offset,offset + fragmentWidth,dottedAt,bgColor,lineColor,isOpaque());
    }
    if (attributes.isSearchMatch()) {
      searchMatches.add(new Object[]{offset,offset + fragmentWidth,textBaseline,fragment,g.getFont()});
    }
    offset=endOffset;
  }
  if (myPaintFocusBorder && myBorder != null) {
    if (focusAroundIcon) {
      myBorder.paintBorder(this,g,0,0,getWidth(),getHeight());
    }
 else {
      myBorder.paintBorder(this,g,textStart,0,getWidth() - textStart,getHeight());
    }
  }
  for (  final Object[] info : searchMatches) {
    UIUtil.drawSearchMatch(g,(Integer)info[0],(Integer)info[1],getHeight());
    g.setFont((Font)info[4]);
    if (shouldDrawMacShadow()) {
      g.setColor(SHADOW_COLOR);
      g.drawString((String)info[3],(Integer)info[0],(Integer)info[2] + 1);
    }
    g.setColor(new JBColor(Gray._50,Gray._0));
    g.drawString((String)info[3],(Integer)info[0],(Integer)info[2]);
  }
  return offset;
}
