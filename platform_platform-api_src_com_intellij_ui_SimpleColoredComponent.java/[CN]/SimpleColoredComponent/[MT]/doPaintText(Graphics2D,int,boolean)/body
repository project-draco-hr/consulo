{
  if (offset == 0) {
    offset=myIpad.left;
  }
  int textStart=offset;
  if (myBorder != null) {
    offset+=myBorder.getBorderInsets(this).left;
  }
  final List<Object[]> searchMatches=new ArrayList<Object[]>();
  UIUtil.applyRenderingHints(g);
  applyAdditionalHints(g);
  final Font ownFont=getFont();
  int baseSize=ownFont != null ? ownFont.getSize() : g.getFont().getSize();
  boolean wasSmaller=false;
  for (int i=0; i < myFragments.size(); i++) {
    final SimpleTextAttributes attributes=myAttributes.get(i);
    Font font=g.getFont();
    boolean isSmaller=attributes.isSmaller();
    if (font.getStyle() != attributes.getFontStyle() || isSmaller != wasSmaller) {
      font=font.deriveFont(attributes.getFontStyle(),isSmaller ? UIUtil.getFontSize(UIUtil.FontSize.SMALL) : baseSize);
    }
    wasSmaller=isSmaller;
    g.setFont(font);
    final FontMetrics metrics=g.getFontMetrics(font);
    final String fragment=myFragments.get(i);
    final int fragmentWidth=metrics.stringWidth(fragment);
    final Color bgColor=attributes.getBgColor();
    if (isOpaque() && bgColor != null) {
      g.setColor(bgColor);
      g.fillRect(offset,0,fragmentWidth,getHeight());
    }
    Color color=attributes.getFgColor();
    if (color == null) {
      color=getForeground();
    }
    if (!isEnabled()) {
      color=UIUtil.getInactiveTextColor();
    }
    g.setColor(color);
    final int textBaseline=getTextBaseLine(metrics,getHeight());
    if (!attributes.isSearchMatch()) {
      if (shouldDrawMacShadow()) {
        g.setColor(STYLE_SEARCH_MATCH_BACKGROUND);
        g.drawString(fragment,offset,textBaseline + 1);
      }
      g.setColor(color);
      g.drawString(fragment,offset,textBaseline);
    }
    if (attributes.isStrikeout()) {
      final int strikeOutAt=textBaseline + (metrics.getDescent() - metrics.getAscent()) / 2;
      UIUtil.drawLine(g,offset,strikeOutAt,offset + fragmentWidth,strikeOutAt);
    }
    if (attributes.isWaved()) {
      if (attributes.getWaveColor() != null) {
        g.setColor(attributes.getWaveColor());
      }
      final int wavedAt=textBaseline + 1;
      for (int x=offset; x <= offset + fragmentWidth; x+=4) {
        UIUtil.drawLine(g,x,wavedAt,x + 2,wavedAt + 2);
        UIUtil.drawLine(g,x + 3,wavedAt + 1,x + 4,wavedAt);
      }
    }
    if (attributes.isUnderline()) {
      final int underlineAt=textBaseline + 1;
      UIUtil.drawLine(g,offset,underlineAt,offset + fragmentWidth,underlineAt);
    }
    if (attributes.isBoldDottedLine()) {
      final int dottedAt=SystemInfo.isMac ? textBaseline : textBaseline + 1;
      final Color lineColor=attributes.getWaveColor();
      UIUtil.drawBoldDottedLine(g,offset,offset + fragmentWidth,dottedAt,bgColor,lineColor,isOpaque());
    }
    if (attributes.isSearchMatch()) {
      searchMatches.add(new Object[]{offset,offset + fragmentWidth,textBaseline,fragment,g.getFont()});
    }
    final Integer fixedWidth=myAligns.get(i);
    if (fixedWidth != null && fragmentWidth < fixedWidth.intValue()) {
      offset=fixedWidth.intValue();
    }
 else {
      offset+=fragmentWidth;
    }
  }
  if (myPaintFocusBorder && myBorder != null) {
    if (focusAroundIcon) {
      myBorder.paintBorder(this,g,0,0,getWidth(),getHeight());
    }
 else {
      myBorder.paintBorder(this,g,textStart,0,getWidth() - textStart,getHeight());
    }
  }
  for (  final Object[] info : searchMatches) {
    UIUtil.drawSearchMatch(g,(Integer)info[0],(Integer)info[1],getHeight());
    g.setFont((Font)info[4]);
    if (shouldDrawMacShadow()) {
      g.setColor(new Color(250,250,250,140));
      g.drawString((String)info[3],(Integer)info[0],(Integer)info[2] + 1);
    }
    g.setColor(new Color(50,50,50));
    g.drawString((String)info[3],(Integer)info[0],(Integer)info[2]);
  }
  return offset;
}
