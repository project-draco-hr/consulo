{
  final Cache oldCache=myDependencyCache.getCache();
  if (!ClsUtil.isAnnotation(oldCache.getFlags(oldCache.getClassId(annotationQName)))) {
    return;
  }
  if (!hasRetentionPolicyChanged(annotationQName,oldCache,myDependencyCache.getNewClassesCache(),myDependencyCache.getSymbolTable())) {
    return;
  }
  final PsiManager psiManager=PsiManager.getInstance(myProject);
  final CacheCorruptedException[] _ex=new CacheCorruptedException[]{null};
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        final String qName=myDependencyCache.resolve(annotationQName);
        PsiClass[] classes=psiManager.findClasses(qName.replace('$','.'),GlobalSearchScope.allScope(myProject));
        for (int i=0; i < classes.length; i++) {
          final PsiClass aClass=classes[i];
          if (!aClass.isAnnotationType()) {
            continue;
          }
          final PsiReference[] references=mySearcher.findReferences(aClass);
          for (int j=0; j < references.length; j++) {
            final PsiClass ownerClass=getOwnerClass(references[j].getElement());
            if (ownerClass != null && !ownerClass.equals(aClass)) {
              int qualifiedName=myDependencyCache.getSymbolTable().getId(ownerClass.getQualifiedName());
              if (myDependencyCache.markClass(qualifiedName,false)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Marked dependent class " + myDependencyCache.resolve(qualifiedName) + "; reason: annotation's retention policy changed from SOURCE to CLASS or RUNTIME "+ myDependencyCache.resolve(annotationQName));
                }
              }
            }
          }
        }
      }
 catch (      CacheCorruptedException e) {
        _ex[0]=e;
      }
    }
  }
);
  if (_ex[0] != null) {
    throw _ex[0];
  }
}
