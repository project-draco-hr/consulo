{
  AlignmentImpl alignment=CoreFormatterUtil.getAlignment(myCurrentBlock);
  WhiteSpace whiteSpace=myCurrentBlock.getWhiteSpace();
  if (alignment == null) {
    if (whiteSpace.containsLineFeeds()) {
      adjustSpacingByIndentOffset();
    }
 else {
      whiteSpace.arrangeSpaces(myCurrentBlock.getSpaceProperty());
    }
    return true;
  }
  BlockAlignmentProcessor alignmentProcessor=ALIGNMENT_PROCESSORS.get(alignment.getAnchor());
  if (alignmentProcessor == null) {
    LOG.error(String.format("Can't find alignment processor for alignment anchor %s",alignment.getAnchor()));
    return true;
  }
  BlockAlignmentProcessor.Context context=new BlockAlignmentProcessor.Context(myDocument,alignment,myCurrentBlock,myAlignmentMappings,myBackwardShiftedAlignedBlocks,myIndentOption);
  BlockAlignmentProcessor.Result result=alignmentProcessor.applyAlignment(context);
switch (result) {
case TARGET_BLOCK_PROCESSED_NOT_ALIGNED:
    return true;
case TARGET_BLOCK_ALIGNED:
  storeAlignmentMapping();
return true;
case BACKWARD_BLOCK_ALIGNED:
LeafBlockWrapper offsetResponsibleBlock=alignment.getOffsetRespBlockBefore(myCurrentBlock);
if (offsetResponsibleBlock == null) {
return true;
}
Set<LeafBlockWrapper> blocksCausedRealignment=new HashSet<LeafBlockWrapper>();
myBackwardShiftedAlignedBlocks.clear();
myBackwardShiftedAlignedBlocks.put(offsetResponsibleBlock,blocksCausedRealignment);
blocksCausedRealignment.add(myCurrentBlock);
storeAlignmentMapping(myCurrentBlock,offsetResponsibleBlock);
myCurrentBlock=offsetResponsibleBlock.getNextBlock();
onCurrentLineChanged();
return false;
case UNABLE_TO_ALIGN_BACKWARD_BLOCK:
if (whiteSpace.containsLineFeeds()) {
adjustSpacingByIndentOffset();
}
 else {
whiteSpace.arrangeSpaces(myCurrentBlock.getSpaceProperty());
}
return true;
default :
return true;
}
}
