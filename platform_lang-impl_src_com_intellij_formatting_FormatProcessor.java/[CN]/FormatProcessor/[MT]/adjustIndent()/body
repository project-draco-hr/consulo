{
  IndentData alignOffset=getAlignOffset();
  WhiteSpace whiteSpace=myCurrentBlock.getWhiteSpace();
  if (alignOffset == null) {
    if (whiteSpace.containsLineFeeds()) {
      adjustSpacingByIndentOffset();
    }
 else {
      whiteSpace.arrangeSpaces(myCurrentBlock.getSpaceProperty());
    }
    return true;
  }
  if (whiteSpace.containsLineFeeds()) {
    whiteSpace.setSpaces(alignOffset.getSpaces(),alignOffset.getIndentSpaces());
    return true;
  }
  IndentData indentBeforeBlock=myCurrentBlock.getNumberOfSymbolsBeforeBlock();
  int diff=alignOffset.getTotalSpaces() - indentBeforeBlock.getTotalSpaces();
  if (diff == 0) {
    return true;
  }
  if (diff > 0) {
    whiteSpace.setSpaces(whiteSpace.getSpaces() + diff,whiteSpace.getIndentSpaces());
    if (!whiteSpace.containsLineFeeds()) {
      whiteSpace.setForceSkipTabulationsUsage(true);
    }
    return true;
  }
  AlignmentImpl alignment=myCurrentBlock.getAlignmentAtStartOffset();
  if (alignment == null) {
    return true;
  }
  if (!alignment.isAllowBackwardShift()) {
    return true;
  }
  LeafBlockWrapper offsetResponsibleBlock=alignment.getOffsetRespBlockBefore(myCurrentBlock);
  if (offsetResponsibleBlock == null) {
    return true;
  }
  if (offsetResponsibleBlock.getWhiteSpace().isIsReadOnly()) {
    return true;
  }
  Set<LeafBlockWrapper> blocksCausedRealignment=myBackwardShiftedAlignedBlocks.get(offsetResponsibleBlock);
  if (blocksCausedRealignment != null && blocksCausedRealignment.contains(myCurrentBlock)) {
    LOG.error(String.format("Formatting error - code block %s is set to be shifted right because of its alignment with " + "block %s more than once. I.e. moving the former block because of alignment algorithm causes " + "subsequent block to be shifted right as well - cyclic dependency",offsetResponsibleBlock.getTextRange(),myCurrentBlock.getTextRange()));
    blocksCausedRealignment.add(myCurrentBlock);
    return true;
  }
  myBackwardShiftedAlignedBlocks.clear();
  myBackwardShiftedAlignedBlocks.put(offsetResponsibleBlock,blocksCausedRealignment=new HashSet<LeafBlockWrapper>());
  blocksCausedRealignment.add(myCurrentBlock);
  WhiteSpace previousWhiteSpace=offsetResponsibleBlock.getWhiteSpace();
  previousWhiteSpace.setSpaces(previousWhiteSpace.getSpaces() - diff,previousWhiteSpace.getIndentOffset());
  if (!previousWhiteSpace.containsLineFeeds()) {
    previousWhiteSpace.setForceSkipTabulationsUsage(true);
  }
  myCurrentBlock=offsetResponsibleBlock.getNextBlock();
  onCurrentLineChanged();
  return false;
}
