{
  myParent=psiParent;
  StringBuffer canonicalText=new StringBuffer();
  LOG.assertTrue(signature.current() == 'L');
  signature.next();
  ArrayList<ClsTypeElementImpl> typeParameters=new ArrayList<ClsTypeElementImpl>();
  while (signature.current() != ';' && signature.current() != CharacterIterator.DONE) {
switch (signature.current()) {
case '$':
case '/':
case '.':
      canonicalText.append('.');
    break;
case '<':
  canonicalText.append('<');
signature.next();
do {
processTypeArgument(signature,typeParameters,canonicalText);
}
 while (signature.current() != '>');
canonicalText.append('>');
break;
case ' ':
break;
default :
canonicalText.append(signature.current());
}
signature.next();
}
if (signature.current() == CharacterIterator.DONE) {
throw new ClsFormatException();
}
for (int index=0; index < canonicalText.length(); index++) {
final char c=canonicalText.charAt(index);
if ('0' <= c && c <= '1') {
if (index > 0 && canonicalText.charAt(index - 1) == '.') {
canonicalText.setCharAt(index - 1,'$');
}
}
}
myCanonicalText=canonicalText.toString();
myTypeParameters=typeParameters.toArray(new ClsTypeElementImpl[typeParameters.size()]);
;
myQualifiedName=PsiNameHelper.getQualifiedClassName(myCanonicalText,false);
signature.next();
}
