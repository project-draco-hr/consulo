{
  while (!additionalConstraints.isEmpty()) {
    final Set<InferenceVariable> outputVariables=new HashSet<InferenceVariable>();
    for (    ConstraintFormula constraint : additionalConstraints) {
      if (constraint instanceof InputOutputConstraintFormula) {
        final Set<InferenceVariable> outputVars=((InputOutputConstraintFormula)constraint).getOutputVariables(((InputOutputConstraintFormula)constraint).getInputVariables(this),this);
        if (outputVars != null) {
          outputVariables.addAll(outputVars);
        }
      }
    }
    Set<ConstraintFormula> subset=new HashSet<ConstraintFormula>();
    final Set<InferenceVariable> varsToResolve=new HashSet<InferenceVariable>();
    for (    ConstraintFormula constraint : additionalConstraints) {
      if (constraint instanceof InputOutputConstraintFormula) {
        final Set<InferenceVariable> inputVariables=((InputOutputConstraintFormula)constraint).getInputVariables(this);
        if (inputVariables != null) {
          boolean dependsOnOutput=false;
          for (          InferenceVariable inputVariable : inputVariables) {
            final Set<InferenceVariable> dependencies=inputVariable.getDependencies(this);
            dependencies.retainAll(outputVariables);
            if (!dependencies.isEmpty()) {
              dependsOnOutput=true;
              break;
            }
          }
          if (!dependsOnOutput) {
            subset.add(constraint);
            varsToResolve.addAll(inputVariables);
          }
        }
      }
 else {
        subset.add(constraint);
      }
    }
    if (subset.isEmpty()) {
      subset=Collections.singleton(additionalConstraints.iterator().next());
    }
    additionalConstraints.removeAll(subset);
    mySiteSubstitutor=resolveBounds(varsToResolve,mySiteSubstitutor);
    for (    ConstraintFormula constraint : subset) {
      constraint.apply(mySiteSubstitutor);
      if (!constraint.reduce(this,myConstraints)) {
        return false;
      }
    }
    myConstraintIdx=myConstraints.size();
    myIncorporationPhase.incorporate();
  }
  return true;
}
