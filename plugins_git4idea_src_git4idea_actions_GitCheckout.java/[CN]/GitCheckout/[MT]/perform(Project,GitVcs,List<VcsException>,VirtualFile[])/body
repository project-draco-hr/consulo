{
  saveAll();
  final VirtualFile[] roots=ProjectLevelVcsManager.getInstance(project).getRootsUnderVcs(vcs);
  List<GitBranch> branches;
  for (  VirtualFile root : roots) {
    GitCommand command=new GitCommand(project,vcs.getSettings(),root);
    branches=command.branchList();
    String[] branchesList=new String[branches.size()];
    String selectedBranch=null;
    int i=0;
    for (    GitBranch b : branches) {
      branchesList[i++]=b.getName();
      if (selectedBranch == null || b.isActive())       selectedBranch=b.getName();
    }
    String branchName=Messages.showEditableChooseDialog(GitBundle.getString("select.branch.to.checkout"),GitBundle.getString("checkout.branch"),Messages.getQuestionIcon(),branchesList,selectedBranch,new GitBranchNameValidator());
    if (branchName == null)     return;
    selectedBranch=null;
    for (    GitBranch b : branches) {
      if (branchName.equals(b.getName())) {
        selectedBranch=branchName;
      }
    }
    String[] args=new String[1];
    if (selectedBranch != null) {
      args[0]=selectedBranch;
    }
 else {
      args[0]=branchName;
    }
    GitCommandRunnable cmdr=new GitCommandRunnable(project,vcs.getSettings(),root);
    cmdr.setCommand(GitCommand.CHECKOUT_CMD);
    cmdr.setArgs(args);
    ProgressManager manager=ProgressManager.getInstance();
    manager.runProcessWithProgressSynchronously(cmdr,GitBundle.message("checking.out",args[0]),false,project);
    @SuppressWarnings({"ThrowableResultOfMethodCallIgnored"}) VcsException ex=cmdr.getException();
    if (ex != null) {
      GitUtil.showOperationError(project,ex,"git checkout");
    }
  }
}
