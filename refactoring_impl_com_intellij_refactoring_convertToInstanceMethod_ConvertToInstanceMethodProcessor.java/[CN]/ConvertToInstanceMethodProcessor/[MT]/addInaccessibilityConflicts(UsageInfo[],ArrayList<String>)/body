{
  final PsiModifierList copy=(PsiModifierList)myMethod.getModifierList().copy();
  if (myNewVisibility != null) {
    if (myNewVisibility.equals(VisibilityUtil.ESCALATE_VISIBILITY)) {
      RefactoringUtil.setVisibility(copy,PsiModifier.PUBLIC);
    }
 else {
      RefactoringUtil.setVisibility(copy,myNewVisibility);
    }
  }
  for (  UsageInfo usage : usages) {
    if (usage instanceof MethodCallUsageInfo) {
      final PsiMethodCallExpression call=((MethodCallUsageInfo)usage).getMethodCall();
      PsiClass accessObjectClass=null;
      final PsiExpression[] arguments=call.getArgumentList().getExpressions();
      final int index=myMethod.getParameterList().getParameterIndex(myTargetParameter);
      LOG.assertTrue(index >= 0);
      if (index < arguments.length) {
        final PsiExpression argument=arguments[index];
        final PsiType argumentType=argument.getType();
        if (argumentType instanceof PsiClassType)         accessObjectClass=((PsiClassType)argumentType).resolve();
      }
      if (!ResolveUtil.isAccessible(myMethod,myTargetClass,copy,call,accessObjectClass,null)) {
        final String newVisibility=myNewVisibility == null ? VisibilityUtil.getVisibilityStringToDisplay(myMethod) : myNewVisibility;
        String message=RefactoringBundle.message("0.with.1.visibility.is.not.accesible.from.2",ConflictsUtil.getDescription(myMethod,true),newVisibility,ConflictsUtil.getDescription(ConflictsUtil.getContainer(call),true));
        conflicts.add(message);
      }
    }
  }
}
