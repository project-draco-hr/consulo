{
  boolean tempIsStatic=myIsConstant;
  PsiElement parent=local.getParent();
  List<PsiClass> classes=new ArrayList<PsiClass>();
  while (parent != null && parent.getContainingFile() != null) {
    if (parent instanceof PsiClass && !(myIsConstant && parent instanceof PsiAnonymousClass)) {
      classes.add((PsiClass)parent);
    }
    if (parent instanceof PsiFile && JspPsiUtil.isInJspFile(parent)) {
      String message=RefactoringBundle.message("error.not.supported.for.jsp",REFACTORING_NAME);
      CommonRefactoringUtil.showErrorHint(myProject,editor,message,REFACTORING_NAME,HelpID.LOCAL_TO_FIELD);
      return false;
    }
    if (parent instanceof PsiModifierListOwner && ((PsiModifierListOwner)parent).hasModifierProperty(PsiModifier.STATIC)) {
      tempIsStatic=true;
    }
    parent=parent.getParent();
  }
  if (classes.isEmpty())   return false;
  if (classes.size() == 1 || ApplicationManager.getApplication().isUnitTestMode()) {
    if (convertLocalToField(local,classes.get(getChosenClassIndex(classes)),editor,tempIsStatic))     return false;
  }
 else {
    final boolean isStatic=tempIsStatic;
    NavigationUtil.getPsiElementPopup(classes.toArray(new PsiClass[classes.size()]),new PsiClassListCellRenderer(),"Choose class to introduce " + (myIsConstant ? "constant" : "field"),new PsiElementProcessor<PsiClass>(){
      @Override public boolean execute(      @NotNull PsiClass aClass){
        convertLocalToField(local,aClass,editor,isStatic);
        return false;
      }
    }
).showInBestPositionFor(editor);
  }
  return true;
}
