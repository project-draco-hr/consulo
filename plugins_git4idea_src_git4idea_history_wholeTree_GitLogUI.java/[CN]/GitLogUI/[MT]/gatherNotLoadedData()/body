{
  if (myDataBeingAdded)   return false;
  final int[] rows=myJBTable.getSelectedRows();
  final List<GitCommit> commits=new ArrayList<GitCommit>();
  final List<CommitI> forComparison=new ArrayList<CommitI>();
  final MultiMap<VirtualFile,AbstractHash> missingHashes=new MultiMap<VirtualFile,AbstractHash>();
  for (int i=rows.length - 1; i >= 0; --i) {
    final int row=rows[i];
    final CommitI commitI=myTableModel.getCommitAt(row);
    if (commitI == null || commitI.holdsDecoration())     continue;
    final GitCommit details=fullCommitPresentation(commitI);
    if (details == null) {
      missingHashes.putValue(commitI.selectRepository(myRootsUnderVcs),commitI.getHash());
    }
 else     if (missingHashes.isEmpty()) {
      forComparison.add(commitI);
      commits.add(details);
    }
  }
  if (!missingHashes.isEmpty()) {
    myDetailsCache.acceptQuestion(missingHashes);
    return false;
  }
  if (Comparing.equal(myCommitsInRepositoryChangesBrowser,forComparison))   return true;
  myCommitsInRepositoryChangesBrowser.clear();
  myCommitsInRepositoryChangesBrowser.addAll(forComparison);
  final List<Change> changes=new ArrayList<Change>();
  for (  GitCommit commit : commits) {
    changes.addAll(commit.getChanges());
  }
  final List<Change> zipped=CommittedChangesTreeBrowser.zipChanges(changes);
  myRepositoryChangesBrowser.setChangesToDisplay(zipped);
  return true;
}
