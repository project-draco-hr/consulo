{
  myState=StepType.CONTINUE;
  final int was=myTableModel.getRowCount();
  myDetailsCache.resetAsideCaches();
  final Collection<String> startingPoints=mySelectedBranch == null ? Collections.<String>emptyList() : Collections.singletonList(mySelectedBranch);
  myDescriptionRenderer.resetIcons();
  final boolean commentFilterEmpty=StringUtil.isEmptyOrSpaces(myPreviousFilter);
  mySearchContext.clear();
  myUsersSearchContext.clear();
  if (commentFilterEmpty && (myUserFilterI.myFilter == null)) {
    myUsersSearchContext.clear();
    myMediator.reload(new RootsHolder(myRootsUnderVcs),startingPoints,new GitLogFilters());
  }
 else {
    ChangesFilter.Comment comment=null;
    if (!commentFilterEmpty) {
      final Pair<String,List<String>> preparse=preparse(myPreviousFilter);
      final String first=preparse.getFirst();
      comment=new ChangesFilter.Comment(first);
    }
    Set<ChangesFilter.Filter> userFilters=null;
    if (myUserFilterI.myFilter != null) {
      final String[] strings=myUserFilterI.myFilter.split(",");
      userFilters=new HashSet<ChangesFilter.Filter>();
      for (      String string : strings) {
        string=string.trim();
        if (string.length() == 0)         continue;
        myUsersSearchContext.add(string.toLowerCase());
        final String regexp="\"" + string + "\"";
        userFilters.add(new ChangesFilter.Committer(regexp));
        userFilters.add(new ChangesFilter.Author(regexp));
      }
    }
    final List<String> possibleReferencies=commentFilterEmpty ? null : Arrays.asList(myPreviousFilter.split("[\\s]"));
    myMediator.reload(new RootsHolder(myRootsUnderVcs),startingPoints,new GitLogFilters(comment,userFilters,null,possibleReferencies));
  }
  updateMoreVisibility();
  selectionChanged();
  fireTableRepaint();
  myTableModel.fireTableRowsDeleted(0,was);
}
