{
  final GitLogSettings settings=GitLogSettings.getInstance(myProject);
  settings.setSelectedBranch(mySelectedBranch);
  settings.setSelectedUser(myUserFilterI.myFilter);
  settings.setSelectedUserIsMe(myUserFilterI.isMeSelected());
  settings.setSelectedPaths(myStructureFilter.myAllSelected ? null : myStructureFilter.getSelected());
  myState=StepType.CONTINUE;
  final int was=myTableModel.getRowCount();
  myDetailsCache.resetAsideCaches();
  final Collection<String> startingPoints=mySelectedBranch == null ? Collections.<String>emptyList() : Collections.singletonList(mySelectedBranch);
  myDescriptionRenderer.resetIcons();
  final boolean commentFilterEmpty=StringUtil.isEmptyOrSpaces(myPreviousFilter);
  myCommentSearchContext.clear();
  myUsersSearchContext.clear();
  myThereAreFilters=true;
  myEqualToHeadr.getParent().setVisible(false);
  if (commentFilterEmpty && (myUserFilterI.myFilter == null) && myStructureFilter.myAllSelected) {
    myThereAreFilters=false;
    if (myMyShowTreeAction.isSelected(null)) {
      myEqualToHeadr.getParent().setVisible(true);
    }
    myUsersSearchContext.clear();
    myMediator.reload(new RootsHolder(myRootsUnderVcs),startingPoints,new GitLogFilters());
  }
 else {
    ChangesFilter.Comment comment=null;
    if (!commentFilterEmpty) {
      final String commentFilter=myCommentSearchContext.preparse(myPreviousFilter);
      comment=new ChangesFilter.Comment(commentFilter);
    }
    Set<ChangesFilter.Filter> userFilters=null;
    if (myUserFilterI.myFilter != null) {
      final String[] strings=myUserFilterI.myFilter.split(",");
      userFilters=new HashSet<ChangesFilter.Filter>();
      for (      String string : strings) {
        string=string.trim();
        if (string.length() == 0)         continue;
        myUsersSearchContext.add(string.toLowerCase());
        final String regexp=StringUtil.escapeToRegexp(string);
        userFilters.add(new ChangesFilter.Committer(regexp));
        userFilters.add(new ChangesFilter.Author(regexp));
      }
    }
    Map<VirtualFile,ChangesFilter.Filter> structureFilters=null;
    if (!myStructureFilter.myAllSelected) {
      structureFilters=new HashMap<VirtualFile,ChangesFilter.Filter>();
      final Collection<VirtualFile> selected=new ArrayList<VirtualFile>(myStructureFilter.getSelected());
      final ArrayList<VirtualFile> copy=new ArrayList<VirtualFile>(myRootsUnderVcs);
      Collections.sort(copy,FilePathComparator.getInstance());
      Collections.reverse(copy);
      for (      VirtualFile root : copy) {
        final Collection<VirtualFile> selectedForRoot=new SmartList<VirtualFile>();
        final Iterator<VirtualFile> iterator=selected.iterator();
        while (iterator.hasNext()) {
          VirtualFile next=iterator.next();
          if (VfsUtil.isAncestor(root,next,false)) {
            selectedForRoot.add(next);
            iterator.remove();
          }
        }
        if (!selectedForRoot.isEmpty()) {
          final ChangesFilter.StructureFilter structureFilter=new ChangesFilter.StructureFilter();
          structureFilter.addFiles(selectedForRoot);
          structureFilters.put(root,structureFilter);
        }
      }
    }
    final List<String> possibleReferencies=commentFilterEmpty ? null : Arrays.asList(myPreviousFilter.split("[\\s]"));
    myMediator.reload(new RootsHolder(myRootsUnderVcs),startingPoints,new GitLogFilters(comment,userFilters,structureFilters,possibleReferencies));
  }
  myCommentSearchContext.addHighlighter(myDetailsPanel.getHtmlHighlighter());
  updateMoreVisibility();
  mySelectionRequestsMerger.request();
  fireTableRepaint();
  myTableModel.fireTableRowsDeleted(0,was);
}
