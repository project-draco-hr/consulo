{
  if (myDataBeingAdded)   return;
  myMissingSelectionData=false;
  final int[] rows=myJBTable.getSelectedRows();
  if (rows.length == 1) {
    final CommitI commitI=myTableModel.getCommitAt(rows[0]);
    if (commitI != null && (!commitI.holdsDecoration())) {
      final VirtualFile root=commitI.selectRepository(myRootsUnderVcs);
      final GitCommit convert=myDetailsCache.convert(root,commitI.getHash());
      if (convert != null) {
        myDetails.refresh(root,convert);
      }
    }
  }
  final List<GitCommit> commits=new ArrayList<GitCommit>();
  final MultiMap<VirtualFile,AbstractHash> missingHashes=new MultiMap<VirtualFile,AbstractHash>();
  for (int i=rows.length - 1; i >= 0; --i) {
    final int row=rows[i];
    final CommitI commitI=myTableModel.getCommitAt(row);
    if (commitI == null || commitI.holdsDecoration())     continue;
    VirtualFile root=commitI.selectRepository(myRootsUnderVcs);
    AbstractHash hash=commitI.getHash();
    final GitCommit details=myDetailsCache.convert(root,hash);
    commits.add(details);
    myMissingSelectionData|=details == null;
    missingHashes.putValue(root,hash);
  }
  if (myMissingSelectionData) {
    myDetailsCache.acceptQuestion(missingHashes);
    return;
  }
  final List<Change> changes=new ArrayList<Change>();
  for (  GitCommit commit : commits) {
    changes.addAll(commit.getChanges());
  }
  final List<Change> zipped=CommittedChangesTreeBrowser.zipChanges(changes);
  myRepositoryChangesBrowser.setChangesToDisplay(zipped);
  myRepoLayout.show(myRepoPanel,"main");
  myRepoPanel.repaint();
}
