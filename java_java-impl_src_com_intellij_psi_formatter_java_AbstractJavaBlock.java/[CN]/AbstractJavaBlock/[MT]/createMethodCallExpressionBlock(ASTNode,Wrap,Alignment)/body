{
  final ArrayList<ASTNode> nodes=new ArrayList<ASTNode>();
  final ArrayList<Block> subBlocks=new ArrayList<Block>();
  collectNodes(nodes,node);
  final Wrap wrap=Wrap.createWrap(getWrapType(mySettings.METHOD_CALL_CHAIN_WRAP),false);
  Alignment chainedCallsAlignment=createAlignment(mySettings.ALIGN_MULTILINE_CHAINED_METHODS,null);
  boolean callPointDefined=false;
  while (!nodes.isEmpty()) {
    ArrayList<ASTNode> subNodes=readToNextDot(nodes);
    Alignment alignmentToUseForSubBlock=null;
    if (chainedCallsAlignment == null || subNodes.isEmpty()) {
      subBlocks.add(createSyntheticBlock(subNodes,wrap,alignmentToUseForSubBlock));
      continue;
    }
    IElementType lastNodeType=subNodes.get(subNodes.size() - 1).getElementType();
    boolean currentSubBlockIsMethodCall=lastNodeType == JavaElementType.EXPRESSION_LIST;
    if (callPointDefined && !currentSubBlockIsMethodCall) {
      chainedCallsAlignment=createAlignment(mySettings.ALIGN_MULTILINE_CHAINED_METHODS,null);
    }
    callPointDefined|=!currentSubBlockIsMethodCall;
    if (callPointDefined && currentSubBlockIsMethodCall) {
      alignmentToUseForSubBlock=chainedCallsAlignment;
    }
    subBlocks.add(createSyntheticBlock(subNodes,wrap,alignmentToUseForSubBlock));
  }
  return new SyntheticCodeBlock(subBlocks,alignment,mySettings,Indent.getContinuationWithoutFirstIndent(myIndentSettings.USE_RELATIVE_INDENTS),blockWrap);
}
