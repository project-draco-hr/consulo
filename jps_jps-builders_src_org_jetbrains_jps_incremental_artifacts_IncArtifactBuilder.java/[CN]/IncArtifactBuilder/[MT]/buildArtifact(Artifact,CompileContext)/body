{
  final BuildDataManager dataManager=context.getDataManager();
  try {
    final ArtifactSourceFilesState state=dataManager.getArtifactsBuildData().getOrCreateState(artifact,context.getProject(),context.getRootsIndex());
    state.initState(dataManager);
    final Set<String> deletedFiles=state.getDeletedFiles();
    final Map<String,IntArrayList> changedFiles=state.getChangedFiles();
    if (deletedFiles.isEmpty() && changedFiles.isEmpty()) {
      return;
    }
    context.processMessage(new ProgressMessage("Building artifact '" + artifact.getName() + "'..."));
    final ArtifactSourceToOutputMapping srcOutMapping=state.getOrCreateSrcOutMapping();
    final ArtifactOutputToSourceMapping outSrcMapping=state.getOrCreateOutSrcMapping();
    final TIntObjectHashMap<Set<String>> filesToProcess=new TIntObjectHashMap<Set<String>>();
    MultiMap<String,String> filesToDelete=new MultiMap<String,String>();
    for (    String sourcePath : deletedFiles) {
      final List<String> outputPaths=srcOutMapping.getState(sourcePath);
      if (outputPaths != null) {
        for (        String outputPath : outputPaths) {
          filesToDelete.putValue(outputPath,sourcePath);
          final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
          if (sources != null) {
            for (            ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
              addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
            }
          }
        }
      }
    }
    Set<String> changedOutputPaths=new THashSet<String>();
    for (    Map.Entry<String,IntArrayList> entry : changedFiles.entrySet()) {
      final IntArrayList roots=entry.getValue();
      final String sourcePath=entry.getKey();
      for (int i=0; i < roots.size(); i++) {
        addFileToProcess(filesToProcess,roots.get(i),sourcePath,deletedFiles);
      }
      final List<String> outputPaths=srcOutMapping.getState(sourcePath);
      if (outputPaths != null) {
        changedOutputPaths.addAll(outputPaths);
        for (        String outputPath : outputPaths) {
          final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
          if (sources != null) {
            for (            ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
              addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
            }
          }
        }
      }
    }
    for (    String sourcePath : changedFiles.keySet()) {
      srcOutMapping.remove(sourcePath);
    }
    for (    String outputPath : changedOutputPaths) {
      outSrcMapping.remove(outputPath);
    }
    deleteOutdatedFiles(filesToDelete,context,srcOutMapping,outSrcMapping);
    context.checkCanceled();
    final ArtifactInstructionsBuilder instructions=state.getOrCreateInstructions();
    final Set<JarInfo> changedJars=new THashSet<JarInfo>();
    instructions.processRoots(new ArtifactRootProcessor(){
      @Override public boolean process(      ArtifactSourceRoot root,      int rootIndex,      Collection<DestinationInfo> destinations) throws IOException {
        if (context.isCanceled())         return false;
        final Set<String> sourcePaths=filesToProcess.get(rootIndex);
        if (sourcePaths == null)         return true;
        for (        String sourcePath : sourcePaths) {
          if (!root.containsFile(sourcePath,dataManager))           continue;
          for (          DestinationInfo destination : destinations) {
            if (destination instanceof ExplodedDestinationInfo) {
              root.copyFromRoot(sourcePath,rootIndex,destination.getOutputPath(),context,srcOutMapping,outSrcMapping);
            }
 else             if (outSrcMapping.getState(destination.getOutputFilePath()) == null) {
              outSrcMapping.update(destination.getOutputFilePath(),Collections.<ArtifactOutputToSourceMapping.SourcePathAndRootIndex>emptyList());
              changedJars.add(((JarDestinationInfo)destination).getJarInfo());
            }
          }
        }
        return true;
      }
    }
);
    context.checkCanceled();
    JarsBuilder builder=new JarsBuilder(changedJars,context,srcOutMapping,outSrcMapping,instructions);
    final boolean processed=builder.buildJars();
    if (!processed) {
      return;
    }
    state.updateTimestamps();
    state.markUpToDate();
    context.processMessage(UptoDateFilesSavedEvent.INSTANCE);
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
}
