{
  JpsArtifact artifact=target.getArtifact();
  String outputFilePath=artifact.getOutputFilePath();
  if (StringUtil.isEmpty(outputFilePath)) {
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,"Cannot build '" + artifact.getName() + "' artifact: output path is not specified"));
    return;
  }
  final ProjectDescriptor pd=context.getProjectDescriptor();
  final ArtifactSorter sorter=new ArtifactSorter(pd.getModel());
  final Map<JpsArtifact,JpsArtifact> selfIncludingNameMap=sorter.getArtifactToSelfIncludingNameMap();
  final JpsArtifact selfIncluding=selfIncludingNameMap.get(artifact);
  if (selfIncluding != null) {
    String name=selfIncluding.equals(artifact) ? "it" : "'" + selfIncluding.getName() + "' artifact";
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,"Cannot build '" + artifact.getName() + "' artifact: "+ name+ " includes itself in the output layout"));
    return;
  }
  try {
    final Collection<String> deletedFiles=holder.getRemovedFiles(target);
    String messageText="Building artifact '" + artifact.getName() + "'...";
    context.processMessage(new ProgressMessage(messageText));
    LOG.debug(messageText);
    runArtifactTasks(context,target.getArtifact(),ArtifactBuildTaskProvider.ArtifactBuildPhase.PRE_PROCESSING);
    final SourceToOutputMapping srcOutMapping=pd.dataManager.getSourceToOutputMap(target);
    final ArtifactOutputToSourceMapping outSrcMapping=pd.dataManager.getStorage(target,ArtifactOutToSourceStorageProvider.INSTANCE);
    final TIntObjectHashMap<Set<String>> filesToProcess=new TIntObjectHashMap<Set<String>>();
    final MultiMap<String,String> filesToDelete=new MultiMap<String,String>();
    for (    String sourcePath : deletedFiles) {
      final Collection<String> outputPaths=srcOutMapping.getOutputs(sourcePath);
      if (outputPaths != null) {
        for (        String outputPath : outputPaths) {
          filesToDelete.putValue(outputPath,sourcePath);
          final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
          if (sources != null) {
            for (            ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
              addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
            }
          }
        }
      }
    }
    final Set<String> changedOutputPaths=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
    holder.processDirtyFiles(new FileProcessor<ArtifactRootDescriptor,ArtifactBuildTarget>(){
      @Override public boolean apply(      ArtifactBuildTarget target,      File file,      ArtifactRootDescriptor root) throws IOException {
        int rootIndex=root.getRootIndex();
        String sourcePath=FileUtil.toSystemIndependentName(file.getPath());
        addFileToProcess(filesToProcess,rootIndex,sourcePath,deletedFiles);
        final Collection<String> outputPaths=srcOutMapping.getOutputs(sourcePath);
        if (outputPaths != null) {
          changedOutputPaths.addAll(outputPaths);
          for (          String outputPath : outputPaths) {
            filesToDelete.putValue(outputPath,sourcePath);
            final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
            if (sources != null) {
              for (              ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
                addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
              }
            }
          }
        }
        return true;
      }
    }
);
    BuildOperations.cleanOutputsCorrespondingToChangedFiles(context,holder);
    for (    String outputPath : changedOutputPaths) {
      outSrcMapping.remove(outputPath);
    }
    if (filesToDelete.isEmpty() && filesToProcess.isEmpty()) {
      return;
    }
    deleteOutdatedFiles(filesToDelete,context,srcOutMapping,outSrcMapping);
    context.checkCanceled();
    final Set<JarInfo> changedJars=new THashSet<JarInfo>();
    for (    ArtifactRootDescriptor descriptor : pd.getBuildRootIndex().getTargetRoots(target,context)) {
      context.checkCanceled();
      final Set<String> sourcePaths=filesToProcess.get(descriptor.getRootIndex());
      if (sourcePaths == null)       continue;
      for (      String sourcePath : sourcePaths) {
        if (!descriptor.getFilter().shouldBeCopied(sourcePath,pd)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("File " + sourcePath + " will be skipped because it isn't accepted by filter");
          }
          continue;
        }
        DestinationInfo destination=descriptor.getDestinationInfo();
        if (destination instanceof ExplodedDestinationInfo) {
          descriptor.copyFromRoot(sourcePath,descriptor.getRootIndex(),destination.getOutputPath(),context,outputConsumer,outSrcMapping);
        }
 else {
          List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(destination.getOutputFilePath());
          if (sources == null || sources.size() > 0 && sources.get(0).getRootIndex() == descriptor.getRootIndex()) {
            outSrcMapping.update(destination.getOutputFilePath(),Collections.<ArtifactOutputToSourceMapping.SourcePathAndRootIndex>emptyList());
            changedJars.add(((JarDestinationInfo)destination).getJarInfo());
          }
        }
      }
    }
    context.checkCanceled();
    JarsBuilder builder=new JarsBuilder(changedJars,context,outputConsumer,outSrcMapping);
    builder.buildJars();
    runArtifactTasks(context,artifact,ArtifactBuildTaskProvider.ArtifactBuildPhase.POST_PROCESSING);
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
}
