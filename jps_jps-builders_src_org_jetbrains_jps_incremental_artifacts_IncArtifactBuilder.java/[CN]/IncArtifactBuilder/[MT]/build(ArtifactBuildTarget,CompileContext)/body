{
  JpsArtifact artifact=target.getArtifact();
  if (StringUtil.isEmpty(artifact.getOutputPath())) {
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,"Cannot build '" + artifact.getName() + "' artifact: output path is not specified"));
    return;
  }
  final ProjectDescriptor pd=context.getProjectDescriptor();
  final ArtifactSorter sorter=new ArtifactSorter(pd.jpsModel);
  final Map<JpsArtifact,JpsArtifact> selfIncludingNameMap=sorter.getArtifactToSelfIncludingNameMap();
  final JpsArtifact selfIncluding=selfIncludingNameMap.get(artifact);
  if (selfIncluding != null) {
    String name=selfIncluding.equals(artifact) ? "it" : "'" + selfIncluding.getName() + "' artifact";
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,"Cannot build '" + artifact.getName() + "' artifact: "+ name+ " includes itself in the output layout"));
    return;
  }
  try {
    final ArtifactSourceFilesState state=pd.dataManager.getArtifactsBuildData().getOrCreateState(target,pd);
    state.ensureFsStateInitialized(pd.dataManager,context);
    final Collection<String> deletedFiles=pd.fsState.getAndClearDeletedPaths(target);
    final Map<BuildRootDescriptor,Set<File>> filesToRecompile=pd.fsState.getSourcesToRecompile(context,target);
    if (deletedFiles.isEmpty() && filesToRecompile.isEmpty()) {
      state.markUpToDate(context);
      return;
    }
    context.processMessage(new ProgressMessage("Building artifact '" + artifact.getName() + "'..."));
    final SourceToOutputMapping srcOutMapping=pd.dataManager.getSourceToOutputMap(target);
    final ArtifactOutputToSourceMapping outSrcMapping=state.getOrCreateOutSrcMapping();
    final TIntObjectHashMap<Set<String>> filesToProcess=new TIntObjectHashMap<Set<String>>();
    MultiMap<String,String> filesToDelete=new MultiMap<String,String>();
    for (    String sourcePath : deletedFiles) {
      final Collection<String> outputPaths=srcOutMapping.getOutputs(sourcePath);
      if (outputPaths != null) {
        for (        String outputPath : outputPaths) {
          filesToDelete.putValue(outputPath,sourcePath);
          final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
          if (sources != null) {
            for (            ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
              addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
            }
          }
        }
      }
    }
    Set<String> changedOutputPaths=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
    for (    Map.Entry<BuildRootDescriptor,Set<File>> entry : filesToRecompile.entrySet()) {
      int rootIndex=((ArtifactRootDescriptor)entry.getKey()).getRootIndex();
      for (      File file : entry.getValue()) {
        String sourcePath=FileUtil.toSystemIndependentName(file.getPath());
        addFileToProcess(filesToProcess,rootIndex,sourcePath,deletedFiles);
        final Collection<String> outputPaths=srcOutMapping.getOutputs(sourcePath);
        if (outputPaths != null) {
          changedOutputPaths.addAll(outputPaths);
          for (          String outputPath : outputPaths) {
            filesToDelete.putValue(outputPath,sourcePath);
            final List<ArtifactOutputToSourceMapping.SourcePathAndRootIndex> sources=outSrcMapping.getState(outputPath);
            if (sources != null) {
              for (              ArtifactOutputToSourceMapping.SourcePathAndRootIndex source : sources) {
                addFileToProcess(filesToProcess,source.getRootIndex(),source.getPath(),deletedFiles);
              }
            }
          }
        }
      }
    }
    for (    Set<File> files : filesToRecompile.values()) {
      for (      File file : files) {
        srcOutMapping.remove(file.getPath());
      }
    }
    for (    String outputPath : changedOutputPaths) {
      outSrcMapping.remove(outputPath);
    }
    deleteOutdatedFiles(filesToDelete,context,srcOutMapping,outSrcMapping);
    context.checkCanceled();
    final Set<JarInfo> changedJars=new THashSet<JarInfo>();
    for (    ArtifactRootDescriptor descriptor : pd.getBuildRootIndex().getTargetRoots(target,context)) {
      context.checkCanceled();
      final Set<String> sourcePaths=filesToProcess.get(descriptor.getRootIndex());
      if (sourcePaths == null)       continue;
      for (      String sourcePath : sourcePaths) {
        DestinationInfo destination=descriptor.getDestinationInfo();
        if (destination instanceof ExplodedDestinationInfo) {
          descriptor.copyFromRoot(sourcePath,descriptor.getRootIndex(),destination.getOutputPath(),context,srcOutMapping,outSrcMapping);
        }
 else         if (outSrcMapping.getState(destination.getOutputFilePath()) == null) {
          outSrcMapping.update(destination.getOutputFilePath(),Collections.<ArtifactOutputToSourceMapping.SourcePathAndRootIndex>emptyList());
          changedJars.add(((JarDestinationInfo)destination).getJarInfo());
        }
      }
    }
    context.checkCanceled();
    JarsBuilder builder=new JarsBuilder(changedJars,context,srcOutMapping,outSrcMapping);
    final boolean processed=builder.buildJars();
    if (processed && !Utils.errorsDetected(context) && !context.getCancelStatus().isCanceled()) {
      state.markUpToDate(context);
    }
  }
 catch (  IOException e) {
    throw new ProjectBuildException(e);
  }
}
