{
  if (deletedFiles.isEmpty())   return Collections.emptySet();
  context.processMessage(new ProgressMessage("Deleting outdated files..."));
  Set<String> pathsToDelete=new THashSet<String>();
  for (  String path : deletedFiles) {
    final String[] outputPaths=mapping.getState(path);
    Collections.addAll(pathsToDelete,outputPaths);
  }
  int notDeletedFilesCount=0;
  final THashSet<String> notDeletedJars=new THashSet<String>();
  final THashSet<String> deletedJars=new THashSet<String>();
  for (  String fullPath : pathsToDelete) {
    int end=fullPath.indexOf(JarPathUtil.JAR_SEPARATOR);
    boolean isJar=end != -1;
    String filePath=isJar ? fullPath.substring(0,end) : fullPath;
    boolean deleted=false;
    if (isJar) {
      if (notDeletedJars.contains(filePath)) {
        continue;
      }
      deleted=deletedJars.contains(filePath);
    }
    File file=new File(FileUtil.toSystemDependentName(filePath));
    if (!deleted) {
      deleted=FileUtil.delete(file);
    }
    if (deleted) {
      context.getLoggingManager().getArtifactBuilderLogger().fileDeleted(filePath);
      if (isJar) {
        deletedJars.add(filePath);
      }
    }
 else {
      if (isJar) {
        notDeletedJars.add(filePath);
      }
      if (notDeletedFilesCount++ > 50) {
        context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.WARNING,"Deletion of outdated files stopped because too many files cannot be deleted"));
        break;
      }
      context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.WARNING,"Cannot delete file '" + filePath + "'"));
    }
  }
  return deletedJars;
}
