{
  if (filesToDelete.isEmpty())   return;
  context.processMessage(new ProgressMessage("Deleting outdated files..."));
  int notDeletedFilesCount=0;
  final THashSet<String> notDeletedPaths=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
  final THashSet<String> deletedPaths=new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY);
  for (  String filePath : filesToDelete.keySet()) {
    if (notDeletedPaths.contains(filePath)) {
      continue;
    }
    boolean deleted=deletedPaths.contains(filePath);
    if (!deleted) {
      deleted=FileUtil.delete(new File(filePath));
    }
    if (deleted) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Outdated output file deleted: " + filePath);
      }
      outSrcMapping.remove(filePath);
      deletedPaths.add(filePath);
      for (      String sourcePath : filesToDelete.get(filePath)) {
        srcOutMapping.removeOutput(sourcePath,filePath);
      }
    }
 else {
      notDeletedPaths.add(filePath);
      if (notDeletedFilesCount++ > 50) {
        context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.WARNING,"Deletion of outdated files stopped because too many files cannot be deleted"));
        break;
      }
      context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.WARNING,"Cannot delete file '" + filePath + "'"));
    }
  }
  ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
  if (logger.isEnabled()) {
    logger.logDeletedFiles(deletedPaths);
  }
}
