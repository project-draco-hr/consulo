{
  final PsiElement[] elements=getElementsIntersectingRange(myFile,myStartOffset,myEndOffset);
  final int chunkSize=Math.max(10,tools.length / Runtime.getRuntime().availableProcessors() / 10);
  List<Runnable> inspectionChunks=new ArrayList<Runnable>();
  for (int v=0; v < tools.length; v+=chunkSize) {
    final int index=v;
    Runnable chunk=new Runnable(){
      public void run(){
        if (progress != null) {
          if (progress.isCanceled())           return;
          ((ProgressManagerImpl)ProgressManager.getInstance()).progressMe(progress);
        }
        @NonNls final String name="LocalInspections from " + index + " to "+ (index + chunkSize);
        PassExecutorService.info(progress,"Started ",name);
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            ProblemsHolder holder=new ProblemsHolder(iManager);
            try {
              for (int i=index; i < index + chunkSize && i < tools.length; i++) {
                LocalInspectionTool tool=tools[i];
                PsiElementVisitor elementVisitor=tool.buildVisitor(holder,true);
                for (                PsiElement element : elements) {
                  if (progress != null) {
                    progress.checkCanceled();
                  }
                  element.accept(elementVisitor);
                }
                if (holder.hasResults()) {
                  appendDescriptors(holder.getResults(),tool,progress);
                }
              }
            }
 catch (            ProcessCanceledException e) {
              PassExecutorService.info(progress,"Canceled ",name);
            }
          }
        }
);
        PassExecutorService.info(progress,"Finished ",name);
      }
    }
;
    inspectionChunks.add(chunk);
  }
  try {
    ConcurrencyUtil.invokeAll(inspectionChunks,myExecutorService);
  }
 catch (  ProcessCanceledException e) {
  }
catch (  Throwable e) {
    LOG.error(e);
  }
  inspectInjectedPsi(elements);
}
