{
  final PsiElement[] elements=getElementsIntersectingRange(myFile,myStartOffset,myEndOffset);
  final int chunkSize=Math.max(10,tools.length / Runtime.getRuntime().availableProcessors() / 10);
  List<Callable<Boolean>> inspectionChunks=new ArrayList<Callable<Boolean>>();
  for (int v=0; v < tools.length; v+=chunkSize) {
    final int index=v;
    Callable<Boolean> chunk=new Callable<Boolean>(){
      public Boolean call() throws Exception {
        if (progress != null) {
          if (progress.isCanceled())           return false;
        }
        final ProgressManager progressManager=ProgressManager.getInstance();
        ((ProgressManagerImpl)progressManager).executeProcessUnderProgress(new Runnable(){
          public void run(){
            @NonNls final String name="LocalInspections from " + index + " to "+ (index + chunkSize);
            PassExecutorService.log(progress,"Started ",name);
            ApplicationManager.getApplication().runReadAction(new Runnable(){
              public void run(){
                ProblemsHolder holder=new ProblemsHolder(iManager);
                try {
                  for (int i=index; i < index + chunkSize && i < tools.length; i++) {
                    LocalInspectionTool tool=tools[i];
                    PsiElementVisitor elementVisitor=tool.buildVisitor(holder,isOnTheFly);
                    if (elementVisitor == null) {
                      LOG.error("Tool " + tool + " must not return null from the buildVisitor() method");
                    }
                    for (                    PsiElement element : elements) {
                      progressManager.checkCanceled();
                      element.accept(elementVisitor);
                    }
                    if (holder.hasResults()) {
                      appendDescriptors(holder.getResults(),tool);
                    }
                  }
                }
 catch (                ProcessCanceledException e) {
                  PassExecutorService.log(progress,"Canceled ",name);
                }
              }
            }
);
            PassExecutorService.log(progress,"Finished ",name);
          }
        }
,progress);
        return true;
      }
    }
;
    inspectionChunks.add(chunk);
  }
  try {
    ConcurrencyUtil.invokeAll(inspectionChunks,myExecutorService);
  }
 catch (  ProcessCanceledException e) {
  }
catch (  Throwable e) {
    LOG.error(e);
  }
  inspectInjectedPsi(elements);
}
