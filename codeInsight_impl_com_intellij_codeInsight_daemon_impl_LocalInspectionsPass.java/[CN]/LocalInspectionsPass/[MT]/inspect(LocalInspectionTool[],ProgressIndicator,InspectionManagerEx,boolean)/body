{
  final PsiElement[] elements=getElementsIntersectingRange(myFile,myStartOffset,myEndOffset);
  final Job<?> job=JobScheduler.getInstance().createJob("Inspection tools",Job.DEFAULT_PRIORITY);
  for (  final LocalInspectionTool tool : tools) {
    job.addTask(new Runnable(){
      public void run(){
        if (progress != null) {
          if (progress.isCanceled()) {
            job.cancel();
            return;
          }
        }
        final ProgressManager progressManager=ProgressManager.getInstance();
        ((ProgressManagerImpl)progressManager).executeProcessUnderProgress(new Runnable(){
          public void run(){
            ApplicationManager.getApplication().assertReadAccessAllowed();
            ProblemsHolder holder=new ProblemsHolder(iManager);
            try {
              progressManager.checkCanceled();
              PsiElementVisitor elementVisitor=tool.buildVisitor(holder,isOnTheFly);
              if (elementVisitor == null) {
                LOG.error("Tool " + tool + " must not return null from the buildVisitor() method");
              }
              for (              PsiElement element : elements) {
                progressManager.checkCanceled();
                element.accept(elementVisitor);
              }
              advanceProgress(elements.length);
              if (holder.hasResults()) {
                appendDescriptors(holder.getResults(),tool);
              }
            }
 catch (            ProcessCanceledException e) {
              job.cancel();
            }
          }
        }
,progress);
      }
    }
);
  }
  setProgressLimit(1L * tools.length * elements.length);
  try {
    job.scheduleAndWaitForResults();
    if (job.isCanceled())     return;
  }
 catch (  ProcessCanceledException e) {
    return;
  }
catch (  Throwable e) {
    LOG.error(e);
  }
  inspectInjectedPsi(elements,tools);
  myInfos=new ArrayList<HighlightInfo>(myDescriptors.size());
  addHighlightsFromDescriptors(myInfos);
  addHighlightsFromInjectedPsiProblems(myInfos);
}
