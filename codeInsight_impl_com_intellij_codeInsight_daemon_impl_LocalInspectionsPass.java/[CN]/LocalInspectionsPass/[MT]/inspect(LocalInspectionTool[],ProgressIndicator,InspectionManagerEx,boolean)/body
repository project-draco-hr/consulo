{
  if (tools.length == 0)   return;
  final PsiElement[] elements=getElementsIntersectingRange(myFile,myStartOffset,myEndOffset);
  final Job<?> job=JobScheduler.getInstance().createJob("Inspection tools",Job.DEFAULT_PRIORITY);
  setProgressLimit(1L * tools.length * elements.length);
  JobUtil.invokeConcurrentlyForAll(tools,new Processor<LocalInspectionTool>(){
    public boolean process(    final LocalInspectionTool tool){
      if (progress != null) {
        if (progress.isCanceled()) {
          return false;
        }
      }
      final ProgressManager progressManager=ProgressManager.getInstance();
      ((ProgressManagerImpl)progressManager).executeProcessUnderProgress(new Runnable(){
        public void run(){
          ApplicationManager.getApplication().assertReadAccessAllowed();
          ProblemsHolder holder=new ProblemsHolder(iManager);
          try {
            progressManager.checkCanceled();
            PsiElementVisitor elementVisitor=tool.buildVisitor(holder,isOnTheFly);
            if (elementVisitor == null) {
              LOG.error("Tool " + tool + " must not return null from the buildVisitor() method");
            }
            for (            PsiElement element : elements) {
              progressManager.checkCanceled();
              element.accept(elementVisitor);
            }
            advanceProgress(elements.length);
            if (holder.hasResults()) {
              appendDescriptors(holder.getResults(),tool);
            }
          }
 catch (          ProcessCanceledException e) {
            job.cancel();
          }
        }
      }
,progress);
      return true;
    }
  }
,"Inspection tools");
  inspectInjectedPsi(elements,tools);
  myInfos=new ArrayList<HighlightInfo>(myDescriptors.size());
  addHighlightsFromDescriptors(myInfos);
  addHighlightsFromInjectedPsiProblems(myInfos);
}
