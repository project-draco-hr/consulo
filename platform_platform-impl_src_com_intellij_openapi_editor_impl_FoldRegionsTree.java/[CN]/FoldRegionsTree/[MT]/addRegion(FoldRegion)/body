{
  final boolean canUseCachedValue=myCachedLastIndex != -1 && isBatchFoldingProcessing() && myRegions.get(myCachedLastIndex).getStartOffset() <= range.getStartOffset();
  int fastIndex=canUseCachedValue ? myCachedLastIndex + 1 : Collections.binarySearch(myRegions,range,RangeMarker.BY_START_OFFSET);
  if (fastIndex < 0)   fastIndex=-fastIndex - 1;
  if (fastIndex < myRegions.size()) {
    FoldRegion foldRegion=myRegions.get(fastIndex);
    if (TextRange.areSegmentsEqual(foldRegion,range)) {
      removeRegion(foldRegion);
      return addRegion(range);
    }
  }
  for (int i=fastIndex - 1; i >= 0; --i) {
    final FoldRegion region=myRegions.get(i);
    if (region.getEndOffset() < range.getStartOffset())     break;
    if (region.isValid() && intersects(region,range)) {
      return false;
    }
  }
  for (int i=fastIndex; i < myRegions.size(); i++) {
    final FoldRegion region=myRegions.get(i);
    if (range.getStartOffset() < region.getStartOffset() || range.getStartOffset() == region.getStartOffset() && range.getEndOffset() > region.getEndOffset()) {
      for (int j=i + 1; j < myRegions.size(); j++) {
        final FoldRegion next=myRegions.get(j);
        if (next.getEndOffset() >= range.getEndOffset() && next.isValid()) {
          if (next.getStartOffset() < range.getStartOffset()) {
            return false;
          }
 else {
            break;
          }
        }
      }
      myRegions.add(myCachedLastIndex=i,range);
      return true;
    }
  }
  myRegions.add(myCachedLastIndex=myRegions.size(),range);
  return true;
}
