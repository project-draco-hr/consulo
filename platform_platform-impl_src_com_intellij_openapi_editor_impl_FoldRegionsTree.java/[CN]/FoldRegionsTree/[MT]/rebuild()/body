{
  List<FoldRegion> topLevels=new ArrayList<FoldRegion>(myRegions.size() / 2);
  List<FoldRegion> visible=new ArrayList<FoldRegion>(myRegions.size());
  List<FoldRegion> allValid=new ArrayList<FoldRegion>(myRegions.size());
  THashMap<FoldRegion,FoldRegion> distinctRegions=new THashMap<FoldRegion,FoldRegion>(myRegions.size(),OFFSET_BASED_HASHING_STRATEGY);
  for (  FoldRegion region : myRegions) {
    if (!region.isValid()) {
      continue;
    }
    if (distinctRegions.contains(region)) {
      if (region.getUserData(VISIBLE) == null) {
        region.dispose();
        continue;
      }
 else {
        FoldRegion identicalRegion=distinctRegions.remove(region);
        identicalRegion.dispose();
      }
    }
    distinctRegions.put(region,region);
  }
  for (  FoldRegion region : myRegions) {
    if (region.isValid()) {
      allValid.add(region);
    }
  }
  if (allValid.size() < myRegions.size()) {
    myRegions=allValid;
  }
  Collections.sort(myRegions,RangeMarker.BY_START_OFFSET);
  FoldRegion currentCollapsed=null;
  for (  FoldRegion region : myRegions) {
    if (!region.isExpanded()) {
      removeRegionsWithSameStartOffset(visible,region);
      removeRegionsWithSameStartOffset(topLevels,region);
    }
    if (currentCollapsed == null || !contains(currentCollapsed,region)) {
      visible.add(region);
      region.putUserData(VISIBLE,Boolean.TRUE);
      if (!region.isExpanded()) {
        currentCollapsed=region;
        topLevels.add(region);
      }
    }
 else {
      region.putUserData(VISIBLE,null);
    }
  }
  FoldRegion[] topLevelRegions=toFoldArray(topLevels);
  FoldRegion[] visibleRegions=toFoldArray(visible);
  Arrays.sort(topLevelRegions,BY_END_OFFSET);
  Arrays.sort(visibleRegions,BY_END_OFFSET_REVERSE);
  updateCachedOffsets(visibleRegions,topLevelRegions);
}
