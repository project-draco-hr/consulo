{
  myTypeParameterReplacements=buildTypeParameterReplacements();
  List<PsiClass> inheritors=new ArrayList<PsiClass>();
  for (int i=0; i < usages.length; i++) {
    final UsageInfo usage=usages[i];
    if (usage instanceof MethodCallUsageInfo) {
      processMethodCall((MethodCallUsageInfo)usage);
    }
 else     if (usage instanceof ParameterUsageInfo) {
      processParameterUsage((ParameterUsageInfo)usage);
    }
 else     if (usage instanceof ImplementingClassUsageInfo) {
      inheritors.add(((ImplementingClassUsageInfo)usage).getPsiClass());
    }
  }
  prepareTypeParameterReplacement();
  myTargetParameter.delete();
  ChangeContextUtil.encodeContextInfo(myMethod,true);
  if (!myTargetClass.isInterface()) {
    addMethodToClass(myTargetClass);
  }
 else {
    final PsiMethod interfaceMethod=addMethodToClass(myTargetClass);
    RefactoringUtil.abstractizeMethod(myTargetClass,interfaceMethod);
    for (Iterator<PsiClass> iterator=inheritors.iterator(); iterator.hasNext(); ) {
      final PsiClass psiClass=iterator.next();
      final PsiMethod newMethod=addMethodToClass(psiClass);
      newMethod.getModifierList().setModifierProperty((myNewVisibility != null ? myNewVisibility : PsiModifier.PUBLIC),true);
    }
  }
  myMethod.delete();
}
