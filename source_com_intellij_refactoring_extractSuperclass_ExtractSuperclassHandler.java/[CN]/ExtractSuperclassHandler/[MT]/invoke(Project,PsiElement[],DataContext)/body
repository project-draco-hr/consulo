{
  if (elements.length != 1)   return;
  myProject=project;
  mySubclass=(PsiClass)elements[0];
  if (!mySubclass.isWritable()) {
    RefactoringMessageUtil.showReadOnlyElementRefactoringMessage(project,mySubclass);
    return;
  }
  if (mySubclass.isInterface()) {
    String message="Cannot perform the refactoring.\n" + "Superclass cannot be extracted from an interface.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.EXTRACT_SUPERCLASS,project);
    return;
  }
  final MemberInfo[] memberInfos=MemberInfo.extractClassMembers(mySubclass,new MemberInfo.Filter(){
    public boolean includeMember(    PsiMember element){
      if (element instanceof PsiMethod) {
        return !((PsiMethod)element).isConstructor();
      }
 else {
        return true;
      }
    }
  }
);
  final String targetPackageName=(mySubclass.getContainingFile() instanceof PsiJavaFile) ? ((PsiJavaFile)mySubclass.getContainingFile()).getPackageName() : null;
  final ExtractSuperclassDialog dialog=new ExtractSuperclassDialog(project,mySubclass,memberInfos,targetPackageName,ExtractSuperclassHandler.this);
  dialog.show();
  if (!dialog.isOK() || !dialog.isExtractSuperclass())   return;
  CommandProcessor.getInstance().executeCommand(myProject,new Runnable(){
    public void run(){
      final Runnable action=new Runnable(){
        public void run(){
          doRefactoring(project,mySubclass,dialog);
        }
      }
;
      ApplicationManager.getApplication().runWriteAction(action);
    }
  }
,"Extract Superclass",null);
}
