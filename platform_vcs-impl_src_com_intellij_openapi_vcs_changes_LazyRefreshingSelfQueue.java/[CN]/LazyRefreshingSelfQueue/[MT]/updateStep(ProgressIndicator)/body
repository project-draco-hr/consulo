{
  final List<T> dirty=new LinkedList<T>();
  final long startTime=System.currentTimeMillis() - myUpdateInterval;
  boolean onlyAbsolute=true;
synchronized (myLock) {
    for (    Pair<Long,T> pair : myQueue) {
      if (pair.getFirst() != null) {
        onlyAbsolute=pair.getFirst() > startTime;
        break;
      }
    }
  }
  final Boolean shouldUpdateOld=onlyAbsolute ? false : myShouldUpdateOldChecker.compute();
synchronized (myLock) {
    while (!myQueue.isEmpty()) {
      pi.checkCanceled();
      final Pair<Long,T> pair=myQueue.get(0);
      if (pair.getFirst() == null) {
        dirty.add(myQueue.removeFirst().getSecond());
      }
 else {
        break;
      }
    }
    if (Boolean.TRUE.equals(shouldUpdateOld) && (!myQueue.isEmpty())) {
      while (!myQueue.isEmpty()) {
        final Pair<Long,T> pair=myQueue.get(0);
        if (pair.getFirst() < startTime) {
          myQueue.removeFirst();
          dirty.add(pair.getSecond());
        }
 else {
          break;
        }
      }
    }
    myInProgress.addAll(dirty);
  }
  LOG.debug("found something to update: " + (!dirty.isEmpty()));
  for (  T t : dirty) {
    ProgressManager.checkCanceled();
    myUpdater.consume(t);
synchronized (myLock) {
      if (myInProgress.remove(t)) {
        myQueue.addLast(new Pair<Long,T>(System.currentTimeMillis(),t));
      }
    }
  }
}
