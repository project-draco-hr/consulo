{
  boolean success=true;
  for (  Map.Entry<Module,MyModuleData> entry : moduleDataMap.entrySet()) {
    final Module module=entry.getKey();
    final MyModuleData moduleData=entry.getValue();
    final AndroidFacet facet=moduleData.getFacet();
    final File generatedSourcesDir=AndroidJpsUtil.getGeneratedSourcesStorage(module);
    final File aptOutputDirectory=new File(generatedSourcesDir,AndroidJpsUtil.AAPT_GENERATED_SOURCE_ROOT_NAME);
    final IAndroidTarget target=moduleData.getPlatform().getTarget();
    try {
      if (!needToRunAaptCompilation(facet)) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context)) {
          success=false;
        }
        continue;
      }
      final String[] resPaths=AndroidJpsUtil.collectResourceDirsForCompilation(facet,false,context);
      if (resPaths.length == 0) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context)) {
          success=false;
        }
        continue;
      }
      final String packageName=moduleData.getPackage();
      final File manifestFile=moduleData.getManifestFileForCompiler();
      if (isLibraryWithBadCircularDependency(facet)) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context)) {
          success=false;
        }
        continue;
      }
      final Map<Module,String> packageMap=getDepLibPackages(module);
      packageMap.put(module,packageName);
      final Module circularDepLibWithSamePackage=findCircularDependencyOnLibraryWithSamePackage(facet,packageMap);
      if (circularDepLibWithSamePackage != null && !facet.isLibrary()) {
        final String message="Generated fields in " + packageName + ".R class in module '"+ module.getName()+ "' won't be final, because of circular dependency on module '"+ circularDepLibWithSamePackage.getName()+ "'";
        context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.WARNING,message));
      }
      final boolean generateNonFinalFields=facet.isLibrary() || circularDepLibWithSamePackage != null;
      final Map<String,ResourceFileData> resources=collectResources(resPaths);
      final List<ResourceEntry> manifestElements=collectManifestElements(manifestFile);
      final Set<String> depLibPackagesSet=new HashSet<String>(packageMap.values());
      depLibPackagesSet.remove(packageName);
      final AndroidAptValidityState newState=new AndroidAptValidityState(resources,manifestElements,depLibPackagesSet,packageName);
      if (context.isMake()) {
        final AndroidAptValidityState oldState=storage.getState(module.getName());
        if (newState.equalsTo(oldState)) {
          continue;
        }
      }
      if (!clearDirectory(aptOutputDirectory,context)) {
        success=false;
        continue;
      }
      context.processMessage(new ProgressMessage(AndroidJpsBundle.message("android.jps.progress.aapt",module.getName())));
      final Map<AndroidCompilerMessageKind,List<String>> messages=AndroidApt.compile(target,-1,manifestFile.getPath(),packageName,aptOutputDirectory.getPath(),resPaths,ArrayUtil.toStringArray(depLibPackagesSet),generateNonFinalFields);
      AndroidJpsUtil.addMessages(context,messages,BUILDER_NAME);
      if (messages.get(AndroidCompilerMessageKind.ERROR).size() > 0) {
        success=false;
        storage.update(module.getName(),null);
      }
 else {
        storage.update(module.getName(),newState);
        markDirtyRecursively(aptOutputDirectory,context);
      }
    }
 catch (    IOException e) {
      AndroidJpsUtil.reportExceptionError(context,null,e,BUILDER_NAME);
      success=false;
    }
  }
  return success;
}
