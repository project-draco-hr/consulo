{
  boolean success=true;
  for (  Map.Entry<Module,MyModuleData> entry : moduleDataMap.entrySet()) {
    final Module module=entry.getKey();
    final MyModuleData moduleData=entry.getValue();
    final AndroidFacet facet=moduleData.getFacet();
    final File generatedSourcesDir=AndroidJpsUtil.getGeneratedSourcesStorage(module);
    final File aptOutputDirectory=new File(generatedSourcesDir,AndroidJpsUtil.AAPT_GENERATED_SOURCE_ROOT_NAME);
    final IAndroidTarget target=moduleData.getPlatform().getTarget();
    try {
      if (!needToRunAaptCompilation(facet)) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context,ANDROID_APT_COMPILER)) {
          success=false;
        }
        continue;
      }
      final String[] resPaths=AndroidJpsUtil.collectResourceDirsForCompilation(facet,false,context);
      if (resPaths.length == 0) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context,ANDROID_APT_COMPILER)) {
          success=false;
        }
        continue;
      }
      final String packageName=moduleData.getPackage();
      final File manifestFile=moduleData.getManifestFileForCompiler();
      if (isLibraryWithBadCircularDependency(facet)) {
        if (!clearDirectoryIfNotEmpty(aptOutputDirectory,context,ANDROID_APT_COMPILER)) {
          success=false;
        }
        continue;
      }
      final Map<Module,String> packageMap=getDepLibPackages(module);
      packageMap.put(module,packageName);
      final Module circularDepLibWithSamePackage=findCircularDependencyOnLibraryWithSamePackage(facet,packageMap);
      if (circularDepLibWithSamePackage != null && !facet.isLibrary()) {
        final String message="Generated fields in " + packageName + ".R class in module '"+ module.getName()+ "' won't be final, because of circular dependency on module '"+ circularDepLibWithSamePackage.getName()+ "'";
        context.processMessage(new CompilerMessage(ANDROID_APT_COMPILER,BuildMessage.Kind.WARNING,message));
      }
      final boolean generateNonFinalFields=facet.isLibrary() || circularDepLibWithSamePackage != null;
      final Map<String,ResourceFileData> resources=collectResources(resPaths);
      final List<ResourceEntry> manifestElements=collectManifestElements(manifestFile);
      final Set<String> depLibPackagesSet=new HashSet<String>(packageMap.values());
      depLibPackagesSet.remove(packageName);
      final String proguardOutputCfgFilePath;
      if (toLaunchProGuard(context,facet)) {
        final File outputDirForArtifacts=AndroidJpsUtil.getDirectoryForIntermediateArtifacts(context,module);
        if (AndroidJpsUtil.createDirIfNotExist(outputDirForArtifacts,context,BUILDER_NAME) == null) {
          success=false;
          continue;
        }
        proguardOutputCfgFilePath=new File(outputDirForArtifacts,AndroidCommonUtils.PROGUARD_CFG_OUTPUT_FILE_NAME).getPath();
      }
 else {
        proguardOutputCfgFilePath=null;
      }
      final AndroidAptValidityState newState=new AndroidAptValidityState(resources,manifestElements,depLibPackagesSet,packageName,proguardOutputCfgFilePath);
      if (context.isMake()) {
        final AndroidAptValidityState oldState=storage.getState(module.getName());
        if (newState.equalsTo(oldState)) {
          continue;
        }
      }
      context.processMessage(new ProgressMessage(AndroidJpsBundle.message("android.jps.progress.aapt",module.getName())));
      File tmpOutputDir=null;
      try {
        tmpOutputDir=FileUtil.createTempDirectory("android_apt_output","tmp");
        final Map<AndroidCompilerMessageKind,List<String>> messages=AndroidApt.compile(target,-1,manifestFile.getPath(),packageName,tmpOutputDir.getPath(),resPaths,ArrayUtil.toStringArray(depLibPackagesSet),generateNonFinalFields,proguardOutputCfgFilePath);
        AndroidJpsUtil.addMessages(context,messages,ANDROID_APT_COMPILER,module.getName());
        if (messages.get(AndroidCompilerMessageKind.ERROR).size() > 0) {
          success=false;
          storage.update(module.getName(),null);
        }
 else {
          if (!AndroidCommonUtils.directoriesContainSameContent(tmpOutputDir,aptOutputDirectory,JavaFilesFilter.INSTANCE)) {
            if (!deleteAndMarkRecursively(aptOutputDirectory,context,ANDROID_APT_COMPILER)) {
              success=false;
              continue;
            }
            final File parent=aptOutputDirectory.getParentFile();
            if (parent != null && !parent.exists() && !parent.mkdirs()) {
              context.processMessage(new CompilerMessage(ANDROID_APT_COMPILER,BuildMessage.Kind.ERROR,AndroidJpsBundle.message("android.jps.cannot.create.directory",parent.getPath())));
              success=false;
              continue;
            }
            FileUtil.copyDir(tmpOutputDir,aptOutputDirectory);
            markDirtyRecursively(aptOutputDirectory,context,ANDROID_APT_COMPILER);
          }
          storage.update(module.getName(),newState);
        }
      }
  finally {
        if (tmpOutputDir != null) {
          FileUtil.delete(tmpOutputDir);
        }
      }
    }
 catch (    IOException e) {
      AndroidJpsUtil.reportExceptionError(context,null,e,ANDROID_APT_COMPILER);
      success=false;
    }
  }
  return success;
}
