{
  super(BuildProperties.getJ2EEExplodedBuildTargetName(chunk.getName()),null,CompilerBundle.message("generated.ant.build.build.exploded.dir.for.module.description",chunk.getName()),null);
  final Module module=chunk.getModules()[0];
  final ArrayList<Tag> tags=new ArrayList<Tag>();
  BuildRecipe buildRecipe=DeploymentUtil.getInstance().getModuleItems(moduleBuildProperties.getModule());
  buildRecipe.visitInstructions(new BuildInstructionVisitor(){
    public boolean visitFileCopyInstruction(    FileCopyInstruction instruction) throws RuntimeException {
      if (instruction.isExternalDependencyInstruction())       return true;
      final File sourceFile=instruction.getFile();
      final String outputRelativePath="/" + instruction.getOutputRelativePath();
      final String explodedPathProperty=BuildProperties.getJ2EEExplodedPathProperty();
      final String sourceLocation=GenerationUtils.toRelativePath(sourceFile.getPath(),moduleBaseDir,BuildProperties.getModuleBasedirProperty(instruction.getModule()),genOptions,!module.isSavePathsRelative());
      final Copy copy;
      if (instruction.isDirectory()) {
        copy=new Copy(BuildProperties.propertyRef(explodedPathProperty) + outputRelativePath);
        final FileSet fileSet=new FileSet(sourceLocation);
        copy.add(fileSet);
      }
 else {
        copy=new Copy(sourceLocation,BuildProperties.propertyRef(explodedPathProperty) + outputRelativePath);
      }
      tags.add(copy);
      return true;
    }
    public boolean visitJarAndCopyBuildInstruction(    JarAndCopyBuildInstruction instruction) throws RuntimeException {
      if (instruction.isExternalDependencyInstruction())       return true;
      final String outputRelativePath=instruction.getOutputRelativePath();
      final String explodedPathProperty=BuildProperties.getJ2EEExplodedPathProperty();
      final String destFile=BuildProperties.propertyRef(explodedPathProperty) + outputRelativePath;
      final @NonNls String jarDirProperty="jar.dir";
      tags.add(new Dirname(jarDirProperty,destFile));
      tags.add(new Mkdir(BuildProperties.propertyRef(jarDirProperty)));
      tags.add(generateJarTag(instruction,destFile,moduleBaseDir,genOptions));
      return true;
    }
    public boolean visitJ2EEModuleBuildInstruction(    JavaeeModuleBuildInstruction instruction) throws RuntimeException {
      if (instruction.isExternalDependencyInstruction())       return true;
      final String outputRelativePath="/" + instruction.getOutputRelativePath();
      final String explodedPathProperty=BuildProperties.getJ2EEExplodedPathProperty();
      final String outputPath=BuildProperties.propertyRef(explodedPathProperty) + outputRelativePath;
      final String moduleName=instruction.getBuildProperties().getModule().getName();
      final Tag tag;
      if (instruction.getBuildProperties().isExplodedEnabled()) {
        tag=new Copy(outputPath);
        tag.add(new FileSet(BuildProperties.propertyRef(BuildProperties.getJ2EEExplodedPathProperty(moduleName))));
      }
 else {
        tag=new AntCall(BuildProperties.getJ2EEExplodedBuildTargetName(moduleName));
        tag.add(new Param(BuildProperties.getJ2EEExplodedPathProperty(),outputPath));
      }
      tags.add(tag);
      return true;
    }
  }
,true);
  for (  Tag tag : tags) {
    add(tag);
  }
}
