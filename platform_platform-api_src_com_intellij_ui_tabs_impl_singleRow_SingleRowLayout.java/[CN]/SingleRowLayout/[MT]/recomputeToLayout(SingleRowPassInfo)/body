{
  data.toFitLength=getStrategy().getToFitLength(data);
  if (myTabs.isGhostsAlwaysVisible()) {
    data.toFitLength-=myTabs.getGhostTabLength() * 2 + (myTabs.getInterTabSpaceLength() * 2);
  }
  for (  TabInfo eachInfo : data.myVisibleInfos) {
    data.requiredLength+=getStrategy().getLengthIncrement(myTabs.myInfo2Label.get(eachInfo).getPreferredSize()) + (myTabs.isEditorTabs() ? myTabs.getInterTabSpaceLength() : 0);
    data.toLayout.add(eachInfo);
  }
  while (true) {
    if (data.requiredLength <= data.toFitLength - data.position)     break;
    if (data.toLayout.size() == 0)     break;
    final TabInfo first=data.toLayout.get(0);
    final TabInfo last=data.toLayout.get(data.toLayout.size() - 1);
    if (myRowDropPolicy == RowDropPolicy.first) {
      if (first != myTabs.getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else       if (last != myTabs.getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else {
        break;
      }
    }
 else {
      if (last != myTabs.getSelectedInfo()) {
        processDrop(data,last,false);
      }
 else       if (first != myTabs.getSelectedInfo()) {
        processDrop(data,first,true);
      }
 else {
        break;
      }
    }
  }
  for (int i=1; i < data.myVisibleInfos.size() - 1; i++) {
    final TabInfo each=data.myVisibleInfos.get(i);
    final TabInfo prev=data.myVisibleInfos.get(i - 1);
    final TabInfo next=data.myVisibleInfos.get(i + 1);
    if (data.toLayout.contains(each) && data.toDrop.contains(prev)) {
      myLeftGhost.setInfo(prev);
    }
 else     if (data.toLayout.contains(each) && data.toDrop.contains(next)) {
      myRightGhost.setInfo(next);
    }
  }
}
