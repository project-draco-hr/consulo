{
  ExternalSystemManager<?,?,?,?,?> manager=ExternalSystemApiUtil.getManager(externalSystemId);
  if (manager == null) {
    return;
  }
  AbstractExternalSystemSettings<?,?,?> settings=manager.getSettingsProvider().fun(project);
  final Collection<? extends ExternalProjectSettings> projectsSettings=settings.getLinkedProjectsSettings();
  if (projectsSettings.isEmpty()) {
    return;
  }
  final ProjectDataManager projectDataManager=ServiceManager.getService(ProjectDataManager.class);
  final int[] counter=new int[1];
  ExternalProjectRefreshCallback callback=new ExternalProjectRefreshCallback(){
    @NotNull private final Set<String> myExternalModulePaths=ContainerUtilRt.newHashSet();
    @Override public void onSuccess(    @Nullable final DataNode<ProjectData> externalProject){
      if (externalProject == null) {
        return;
      }
      Collection<DataNode<ModuleData>> moduleNodes=ExternalSystemApiUtil.findAll(externalProject,ProjectKeys.MODULE);
      for (      DataNode<ModuleData> node : moduleNodes) {
        myExternalModulePaths.add(node.getData().getLinkedExternalProjectPath());
      }
      ExternalSystemApiUtil.executeProjectChangeAction(true,new DisposeAwareProjectChange(project){
        @Override public void execute(){
          ProjectRootManagerEx.getInstanceEx(project).mergeRootsChangesDuring(new Runnable(){
            @Override public void run(){
              projectDataManager.importData(externalProject.getKey(),Collections.singleton(externalProject),project,true);
            }
          }
);
          processOrphanProjectLibraries();
        }
      }
);
      if (--counter[0] <= 0) {
        processOrphanModules();
      }
    }
    @Override public void onFailure(    @NotNull String errorMessage,    @Nullable String errorDetails){
      counter[0]=Integer.MAX_VALUE;
    }
    private void processOrphanModules(){
      if (ExternalSystemDebugEnvironment.DEBUG_ORPHAN_MODULES_PROCESSING) {
        LOG.info(String.format("Checking for orphan modules. External paths returned by external system: '%s'",myExternalModulePaths));
      }
      PlatformFacade platformFacade=ServiceManager.getService(PlatformFacade.class);
      List<Module> orphanIdeModules=ContainerUtilRt.newArrayList();
      String externalSystemIdAsString=externalSystemId.toString();
      for (      Module module : platformFacade.getModules(project)) {
        String s=module.getOptionValue(ExternalSystemConstants.EXTERNAL_SYSTEM_ID_KEY);
        String p=module.getOptionValue(ExternalSystemConstants.LINKED_PROJECT_PATH_KEY);
        if (ExternalSystemDebugEnvironment.DEBUG_ORPHAN_MODULES_PROCESSING) {
          LOG.info(String.format("IDE module: EXTERNAL_SYSTEM_ID_KEY - '%s', LINKED_PROJECT_PATH_KEY - '%s'.",s,p));
        }
        if (externalSystemIdAsString.equals(s) && !myExternalModulePaths.contains(p)) {
          orphanIdeModules.add(module);
          if (ExternalSystemDebugEnvironment.DEBUG_ORPHAN_MODULES_PROCESSING) {
            LOG.info(String.format("External paths doesn't contain IDE module LINKED_PROJECT_PATH_KEY anymore => add to orphan IDE modules."));
          }
        }
      }
      if (!orphanIdeModules.isEmpty()) {
        ruleOrphanModules(orphanIdeModules,project,externalSystemId);
      }
    }
    private void processOrphanProjectLibraries(){
      PlatformFacade platformFacade=ServiceManager.getService(PlatformFacade.class);
      List<Library> orphanIdeLibraries=ContainerUtilRt.newArrayList();
      LibraryTable projectLibraryTable=platformFacade.getProjectLibraryTable(project);
      for (      Library library : projectLibraryTable.getLibraries()) {
        if (!ExternalSystemApiUtil.isExternalSystemLibrary(library,externalSystemId))         continue;
        if (ProjectStructureHelper.isOrphanProjectLibrary(library,platformFacade.getModules(project))) {
          orphanIdeLibraries.add(library);
        }
      }
      for (      Library orphanIdeLibrary : orphanIdeLibraries) {
        projectLibraryTable.removeLibrary(orphanIdeLibrary);
      }
    }
  }
;
  Map<String,Long> modificationStamps=manager.getLocalSettingsProvider().fun(project).getExternalConfigModificationStamps();
  Set<String> toRefresh=ContainerUtilRt.newHashSet();
  for (  ExternalProjectSettings setting : projectsSettings) {
    Long oldModificationStamp=modificationStamps.get(setting.getExternalProjectPath());
    long currentModificationStamp=getTimeStamp(setting.getExternalProjectPath(),externalSystemId);
    if (force || currentModificationStamp < 0 || oldModificationStamp == null || oldModificationStamp < currentModificationStamp) {
      toRefresh.add(setting.getExternalProjectPath());
    }
  }
  if (!toRefresh.isEmpty()) {
    counter[0]=toRefresh.size();
    for (    String path : toRefresh) {
      refreshProject(project,externalSystemId,path,callback,false,progressExecutionMode);
    }
  }
}
