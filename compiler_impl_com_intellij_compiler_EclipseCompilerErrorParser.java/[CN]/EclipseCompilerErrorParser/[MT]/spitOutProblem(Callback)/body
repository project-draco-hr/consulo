{
  final String problem=problemText.toString();
  if (problem.trim().length() == 0)   return;
  @NonNls final String problemTemplate="(\\d*)\\. (\\w*) in (.*)\n" + "\\s*\\(at line (\\d*)\\)\n" + "\\s*(.*)\n"+ "(\\s*)\\^+\n"+ "(.*)\\s*";
  final Pattern PATTERN=Pattern.compile(problemTemplate,Pattern.DOTALL);
  Matcher matcher=PATTERN.matcher(problem);
  if (matcher.matches()) {
    String seqN=matcher.group(1);
    @NonNls String problemType=matcher.group(2);
    String path=matcher.group(3);
    String lineNum=matcher.group(4);
    String codeSnippet=matcher.group(5);
    String indentWhiteSpace=matcher.group(6);
    String message=matcher.group(7);
    CompilerMessageCategory messageCategory;
    if ("WARNING".equals(problemType)) {
      messageCategory=CompilerMessageCategory.WARNING;
    }
 else     if ("ERROR".equals(problemType)) {
      messageCategory=CompilerMessageCategory.ERROR;
    }
 else {
      messageCategory=CompilerMessageCategory.INFORMATION;
    }
    final String url=VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL,FileUtil.toSystemIndependentName(path));
    final int line=Integer.parseInt(lineNum);
    int col=indentWhiteSpace.length();
    final String offendingCode=codeSnippet.substring(col - 1);
    callback.message(messageCategory,message,url,line,col);
  }
 else {
    callback.message(CompilerMessageCategory.WARNING,problem,null,-1,-1);
  }
}
