{
  final Ref<Boolean> start=new Ref<Boolean>(Boolean.TRUE);
  final Application application=ApplicationManager.getApplication();
  LOG.assertTrue(!application.isDispatchThread());
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  Runnable runnable1=new Runnable(){
    public void run(){
      try {
        runnable.run();
      }
  finally {
        semaphore.up();
      }
    }
    @NonNls public String toString(){
      return "PeriodicalTaskCloser's invoke and wait [" + runnable.toString() + "]";
    }
  }
;
  LaterInvocator.invokeLater(runnable1,modalityState,new Condition<Object>(){
    public boolean value(    Object o){
synchronized (start) {
        return !start.get();
      }
    }
  }
);
  while (true) {
    if (semaphore.waitFor(1000)) {
      return;
    }
    final Ref<Boolean> fire=new Ref<Boolean>();
    if (project != null) {
synchronized (ourLock) {
        final Boolean state=myStates.get(project);
        if (!Boolean.TRUE.equals(state)) {
          fire.set(Boolean.TRUE);
        }
        if (Boolean.TRUE.equals(fire.get())) {
synchronized (start) {
            start.set(Boolean.FALSE);
            return;
          }
        }
      }
    }
  }
}
