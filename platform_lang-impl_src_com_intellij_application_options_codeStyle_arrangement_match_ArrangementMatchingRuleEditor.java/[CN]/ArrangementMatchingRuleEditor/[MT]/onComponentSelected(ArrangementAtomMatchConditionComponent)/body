{
  ArrangementAtomMatchCondition chosenCondition=component.getMatchCondition();
  boolean remove=myRuleInfo.hasCondition(chosenCondition.getValue());
  component.setSelected(!remove);
  repaintComponent(component);
  if (remove) {
    myRuleInfo.removeCondition(chosenCondition.getValue());
    ensureConsistency();
    updateState();
    return;
  }
  Collection<Set<?>> mutexes=myFilter.getMutexes();
  for (  Set<?> mutex : mutexes) {
    if (!mutex.contains(chosenCondition.getValue())) {
      continue;
    }
    for (    Object key : mutex) {
      if (myRuleInfo.hasCondition(key)) {
        ArrangementAtomMatchConditionComponent componentToDeselect=myConditionComponents.get(key);
        myRuleInfo.removeCondition(componentToDeselect.getMatchCondition().getValue());
        myRuleInfo.addAtomCondition(chosenCondition);
        ArrangementMatchCondition newCondition=myRuleInfo.buildCondition();
        for (        ArrangementAtomMatchConditionComponent componentToCheck : myConditionComponents.values()) {
          Object value=componentToCheck.getMatchCondition().getValue();
          if (myRuleInfo.hasCondition(value) && !ArrangementConfigUtil.isEnabled(value,myFilter,newCondition)) {
            myRuleInfo.removeCondition(componentToCheck.getMatchCondition().getValue());
            newCondition=myRuleInfo.buildCondition();
          }
        }
        updateState();
        return;
      }
    }
  }
  myRuleInfo.addAtomCondition(chosenCondition);
  updateState();
}
