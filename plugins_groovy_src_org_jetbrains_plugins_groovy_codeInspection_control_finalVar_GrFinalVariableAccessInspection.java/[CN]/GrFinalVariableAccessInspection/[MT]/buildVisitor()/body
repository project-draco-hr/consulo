{
  return new BaseInspectionVisitor(){
    @Override public void visitMethod(    GrMethod method){
      super.visitMethod(method);
      final GrOpenBlock block=method.getBlock();
      if (block != null) {
        processLocalVars(block);
      }
      if (method.isConstructor()) {
        processFieldsInConstructors(method);
      }
    }
    @Override public void visitFile(    GroovyFileBase file){
      super.visitFile(file);
      if (file instanceof GroovyFile && file.isScript()) {
        processLocalVars(file);
      }
    }
    @Override public void visitField(    GrField field){
      super.visitField(field);
      final GrExpression initializer=field.getInitializerGroovy();
      if (initializer != null) {
        processLocalVars(initializer);
      }
      if (field.hasModifierProperty(PsiModifier.FINAL)) {
        if (!isFieldInitialized(field)) {
          registerError(field.getNameIdentifierGroovy(),GroovyBundle.message("variable.0.might.not.have.been.initialized",field.getName()),LocalQuickFix.EMPTY_ARRAY,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }
    }
    @Override public void visitClassInitializer(    GrClassInitializer initializer){
      super.visitClassInitializer(initializer);
      processLocalVars(initializer.getBlock());
      processFieldsInClassInitializer(initializer);
    }
    private void processFieldsInConstructors(    @NotNull GrMethod constructor){
      final GrOpenBlock block=constructor.getBlock();
      if (block == null)       return;
      final GrTypeDefinition clazz=(GrTypeDefinition)constructor.getContainingClass();
      if (clazz == null)       return;
      final GrClassInitializer[] initializers=clazz.getInitializers();
      final GrField[] fields=clazz.getCodeFields();
      Set<GrVariable> initializedFields=ContainerUtil.newHashSet();
      appendFieldInitializedInDeclaration(false,fields,initializedFields);
      appendFieldsInitializedInClassInitializer(initializers,null,false,fields,initializedFields);
      appendInitializationFromChainedConstructors(constructor,fields,initializedFields);
      final Instruction[] flow=buildFlowForField(block);
      final Map<String,GrVariable> variables=buildVarMap(fields,false);
      highlightInvalidWriteAccess(flow,variables,initializedFields);
    }
    private void processFieldsInClassInitializer(    @NotNull GrClassInitializer initializer){
      final GrTypeDefinition clazz=(GrTypeDefinition)initializer.getContainingClass();
      if (clazz == null)       return;
      final boolean isStatic=initializer.isStatic();
      final GrClassInitializer[] initializers=clazz.getInitializers();
      final GrField[] fields=clazz.getCodeFields();
      Set<GrVariable> initializedFields=ContainerUtil.newHashSet();
      appendFieldInitializedInDeclaration(isStatic,fields,initializedFields);
      appendFieldsInitializedInClassInitializer(initializers,initializer,isStatic,fields,initializedFields);
      final Instruction[] flow=buildFlowForField(initializer.getBlock());
      final Map<String,GrVariable> variables=buildVarMap(fields,isStatic);
      highlightInvalidWriteAccess(flow,variables,initializedFields);
    }
    private void processLocalVars(    @NotNull GroovyPsiElement scope){
      final MultiMap<PsiElement,GrVariable> scopes=collectVariables(scope);
      for (      final Map.Entry<PsiElement,Collection<GrVariable>> entry : scopes.entrySet()) {
        final PsiElement scopeToProcess=entry.getKey();
        final Set<GrVariable> forInParameters=ContainerUtil.newHashSet();
        final Map<String,GrVariable> variables=ContainerUtil.newHashMap();
        for (        final GrVariable var : entry.getValue()) {
          variables.put(var.getName(),var);
          if (var instanceof GrParameter && ((GrParameter)var).getDeclarationScope() instanceof GrForStatement) {
            forInParameters.add(var);
          }
        }
        final Instruction[] flow=getFlow(scopeToProcess);
        highlightInvalidWriteAccess(flow,variables,forInParameters);
      }
    }
    private void highlightInvalidWriteAccess(    @NotNull Instruction[] flow,    @NotNull Map<String,GrVariable> variables,    @NotNull Set<GrVariable> initializedVariables){
      final List<ReadWriteVariableInstruction> result=InvalidWriteAccessSearcher.findInvalidWriteAccess(flow,variables,initializedVariables);
      if (result == null)       return;
      for (      final ReadWriteVariableInstruction instruction : result) {
        if (variables.containsKey(instruction.getVariableName())) {
          registerError(instruction.getElement(),GroovyBundle.message("cannot.assign.a.value.to.final.field.0",instruction.getVariableName()),LocalQuickFix.EMPTY_ARRAY,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
        }
      }
    }
  }
;
}
