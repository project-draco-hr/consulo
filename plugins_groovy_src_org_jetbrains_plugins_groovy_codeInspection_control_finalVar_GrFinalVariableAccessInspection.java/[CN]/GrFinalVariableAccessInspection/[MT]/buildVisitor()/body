{
  return new BaseInspectionVisitor(){
    @Override public void visitMethod(    GrMethod method){
      super.visitMethod(method);
      final GrOpenBlock block=method.getBlock();
      if (block != null) {
        processLocalVars(block);
      }
      if (method.isConstructor()) {
        processFieldsInConstructors(method);
      }
    }
    @Override public void visitFile(    GroovyFileBase file){
      super.visitFile(file);
      if (file instanceof GroovyFile && file.isScript()) {
        processLocalVars(file);
      }
    }
    @Override public void visitField(    GrField field){
      super.visitField(field);
      final GrExpression initializer=field.getInitializerGroovy();
      if (initializer != null) {
        processLocalVars(initializer);
      }
      if (field.hasModifierProperty(PsiModifier.FINAL)) {
        checkFieldIsInitialized(field);
      }
    }
    private void checkFieldIsInitialized(    @NotNull GrField field){
      if (!isFieldInitialized(field)) {
        registerError(field.getNameIdentifierGroovy(),GroovyBundle.message("variable.0.might.not.have.been.initialized",field.getName()),LocalQuickFix.EMPTY_ARRAY,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
      }
    }
    @Override public void visitClassInitializer(    GrClassInitializer initializer){
      super.visitClassInitializer(initializer);
      final GrOpenBlock block=initializer.getBlock();
      processLocalVars(block);
      processFieldsInClassInitializer(initializer);
    }
    private void processFieldsInConstructors(    GrMethod constructor){
      final GrOpenBlock block=constructor.getBlock();
      if (block == null)       return;
      final GrTypeDefinition clazz=(GrTypeDefinition)constructor.getContainingClass();
      if (clazz == null)       return;
      final GrClassInitializer[] initializers=clazz.getInitializers();
      final GrField[] fields=clazz.getCodeFields();
      Set<GrVariable> initializedFields=ContainerUtil.newHashSet();
      appendFieldInitializedInDeclaration(false,fields,initializedFields);
      appendFieldsInitializedInClassInitializer(null,false,initializers,fields,initializedFields);
      appendInitializationFromChainedConstructors(initializedFields,constructor,fields);
      final Instruction[] flow=buildFlowForField(block);
      final Map<String,GrVariable> variables=buildVarMap(fields,false);
      final List<ReadWriteVariableInstruction> invalidWriteAccess=new InvalidWriteAccessSearcher().findInvalidWriteAccess(flow,variables,initializedFields);
      highlightInvalidWriteAccess(variables,invalidWriteAccess);
    }
    private void processFieldsInClassInitializer(    GrClassInitializer initializer){
      GrTypeDefinition clazz=(GrTypeDefinition)initializer.getContainingClass();
      if (clazz == null)       return;
      final boolean isStatic=initializer.isStatic();
      final GrClassInitializer[] initializers=clazz.getInitializers();
      final GrField[] fields=clazz.getCodeFields();
      Set<GrVariable> initializedFields=ContainerUtil.newHashSet();
      appendFieldInitializedInDeclaration(isStatic,fields,initializedFields);
      appendFieldsInitializedInClassInitializer(initializer,isStatic,initializers,fields,initializedFields);
      final Instruction[] flow=buildFlowForField(initializer.getBlock());
      final Map<String,GrVariable> variables=buildVarMap(fields,isStatic);
      final List<ReadWriteVariableInstruction> invalidWriteAccess=new InvalidWriteAccessSearcher().findInvalidWriteAccess(flow,variables,initializedFields);
      highlightInvalidWriteAccess(variables,invalidWriteAccess);
    }
    private void processLocalVars(    GroovyPsiElement scope){
      MultiMap<PsiElement,GrVariable> scopes=collectVariables(scope);
      for (      Map.Entry<PsiElement,Collection<GrVariable>> entry : scopes.entrySet()) {
        final PsiElement scopeToProcess=entry.getKey();
        final Set<GrVariable> forInParameters=ContainerUtil.newHashSet();
        final Map<String,GrVariable> variables=ContainerUtil.newHashMap();
        for (        GrVariable var : entry.getValue()) {
          variables.put(var.getName(),var);
          if (var instanceof GrParameter && ((GrParameter)var).getDeclarationScope() instanceof GrForStatement) {
            forInParameters.add(var);
          }
        }
        final List<ReadWriteVariableInstruction> result=new InvalidWriteAccessSearcher().findInvalidWriteAccess(getFlow(scopeToProcess),variables,forInParameters);
        highlightInvalidWriteAccess(variables,result);
      }
    }
    private void highlightInvalidWriteAccess(    Map<String,GrVariable> variables,    List<ReadWriteVariableInstruction> result){
      if (result != null) {
        for (        ReadWriteVariableInstruction instruction : result) {
          if (variables.containsKey(instruction.getVariableName())) {
            registerError(instruction.getElement(),GroovyBundle.message("cannot.assign.a.value.to.final.field.0",instruction.getVariableName()),LocalQuickFix.EMPTY_ARRAY,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
          }
        }
      }
    }
  }
;
}
