{
  mxGraphHierarchyEdge edge=(mxGraphHierarchyEdge)cell;
  double offsetX=0.0;
  if (edge.temp[0] != 101207) {
    int maxRank=edge.maxRank;
    int minRank=edge.minRank;
    if (maxRank == minRank) {
      maxRank=edge.source.maxRank;
      minRank=edge.target.minRank;
    }
    Iterator<Object> parallelEdges=edge.edges.iterator();
    int parallelEdgeCount=0;
    double[] jettys=jettyPositions.get(edge);
    Object source=edge.isReversed() ? edge.target.cell : edge.source.cell;
    while (parallelEdges.hasNext()) {
      Object realEdge=parallelEdges.next();
      Object realSource=layout.getGraph().getView().getVisibleTerminal(realEdge,true);
      List<mxPoint> newPoints=new ArrayList<mxPoint>(edge.x.length);
      boolean reversed=edge.isReversed();
      if (realSource != source) {
        reversed=!reversed;
      }
      if (jettys != null) {
        int arrayOffset=reversed ? 2 : 0;
        double y=reversed ? rankTopY[minRank] : rankBottomY[maxRank];
        double jetty=jettys[parallelEdgeCount * 4 + 1 + arrayOffset];
        if (reversed) {
          jetty=-jetty;
        }
        y+=jetty;
        double x=jettys[parallelEdgeCount * 4 + arrayOffset];
        if (orientation == SwingConstants.NORTH || orientation == SwingConstants.SOUTH) {
          newPoints.add(new mxPoint(x,y));
        }
 else {
          newPoints.add(new mxPoint(y,x));
        }
      }
      int loopStart=edge.x.length - 1;
      int loopLimit=-1;
      int loopDelta=-1;
      int currentRank=edge.maxRank - 1;
      if (reversed) {
        loopStart=0;
        loopLimit=edge.x.length;
        loopDelta=1;
        currentRank=edge.minRank + 1;
      }
      for (int j=loopStart; (edge.maxRank != edge.minRank) && j != loopLimit; j+=loopDelta) {
        double positionX=edge.x[j] + offsetX;
        double topChannelY=(rankTopY[currentRank] + rankBottomY[currentRank + 1]) / 2.0;
        double bottomChannelY=(rankTopY[currentRank - 1] + rankBottomY[currentRank]) / 2.0;
        if (reversed) {
          double tmp=topChannelY;
          topChannelY=bottomChannelY;
          bottomChannelY=tmp;
        }
        if (orientation == SwingConstants.NORTH || orientation == SwingConstants.SOUTH) {
          newPoints.add(new mxPoint(positionX,topChannelY));
          newPoints.add(new mxPoint(positionX,bottomChannelY));
        }
 else {
          newPoints.add(new mxPoint(topChannelY,positionX));
          newPoints.add(new mxPoint(bottomChannelY,positionX));
        }
        limitX=Math.max(limitX,positionX);
        currentRank+=loopDelta;
      }
      if (jettys != null) {
        int arrayOffset=reversed ? 2 : 0;
        double rankY=reversed ? rankBottomY[maxRank] : rankTopY[minRank];
        double jetty=jettys[parallelEdgeCount * 4 + 3 - arrayOffset];
        if (reversed) {
          jetty=-jetty;
        }
        double y=rankY - jetty;
        double x=jettys[parallelEdgeCount * 4 + 2 - arrayOffset];
        if (orientation == SwingConstants.NORTH || orientation == SwingConstants.SOUTH) {
          newPoints.add(new mxPoint(x,y));
        }
 else {
          newPoints.add(new mxPoint(y,x));
        }
      }
      if (edge.isReversed()) {
        processReversedEdge(edge,realEdge);
      }
      layout.setEdgePoints(realEdge,newPoints);
      if (offsetX == 0.0) {
        offsetX=parallelEdgeSpacing;
      }
 else       if (offsetX > 0) {
        offsetX=-offsetX;
      }
 else {
        offsetX=-offsetX + parallelEdgeSpacing;
      }
      parallelEdgeCount++;
    }
    edge.temp[0]=101207;
  }
}
