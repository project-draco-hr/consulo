{
  double y=-interRankCellSpacing;
  double lastRankMaxCellHeight=0.0;
  rankWidths=new double[model.maxRank + 1];
  rankY=new double[model.maxRank + 1];
  for (int rankValue=model.maxRank; rankValue >= 0; rankValue--) {
    double maxCellHeight=0.0;
    mxGraphHierarchyRank rank=model.ranks.get(new Integer(rankValue));
    double localX=initialX;
    boolean boundsWarning=false;
    Iterator<mxGraphAbstractHierarchyCell> iter=rank.iterator();
    while (iter.hasNext()) {
      mxGraphAbstractHierarchyCell cell=iter.next();
      if (cell.isVertex()) {
        mxGraphHierarchyNode node=(mxGraphHierarchyNode)cell;
        mxRectangle bounds=layout.getVertexBounds(node.cell);
        if (bounds != null) {
          if (orientation == SwingConstants.NORTH || orientation == SwingConstants.SOUTH) {
            cell.width=bounds.getWidth();
            cell.height=bounds.getHeight();
          }
 else {
            cell.width=bounds.getHeight();
            cell.height=bounds.getWidth();
          }
        }
 else {
          boundsWarning=true;
        }
        maxCellHeight=Math.max(maxCellHeight,cell.height);
      }
 else       if (cell.isEdge()) {
        mxGraphHierarchyEdge edge=(mxGraphHierarchyEdge)cell;
        int numEdges=1;
        if (edge.edges != null) {
          numEdges=edge.edges.size();
        }
 else {
          logger.info("edge.edges is null");
        }
        cell.width=(numEdges - 1) * parallelEdgeSpacing;
      }
      localX+=cell.width / 2.0;
      cell.setX(rankValue,localX);
      cell.setGeneralPurposeVariable(rankValue,(int)localX);
      localX+=cell.width / 2.0;
      localX+=intraCellSpacing;
      if (localX > widestRankValue) {
        widestRankValue=localX;
        widestRank=rankValue;
      }
      rankWidths[rankValue]=localX;
    }
    if (boundsWarning == true) {
      logger.info("At least one cell has no bounds");
    }
    rankY[rankValue]=y;
    double distanceToNextRank=maxCellHeight / 2.0 + lastRankMaxCellHeight / 2.0 + interRankCellSpacing;
    lastRankMaxCellHeight=maxCellHeight;
    if (orientation == SwingConstants.NORTH || orientation == SwingConstants.WEST) {
      y+=distanceToNextRank;
    }
 else {
      y-=distanceToNextRank;
    }
    iter=rank.iterator();
    while (iter.hasNext()) {
      mxGraphAbstractHierarchyCell cell=iter.next();
      cell.setY(rankValue,y);
    }
  }
}
