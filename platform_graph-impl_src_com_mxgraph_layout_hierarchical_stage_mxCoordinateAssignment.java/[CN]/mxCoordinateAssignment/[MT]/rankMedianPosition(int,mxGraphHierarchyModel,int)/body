{
  mxGraphHierarchyRank rankSet=model.ranks.get(new Integer(rankValue));
  Object[] rank=rankSet.toArray();
  WeightedCellSorter[] weightedValues=new WeightedCellSorter[rank.length];
  Map<mxGraphAbstractHierarchyCell,WeightedCellSorter> cellMap=new Hashtable<mxGraphAbstractHierarchyCell,WeightedCellSorter>(rank.length);
  for (int i=0; i < rank.length; i++) {
    mxGraphAbstractHierarchyCell currentCell=(mxGraphAbstractHierarchyCell)rank[i];
    weightedValues[i]=new WeightedCellSorter();
    weightedValues[i].cell=currentCell;
    weightedValues[i].rankIndex=i;
    cellMap.put(currentCell,weightedValues[i]);
    Collection<mxGraphAbstractHierarchyCell> nextLayerConnectedCells=null;
    if (nextRankValue < rankValue) {
      nextLayerConnectedCells=currentCell.getPreviousLayerConnectedCells(rankValue);
    }
 else {
      nextLayerConnectedCells=currentCell.getNextLayerConnectedCells(rankValue);
    }
    weightedValues[i].weightedValue=calculatedWeightedValue(currentCell,nextLayerConnectedCells);
  }
  Arrays.sort(weightedValues);
  for (int i=0; i < weightedValues.length; i++) {
    int numConnectionsNextLevel=0;
    mxGraphAbstractHierarchyCell cell=weightedValues[i].cell;
    Object[] nextLayerConnectedCells=null;
    int medianNextLevel=0;
    if (nextRankValue < rankValue) {
      nextLayerConnectedCells=cell.getPreviousLayerConnectedCells(rankValue).toArray();
    }
 else {
      nextLayerConnectedCells=cell.getNextLayerConnectedCells(rankValue).toArray();
    }
    if (nextLayerConnectedCells != null) {
      numConnectionsNextLevel=nextLayerConnectedCells.length;
      if (numConnectionsNextLevel > 0) {
        medianNextLevel=medianXValue(nextLayerConnectedCells,nextRankValue);
      }
 else {
        medianNextLevel=cell.getGeneralPurposeVariable(rankValue);
      }
    }
    double leftBuffer=0.0;
    double leftLimit=-100000000.0;
    for (int j=weightedValues[i].rankIndex - 1; j >= 0; ) {
      WeightedCellSorter weightedValue=cellMap.get(rank[j]);
      if (weightedValue != null) {
        mxGraphAbstractHierarchyCell leftCell=weightedValue.cell;
        if (weightedValue.visited) {
          leftLimit=leftCell.getGeneralPurposeVariable(rankValue) + leftCell.width / 2.0 + intraCellSpacing + leftBuffer + cell.width / 2.0;
          j=-1;
        }
 else {
          leftBuffer+=leftCell.width + intraCellSpacing;
          j--;
        }
      }
    }
    double rightBuffer=0.0;
    double rightLimit=100000000.0;
    for (int j=weightedValues[i].rankIndex + 1; j < weightedValues.length; ) {
      WeightedCellSorter weightedValue=cellMap.get(rank[j]);
      if (weightedValue != null) {
        mxGraphAbstractHierarchyCell rightCell=weightedValue.cell;
        if (weightedValue.visited) {
          rightLimit=rightCell.getGeneralPurposeVariable(rankValue) - rightCell.width / 2.0 - intraCellSpacing - rightBuffer - cell.width / 2.0;
          j=weightedValues.length;
        }
 else {
          rightBuffer+=rightCell.width + intraCellSpacing;
          j++;
        }
      }
    }
    if (medianNextLevel >= leftLimit && medianNextLevel <= rightLimit) {
      cell.setGeneralPurposeVariable(rankValue,medianNextLevel);
    }
 else     if (medianNextLevel < leftLimit) {
      cell.setGeneralPurposeVariable(rankValue,(int)leftLimit);
      currentXDelta+=leftLimit - medianNextLevel;
    }
 else     if (medianNextLevel > rightLimit) {
      cell.setGeneralPurposeVariable(rankValue,(int)rightLimit);
      currentXDelta+=medianNextLevel - rightLimit;
    }
    weightedValues[i].visited=true;
  }
}
