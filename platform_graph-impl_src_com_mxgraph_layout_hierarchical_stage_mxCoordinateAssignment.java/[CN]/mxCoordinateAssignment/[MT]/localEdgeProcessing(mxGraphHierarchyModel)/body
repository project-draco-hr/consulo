{
  Map<Object,mxGraphHierarchyEdge> edgeMapping=model.getEdgeMapper();
  if (edgeMapping != null && jettyPositions.size() != edgeMapping.size()) {
    jettyPositions=new HashMap<mxGraphHierarchyEdge,double[]>();
  }
  for (int i=0; i < model.ranks.size(); i++) {
    mxGraphHierarchyRank rank=model.ranks.get(new Integer(i));
    Iterator<mxGraphAbstractHierarchyCell> iter=rank.iterator();
    while (iter.hasNext()) {
      mxGraphAbstractHierarchyCell cell=iter.next();
      if (cell.isVertex()) {
        mxGraphAbstractHierarchyCell[] currentCells=(cell.getPreviousLayerConnectedCells(i)).toArray(new mxGraphAbstractHierarchyCell[cell.getPreviousLayerConnectedCells(i).size()]);
        int currentRank=i - 1;
        for (int k=0; k < 2; k++) {
          if (currentRank > -1 && currentRank < model.ranks.size() && currentCells != null && currentCells.length > 0) {
            WeightedCellSorter[] sortedCells=new WeightedCellSorter[currentCells.length];
            for (int j=0; j < currentCells.length; j++) {
              sortedCells[j]=new WeightedCellSorter(currentCells[j],-(int)currentCells[j].getX(currentRank));
            }
            Arrays.sort(sortedCells);
            mxGraphHierarchyNode node=(mxGraphHierarchyNode)cell;
            double leftLimit=node.x[0] - node.width / 2;
            double rightLimit=leftLimit + node.width;
            int connectedEdgeCount=0;
            int connectedEdgeGroupCount=0;
            mxGraphHierarchyEdge[] connectedEdges=new mxGraphHierarchyEdge[sortedCells.length];
            for (int j=0; j < sortedCells.length; j++) {
              mxGraphAbstractHierarchyCell innerCell=sortedCells[j].cell;
              Collection<mxGraphHierarchyEdge> connections;
              if (innerCell.isVertex()) {
                if (k == 0) {
                  connections=((mxGraphHierarchyNode)cell).connectsAsSource;
                }
 else {
                  connections=((mxGraphHierarchyNode)cell).connectsAsTarget;
                }
                for (                mxGraphHierarchyEdge connectedEdge : connections) {
                  if (connectedEdge.source == innerCell || connectedEdge.target == innerCell) {
                    connectedEdgeCount+=connectedEdge.edges.size();
                    connectedEdgeGroupCount++;
                    connectedEdges[j]=connectedEdge;
                  }
                }
              }
 else {
                connectedEdgeCount+=((mxGraphHierarchyEdge)innerCell).edges.size();
                connectedEdgeGroupCount++;
                connectedEdges[j]=(mxGraphHierarchyEdge)innerCell;
              }
            }
            double requiredWidth=(connectedEdgeCount + 1) * prefHozEdgeSep;
            if (cell.width > requiredWidth + (2 * prefHozEdgeSep)) {
              leftLimit+=prefHozEdgeSep;
              rightLimit-=prefHozEdgeSep;
            }
            double availableWidth=rightLimit - leftLimit;
            double edgeSpacing=availableWidth / connectedEdgeCount;
            double currentX=leftLimit + edgeSpacing / 2.0;
            double currentYOffset=minEdgeJetty - prefVertEdgeOff;
            double maxYOffset=0;
            for (int j=0; j < connectedEdges.length; j++) {
              int numActualEdges=connectedEdges[j].edges.size();
              double[] pos=jettyPositions.get(connectedEdges[j]);
              if (pos == null || pos.length != 4 * numActualEdges) {
                pos=new double[4 * numActualEdges];
                jettyPositions.put(connectedEdges[j],pos);
              }
              if (j < (float)connectedEdgeCount / 2.0f) {
                currentYOffset+=prefVertEdgeOff;
              }
 else               if (j > (float)connectedEdgeCount / 2.0f) {
                currentYOffset-=prefVertEdgeOff;
              }
              for (int m=0; m < numActualEdges; m++) {
                pos[m * 4 + k * 2]=currentX;
                currentX+=edgeSpacing;
                pos[m * 4 + k * 2 + 1]=currentYOffset;
              }
              maxYOffset=Math.max(maxYOffset,currentYOffset);
            }
          }
          currentCells=(cell.getNextLayerConnectedCells(i)).toArray(new mxGraphAbstractHierarchyCell[cell.getNextLayerConnectedCells(i).size()]);
          currentRank=i + 1;
        }
      }
    }
  }
}
