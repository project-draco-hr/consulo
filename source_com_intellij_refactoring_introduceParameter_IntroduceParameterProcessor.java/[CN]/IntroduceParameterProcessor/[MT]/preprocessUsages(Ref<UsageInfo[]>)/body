{
  UsageInfo[] usagesIn=refUsages.get();
  ArrayList<String> conflicts=new ArrayList<String>();
  AnySameNameVariables anySameNameVariables=new AnySameNameVariables();
  myMethodToReplaceIn.accept(anySameNameVariables);
  if (anySameNameVariables.getConflict() != null) {
    conflicts.add(anySameNameVariables.getConflict());
  }
  detectAccessibilityConflicts(usagesIn,conflicts);
  if (myParameterInitializer != null && !myMethodToReplaceIn.hasModifierProperty(PsiModifier.PRIVATE)) {
    final AnySupers anySupers=new AnySupers();
    myParameterInitializer.accept(anySupers);
    if (anySupers.isResult()) {
      for (      UsageInfo usageInfo : usagesIn) {
        if (!(usageInfo.getElement() instanceof PsiMethod) && !(usageInfo instanceof InternalUsageInfo)) {
          final PsiElement element=usageInfo.getElement();
          if (!PsiTreeUtil.isAncestor(myMethodToReplaceIn.getContainingClass(),element,false)) {
            conflicts.add("Parameter initializer contains " + ConflictsUtil.htmlEmphasize("super") + ", but not all calls to method are in its class.");
            break;
          }
        }
      }
    }
  }
  if (conflicts.size() > 0 && myPrepareSuccessfulSwingThreadCallback != null) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK())     return false;
  }
  prepareSuccessful();
  return true;
}
