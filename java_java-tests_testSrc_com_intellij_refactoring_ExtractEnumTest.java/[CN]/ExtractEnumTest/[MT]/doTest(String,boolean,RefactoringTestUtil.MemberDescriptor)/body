{
  doTest(new PerformAction(){
    @Override public void performAction(    VirtualFile rootDir,    VirtualFile rootAfter) throws Exception {
      final PsiClass aClass=myJavaFacade.findClass("Test",GlobalSearchScope.projectScope(myProject));
      assertNotNull("Class Test not found",aClass);
      final ArrayList<PsiField> fields=new ArrayList<PsiField>();
      final ArrayList<PsiMethod> methods=new ArrayList<PsiMethod>();
      final List<MemberInfo> enumConstants=new ArrayList<MemberInfo>();
      for (      MemberInfo memberInfo : RefactoringTestUtil.findMembers(aClass,memberDescriptors)) {
        final PsiMember member=memberInfo.getMember();
        if (member instanceof PsiField) {
          fields.add((PsiField)member);
          if (member.hasModifierProperty(PsiModifier.STATIC) && member.hasModifierProperty(PsiModifier.FINAL) && ((PsiField)member).hasInitializer()) {
            if (memberInfo.isToAbstract()) {
              enumConstants.add(memberInfo);
            }
          }
        }
 else         if (member instanceof PsiMethod) {
          methods.add((PsiMethod)member);
        }
      }
      try {
        final ExtractClassProcessor processor=new ExtractClassProcessor(aClass,fields,methods,new ArrayList<PsiClass>(),"",null,"EEnum",null,generateAccessors,enumConstants);
        processor.run();
        LocalFileSystem.getInstance().refresh(false);
        FileDocumentManager.getInstance().saveAllDocuments();
      }
 catch (      BaseRefactoringProcessor.ConflictsInTestsException e) {
        if (conflicts != null) {
          TreeSet expectedConflictsSet=new TreeSet(Arrays.asList(conflicts.split("\n")));
          TreeSet actualConflictsSet=new TreeSet(Arrays.asList(e.getMessage().split("\n")));
          Assert.assertEquals(expectedConflictsSet,actualConflictsSet);
          return;
        }
 else {
          fail(e.getMessage());
        }
      }
      if (conflicts != null) {
        fail("Conflicts were not detected: " + conflicts);
      }
    }
  }
);
}
