{
  if (mySignature == null)   return null;
  boolean hasReceiver=false;
  final PsiType[] parameterTypes=mySignature.getParameterTypes();
  if (parameterTypes.length > 0 && PsiMethodReferenceUtil.isReceiverType(parameterTypes[0],myContainingClass,mySubstitutor)) {
    hasReceiver=true;
  }
  final List<CandidateInfo> firstCandidates=new ArrayList<CandidateInfo>();
  final List<CandidateInfo> secondCandidates=new ArrayList<CandidateInfo>();
  for (  CandidateInfo conflict : conflicts) {
    if (!(conflict instanceof MethodCandidateInfo))     continue;
    final PsiMethod psiMethod=((MethodCandidateInfo)conflict).getElement();
    if (psiMethod == null)     continue;
    PsiSubstitutor subst=PsiSubstitutor.EMPTY;
    subst=subst.putAll(mySubstitutor);
    subst=subst.putAll(conflict.getSubstitutor());
    final PsiType[] signatureParameterTypes2=psiMethod.getSignature(subst).getParameterTypes();
    final boolean varArgs=psiMethod.isVarArgs();
    final boolean validConstructorRef=psiMethod.isConstructor() && (myContainingClass.getContainingClass() == null || myContainingClass.hasModifierProperty(PsiModifier.STATIC));
    final boolean staticOrValidConstructorRef=psiMethod.hasModifierProperty(PsiModifier.STATIC) || validConstructorRef;
    if ((parameterTypes.length == signatureParameterTypes2.length || varArgs) && (!(myBeginsWithReferenceType ^ staticOrValidConstructorRef) || (psiMethod.isConstructor() && conflict.isStaticsScopeCorrect()))) {
      boolean correct=true;
      for (int i=0; i < parameterTypes.length; i++) {
        final PsiType type1=subst.substitute(GenericsUtil.eliminateWildcards(parameterTypes[i]));
        if (varArgs && i >= signatureParameterTypes2.length - 1) {
          final PsiType type2=signatureParameterTypes2[signatureParameterTypes2.length - 1];
          correct&=TypeConversionUtil.isAssignable(type2,type1) || TypeConversionUtil.isAssignable(((PsiArrayType)type2).getComponentType(),type1);
        }
 else {
          correct&=TypeConversionUtil.isAssignable(signatureParameterTypes2[i],type1);
        }
      }
      if (correct) {
        firstCandidates.add(conflict);
      }
    }
    if (hasReceiver && parameterTypes.length == signatureParameterTypes2.length + 1 && !staticOrValidConstructorRef) {
      boolean correct=true;
      for (int i=0; i < signatureParameterTypes2.length; i++) {
        final PsiType type1=subst.substitute(GenericsUtil.eliminateWildcards(parameterTypes[i + 1]));
        final PsiType type2=signatureParameterTypes2[i];
        final boolean assignable=TypeConversionUtil.isAssignable(type2,type1);
        if (varArgs && i == signatureParameterTypes2.length - 1) {
          correct&=assignable || TypeConversionUtil.isAssignable(((PsiArrayType)type2).getComponentType(),type1);
        }
 else {
          correct&=assignable;
        }
      }
      if (correct) {
        secondCandidates.add(conflict);
      }
    }
  }
  final int acceptedCount=secondCandidates.size() + firstCandidates.size();
  if (acceptedCount != 1) {
    if (acceptedCount == 0) {
      conflicts.clear();
    }
    firstCandidates.addAll(secondCandidates);
    conflicts.retainAll(firstCandidates);
    return null;
  }
  return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);
}
