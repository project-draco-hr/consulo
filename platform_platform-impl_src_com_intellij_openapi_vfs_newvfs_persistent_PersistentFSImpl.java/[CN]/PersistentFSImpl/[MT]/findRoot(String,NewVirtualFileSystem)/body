{
  String rootUrl=normalizeRootUrl(basePath,fs);
  boolean isFakeRoot=basePath.isEmpty();
  myRootsLock.readLock().lock();
  VirtualFileSystemEntry root;
  try {
    root=isFakeRoot ? mySuperRoot : myRoots.get(rootUrl);
    if (root != null)     return root;
  }
  finally {
    myRootsLock.readLock().unlock();
  }
  myRootsLock.writeLock().lock();
  try {
    root=isFakeRoot ? mySuperRoot : myRoots.get(rootUrl);
    if (root != null)     return root;
    int rootId=FSRecords.findRootRecord(rootUrl);
    root=myRootsById.get(rootId);
    if (root != null)     return root;
    if (isFakeRoot) {
      root=new VirtualDirectoryImpl("",null,fs,rootId,0){
        @SuppressWarnings("NonSynchronizedMethodOverridesSynchronizedMethod") @Override @NotNull public VirtualFile[] getChildren(){
          return getRoots(getFileSystem());
        }
        @Override public VirtualFileSystemEntry findChild(        @NotNull String name){
          if (name.isEmpty())           return null;
          return findRoot(name,getFileSystem());
        }
        @Override protected char[] appendPathOnFileSystem(        int pathLength,        int[] position){
          String fakeName="@&^%$#*/\\(";
          int rootPathLength=pathLength + fakeName.length();
          char[] chars=new char[rootPathLength];
          position[0]=copyString(chars,position[0],fakeName);
          return chars;
        }
      }
;
    }
 else     if (fs instanceof ArchiveFileSystem) {
      String parentPath=basePath.substring(0,basePath.indexOf(ArchiveFileSystem.ARCHIVE_SEPARATOR));
      VirtualFile parentLocalFile=LocalFileSystem.getInstance().findFileByPath(parentPath);
      if (parentLocalFile == null)       return null;
      root=myRoots.get(rootUrl);
      if (root != null)       return root;
      root=myRootsById.get(rootId);
      if (root != null)       return root;
      root=new JarRoot(fs,rootId,parentLocalFile);
    }
 else {
      root=new VirtualDirectoryImpl(basePath,null,fs,rootId,0){
        @Override protected char[] appendPathOnFileSystem(        int pathLength,        int[] position){
          String name=getName();
          int nameLength=name.length();
          boolean appendSlash=SystemInfo.isWindows && nameLength == 2 && name.charAt(1) == ':';
          int rootPathLength=pathLength + nameLength;
          if (appendSlash)           ++rootPathLength;
          char[] chars=new char[rootPathLength];
          position[0]=copyString(chars,position[0],name);
          if (appendSlash) {
            chars[position[0]++]='/';
          }
          return chars;
        }
      }
;
    }
    if (isFakeRoot) {
      mySuperRoot=root;
    }
 else {
      FileAttributes attributes=fs.getAttributes(root);
      if (attributes == null || !attributes.isDirectory()) {
        return null;
      }
      final boolean newRoot=writeAttributesToRecord(rootId,0,root,fs,attributes);
      if (!newRoot && attributes.lastModified != FSRecords.getTimestamp(rootId)) {
        root.markDirtyRecursively();
      }
      myRoots.put(rootUrl,root);
      myRootsById.put(rootId,root);
      if (rootId != root.getId())       throw new AssertionError();
    }
    return root;
  }
  finally {
    myRootsLock.writeLock().unlock();
  }
}
