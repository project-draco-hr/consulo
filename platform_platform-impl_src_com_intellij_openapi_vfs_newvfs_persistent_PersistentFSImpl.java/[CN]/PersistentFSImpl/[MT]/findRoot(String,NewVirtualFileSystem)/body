{
  if (basePath.isEmpty()) {
    LOG.error("Invalid root, fs=" + fs);
    return null;
  }
  String rootUrl=normalizeRootUrl(basePath,fs);
  VirtualFileSystemEntry root=myRoots.get(rootUrl);
  if (root != null)   return root;
  final VirtualFileSystemEntry newRoot;
  int rootId=FSRecords.findRootRecord(rootUrl);
  VfsData.Segment segment=VfsData.getSegment(rootId,true);
  VfsData.DirectoryData directoryData=new VfsData.DirectoryData();
  if (fs instanceof ArchiveFileSystem) {
    String parentPath=basePath.substring(0,basePath.indexOf(ArchiveFileSystem.ARCHIVE_SEPARATOR));
    VirtualFile parentFile=LocalFileSystem.getInstance().findFileByPath(parentPath);
    if (parentFile == null)     return null;
    FileType type=FileTypeRegistry.getInstance().getFileTypeByFileName(parentFile.getName());
    if (!(type instanceof ArchiveFileType))     return null;
    newRoot=new FsRoot(rootId,segment,directoryData,fs,parentFile.getName(),parentFile.getPath() + "!");
  }
 else {
    newRoot=new FsRoot(rootId,segment,directoryData,fs,basePath,StringUtil.trimEnd(basePath,"/"));
  }
  FileAttributes attributes=fs.getAttributes(new StubVirtualFile(){
    @NotNull @Override public String getPath(){
      return newRoot.getPath();
    }
    @Nullable @Override public VirtualFile getParent(){
      return null;
    }
  }
);
  if (attributes == null || !attributes.isDirectory()) {
    return null;
  }
  boolean mark;
synchronized (myRoots) {
    root=myRoots.get(rootUrl);
    if (root != null)     return root;
    try {
      VfsData.initFile(rootId,segment,-1,directoryData);
    }
 catch (    AssertionError e) {
      for (      Map.Entry<String,VirtualFileSystemEntry> entry : myRoots.entrySet()) {
        final VirtualFileSystemEntry existingRoot=entry.getValue();
        if (Math.abs(existingRoot.getId()) == rootId) {
          throw new RuntimeException("Duplicate FS roots: " + rootUrl + " and "+ entry.getKey()+ ", id="+ rootId+ ", valid="+ existingRoot.isValid(),e);
        }
      }
      throw new RuntimeException("No root duplication",e);
    }
    incStructuralModificationCount();
    mark=writeAttributesToRecord(rootId,0,newRoot,fs,attributes);
    myRoots.put(rootUrl,newRoot);
    myRootsById.put(rootId,newRoot);
    myIdToDirCache.put(rootId,newRoot);
  }
  if (!mark && attributes.lastModified != FSRecords.getTimestamp(rootId)) {
    newRoot.markDirtyRecursively();
  }
  LOG.assertTrue(rootId == newRoot.getId(),"root=" + newRoot + " expected="+ rootId+ " actual="+ newRoot.getId());
  return newRoot;
}
