{
  final List<EventWrapper> deletionEvents=ContainerUtil.newArrayList();
  for (int i=0, size=events.size(); i < size; i++) {
    final VFileEvent event=events.get(i);
    if (event instanceof VFileDeleteEvent && event.isValid()) {
      deletionEvents.add(new EventWrapper((VFileDeleteEvent)event,i));
    }
  }
  final TIntHashSet invalidIDs;
  if (deletionEvents.isEmpty()) {
    invalidIDs=EmptyIntHashSet.INSTANCE;
  }
 else {
    ContainerUtil.quickSort(deletionEvents,DEPTH_COMPARATOR);
    invalidIDs=new TIntHashSet(deletionEvents.size());
    final Set<VirtualFile> dirsToBeDeleted=new THashSet<VirtualFile>(deletionEvents.size());
    nextEvent:     for (    EventWrapper wrapper : deletionEvents) {
      final VirtualFile candidate=wrapper.event.getFile();
      VirtualFile parent=candidate;
      while (parent != null) {
        if (dirsToBeDeleted.contains(parent)) {
          invalidIDs.add(wrapper.id);
          continue nextEvent;
        }
        parent=parent.getParent();
      }
      if (candidate.isDirectory()) {
        dirsToBeDeleted.add(candidate);
      }
    }
  }
  final List<VFileEvent> filtered=new ArrayList<VFileEvent>(events.size() - invalidIDs.size());
  for (int i=0, size=events.size(); i < size; i++) {
    final VFileEvent event=events.get(i);
    if (event.isValid() && !(event instanceof VFileDeleteEvent && invalidIDs.contains(i))) {
      filtered.add(event);
    }
  }
  return filtered;
}
