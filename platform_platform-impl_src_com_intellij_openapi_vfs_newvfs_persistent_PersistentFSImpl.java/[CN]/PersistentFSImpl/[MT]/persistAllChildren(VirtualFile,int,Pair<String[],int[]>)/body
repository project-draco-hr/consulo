{
  String[] currentNames=current.first;
  int[] currentIds=current.second;
  NewVirtualFileSystem fs=replaceWithNativeFS(getDelegate(file));
  String[] delegateNames=VfsUtil.filterNames(fs.list(file));
  if (delegateNames.length == 0 && currentNames.length > 0) {
    return current;
  }
  String[] names;
  if (currentNames.length == 0) {
    names=delegateNames;
  }
 else {
    Set<String> allNamesSet=new LinkedHashSet<String>((currentNames.length + delegateNames.length) * 2);
    ContainerUtil.addAll(allNamesSet,currentNames);
    ContainerUtil.addAll(allNamesSet,delegateNames);
    names=ArrayUtil.toStringArray(allNamesSet);
  }
  int[] childrenIds=ArrayUtil.newIntArray(names.length);
  int filter=0;
  for (int i=0; i < names.length; i++) {
    final String name=names[i];
    int idx=ArrayUtil.indexOf(currentNames,name);
    if (idx >= 0) {
      childrenIds[i]=currentIds[idx];
    }
 else {
      final FakeVirtualFile child=new FakeVirtualFile(file,name);
      final FileAttributes attributes=fs.getAttributes(child);
      if (attributes != null) {
        final int childId=createAndCopyRecord(fs,child,id,attributes);
        childrenIds[i]=childId;
      }
 else {
        childrenIds[i]=-1;
        ++filter;
        LOG.warn("fs=" + fs + " dir="+ file+ " name="+ name+ " curr="+ currentNames.length);
      }
    }
  }
  if (filter != 0) {
    final int newLength=names.length - filter;
    final String[] newNames=ArrayUtil.newStringArray(newLength);
    final int[] newIds=ArrayUtil.newIntArray(newLength);
    for (int i=0, k=0; i < names.length; i++) {
      if (childrenIds[i] >= 0) {
        newNames[k]=names[i];
        newIds[k]=childrenIds[i];
        ++k;
      }
    }
    names=newNames;
    childrenIds=newIds;
  }
  FSRecords.updateList(id,childrenIds);
  int flags=FSRecords.getFlags(id);
  FSRecords.setFlags(id,flags | CHILDREN_CACHED_FLAG,true);
  return Pair.create(names,childrenIds);
}
