{
  final ConcurrentMap<PsiElement,Object> map=new ConcurrentHashMap<PsiElement,Object>();
  return myHelper.computeExpression(e,false,new PsiConstantEvaluationHelper.AuxEvaluator(){
    public Object computeExpression(    final PsiExpression o,    final PsiConstantEvaluationHelper.AuxEvaluator auxEvaluator){
      if (o instanceof PsiMethodCallExpression) {
        final PsiMethodCallExpression c=(PsiMethodCallExpression)o;
        final PsiMethod m=(PsiMethod)c.getMethodExpression().resolve();
        final PsiType returnType=m != null ? m.getReturnType() : null;
        if (returnType != null && returnType != PsiType.VOID) {
          final Object substituted=calcSubstituted(m);
          if (substituted != null)           return substituted;
        }
      }
 else       if (o instanceof PsiReferenceExpression) {
        final PsiElement resolved=((PsiReferenceExpression)o).resolve();
        if (resolved instanceof PsiModifierListOwner) {
          final Object substituted=calcSubstituted((PsiModifierListOwner)resolved);
          if (substituted != null)           return substituted;
          if (resolved instanceof PsiVariable) {
            final Collection<PsiExpression> values=DfaUtil.getCachedVariableValues(((PsiVariable)resolved),o);
            for (            PsiExpression value : values) {
              final Object computedValue=auxEvaluator.computeExpression(value,this);
              if (computedValue != null) {
                return computedValue;
              }
            }
          }
        }
      }
      if (includeUncomputablesAsLiterals) {
        final PsiExpression expression=o instanceof PsiMethodCallExpression ? ((PsiMethodCallExpression)o).getMethodExpression() : o;
        final String text=expression.getText().replaceAll("\\s","");
        return "\"" + StringUtil.escapeStringCharacters(text) + "\"";
      }
      if (uncomputables != null)       uncomputables.add(o);
      return null;
    }
    public ConcurrentMap<PsiElement,Object> getCacheMap(    final boolean overflow){
      return map;
    }
  }
);
}
