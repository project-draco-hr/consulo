{
  final ConcurrentMap<PsiElement,Object> map=new ConcurrentHashMap<PsiElement,Object>();
  return myHelper.computeExpression(e,false,new PsiConstantEvaluationHelper.AuxEvaluator(){
    @Nullable public Object computeExpression(    final PsiExpression o,    final PsiConstantEvaluationHelper.AuxEvaluator auxEvaluator){
      PsiType resolvedType=null;
      if (o instanceof PsiMethodCallExpression) {
        final PsiMethodCallExpression c=(PsiMethodCallExpression)o;
        final PsiMethod m=(PsiMethod)c.getMethodExpression().resolve();
        final PsiType returnType=m != null ? m.getReturnType() : null;
        if (returnType != null && returnType != PsiType.VOID) {
          final Object substituted=calcSubstituted(m);
          if (substituted != null)           return substituted;
        }
        resolvedType=returnType;
      }
 else       if (o instanceof PsiReferenceExpression) {
        final PsiElement resolved=((PsiReferenceExpression)o).resolve();
        if (resolved instanceof PsiModifierListOwner) {
          final Object substituted=calcSubstituted((PsiModifierListOwner)resolved);
          if (substituted != null)           return substituted;
          if (resolved instanceof PsiVariable) {
            resolvedType=((PsiVariable)resolved).getType();
            final Collection<PsiExpression> values=!useDfa ? Collections.<PsiExpression>emptyList() : DfaUtil.getCachedVariableValues(((PsiVariable)resolved),o);
            for (            PsiExpression value : values) {
              final Object computedValue=auxEvaluator.computeExpression(value,this);
              if (computedValue != null) {
                return computedValue;
              }
            }
          }
        }
      }
      if (uncomputables != null)       uncomputables.add(o);
      if (includeUncomputablesAsLiterals) {
        if (resolvedType != null) {
          if (PsiPrimitiveType.DOUBLE.isAssignableFrom(resolvedType))           return 1;
        }
        final StringBuilder sb=new StringBuilder();
        o.accept(new PsiRecursiveElementWalkingVisitor(){
          @Override public void visitElement(          PsiElement element){
            if (element instanceof PsiExpressionList)             return;
            if (element instanceof PsiIdentifier) {
              if (sb.length() > 0)               sb.append(".");
              sb.append(element.getText());
            }
            super.visitElement(element);
          }
        }
);
        return sb.toString();
      }
      return null;
    }
    public ConcurrentMap<PsiElement,Object> getCacheMap(    final boolean overflow){
      return map;
    }
  }
);
}
