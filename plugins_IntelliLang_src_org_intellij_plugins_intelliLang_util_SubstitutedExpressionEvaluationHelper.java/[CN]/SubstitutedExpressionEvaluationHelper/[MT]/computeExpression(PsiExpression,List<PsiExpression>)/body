{
  final StringBuilder builder=new StringBuilder();
  final List<PsiExpression> list=nonConstant != null ? nonConstant : new SmartList<PsiExpression>();
  final PsiElementVisitor processor=new JavaRecursiveElementWalkingVisitor(){
    SubstitutedExpressionEvaluationHelper helper=new SubstitutedExpressionEvaluationHelper(e.getProject());
    @Override public void visitConditionalExpression(    PsiConditionalExpression expression){
      PsiExpression c=expression.getCondition();
      final Object o=helper.myHelper.computeConstantExpression(c);
      if (Boolean.TRUE.equals(o)) {
        final PsiExpression then=expression.getThenExpression();
        if (then != null) {
          execute(then);
        }
      }
 else       if (Boolean.FALSE.equals(o)) {
        final PsiExpression elseExpr=expression.getElseExpression();
        if (elseExpr != null) {
          execute(elseExpr);
        }
      }
 else       if (o == null) {
        list.add(expression);
      }
    }
    @Override public void visitLiteralExpression(    PsiLiteralExpression expression){
      execute(expression);
    }
    @Override public void visitReferenceExpression(    PsiReferenceExpression expression){
      execute(expression);
    }
    @Override public void visitMethodCallExpression(    PsiMethodCallExpression expression){
      execute(expression);
    }
    @Override public void visitAssignmentExpression(    PsiAssignmentExpression expression){
      final PsiExpression expr=expression.getRExpression();
      if (expr != null)       expr.accept(this);
    }
    public void execute(    PsiExpression e){
      final Object s=helper.computeSimpleExpression(e);
      if (s != null) {
        builder.append(String.valueOf(s));
      }
 else {
        list.add(e);
      }
    }
  }
;
  e.accept(processor);
  return list.isEmpty() ? builder.toString() : null;
}
