{
  final HashSet<PsiMember> movedMembers=new HashSet<PsiMember>();
  myMembersAfterMove=new HashSet<PsiMember>();
  for (int idx=0; idx < myMembersToMove.length; idx++) {
    PsiMember member=myMembersToMove[idx].getMember();
    movedMembers.add(member);
  }
  for (int idx=0; idx < myMembersToMove.length; idx++) {
    MemberInfo info=myMembersToMove[idx];
    if (info.getMember() instanceof PsiClass && info.getOverrides() != null)     continue;
    PsiModifierListOwner modifierListOwner=info.getMember();
    if (myIsTargetInterface) {
      modifierListOwner.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true);
    }
 else     if (modifierListOwner.hasModifierProperty(PsiModifier.PRIVATE)) {
      if (info.isToAbstract() || willBeUsedInSubclass(modifierListOwner,movedMembers,myTargetSuperClass,mySourceClass)) {
        modifierListOwner.getModifierList().setModifierProperty(PsiModifier.PROTECTED,true);
      }
    }
    ChangeContextUtil.encodeContextInfo(info.getMember(),true);
  }
  for (int idx=0; idx < myMembersToMove.length; idx++) {
    MemberInfo info=myMembersToMove[idx];
    if (info.getMember() instanceof PsiMethod) {
      PsiMethod method=(PsiMethod)info.getMember();
      final boolean isOriginalMethodAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
      if (myIsTargetInterface || info.isToAbstract()) {
        PsiMethod methodCopy=(PsiMethod)method.copy();
        ChangeContextUtil.clearContextInfo(method);
        RefactoringUtil.abstractizeMethod(myTargetSuperClass,methodCopy);
        myJavaDocPolicy.processCopiedJavaDoc(methodCopy.getDocComment(),method.getDocComment(),isOriginalMethodAbstract);
        final PsiMember movedElement=(PsiMember)myTargetSuperClass.add(methodCopy);
        myMembersAfterMove.add(movedElement);
        if (isOriginalMethodAbstract) {
          method.delete();
        }
      }
 else {
        if (isOriginalMethodAbstract) {
          myTargetSuperClass.getModifierList().setModifierProperty(PsiModifier.ABSTRACT,true);
        }
        fixReferencesToStatic(method,movedMembers);
        final PsiMethod superClassMethod=myTargetSuperClass.findMethodBySignature(method,false);
        if (superClassMethod != null && superClassMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
          superClassMethod.replace(method);
        }
 else {
          final PsiMember movedElement=(PsiMember)myTargetSuperClass.add(method);
          myMembersAfterMove.add(movedElement);
        }
        method.delete();
      }
    }
 else     if (info.getMember() instanceof PsiField) {
      PsiField field=(PsiField)info.getMember();
      field.normalizeDeclaration();
      fixReferencesToStatic(field,movedMembers);
      if (myIsTargetInterface) {
        field.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true);
      }
      final PsiMember movedElement=(PsiMember)myTargetSuperClass.add(field);
      myMembersAfterMove.add(movedElement);
      field.delete();
    }
 else     if (info.getMember() instanceof PsiClass) {
      PsiClass aClass=(PsiClass)info.getMember();
      if (Boolean.FALSE.equals(info.getOverrides())) {
        final PsiReferenceList sourceReferenceList;
        if (!mySourceClass.isInterface()) {
          sourceReferenceList=mySourceClass.getImplementsList();
        }
 else {
          sourceReferenceList=mySourceClass.getExtendsList();
        }
        PsiJavaCodeReferenceElement ref=RefactoringUtil.removeFromReferenceList(sourceReferenceList,aClass);
        if (ref != null) {
          final PsiReferenceList referenceList;
          if (!myTargetSuperClass.isInterface()) {
            referenceList=myTargetSuperClass.getImplementsList();
          }
 else {
            referenceList=myTargetSuperClass.getExtendsList();
          }
          referenceList.add(ref);
        }
      }
 else {
        fixReferencesToStatic(aClass,movedMembers);
        final PsiMember movedElement=(PsiMember)myTargetSuperClass.add(aClass);
        myMembersAfterMove.add(movedElement);
        aClass.delete();
      }
    }
  }
  ExplicitSuperDeleter explicitSuperDeleter=new ExplicitSuperDeleter();
  for (Iterator<PsiMember> iterator=myMembersAfterMove.iterator(); iterator.hasNext(); ) {
    PsiMember element=iterator.next();
    if (!(element instanceof PsiClass)) {
      element.accept(explicitSuperDeleter);
    }
  }
  explicitSuperDeleter.fixSupers();
  ChangeContextUtil.decodeContextInfo(myTargetSuperClass,null,null);
}
