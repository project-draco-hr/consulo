{
  final com.intellij.util.containers.HashMap<PsiMethod,HashSet<PsiMethod>> constructorsToSubConstructors=new com.intellij.util.containers.HashMap<PsiMethod,HashSet<PsiMethod>>();
  for (int i=0; i < constructors.length; i++) {
    PsiMethod constructor=constructors[i];
    final HashSet<PsiMethod> referencingSubConstructors=new HashSet<PsiMethod>();
    constructorsToSubConstructors.put(constructor,referencingSubConstructors);
    if (constructor != null) {
      final PsiReference[] references=myManager.getSearchHelper().findReferences(constructor,new LocalSearchScope(mySourceClass),false);
      for (int j=0; j < references.length; j++) {
        PsiReference reference=references[j];
        final PsiElement element=reference.getElement();
        if (element != null && "super".equals(element.getText())) {
          PsiMethod parentMethod=PsiTreeUtil.getParentOfType(element,PsiMethod.class);
          if (parentMethod != null && parentMethod.isConstructor()) {
            referencingSubConstructors.add(parentMethod);
          }
        }
      }
    }
    if (constructor == null || constructor.getParameterList().getParameters().length == 0) {
      RefactoringUtil.visitImplicitSuperConstructorUsages(mySourceClass,new RefactoringUtil.ImplicitConstructorUsageVisitor(){
        public void visitConstructor(        PsiMethod constructor){
          referencingSubConstructors.add(constructor);
        }
        public void visitClassWithoutConstructors(        PsiClass aClass){
        }
      }
);
    }
  }
  return constructorsToSubConstructors;
}
