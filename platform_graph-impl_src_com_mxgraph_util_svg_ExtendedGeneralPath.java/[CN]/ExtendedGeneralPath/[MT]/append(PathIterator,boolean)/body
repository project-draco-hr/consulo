{
  double[] vals=new double[6];
  while (!pi.isDone()) {
    Arrays.fill(vals,0);
    int type=pi.currentSegment(vals);
    pi.next();
    if (connect && (numVals != 0)) {
      if (type == PathIterator.SEG_MOVETO) {
        double x=vals[0];
        double y=vals[1];
        if ((x != cx) || (y != cy)) {
          type=PathIterator.SEG_LINETO;
        }
 else {
          if (pi.isDone())           break;
          type=pi.currentSegment(vals);
          pi.next();
        }
      }
      connect=false;
    }
switch (type) {
case PathIterator.SEG_CLOSE:
      closePath();
    break;
case PathIterator.SEG_MOVETO:
  moveTo((float)vals[0],(float)vals[1]);
break;
case PathIterator.SEG_LINETO:
lineTo((float)vals[0],(float)vals[1]);
break;
case PathIterator.SEG_QUADTO:
quadTo((float)vals[0],(float)vals[1],(float)vals[2],(float)vals[3]);
break;
case PathIterator.SEG_CUBICTO:
curveTo((float)vals[0],(float)vals[1],(float)vals[2],(float)vals[3],(float)vals[4],(float)vals[5]);
break;
}
}
}
