{
  buildMethodMaps();
  final CustomMethod customMethod=method.getAnnotation(CustomMethod.class);
  if (customMethod != null) {
    return createCustomMethodInvocation(customMethod,method);
  }
  final PropertyAccessor accessor=method.getAnnotation(PropertyAccessor.class);
  if (accessor != null) {
    return createPropertyAccessorInvocation(accessor);
  }
  if (myAttributeChildrenMethods.containsKey(method)) {
    return new GetAttributeChildInvocation(method);
  }
  if (myFixedChildrenMethods.containsKey(method)) {
    return new GetFixedChildInvocation(method);
  }
  String qname=myCollectionChildrenGetterMethods.get(method);
  if (qname != null) {
    return new GetCollectionChildInvocation(qname,getFixedChildrenCount(qname));
  }
  qname=myCollectionChildrenAdditionMethods.get(method);
  if (qname != null) {
    return new AddChildInvocation(getTypeGetter(method),getIndexGetter(method,getFixedChildrenCount(qname)),qname,myCollectionChildrenClasses.get(qname));
  }
  for (  final Method method1 : myClass.getMethods()) {
    if (!method1.equals(method) && method1.getName().equals(method.getName()) && Arrays.equals(method.getParameterTypes(),method1.getParameterTypes())) {
      return new Invocation(){
        public Object invoke(        final DomInvocationHandler handler,        final Object[] args) throws Throwable {
          return method1.invoke(handler,args);
        }
      }
;
    }
  }
  throw new UnsupportedOperationException("No implementation for method " + method.toString());
}
