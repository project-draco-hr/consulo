{
  if (aClass.isInterface())   return null;
  final PsiClass topLevelClass=PsiUtil.getTopLevelClass(aClass);
  if (topLevelClass == null)   return null;
  final PsiField[] fields=aClass.getFields();
  final Set<PsiField> candidates=new LinkedHashSet<PsiField>();
  for (  PsiField field : fields) {
    if (field.hasModifierProperty(PsiModifier.PRIVATE)) {
      candidates.add(field);
    }
  }
  topLevelClass.accept(new PsiRecursiveElementVisitor(){
    public void visitMethod(    PsiMethod method){
    }
    public void visitClassInitializer(    PsiClassInitializer initializer){
    }
    public void visitReferenceExpression(    PsiReferenceExpression expression){
      final PsiExpression qualifier=expression.getQualifierExpression();
      if (qualifier == null || (qualifier instanceof PsiThisExpression && ((PsiThisExpression)qualifier).getQualifier() == null)) {
        final PsiElement resolved=expression.resolve();
        if (resolved instanceof PsiField) {
          final PsiField field=(PsiField)resolved;
          if (aClass.equals(field.getContainingClass())) {
            candidates.remove(field);
          }
        }
      }
      super.visitReferenceExpression(expression);
    }
  }
);
  final Set<PsiField> usedFields=new HashSet<PsiField>();
  topLevelClass.accept(new PsiRecursiveElementVisitor(){
    public void visitElement(    PsiElement element){
      if (!candidates.isEmpty())       super.visitElement(element);
    }
    public void visitMethod(    PsiMethod method){
      super.visitMethod(method);
      final PsiCodeBlock body=method.getBody();
      if (body != null) {
        checkCodeBlock(body,candidates);
      }
    }
    public void visitClassInitializer(    PsiClassInitializer initializer){
      super.visitClassInitializer(initializer);
      checkCodeBlock(initializer.getBody(),candidates);
    }
    private void checkCodeBlock(    final PsiCodeBlock body,    final Set<PsiField> candidates){
      try {
        final ControlFlow controlFlow=ControlFlowFactory.getInstance(body.getProject()).getControlFlow(body,AllVariablesControlFlowPolicy.getInstance());
        final PsiVariable[] usedVars=ControlFlowUtil.getUsedVariables(controlFlow,0,controlFlow.getSize());
        for (        PsiVariable usedVariable : usedVars) {
          if (usedVariable instanceof PsiField) {
            final PsiField usedField=(PsiField)usedVariable;
            if (usedFields.contains(usedField)) {
              candidates.remove(usedField);
            }
 else {
              usedFields.add(usedField);
            }
          }
        }
        final List<PsiReferenceExpression> readBeforeWrites=ControlFlowUtil.getReadBeforeWrite(controlFlow);
        for (        final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {
          final PsiElement resolved=readBeforeWrite.resolve();
          if (resolved instanceof PsiField) {
            final PsiField field=(PsiField)resolved;
            candidates.remove(field);
          }
        }
      }
 catch (      AnalysisCanceledException e) {
        candidates.clear();
      }
    }
  }
);
  if (candidates.isEmpty())   return null;
  final List<ProblemDescriptor> result=new ArrayList<ProblemDescriptor>();
  final ImplicitUsageProvider[] implicitUsageProviders=Extensions.getExtensions(ImplicitUsageProvider.EP_NAME);
  for (  PsiField field : candidates) {
    if (usedFields.contains(field) && !hasImplicitReadOrWriteUsage(field,implicitUsageProviders)) {
      final String message=InspectionsBundle.message("inspection.field.can.be.local.problem.descriptor");
      result.add(manager.createProblemDescriptor(field.getNameIdentifier(),message,new MyQuickFix(field),ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
    }
  }
  return result.toArray(new ProblemDescriptor[result.size()]);
}
