{
  final Set<PsiField> candidates=new LinkedHashSet<PsiField>();
  final PsiClass topLevelClass=PsiUtil.getTopLevelClass(aClass);
  if (topLevelClass == null)   return null;
  final PsiField[] fields=aClass.getFields();
  NextField:   for (  PsiField field : fields) {
    if (field.hasModifierProperty(PsiModifier.PRIVATE)) {
      if (HighlightUtil.isSerializationImplicitlyUsedField(field))       continue;
      final Collection<PsiReference> refs=ReferencesSearch.search(field,new LocalSearchScope(field.getContainingFile()),true).findAll();
      if (refs.size() == 0)       continue;
      for (      PsiReference ref : refs) {
        PsiElement element=ref.getElement();
        final PsiMember parentOfType=PsiTreeUtil.getParentOfType(element,PsiMember.class);
        if (!(parentOfType instanceof PsiMethod) && !(parentOfType instanceof PsiClassInitializer)) {
          continue NextField;
        }
      }
      candidates.add(field);
    }
  }
  topLevelClass.accept(new PsiRecursiveElementVisitor(){
    public void visitElement(    PsiElement element){
      if (candidates.size() > 0)       super.visitElement(element);
    }
    public void visitMethod(    PsiMethod method){
      super.visitMethod(method);
      final PsiCodeBlock body=method.getBody();
      if (body != null) {
        checkCodeBlock(body,candidates);
      }
    }
    public void visitClassInitializer(    PsiClassInitializer initializer){
      super.visitClassInitializer(initializer);
      checkCodeBlock(initializer.getBody(),candidates);
    }
    private void checkCodeBlock(    final PsiCodeBlock body,    final Set<PsiField> candidates){
      try {
        final ControlFlow controlFlow=ControlFlowFactory.getControlFlow(body,AllVariablesControlFlowPolicy.getInstance());
        final List<PsiReferenceExpression> readBeforeWrites=ControlFlowUtil.getReadBeforeWrite(controlFlow);
        for (        final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {
          final PsiElement resolved=readBeforeWrite.resolve();
          if (resolved instanceof PsiField) {
            final PsiField field=(PsiField)resolved;
            candidates.remove(field);
          }
        }
      }
 catch (      AnalysisCanceledException e) {
        candidates.clear();
      }
    }
  }
);
  if (candidates.isEmpty())   return null;
  ProblemDescriptor[] result=new ProblemDescriptor[candidates.size()];
  int i=0;
  for (Iterator<PsiField> iterator=candidates.iterator(); iterator.hasNext(); i++) {
    PsiField field=iterator.next();
    final String message=InspectionsBundle.message("inspection.field.can.be.local.problem.descriptor");
    result[i]=manager.createProblemDescriptor(field.getNameIdentifier(),message,new MyQuickFix(field),ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
  }
  return result;
}
