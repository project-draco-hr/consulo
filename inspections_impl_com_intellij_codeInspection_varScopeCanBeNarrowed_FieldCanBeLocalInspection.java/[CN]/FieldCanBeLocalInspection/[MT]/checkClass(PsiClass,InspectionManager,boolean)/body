{
  if (aClass.isInterface())   return null;
  final Set<PsiField> candidates=new LinkedHashSet<PsiField>();
  final PsiClass topLevelClass=PsiUtil.getTopLevelClass(aClass);
  if (topLevelClass == null)   return null;
  final PsiField[] fields=aClass.getFields();
  for (  PsiField field : fields) {
    if (field.hasModifierProperty(PsiModifier.PRIVATE)) {
      candidates.add(field);
    }
  }
  topLevelClass.accept(new PsiRecursiveElementVisitor(){
    public void visitMethod(    PsiMethod method){
    }
    public void visitClassInitializer(    PsiClassInitializer initializer){
    }
    public void visitReferenceExpression(    PsiReferenceExpression expression){
      final PsiExpression qualifier=expression.getQualifierExpression();
      if (qualifier == null || (qualifier instanceof PsiThisExpression && ((PsiThisExpression)qualifier).getQualifier() == null)) {
        final PsiElement resolved=expression.resolve();
        if (resolved instanceof PsiField) {
          final PsiField field=(PsiField)resolved;
          if (aClass.equals(field.getContainingClass())) {
            candidates.remove(field);
          }
        }
      }
      super.visitReferenceExpression(expression);
    }
  }
);
  topLevelClass.accept(new PsiRecursiveElementVisitor(){
    public void visitElement(    PsiElement element){
      if (candidates.size() > 0)       super.visitElement(element);
    }
    public void visitMethod(    PsiMethod method){
      super.visitMethod(method);
      final PsiCodeBlock body=method.getBody();
      if (body != null) {
        checkCodeBlock(body,candidates);
      }
    }
    public void visitClassInitializer(    PsiClassInitializer initializer){
      super.visitClassInitializer(initializer);
      checkCodeBlock(initializer.getBody(),candidates);
    }
    private void checkCodeBlock(    final PsiCodeBlock body,    final Set<PsiField> candidates){
      try {
        final ControlFlow controlFlow=ControlFlowFactory.getControlFlow(body,AllVariablesControlFlowPolicy.getInstance());
        final List<PsiReferenceExpression> readBeforeWrites=ControlFlowUtil.getReadBeforeWrite(controlFlow);
        for (        final PsiReferenceExpression readBeforeWrite : readBeforeWrites) {
          final PsiElement resolved=readBeforeWrite.resolve();
          if (resolved instanceof PsiField) {
            final PsiField field=(PsiField)resolved;
            candidates.remove(field);
          }
        }
      }
 catch (      AnalysisCanceledException e) {
        candidates.clear();
      }
    }
  }
);
  if (candidates.isEmpty())   return null;
  ProblemDescriptor[] result=new ProblemDescriptor[candidates.size()];
  int i=0;
  for (Iterator<PsiField> iterator=candidates.iterator(); iterator.hasNext(); i++) {
    PsiField field=iterator.next();
    final String message=InspectionsBundle.message("inspection.field.can.be.local.problem.descriptor");
    result[i]=manager.createProblemDescriptor(field.getNameIdentifier(),message,new MyQuickFix(field),ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
  }
  return result;
}
