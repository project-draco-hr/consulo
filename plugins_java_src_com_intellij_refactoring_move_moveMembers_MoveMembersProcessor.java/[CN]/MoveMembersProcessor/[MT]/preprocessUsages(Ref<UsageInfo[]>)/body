{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final UsageInfo[] usages=refUsages.get();
  String newVisibility=myNewVisibility;
  if (VisibilityUtil.ESCALATE_VISIBILITY.equals(newVisibility)) {
    newVisibility=PsiModifier.PUBLIC;
  }
  final Map<PsiMember,PsiModifierList> modifierListCopies=new HashMap<PsiMember,PsiModifierList>();
  for (  PsiMember member : myMembersToMove) {
    PsiModifierList modifierListCopy=member.getModifierList();
    if (modifierListCopy != null) {
      modifierListCopy=(PsiModifierList)modifierListCopy.copy();
    }
    if (modifierListCopy != null && newVisibility != null) {
      try {
        VisibilityUtil.setVisibility(modifierListCopy,newVisibility);
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
    modifierListCopies.put(member,modifierListCopy);
  }
  analyzeConflictsOnUsages(usages,myMembersToMove,newVisibility,myTargetClass,modifierListCopies,conflicts);
  analyzeConflictsOnMembers(myMembersToMove,newVisibility,myTargetClass,modifierListCopies,conflicts);
  RefactoringConflictsUtil.analyzeModuleConflicts(myProject,myMembersToMove,usages,myTargetClass,conflicts);
  return showConflicts(conflicts,usages);
}
