{
  try {
    lockStorage();
    if (IntToIntBtree.doDump)     System.out.println(value);
    final int valueHC=myDataDescriptor.getHashCode(value);
    final boolean hasMapping=btree.get(valueHC,myResultBuf);
    if (!hasMapping && onlyCheckForExisting) {
      return NULL_ID;
    }
    int indexNodeValueAddress=hasMapping ? myResultBuf[0] : 0;
    int collisionAddress=NULL_ID;
    Data existingData=null;
    if (!myInlineKeysNoMapping) {
      collisionAddress=NULL_ID;
      if (indexNodeValueAddress > 0) {
        Data candidate=valueOf(indexNodeValueAddress);
        if (IntToIntBtree.doSanityCheck)         IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
        if (myDataDescriptor.isEqual(value,candidate)) {
          if (!saveNewValue) {
            ++myExistingKeysEnumerated;
            return indexNodeValueAddress;
          }
          existingData=candidate;
        }
        collisionAddress=indexNodeValueAddress;
      }
 else       if (indexNodeValueAddress < 0) {
        collisionAddress=-indexNodeValueAddress;
        while (true) {
          final int address=myStorage.getInt(collisionAddress);
          Data candidate=valueOf(address);
          if (myDataDescriptor.isEqual(value,candidate)) {
            if (!saveNewValue)             return address;
            existingData=candidate;
            break;
          }
          if (IntToIntBtree.doSanityCheck)           IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
          int newCollisionAddress=myStorage.getInt(collisionAddress + COLLISION_OFFSET);
          if (newCollisionAddress == 0)           break;
          collisionAddress=newCollisionAddress;
        }
      }
      if (onlyCheckForExisting)       return NULL_ID;
    }
 else {
      if (hasMapping) {
        if (!saveNewValue)         return indexNodeValueAddress;
        existingData=value;
      }
    }
    int newValueId=writeData(value,valueHC);
    ++myValuesCount;
    if (IOStatistics.DEBUG && (myValuesCount & IOStatistics.KEYS_FACTOR_MASK) == 0) {
      IOStatistics.dump("Index " + myFile + ", values "+ myValuesCount+ ", existing keys enumerated:"+ myExistingKeysEnumerated+ ", storage size:"+ myStorage.length());
      btree.dumpStatistics();
    }
    if (collisionAddress != NULL_ID) {
      if (existingData != null) {
        if (indexNodeValueAddress > 0) {
          btree.put(valueHC,newValueId);
        }
 else {
          myStorage.putInt(collisionAddress,newValueId);
        }
      }
 else {
        if (indexNodeValueAddress > 0) {
          int duplicatedValueOff=nextDuplicatedValueRecord();
          btree.put(valueHC,-duplicatedValueOff);
          myStorage.putInt(duplicatedValueOff,indexNodeValueAddress);
          collisionAddress=duplicatedValueOff;
          ++myCollisions;
        }
        ++myCollisions;
        int duplicatedValueOff=nextDuplicatedValueRecord();
        myStorage.putInt(collisionAddress + COLLISION_OFFSET,duplicatedValueOff);
        myStorage.putInt(duplicatedValueOff,newValueId);
        myStorage.putInt(duplicatedValueOff + COLLISION_OFFSET,0);
      }
    }
 else {
      btree.put(valueHC,newValueId);
    }
    if (IntToIntBtree.doSanityCheck) {
      if (!myInlineKeysNoMapping) {
        Data data=valueOf(newValueId);
        IntToIntBtree.myAssert(myDataDescriptor.isEqual(value,data));
      }
    }
    return newValueId;
  }
 catch (  IllegalStateException e) {
    CorruptedException exception=new CorruptedException(myFile);
    exception.initCause(e);
    throw exception;
  }
 finally {
    unlockStorage();
  }
}
