{
  try {
synchronized (ourLock) {
      if (IntToIntBtree.doDump)       System.out.println(value);
      final int valueHC=myDataDescriptor.getHashCode(value);
      final boolean hasMapping=btree.get(valueHC,myResultBuf);
      if (!hasMapping && onlyCheckForExisting) {
        return NULL_ID;
      }
      int indexNodeValueAddress=hasMapping ? myResultBuf[0] : 0;
      int collisionAddress=NULL_ID;
      Data existingData=null;
      if (!myInlineKeysNoMapping) {
        collisionAddress=NULL_ID;
        if (indexNodeValueAddress > 0) {
          Data candidate=valueOf(indexNodeValueAddress);
          if (IntToIntBtree.doSanityCheck)           IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
          if (myDataDescriptor.isEqual(value,candidate)) {
            if (!saveNewValue)             return indexNodeValueAddress;
            existingData=candidate;
          }
          collisionAddress=indexNodeValueAddress;
        }
 else         if (indexNodeValueAddress < 0) {
          collisionAddress=-indexNodeValueAddress;
          while (true) {
            final int address=myStorage.getInt(collisionAddress);
            Data candidate=valueOf(address);
            if (myDataDescriptor.isEqual(value,candidate)) {
              if (!saveNewValue)               return address;
              existingData=candidate;
              break;
            }
            if (IntToIntBtree.doSanityCheck)             IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
            int newCollisionAddress=myStorage.getInt(collisionAddress + COLLISION_OFFSET);
            if (newCollisionAddress == 0)             break;
            collisionAddress=newCollisionAddress;
          }
        }
        if (onlyCheckForExisting)         return NULL_ID;
      }
 else {
        if (hasMapping) {
          if (!saveNewValue)           return indexNodeValueAddress;
          existingData=value;
        }
      }
      int newValueId=writeData(value,valueHC);
      ++valuesCount;
      if (valuesCount % IOStatistics.KEYS_FACTOR == 0 && IOStatistics.DEBUG) {
        IOStatistics.dump("Index " + myFile + ", values "+ valuesCount+ ", storage size:"+ myStorage.length());
        btree.dumpStatistics();
      }
      if (collisionAddress != NULL_ID) {
        if (existingData != null) {
          if (indexNodeValueAddress > 0) {
            btree.put(valueHC,newValueId);
          }
 else {
            myStorage.putInt(collisionAddress,newValueId);
          }
        }
 else {
          if (indexNodeValueAddress > 0) {
            int duplicatedValueOff=nextDuplicatedValueRecord();
            btree.put(valueHC,-duplicatedValueOff);
            myStorage.putInt(duplicatedValueOff,indexNodeValueAddress);
            collisionAddress=duplicatedValueOff;
            ++collisions;
          }
          ++collisions;
          int duplicatedValueOff=nextDuplicatedValueRecord();
          myStorage.putInt(collisionAddress + COLLISION_OFFSET,duplicatedValueOff);
          myStorage.putInt(duplicatedValueOff,newValueId);
          myStorage.putInt(duplicatedValueOff + COLLISION_OFFSET,0);
        }
      }
 else {
        btree.put(valueHC,newValueId);
      }
      if (IntToIntBtree.doSanityCheck) {
        if (!myInlineKeysNoMapping) {
          Data data=valueOf(newValueId);
          IntToIntBtree.myAssert(myDataDescriptor.isEqual(value,data));
        }
      }
      return newValueId;
    }
  }
 catch (  IllegalStateException e) {
    CorruptedException exception=new CorruptedException(myFile);
    exception.initCause(e);
    throw exception;
  }
}
