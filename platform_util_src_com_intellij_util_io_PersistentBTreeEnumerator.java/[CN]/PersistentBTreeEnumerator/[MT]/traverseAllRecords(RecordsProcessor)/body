{
  try {
synchronized (ourLock) {
      List<IntToIntBtree.BtreeIndexNodeView> leafPages=new ArrayList<IntToIntBtree.BtreeIndexNodeView>();
      btree.doFlush();
      btree.root.syncWithStore();
      collectLeafPages(btree.root,leafPages);
      Collections.sort(leafPages,new Comparator<IntToIntBtree.BtreeIndexNodeView>(){
        @Override public int compare(        IntToIntBtree.BtreeIndexNodeView o1,        IntToIntBtree.BtreeIndexNodeView o2){
          return o1.address - o2.address;
        }
      }
);
      out:       for (      IntToIntBtree.BtreeIndexNodeView page : leafPages) {
        for (        int key : page.exportKeys()) {
          boolean hasMapping=btree.get(key,myResultBuf);
          p.setCurrentKey(key);
          assert hasMapping;
          int record=myResultBuf[0];
          if (record > 0) {
            if (!p.process(record))             return false;
          }
 else {
            int rec=-record;
            while (rec != 0) {
              int id=myStorage.getInt(rec);
              if (!p.process(id))               return false;
              rec=myStorage.getInt(rec + COLLISION_OFFSET);
            }
          }
        }
      }
      return true;
    }
  }
 catch (  IllegalStateException e) {
    CorruptedException corruptedException=new CorruptedException(myFile);
    corruptedException.initCause(e);
    throw corruptedException;
  }
}
