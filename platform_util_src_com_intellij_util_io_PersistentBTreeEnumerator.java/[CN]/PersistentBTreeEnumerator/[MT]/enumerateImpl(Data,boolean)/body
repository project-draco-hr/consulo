{
  try {
    if (IntToIntBtree.doDump)     System.out.println(value);
    final int valueHC=myDataDescriptor.getHashCode(value);
    final Integer keyValue=btree.get(valueHC);
    if (keyValue == null && !saveNewValue) {
      return NULL_ID;
    }
    int indexNodeValueAddress=keyValue != null ? keyValue : 0;
    int collisionAddress=NULL_ID;
    if (!myInlineKeysNoMapping) {
      indexNodeValueAddress=keyValue != null ? keyValue : 0;
      collisionAddress=NULL_ID;
      if (indexNodeValueAddress > 0) {
        Data candidate=valueOf(indexNodeValueAddress);
        if (IntToIntBtree.doSanityCheck)         IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
        if (myDataDescriptor.isEqual(value,candidate)) {
          return indexNodeValueAddress;
        }
        collisionAddress=indexNodeValueAddress;
      }
 else       if (indexNodeValueAddress < 0) {
        collisionAddress=-indexNodeValueAddress;
        while (true) {
          final int address=myStorage.getInt(collisionAddress);
          Data candidate=valueOf(address);
          if (myDataDescriptor.isEqual(value,candidate)) {
            return address;
          }
          if (IntToIntBtree.doSanityCheck)           IntToIntBtree.myAssert(myDataDescriptor.getHashCode(candidate) == valueHC);
          int newCollisionAddress=myStorage.getInt(collisionAddress + COLLISION_OFFSET);
          if (newCollisionAddress == 0)           break;
          collisionAddress=newCollisionAddress;
        }
      }
      if (!saveNewValue)       return NULL_ID;
    }
 else {
      if (keyValue != null)       return indexNodeValueAddress;
    }
    int newValueId=writeData(value,valueHC);
    ++valuesCount;
    if (valuesCount % 10000 == 0 && IOStatistics.DEBUG) {
      IOStatistics.dump("Index " + myFile + ", values "+ valuesCount+ ", storage size:"+ myStorage.length()+ ", pagecount:"+ btree.getPageCount()+ ", height:"+ btree.getMaxStepsSearched());
    }
    if (collisionAddress != NULL_ID) {
      if (indexNodeValueAddress > 0) {
        int duplicatedValueOff=nextDuplicatedValueRecord();
        btree.put(valueHC,-duplicatedValueOff);
        myStorage.putInt(duplicatedValueOff,indexNodeValueAddress);
        collisionAddress=duplicatedValueOff;
        ++collisions;
      }
      ++collisions;
      int duplicatedValueOff=nextDuplicatedValueRecord();
      myStorage.putInt(collisionAddress + COLLISION_OFFSET,duplicatedValueOff);
      myStorage.putInt(duplicatedValueOff,newValueId);
      myStorage.putInt(duplicatedValueOff + COLLISION_OFFSET,0);
    }
 else {
      btree.put(valueHC,newValueId);
    }
    if (IntToIntBtree.doSanityCheck) {
      if (!myInlineKeysNoMapping) {
        Data data=valueOf(newValueId);
        IntToIntBtree.myAssert(myDataDescriptor.isEqual(value,data));
      }
    }
    return newValueId;
  }
 catch (  IOException io) {
    markCorrupted();
    throw io;
  }
catch (  Throwable e) {
    markCorrupted();
    LOG.error(e);
    throw new RuntimeException(e);
  }
}
