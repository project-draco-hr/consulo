{
  final OrFilter filter=new OrFilter();
  PsiElement superParent=getParent();
  boolean smartCompletion=true;
  if (isQualified()) {
    smartCompletion=false;
  }
 else {
    while (superParent != null) {
      if (superParent instanceof PsiCodeBlock || superParent instanceof PsiVariable) {
        smartCompletion=false;
        break;
      }
      superParent=superParent.getParent();
    }
  }
  if (!smartCompletion) {
    filter.addFilter(new NotFilter(new ConstructorFilter()));
    filter.addFilter(new ClassFilter(PsiVariable.class));
  }
switch (getKind()) {
case CLASS_OR_PACKAGE_NAME_KIND:
    filter.addFilter(new ClassFilter(PsiClass.class));
  filter.addFilter(new ClassFilter(PsiPackage.class));
break;
case CLASS_NAME_KIND:
if (getParent() instanceof PsiAnnotation) {
filter.addFilter(new AnnotationTypeFilter());
}
 else {
filter.addFilter(new ClassFilter(PsiClass.class));
}
break;
case PACKAGE_NAME_KIND:
filter.addFilter(new ClassFilter(PsiPackage.class));
break;
case CLASS_FQ_NAME_KIND:
case CLASS_FQ_OR_PACKAGE_NAME_KIND:
filter.addFilter(new ClassFilter(PsiPackage.class));
if (isQualified()) {
filter.addFilter(new ClassFilter(PsiClass.class));
}
break;
case CLASS_IN_QUALIFIED_NEW_KIND:
final PsiElement parent=getParent();
if (parent instanceof PsiNewExpression) {
final PsiNewExpression newExpr=(PsiNewExpression)parent;
final PsiType type=newExpr.getQualifier().getType();
final PsiClass aClass=PsiUtil.resolveClassInType(type);
if (aClass != null) {
PsiScopesUtil.processScope(aClass,new FilterScopeProcessor(new AndFilter(new ClassFilter(PsiClass.class),new ModifierFilter(PsiModifier.STATIC,false)),processor),PsiSubstitutor.EMPTY,null,this);
}
}
return;
default :
throw new RuntimeException("Unknown reference type");
}
final FilterScopeProcessor proc=new FilterScopeProcessor(filter,processor);
PsiScopesUtil.resolveAndWalk(proc,this,null,true);
}
