{
  if (myModulePaths != null && myModulePaths.size() > 0) {
    final Application app=ApplicationManager.getApplication();
    final ProgressIndicator progressIndicator=myProject.isDefault() ? null : myProgressManager.getProgressIndicator();
    if (progressIndicator != null) {
      progressIndicator.setText("Loading modules");
      progressIndicator.setText2("");
    }
    final Runnable swingRunnable=new Runnable(){
      public void run(){
        myFailedModulePaths.clear();
        myFailedModulePaths.addAll(myModulePaths);
        final List<Module> modulesWithUnknownTypes=new ArrayList<Module>();
        List<ModuleLoadingErrorDescription> errors=new ArrayList<ModuleLoadingErrorDescription>();
        for (        final ModulePath modulePath : myModulePaths) {
          try {
            final Module module=moduleModel.loadModuleInternal(modulePath.getPath(),progressIndicator);
            if (ModuleType.get(module) instanceof UnknownModuleType) {
              modulesWithUnknownTypes.add(module);
            }
            final String groupPathString=modulePath.getModuleGroup();
            if (groupPathString != null) {
              final String[] groupPath=groupPathString.split(MODULE_GROUP_SEPARATOR);
              moduleModel.setModuleGroupPath(module,groupPath);
            }
            myFailedModulePaths.remove(modulePath);
          }
 catch (          final IOException e) {
            errors.add(ModuleLoadingErrorDescription.create(ProjectBundle.message("module.cannot.load.error",modulePath.getPath(),e.getMessage()),modulePath,ModuleManagerImpl.this));
          }
catch (          final ModuleWithNameAlreadyExists moduleWithNameAlreadyExists) {
            errors.add(ModuleLoadingErrorDescription.create(moduleWithNameAlreadyExists.getMessage(),modulePath,ModuleManagerImpl.this));
          }
catch (          StateStorageException e) {
            errors.add(ModuleLoadingErrorDescription.create(ProjectBundle.message("module.cannot.load.error",modulePath.getPath(),e.getMessage()),modulePath,ModuleManagerImpl.this));
          }
        }
        fireErrors(errors);
        if (!app.isHeadlessEnvironment() && !modulesWithUnknownTypes.isEmpty()) {
          String message;
          if (modulesWithUnknownTypes.size() == 1) {
            message=ProjectBundle.message("module.unknown.type.single.error",modulesWithUnknownTypes.get(0).getName(),ModuleType.get(modulesWithUnknownTypes.get(0)).getId());
          }
 else {
            StringBuilder modulesBuilder=new StringBuilder();
            for (            final Module module : modulesWithUnknownTypes) {
              modulesBuilder.append("<br>\"");
              modulesBuilder.append(module.getName()).append("\" (type '").append(ModuleType.get(module).getId()).append("')");
            }
            modulesBuilder.append("<br>");
            message=ProjectBundle.message("module.unknown.type.multiple.error",modulesBuilder.toString());
          }
          Notifications.Bus.notify(new Notification("Module Manager",ProjectBundle.message("module.unknown.type.title"),message,NotificationType.WARNING),myProject);
        }
      }
    }
;
    swingRunnable.run();
  }
}
