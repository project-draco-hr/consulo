{
  if (!settings.getInspectionProfile().isToolEnabled(HighlightDisplayKey.DEPRECATED_SYMBOL))   return null;
  if (!InspectionManagerEx.isToCheckMember(methodSignature.getMethod(),HighlightDisplayKey.DEPRECATED_SYMBOL.toString()))   return null;
  PsiMethod method=methodSignature.getMethod();
  PsiElement methodName=method.getNameIdentifier();
  for (  MethodSignatureBackedByPsiMethod superMethodSignature : superMethodSignatures) {
    PsiMethod superMethod=superMethodSignature.getMethod();
    PsiClass aClass=superMethod.getContainingClass();
    if (aClass == null)     continue;
    if (!aClass.isDeprecated() && superMethod.hasModifierProperty(PsiModifier.ABSTRACT))     continue;
    if (superMethod.isDeprecated()) {
      String description=MessageFormat.format("Overrides deprecated method in ''{0}''",new Object[]{HighlightMessageUtil.getSymbolName(aClass,PsiSubstitutor.EMPTY)});
      HighlightInfo highlightInfo=HighlightInfo.createHighlightInfo(HighlightInfoType.DEPRECATED,methodName,description);
      List<IntentionAction> options=new ArrayList<IntentionAction>();
      options.add(new SwitchOffToolAction(HighlightDisplayKey.DEPRECATED_SYMBOL));
      options.add(new AddNoInspectionDocTagAction(HighlightDisplayKey.DEPRECATED_SYMBOL,method));
      options.add(new AddNoInspectionForClassAction(HighlightDisplayKey.DEPRECATED_SYMBOL,method));
      options.add(new AddNoInspectionAllForClassAction(method));
      options.add(new AddSuppressWarningsAnnotationAction(HighlightDisplayKey.DEPRECATED_SYMBOL,method));
      options.add(new AddSuppressWarningsAnnotationForClassAction(HighlightDisplayKey.DEPRECATED_SYMBOL,method));
      options.add(new AddSuppressWarningsAnnotationForAllAction(method));
      QuickFixAction.registerQuickFixAction(highlightInfo,new EmptyIntentionAction(HighlightDisplayKey.getDisplayNameByKey(HighlightDisplayKey.DEPRECATED_SYMBOL),options),options);
      return highlightInfo;
    }
  }
  return null;
}
