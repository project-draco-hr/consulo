{
  if (!settings.getInspectionProfile().isToolEnabled(HighlightDisplayKey.DEPRECATED_SYMBOL))   return null;
  final InspectionManagerEx manager=(InspectionManagerEx)InspectionManager.getInstance(methodSignature.getMethod().getProject());
  if (!manager.isToCheckMember(methodSignature.getMethod(),HighlightDisplayKey.DEPRECATED_SYMBOL.toString()))   return null;
  final PsiMethod method=methodSignature.getMethod();
  PsiElement methodName=method.getNameIdentifier();
  for (int i=0; i < superMethodSignatures.size(); i++) {
    final MethodSignatureBackedByPsiMethod superMethodSignature=superMethodSignatures.get(i);
    PsiMethod superMethod=superMethodSignature.getMethod();
    final PsiClass aClass=superMethod.getContainingClass();
    if (aClass == null)     continue;
    if (!aClass.isDeprecated() && superMethod.hasModifierProperty(PsiModifier.ABSTRACT))     continue;
    if (superMethod.isDeprecated()) {
      String description=MessageFormat.format("Overrides deprecated method in ''{0}''",new Object[]{HighlightMessageUtil.getSymbolName(aClass,PsiSubstitutor.EMPTY)});
      final HighlightInfo highlightInfo=HighlightInfo.createHighlightInfo(HighlightInfoType.DEPRECATED,methodName,description);
      QuickFixAction.registerQuickFixAction(highlightInfo,new AddNoInspectionDocTagAction(HighlightDisplayKey.DEPRECATED_SYMBOL,method));
      QuickFixAction.registerQuickFixAction(highlightInfo,new SwitchOffToolAction(HighlightDisplayKey.DEPRECATED_SYMBOL));
      return highlightInfo;
    }
  }
  return null;
}
