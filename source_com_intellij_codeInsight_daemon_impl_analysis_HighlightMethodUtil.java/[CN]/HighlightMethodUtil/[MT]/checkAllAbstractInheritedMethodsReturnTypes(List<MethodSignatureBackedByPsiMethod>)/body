{
  if (superMethodSignatures.size() < 2)   return null;
  for (int i=0; i < superMethodSignatures.size(); i++) {
    final MethodSignatureBackedByPsiMethod superSignature=superMethodSignatures.get(i);
    final PsiMethod currentMethod=superSignature.getMethod();
    PsiType currentType=superSignature.getSubstitutor().substitute(currentMethod.getReturnType());
    for (int j=i; j < superMethodSignatures.size(); j++) {
      final MethodSignatureBackedByPsiMethod otherSuperSignature=superMethodSignatures.get(j);
      PsiMethod otherSuperMethod=otherSuperSignature.getMethod();
      PsiType otherSuperReturnType=otherSuperSignature.getSubstitutor().substitute(otherSuperMethod.getReturnType());
      final PsiSubstitutor unifyingSubstitutor=MethodSignatureUtil.getSuperMethodSignatureSubstitutor(superSignature,otherSuperSignature);
      if (unifyingSubstitutor != null) {
        otherSuperReturnType=unifyingSubstitutor.substitute(otherSuperReturnType);
        currentType=unifyingSubstitutor.substitute(currentType);
      }
      if (otherSuperReturnType == null || currentType == null)       continue;
      if (otherSuperReturnType.equals(currentType))       continue;
      if (LanguageLevel.JDK_1_5.compareTo(currentMethod.getManager().getEffectiveLanguageLevel()) <= 0) {
        if (otherSuperReturnType.isAssignableFrom(currentType) || currentType.isAssignableFrom(otherSuperReturnType)) {
          continue;
        }
      }
      return createIncompatibleReturnTypeMessage(currentMethod,currentMethod,otherSuperMethod,false,otherSuperReturnType,currentType,"methods have unrelated return types");
    }
  }
  return null;
}
