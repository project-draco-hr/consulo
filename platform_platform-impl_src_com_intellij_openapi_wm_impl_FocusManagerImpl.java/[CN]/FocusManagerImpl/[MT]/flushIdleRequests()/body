{
  int currentModalityCount=getCurrentModalityCount();
  try {
    incFlushingRequests(1,currentModalityCount);
    if (!isTypeaheadEnabled()) {
      myToDispatchOnDone.clear();
      myTypeAheadRequestors.clear();
    }
    if (!myToDispatchOnDone.isEmpty() && myTypeAheadRequestors.isEmpty()) {
      final KeyEvent[] events=myToDispatchOnDone.toArray(new KeyEvent[myToDispatchOnDone.size()]);
      IdeEventQueue.getInstance().getKeyEventDispatcher().resetState();
      for (int eachIndex=0; eachIndex < events.length; eachIndex++) {
        if (!isFocusTransferReady()) {
          break;
        }
        KeyEvent each=events[eachIndex];
        Component owner=KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
        if (owner == null) {
          owner=JOptionPane.getRootFrame();
        }
        boolean metaKey=each.getKeyCode() == KeyEvent.VK_ALT || each.getKeyCode() == KeyEvent.VK_CONTROL || each.getKeyCode() == KeyEvent.VK_SHIFT || each.getKeyCode() == KeyEvent.VK_META;
        boolean toDispatch=false;
        if (!metaKey && (each.getID() == KeyEvent.KEY_RELEASED || each.getID() == KeyEvent.KEY_TYPED)) {
          for (int i=0; i < eachIndex; i++) {
            final KeyEvent prev=events[i];
            if (prev == null)             continue;
            if (prev.getID() == KeyEvent.KEY_PRESSED) {
              if (prev.getKeyCode() == each.getKeyCode() || prev.getKeyChar() == each.getKeyChar()) {
                toDispatch=true;
                events[i]=null;
                break;
              }
            }
          }
        }
 else {
          toDispatch=true;
        }
        myToDispatchOnDone.remove(each);
        if (!toDispatch) {
          continue;
        }
        KeyEvent keyEvent=new KeyEvent(owner,each.getID(),each.getWhen(),each.getModifiersEx(),each.getKeyCode(),each.getKeyChar(),each.getKeyLocation());
        if (owner != null && SwingUtilities.getWindowAncestor(owner) != null) {
          IdeEventQueue.getInstance().dispatchEvent(keyEvent);
        }
 else {
          myQueue._dispatchEvent(keyEvent,true);
        }
      }
      if (myToDispatchOnDone.isEmpty() && myTypeAheadRequestors.isEmpty()) {
        myActivityMonitor.removeActivity(TYPEAHEAD);
      }
    }
    if (!isFocusBeingTransferred()) {
      boolean focusOk=getFocusOwner() != null;
      if (!focusOk && !myFlushWasDelayedToFixFocus) {
        IdeEventQueue.getInstance().fixStickyFocusedComponents(null);
        myFlushWasDelayedToFixFocus=true;
      }
 else       if (!focusOk) {
        myFlushWasDelayedToFixFocus=false;
      }
      if (canFlushIdleRequests() && getFlushingIdleRequests() <= 1 && (focusOk || !myFlushWasDelayedToFixFocus)) {
        myFlushWasDelayedToFixFocus=false;
        flushNow();
      }
    }
  }
  finally {
    incFlushingRequests(-1,currentModalityCount);
    if (!isIdleQueueEmpty()) {
      restartIdleAlarm();
    }
    maybeRemoveFocusActivity();
  }
}
