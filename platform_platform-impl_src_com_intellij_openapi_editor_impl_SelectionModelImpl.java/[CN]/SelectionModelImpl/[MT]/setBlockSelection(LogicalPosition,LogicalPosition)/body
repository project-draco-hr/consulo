{
  if (myEditor.getCaretModel().supportsMultipleCarets()) {
    int startLine=Math.max(Math.min(blockStart.line,myEditor.getDocument().getLineCount() - 1),0);
    int endLine=Math.max(Math.min(blockEnd.line,myEditor.getDocument().getLineCount() - 1),0);
    int step=endLine < startLine ? -1 : 1;
    int count=1 + Math.abs(endLine - startLine);
    List<CaretState> caretStates=new LinkedList<CaretState>();
    boolean hasSelection=false;
    for (int line=startLine, i=0; i < count; i++, line+=step) {
      int startColumn=blockStart.column;
      int endColumn=blockEnd.column;
      int lineEndOffset=myEditor.getDocument().getLineEndOffset(line);
      LogicalPosition lineEndPosition=myEditor.offsetToLogicalPosition(lineEndOffset);
      int lineWidth=lineEndPosition.column;
      if (startColumn > lineWidth && endColumn > lineWidth && !myEditor.isColumnMode()) {
        LogicalPosition caretPos=new LogicalPosition(line,Math.min(startColumn,endColumn));
        caretStates.add(new CaretState(caretPos,lineEndPosition,lineEndPosition));
      }
 else {
        LogicalPosition startPos=new LogicalPosition(line,myEditor.isColumnMode() ? startColumn : Math.min(startColumn,lineWidth));
        LogicalPosition endPos=new LogicalPosition(line,myEditor.isColumnMode() ? endColumn : Math.min(endColumn,lineWidth));
        int startOffset=myEditor.logicalPositionToOffset(startPos);
        int endOffset=myEditor.logicalPositionToOffset(endPos);
        caretStates.add(new CaretState(endPos,startPos,endPos));
        hasSelection|=startOffset != endOffset;
      }
    }
    if (hasSelection && !myEditor.isColumnMode()) {
      Iterator<CaretState> caretStateIterator=caretStates.iterator();
      while (caretStateIterator.hasNext()) {
        CaretState state=caretStateIterator.next();
        if (state.getSelectionStart().equals(state.getSelectionEnd())) {
          caretStateIterator.remove();
        }
      }
    }
    myEditor.getCaretModel().setCaretsAndSelections(caretStates);
  }
 else {
    removeSelection();
    int oldStartLine=0;
    int oldEndLine=0;
    if (hasBlockSelection()) {
      oldStartLine=myBlockStart.line;
      oldEndLine=myBlockEnd.line;
      if (oldStartLine > oldEndLine) {
        int t=oldStartLine;
        oldStartLine=oldEndLine;
        oldEndLine=t;
      }
    }
    int newStartLine=blockStart.line;
    int newEndLine=blockEnd.line;
    if (newStartLine > newEndLine) {
      int t=newStartLine;
      newStartLine=newEndLine;
      newEndLine=t;
    }
    myEditor.repaintLines(Math.min(oldStartLine,newStartLine),Math.max(newEndLine,oldEndLine));
    final int[] oldStarts=getBlockSelectionStarts();
    final int[] oldEnds=getBlockSelectionEnds();
    myBlockStart=blockStart;
    myBlockEnd=blockEnd;
    recalculateBlockOffsets();
    final int[] newStarts=getBlockSelectionStarts();
    final int[] newEnds=getBlockSelectionEnds();
    broadcastSelectionEvent(new SelectionEvent(myEditor,oldStarts,oldEnds,newStarts,newEnds));
  }
}
