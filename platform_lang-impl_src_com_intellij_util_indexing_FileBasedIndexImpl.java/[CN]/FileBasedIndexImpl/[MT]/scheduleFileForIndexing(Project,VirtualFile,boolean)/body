{
  boolean fileIsDirectory=file.isDirectory();
  if (!contentChange) {
    FileContent fileContent=null;
    int inputId=-1;
    for (    ID<?,?> indexId : fileIsDirectory ? myIndicesForDirectories : myNotRequiringContentIndices) {
      if (getInputFilter(indexId).acceptInput(project,file)) {
        try {
          if (fileContent == null) {
            fileContent=new FileContentImpl(file);
            inputId=Math.abs(getFileId(file));
          }
          updateSingleIndex(indexId,file,inputId,fileContent);
        }
 catch (        StorageException e) {
          LOG.info(e);
          requestRebuild(indexId);
        }
      }
    }
  }
  if (!fileIsDirectory) {
    if (!file.isValid() || isTooLarge(file)) {
      myChangedFilesCollector.removeScheduledFileFromUpdate(file);
    }
 else {
      myFileTypeManager.freezeFileTypeTemporarilyIn(file,new Runnable(){
        @Override public void run(){
          final List<ID<?,?>> candidates=FileBasedIndexImpl.this.getAffectedIndexCandidates(file);
          int fileId=getIdMaskingNonIdBasedFile(file);
          boolean scheduleForUpdate=false;
          for (int i=0, size=candidates.size(); i < size; ++i) {
            final ID<?,?> indexId=candidates.get(i);
            if (needsFileContentLoading(indexId) && getInputFilter(indexId).acceptInput(project,file)) {
              getIndex(indexId).resetIndexedStateForFile(fileId);
              scheduleForUpdate=true;
            }
          }
          if (scheduleForUpdate) {
            IndexingStamp.flushCache(fileId);
            myChangedFilesCollector.scheduleForUpdate(file);
          }
          if (!myUpToDateIndicesForUnsavedOrTransactedDocuments.isEmpty()) {
            clearUpToDateStateForPsiIndicesOfUnsavedDocuments(file);
          }
        }
      }
);
    }
  }
}
