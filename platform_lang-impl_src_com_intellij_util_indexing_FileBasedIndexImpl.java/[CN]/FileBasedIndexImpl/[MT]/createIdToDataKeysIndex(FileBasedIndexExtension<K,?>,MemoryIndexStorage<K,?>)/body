{
  ID<K,?> indexId=extension.getName();
  KeyDescriptor<K> keyDescriptor=extension.getKeyDescriptor();
  final File indexStorageFile=IndexInfrastructure.getInputIndexStorageFile(indexId);
  final AtomicBoolean isBufferingMode=new AtomicBoolean();
  final TIntObjectHashMap<Collection<K>> tempMap=new TIntObjectHashMap<Collection<K>>();
  final PersistentHashMap<Integer,Collection<K>> map=new PersistentHashMap<Integer,Collection<K>>(indexStorageFile,EnumeratorIntegerDescriptor.INSTANCE,createInputsIndexExternalizer(extension,indexId,keyDescriptor)){
    @Override protected Collection<K> doGet(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        final Collection<K> collection=tempMap.get(integer);
        if (collection != null) {
          return collection;
        }
      }
      return super.doGet(integer);
    }
    @Override protected void doPut(    Integer integer,    @Nullable Collection<K> ks) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,ks == null ? Collections.<K>emptySet() : ks);
      }
 else {
        super.doPut(integer,ks);
      }
    }
    @Override protected void doRemove(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,Collections.<K>emptySet());
      }
 else {
        super.doRemove(integer);
      }
    }
  }
;
  storage.addBufferingStateListener(new MemoryIndexStorage.BufferingStateListener(){
    @Override public void bufferingStateChanged(    boolean newState){
synchronized (map) {
        isBufferingMode.set(newState);
      }
    }
    @Override public void memoryStorageCleared(){
synchronized (map) {
        tempMap.clear();
      }
    }
  }
);
  return map;
}
