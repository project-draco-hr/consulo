{
  try {
    final FileBasedIndexExtension[] extensions=Extensions.getExtensions(FileBasedIndexExtension.EXTENSION_POINT_NAME);
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      ourRebuildStatus.put(extension.getName(),new AtomicInteger(OK));
    }
    final File corruptionMarker=new File(PathManager.getIndexRoot(),CORRUPTION_MARKER_NAME);
    final boolean currentVersionCorrupted=corruptionMarker.exists();
    boolean versionChanged=false;
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      versionChanged|=registerIndexer(extension,currentVersionCorrupted);
    }
    FileUtil.delete(corruptionMarker);
    String rebuildNotification=null;
    if (currentVersionCorrupted) {
      rebuildNotification="Index files on disk are corrupted. Indices will be rebuilt.";
    }
 else     if (versionChanged) {
      rebuildNotification="Index file format has changed for some indices. These indices will be rebuilt.";
    }
    if (rebuildNotification != null && !ApplicationManager.getApplication().isHeadlessEnvironment() && Registry.is("ide.showIndexRebuildMessage")) {
      new NotificationGroup("Indexing",NotificationDisplayType.BALLOON,false).createNotification("Index Rebuild",rebuildNotification,NotificationType.INFORMATION,null).notify(null);
    }
    dropUnregisteredIndices();
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (ourRebuildStatus.get(indexId).compareAndSet(REQUIRES_REBUILD,OK)) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          requestRebuild(indexId);
          LOG.error(e);
        }
      }
    }
    myVfManager.addVirtualFileListener(myChangedFilesCollector);
    registerIndexableSet(new AdditionalIndexableFileSet(),null);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    ShutDownTracker.getInstance().registerShutdownTask(new Runnable(){
      @Override public void run(){
        performShutdown();
      }
    }
);
    saveRegisteredIndices(myIndices.keySet());
    myFlushingFuture=FlushingDaemon.everyFiveSeconds(new Runnable(){
      int lastModCount=0;
      @Override public void run(){
        if (lastModCount == myLocalModCount) {
          flushAllIndices(lastModCount);
        }
        lastModCount=myLocalModCount;
      }
    }
);
    myInitialized=true;
  }
}
