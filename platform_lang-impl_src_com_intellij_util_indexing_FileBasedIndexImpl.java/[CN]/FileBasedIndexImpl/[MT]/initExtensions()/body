{
  try {
    File indexRoot=PathManager.getIndexRoot();
    final File corruptionMarker=new File(indexRoot,CORRUPTION_MARKER_NAME);
    final boolean currentVersionCorrupted=corruptionMarker.exists();
    if (currentVersionCorrupted) {
      FileUtil.deleteWithRenaming(indexRoot);
      indexRoot.mkdirs();
      mySerializationManagerEx.reinitializeNameStorage();
    }
    FileBasedIndexExtension[] extensions=Extensions.getExtensions(FileBasedIndexExtension.EXTENSION_POINT_NAME);
    boolean versionChanged=false;
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      try {
        ourRebuildStatus.put(extension.getName(),new AtomicInteger(OK));
        versionChanged|=registerIndexer(extension);
      }
 catch (      IOException e) {
        throw e;
      }
catch (      Throwable t) {
        PluginManager.handleComponentError(t,extension.getClass().getName(),null);
      }
    }
    for (    List<ID<?,?>> value : myFileType2IndicesWithFileTypeInfoMap.values()) {
      value.addAll(myIndicesWithoutFileTypeInfo);
    }
    FileUtil.delete(corruptionMarker);
    String rebuildNotification=null;
    if (currentVersionCorrupted) {
      rebuildNotification="Index files on disk are corrupted. Indices will be rebuilt.";
    }
 else     if (versionChanged) {
      rebuildNotification="Index file format has changed for some indices. These indices will be rebuilt.";
    }
    if (rebuildNotification != null && !ApplicationManager.getApplication().isHeadlessEnvironment() && Registry.is("ide.showIndexRebuildMessage")) {
      NOTIFICATIONS.createNotification("Index Rebuild",rebuildNotification,NotificationType.INFORMATION,null).notify(null);
    }
    dropUnregisteredIndices();
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (ourRebuildStatus.get(indexId).compareAndSet(REQUIRES_REBUILD,OK)) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          requestRebuild(indexId);
          LOG.error(e);
        }
      }
    }
    myConnection.subscribe(VirtualFileManager.VFS_CHANGES,myChangedFilesCollector);
    registerIndexableSet(new AdditionalIndexableFileSet(),null);
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
 finally {
    ShutDownTracker.getInstance().registerShutdownTask(new Runnable(){
      @Override public void run(){
        performShutdown();
      }
    }
);
    saveRegisteredIndices(myIndices.keySet());
    myFlushingFuture=FlushingDaemon.everyFiveSeconds(new Runnable(){
      private int lastModCount=0;
      @Override public void run(){
        mySerializationManagerEx.flushNameStorage();
        if (lastModCount == myLocalModCount) {
          flushAllIndices(lastModCount);
        }
        lastModCount=myLocalModCount;
      }
    }
);
    myInitialized=true;
  }
}
