{
  MapIndexStorage<K,V> storage=null;
  final ID<K,V> name=extension.getName();
  boolean contentHashesEnumeratorOk=false;
  for (int attempt=0; attempt < 2; attempt++) {
    try {
      if (extension.hasSnapshotMapping()) {
        ContentHashesSupport.initContentHashesEnumerator();
        contentHashesEnumeratorOk=true;
      }
      storage=new MapIndexStorage<K,V>(IndexInfrastructure.getStorageFile(name),extension.getKeyDescriptor(),extension.getValueExternalizer(),extension.getCacheSize(),extension.keyIsUniqueForIndexedFile(),extension.traceKeyHashToVirtualFileMapping());
      final MemoryIndexStorage<K,V> memStorage=new MemoryIndexStorage<K,V>(storage);
      final UpdatableIndex<K,V,FileContent> index=createIndex(name,extension,memStorage);
      final InputFilter inputFilter=extension.getInputFilter();
      myIndices.put(name,new Pair<UpdatableIndex<?,?,FileContent>,InputFilter>(index,new IndexableFilesFilter(inputFilter)));
      if (inputFilter instanceof FileTypeSpecificInputFilter) {
        ((FileTypeSpecificInputFilter)inputFilter).registerFileTypesUsedForIndexing(new Consumer<FileType>(){
          final Set<FileType> addedTypes=new THashSet<FileType>();
          @Override public void consume(          FileType type){
            if (type == null || !addedTypes.add(type)) {
              return;
            }
            List<ID<?,?>> ids=myFileType2IndicesWithFileTypeInfoMap.get(type);
            if (ids == null)             myFileType2IndicesWithFileTypeInfoMap.put(type,ids=new ArrayList<ID<?,?>>(5));
            ids.add(name);
          }
        }
);
      }
 else {
        myIndicesWithoutFileTypeInfo.add(name);
      }
      myUnsavedDataIndexingSemaphores.put(name,new Semaphore());
      myIndexIdToVersionMap.put(name,version);
      if (!extension.dependsOnFileContent()) {
        if (extension.indexDirectories())         myIndicesForDirectories.add(name);
        myNotRequiringContentIndices.add(name);
      }
 else {
        myRequiringContentIndices.add(name);
      }
      if (extension instanceof PsiDependentIndex)       myPsiDependentIndices.add(name);
      myNoLimitCheckTypes.addAll(extension.getFileTypesWithSizeLimitNotApplicable());
      break;
    }
 catch (    Exception e) {
      LOG.info(e);
      boolean instantiatedStorage=storage != null;
      try {
        if (storage != null)         storage.close();
        storage=null;
      }
 catch (      Exception ignored) {
      }
      FileUtil.deleteWithRenaming(IndexInfrastructure.getIndexRootDir(name));
      if (extension.hasSnapshotMapping() && (!contentHashesEnumeratorOk || instantiatedStorage)) {
        FileUtil.deleteWithRenaming(IndexInfrastructure.getPersistentIndexRootDir(name));
      }
      IndexingStamp.rewriteVersion(versionFile,version);
    }
  }
}
