{
  myVfManager=vfManager;
  myFileDocumentManager=fdm;
  myFileTypeManager=fileTypeManager;
  myIsUnitTestMode=ApplicationManager.getApplication().isUnitTestMode();
  myConfigPath=calcConfigPath(PathManager.getConfigPath());
  mySystemPath=calcConfigPath(PathManager.getSystemPath());
  final MessageBusConnection connection=bus.connect();
  connection.subscribe(PsiDocumentTransactionListener.TOPIC,new PsiDocumentTransactionListener(){
    @Override public void transactionStarted(    final Document doc,    final PsiFile file){
      if (file != null) {
synchronized (myTransactionMap) {
          myTransactionMap.put(doc,file);
        }
        myUpToDateIndices.clear();
      }
    }
    @Override public void transactionCompleted(    final Document doc,    final PsiFile file){
synchronized (myTransactionMap) {
        myTransactionMap.remove(doc);
      }
    }
  }
);
  connection.subscribe(FileTypeManager.TOPIC,new FileTypeListener(){
    @Nullable private Map<FileType,Set<String>> myTypeToExtensionMap;
    @Override public void beforeFileTypesChanged(    final FileTypeEvent event){
      cleanupProcessedFlag();
      myTypeToExtensionMap=new THashMap<FileType,Set<String>>();
      for (      FileType type : myFileTypeManager.getRegisteredFileTypes()) {
        myTypeToExtensionMap.put(type,getExtensions(type));
      }
    }
    @Override public void fileTypesChanged(    final FileTypeEvent event){
      final Map<FileType,Set<String>> oldExtensions=myTypeToExtensionMap;
      myTypeToExtensionMap=null;
      if (oldExtensions != null) {
        final Map<FileType,Set<String>> newExtensions=new THashMap<FileType,Set<String>>();
        for (        FileType type : myFileTypeManager.getRegisteredFileTypes()) {
          newExtensions.put(type,getExtensions(type));
        }
        if (!newExtensions.keySet().containsAll(oldExtensions.keySet())) {
          rebuildAllIndices();
          return;
        }
        for (        Map.Entry<FileType,Set<String>> entry : oldExtensions.entrySet()) {
          FileType fileType=entry.getKey();
          Set<String> strings=entry.getValue();
          if (!newExtensions.get(fileType).containsAll(strings)) {
            rebuildAllIndices();
            return;
          }
        }
      }
    }
    @NotNull private Set<String> getExtensions(    @NotNull FileType type){
      final Set<String> set=new THashSet<String>();
      for (      FileNameMatcher matcher : myFileTypeManager.getAssociations(type)) {
        set.add(matcher.getPresentableString());
      }
      return set;
    }
    private void rebuildAllIndices(){
      for (      ID<?,?> indexId : myIndices.keySet()) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          LOG.info(e);
        }
      }
      scheduleIndexRebuild(true);
    }
  }
);
  connection.subscribe(VirtualFileManager.VFS_CHANGES,new BulkFileListener(){
    @Override public void before(    @NotNull List<? extends VFileEvent> events){
      for (      VFileEvent event : events) {
        final Object requestor=event.getRequestor();
        if (requestor instanceof FileDocumentManager || requestor instanceof PsiManager || requestor == LocalHistory.VFS_EVENT_REQUESTOR) {
          cleanupMemoryStorage();
          break;
        }
      }
    }
    @Override public void after(    @NotNull List<? extends VFileEvent> events){
    }
  }
);
  connection.subscribe(AppTopics.FILE_DOCUMENT_SYNC,new FileDocumentManagerAdapter(){
    @Override public void fileContentReloaded(    VirtualFile file,    @NotNull Document document){
      cleanupMemoryStorage();
    }
    @Override public void unsavedDocumentsDropped(){
      cleanupMemoryStorage();
    }
  }
);
  ApplicationManager.getApplication().addApplicationListener(new ApplicationAdapter(){
    @Override public void writeActionStarted(    Object action){
      myUpToDateIndices.clear();
    }
  }
);
  myChangedFilesCollector=new ChangedFilesCollector();
}
