{
  cleanProcessedFlag(file);
  IndexingStamp.flushCache(file);
  List<ID<?,?>> nontrivialFileIndexedStates=IndexingStamp.getNontrivialFileIndexedStates(file);
  if (!markForReindex) {
    for (    ID<?,?> indexId : nontrivialFileIndexedStates) {
      if (myNotRequiringContentIndices.contains(indexId)) {
        try {
          updateSingleIndex(indexId,file,null);
        }
 catch (        StorageException e) {
          LOG.info(e);
          requestRebuild(indexId);
        }
      }
    }
    myFilesToUpdate.remove(file);
  }
  Collection<ID<?,?>> fileIndexedStatesToUpdate=ContainerUtil.intersection(nontrivialFileIndexedStates,myRequiringContentIndices);
  if (markForReindex) {
    if (!fileIndexedStatesToUpdate.isEmpty()) {
      final List<ID<?,?>> finalNontrivialFileIndexedStates=nontrivialFileIndexedStates;
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          for (int i=0, size=finalNontrivialFileIndexedStates.size(); i < size; ++i) {
            final ID<?,?> indexId=finalNontrivialFileIndexedStates.get(i);
            if (needsFileContentLoading(indexId) && IndexingStamp.isFileIndexedStateCurrent(file,indexId)) {
              IndexingStamp.setFileIndexedStateOutdated(file,indexId);
            }
          }
        }
      }
);
      if (!isTooLarge(file))       scheduleForUpdate(file);
    }
  }
 else   if (!fileIndexedStatesToUpdate.isEmpty()) {
    final Collection<ID<?,?>> finalFileIndexedStatesToUpdate=fileIndexedStatesToUpdate;
    myFutureInvalidations.offer(new InvalidationTask(file){
      @Override public void run(){
        removeFileDataFromIndices(finalFileIndexedStatesToUpdate,file);
      }
    }
);
  }
  IndexingStamp.flushCache(file);
}
