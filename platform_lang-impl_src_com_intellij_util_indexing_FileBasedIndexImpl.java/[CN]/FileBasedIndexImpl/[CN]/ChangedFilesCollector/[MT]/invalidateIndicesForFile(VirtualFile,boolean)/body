{
  cleanProcessedFlag(file);
  final int fileId=Math.abs(getIdMaskingNonIdBasedFile(file));
  IndexingStamp.flushCache(fileId);
  List<ID<?,?>> nontrivialFileIndexedStates=IndexingStamp.getNontrivialFileIndexedStates(fileId);
  if (!markForReindex) {
    for (    ID<?,?> indexId : nontrivialFileIndexedStates) {
      if (myNotRequiringContentIndices.contains(indexId)) {
        try {
          updateSingleIndex(indexId,fileId,null);
        }
 catch (        StorageException e) {
          LOG.info(e);
          requestRebuild(indexId);
        }
      }
    }
    myFilesToUpdate.remove(file);
  }
  Collection<ID<?,?>> fileIndexedStatesToUpdate=ContainerUtil.intersection(nontrivialFileIndexedStates,myRequiringContentIndices);
  if (markForReindex) {
    if (!fileIndexedStatesToUpdate.isEmpty()) {
      for (int i=0, size=nontrivialFileIndexedStates.size(); i < size; ++i) {
        final ID<?,?> indexId=nontrivialFileIndexedStates.get(i);
        if (needsFileContentLoading(indexId) && IndexingStamp.isFileIndexedStateCurrent(fileId,indexId)) {
          IndexingStamp.setFileIndexedStateOutdated(fileId,indexId);
        }
      }
      clearUpToDateStateForPsiIndicesOfUnsavedDocuments(file);
      if (!isTooLarge(file) && getIndexableSetForFile(file) != null)       scheduleForUpdate(file);
    }
  }
 else   if (!fileIndexedStatesToUpdate.isEmpty()) {
    final Collection<ID<?,?>> finalFileIndexedStatesToUpdate=fileIndexedStatesToUpdate;
    myFutureInvalidations.offer(new InvalidationTask(file){
      @Override public void run(){
        removeFileDataFromIndices(finalFileIndexedStatesToUpdate,fileId);
      }
    }
);
  }
  IndexingStamp.flushCache(fileId);
}
