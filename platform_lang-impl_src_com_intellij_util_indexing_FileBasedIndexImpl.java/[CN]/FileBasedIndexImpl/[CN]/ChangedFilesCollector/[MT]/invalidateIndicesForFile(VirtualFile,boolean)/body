{
  cleanProcessedFlag(file);
  IndexingStamp.flushCache(file);
  Collection<ID<?,?>> existingIndexedIds=IndexingStamp.getIndexedIds(file);
  for (  ID<?,?> indexId : existingIndexedIds) {
    if (myNotRequiringContentIndices.contains(indexId)) {
      try {
        updateSingleIndex(indexId,file,null);
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
  }
  Collection<ID<?,?>> indexedIdsToUpdate=ContainerUtil.intersection(existingIndexedIds,myRequiringContentIndices);
  if (markForReindex) {
    if (!indexedIdsToUpdate.isEmpty()) {
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          IndexingStamp.removeAllIndexedState(file);
        }
      }
);
      if (!isTooLarge(file))       scheduleForUpdate(file);
    }
  }
 else {
    boolean removed=myFilesToUpdate.remove(file);
    if (removed) {
      List<ID<?,?>> affectedContentIndices=calculateAffectedContentIndices(null,file);
      affectedContentIndices.addAll(indexedIdsToUpdate);
      indexedIdsToUpdate=affectedContentIndices;
    }
    if (!indexedIdsToUpdate.isEmpty()) {
      final Collection<ID<?,?>> finalIndexedIdsToUpdate=indexedIdsToUpdate;
      myFutureInvalidations.offer(new InvalidationTask(file){
        @Override public void run(){
          removeFileDataFromIndices(finalIndexedIdsToUpdate,file);
        }
      }
);
    }
  }
  IndexingStamp.flushCache(file);
}
