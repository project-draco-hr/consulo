{
  cleanProcessedFlag(file);
  IndexingStamp.flushCache(file);
  Collection<ID<?,?>> existingIndexedIds=IndexingStamp.getIndexedIds(file);
  for (  ID<?,?> indexId : existingIndexedIds) {
    if (myNotRequiringContentIndices.contains(indexId)) {
      try {
        updateSingleIndex(indexId,file,null,true);
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
  }
  final Collection<ID<?,?>> indexedIdsToUpdate=ContainerUtil.intersection(existingIndexedIds,myRequiringContentIndices);
  if (markForReindex) {
    if (!indexedIdsToUpdate.isEmpty()) {
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        @Override public void run(){
          IndexingStamp.removeAllIndexedState(file);
        }
      }
);
    }
    scheduleForUpdate(file);
  }
 else {
    myFilesToUpdate.remove(file);
    if (!indexedIdsToUpdate.isEmpty()) {
      myFutureInvalidations.offer(new InvalidationTask(file){
        @Override public void run(){
          removeFileDataFromIndices(indexedIdsToUpdate,file);
        }
      }
);
    }
  }
  IndexingStamp.flushCache(file);
}
