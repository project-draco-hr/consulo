{
  if (DEBUG_SOFT_WRAP_PROCESSING) {
    log(String.format("xxxxxxxxxxxx CachingSoftWrapDataMapper.onRecalculationEnd(%s, %b). Current cache size: %d",event,normal,myCache.size()));
    if (myCache.size() < 10) {
      log("\tCurrent cache:");
      for (      CacheEntry cacheEntry : myCache) {
        log("\t\t" + cacheEntry);
      }
    }
  }
  int exactOffsetsDiff=event.getExactOffsetsDiff();
  if (normal) {
    myAfterChangeState.updateByDocumentOffsets(event.getNewStartOffset(),event.getNewEndOffset(),event.getNewLogicalLinesDiff());
    myCache.addAll(myNotAffectedByUpdateTailCacheEntries);
  }
 else {
    myAfterChangeState.logicalLines=event.getNewLogicalLinesDiff();
    myAfterChangeState.visualLines=event.getNewLogicalLinesDiff();
    myAfterChangeState.softWrapLines=0;
    myAfterChangeState.foldedLines=0;
    myCache.addAll(myNotAffectedByUpdateTailCacheEntries);
  }
  applyStateChange(exactOffsetsDiff);
  if (myCache.size() > 1) {
    CacheEntry beforeLast=myCache.get(myCache.size() - 2);
    CacheEntry last=myCache.get(myCache.size() - 1);
    if (beforeLast.visualLine == last.visualLine || (beforeLast.visualLine + 1 == last.visualLine && last.startOffset - beforeLast.endOffset > 1) || last.startOffset > myEditor.getDocument().getTextLength()) {
      logInvalidUpdate(event,normal);
    }
  }
  if (!myCache.isEmpty() && myEditor.getDocument().getTextLength() == 0) {
    logInvalidUpdate(event,normal);
  }
  myAffectedByUpdateCacheEntries.clear();
  myNotAffectedByUpdateTailCacheEntries.clear();
  if (DEBUG_SOFT_WRAP_PROCESSING) {
    log("After Applying state change");
    dumpCache();
  }
  myBeforeChangeState.cacheShouldBeUpdated=false;
}
