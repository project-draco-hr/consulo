{
  reset();
  Document document=myEditor.getDocument();
  startCacheEntryIndex=MappingUtil.getCacheEntryIndexForOffset(startOffset,document,myCache);
  endCacheEntryIndex=MappingUtil.getCacheEntryIndexForOffset(endOffset,document,myCache);
  logicalLines=logicalLinesDiff;
  visualLines=logicalLinesDiff;
  softWrapLines=myStorage.getNumberOfSoftWrapsInRange(startOffset,endOffset);
  visualLines+=softWrapLines;
  if (startCacheEntryIndex < 0 && -startCacheEntryIndex - 1 >= myCache.size()) {
    cacheShouldBeUpdated=false;
    return;
  }
  foldedLines=0;
  int startIndex=startCacheEntryIndex;
  if (startIndex < 0) {
    startIndex=-startIndex - 1;
    if (startIndex >= myCache.size() || myCache.get(startIndex).startOffset > endOffset) {
      return;
    }
  }
  int endIndex=endCacheEntryIndex;
  if (endIndex < 0) {
    endIndex=-endIndex - 2;
    endIndex=Math.max(0,Math.min(endIndex,myCache.size() - 1));
  }
  for (int i=startIndex; i <= endIndex; i++) {
    CacheEntry cacheEntry=myCache.get(i);
    foldedLines+=cacheEntry.endFoldedLines - cacheEntry.startFoldedLines;
  }
  visualLines-=foldedLines;
  if (DEBUG_SOFT_WRAP_PROCESSING) {
    log(String.format("CachingSoftWrapDataMapper$CacheState.updateByDocumentOffsets(). Collected %d fold lines for cache entry indices " + "%d-%d (cache size is %d)",foldedLines,startCacheEntryIndex,endCacheEntryIndex,myCache.size()));
  }
}
