{
  if (path == null || myInitialPsiElement == null) {
    return paths.get(0).node;
  }
  final Set<PsiElement> parents=getAllParents(myInitialPsiElement);
  ArrayList<ObjectWithWeight> cur=new ArrayList<ObjectWithWeight>();
  int max=-1;
  for (  ObjectWithWeight p : paths) {
    final Object last=((TreePath)p.node).getLastPathComponent();
    final List<PsiElement> elements=new ArrayList<PsiElement>();
    final Object object=((DefaultMutableTreeNode)last).getUserObject();
    if (object instanceof FilteringTreeStructure.FilteringNode) {
      FilteringTreeStructure.FilteringNode node=(FilteringTreeStructure.FilteringNode)object;
      FilteringTreeStructure.FilteringNode candidate=node;
      while (node != null) {
        elements.add(getPsi(node));
        node=node.getParentNode();
      }
      final int size=ContainerUtil.intersection(parents,elements).size();
      if (size == elements.size() - 1 && size == parents.size() && candidate.children().isEmpty()) {
        return p.node;
      }
      if (size > max) {
        max=size;
        cur.clear();
        cur.add(p);
      }
 else       if (size == max) {
        cur.add(p);
      }
    }
  }
  Collections.sort(cur,new Comparator<ObjectWithWeight>(){
    @Override public int compare(    ObjectWithWeight o1,    ObjectWithWeight o2){
      final int i=o1.compareWith(o2);
      return i != 0 ? i : ((TreePath)o2.node).getPathCount() - ((TreePath)o1.node).getPathCount();
    }
  }
);
  return cur.isEmpty() ? null : cur.get(0).node;
}
