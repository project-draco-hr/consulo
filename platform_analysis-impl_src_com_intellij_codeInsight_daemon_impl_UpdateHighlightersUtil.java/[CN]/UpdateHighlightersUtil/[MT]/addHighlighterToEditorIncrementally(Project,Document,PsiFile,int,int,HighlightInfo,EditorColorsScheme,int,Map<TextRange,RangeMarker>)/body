{
  ApplicationManager.getApplication().assertIsDispatchThread();
  if (isFileLevelOrGutterAnnotation(info))   return;
  if (info.getStartOffset() < startOffset || info.getEndOffset() > endOffset)   return;
  MarkupModel markup=DocumentMarkupModel.forDocument(document,project,true);
  final SeverityRegistrar severityRegistrar=SeverityRegistrar.getSeverityRegistrar(project);
  final boolean myInfoIsError=isSevere(info,severityRegistrar);
  Processor<HighlightInfo> otherHighlightInTheWayProcessor=new Processor<HighlightInfo>(){
    @Override public boolean process(    HighlightInfo oldInfo){
      if (!myInfoIsError && isCovered(info,severityRegistrar,oldInfo)) {
        return false;
      }
      return oldInfo.getGroup() != group || !oldInfo.equalsByActualOffset(info);
    }
  }
;
  boolean allIsClear=DaemonCodeAnalyzerEx.processHighlights(document,project,null,info.getActualStartOffset(),info.getActualEndOffset(),otherHighlightInTheWayProcessor);
  if (allIsClear) {
    createOrReuseHighlighterFor(info,colorsScheme,document,group,file,(MarkupModelEx)markup,null,ranges2markersCache,severityRegistrar);
    clearWhiteSpaceOptimizationFlag(document);
    assertMarkupConsistent(markup,project);
  }
}
