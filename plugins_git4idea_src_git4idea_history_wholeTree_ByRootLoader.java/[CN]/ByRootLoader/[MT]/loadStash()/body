{
  if (myStartingPoints != null && (!myStartingPoints.isEmpty()))   return;
  final List<GitCommit> details=new ArrayList<GitCommit>();
  final List<CommitI> commits=new ArrayList<CommitI>();
  final Map<AbstractHash,String> stashMap=new HashMap<AbstractHash,String>();
  final List<List<AbstractHash>> parents=myGitLogFilters.isEmpty() ? new ArrayList<List<AbstractHash>>() : null;
  myGitLogFilters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
    @Override public void consume(    List<ChangesFilter.Filter> filters){
      ProgressManager.checkCanceled();
      try {
        final List<String> parameters=new ArrayList<String>();
        final List<VirtualFile> paths=new ArrayList<VirtualFile>();
        ChangesFilter.filtersToParameters(filters,parameters,paths);
        final List<Pair<String,GitCommit>> stash=GitHistoryUtils.loadStashStackAsCommits(myProject,myRootHolder.getRoot(),mySymbolicRefs,parameters.toArray(new String[parameters.size()]));
        if (stash == null)         return;
        for (        Pair<String,GitCommit> pair : stash) {
          ProgressManager.checkCanceled();
          final GitCommit gitCommit=pair.getSecond();
          if (stashMap.containsKey(gitCommit.getShortHash()))           continue;
          details.add(gitCommit);
          if (parents != null) {
            parents.add(gitCommit.getConvertedParents());
          }
          commits.add(createCommitI(gitCommit));
          stashMap.put(gitCommit.getShortHash(),pair.getFirst());
        }
      }
 catch (      VcsException e) {
        myMediator.acceptException(e);
      }
    }
  }
,true,myRootHolder.getRoot());
  myDetailsCache.putStash(myRootHolder.getRoot(),stashMap);
  ProgressManager.checkCanceled();
  myMediator.appendResult(myTicket,commits,parents,myRootHolder.getRoot(),false);
}
