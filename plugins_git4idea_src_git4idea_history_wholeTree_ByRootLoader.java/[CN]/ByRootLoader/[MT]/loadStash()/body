{
  if (myStartingPoints != null && (!myStartingPoints.isEmpty()))   return;
  final List<GitCommit> details=new ArrayList<GitCommit>();
  final List<CommitI> commits=new ArrayList<CommitI>();
  final Map<AbstractHash,String> stashMap=new HashMap<AbstractHash,String>();
  final List<List<AbstractHash>> parents=myGitLogFilters.isEmpty() ? new ArrayList<List<AbstractHash>>() : null;
  myGitLogFilters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
    @Override public void consume(    List<ChangesFilter.Filter> filters){
      ProgressManager.checkCanceled();
      try {
        final List<Pair<String,GitCommit>> stash=GitHistoryUtils.loadStashStackAsCommits(myProject,myRootHolder.getRoot(),mySymbolicRefs,ChangesFilter.filtersToParameterArray(filters));
        if (stash == null)         return;
        for (        Pair<String,GitCommit> pair : stash) {
          ProgressManager.checkCanceled();
          final GitCommit gitCommit=pair.getSecond();
          if (stashMap.containsKey(gitCommit.getShortHash()))           continue;
          details.add(gitCommit);
          if (parents != null) {
            parents.add(gitCommit.getConvertedParents());
          }
          commits.add(createCommitI(gitCommit));
          stashMap.put(gitCommit.getShortHash(),pair.getFirst());
        }
      }
 catch (      VcsException e) {
        myMediator.acceptException(e);
      }
    }
  }
,true);
  myDetailsCache.putStash(myRootHolder.getRoot(),stashMap);
  ProgressManager.checkCanceled();
  myMediator.appendResult(myTicket,commits,parents);
}
