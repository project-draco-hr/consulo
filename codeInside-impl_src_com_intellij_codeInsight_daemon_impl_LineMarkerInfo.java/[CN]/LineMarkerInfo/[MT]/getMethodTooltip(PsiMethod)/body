{
  if (type == OVERRIDING_METHOD) {
    PsiMethod[] superMethods=method.findSuperMethods(false);
    if (superMethods.length == 0)     return null;
    PsiMethod superMethod=superMethods[0];
    boolean isAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
    boolean isSuperAbstract=superMethod.hasModifierProperty(PsiModifier.ABSTRACT);
    final boolean sameSignature=superMethod.getSignature(PsiSubstitutor.EMPTY).equals(method.getSignature(PsiSubstitutor.EMPTY));
    @NonNls final String key;
    if (isSuperAbstract && !isAbstract) {
      key=sameSignature ? "method.implements" : "method.implements.2";
    }
 else {
      key=sameSignature ? "method.overrides" : "method.overrides.2";
    }
    return composeText(superMethods,"",DaemonBundle.message(key));
  }
 else   if (type == OVERRIDEN_METHOD) {
    PsiManager manager=method.getManager();
    PsiSearchHelper helper=manager.getSearchHelper();
    PsiElementProcessor.CollectElementsWithLimit<PsiMethod> processor=new PsiElementProcessor.CollectElementsWithLimit<PsiMethod>(5);
    helper.processOverridingMethods(processor,method,GlobalSearchScope.allScope(manager.getProject()),true);
    boolean isAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
    if (processor.isOverflow()) {
      return isAbstract ? DaemonBundle.message("method.is.implemented.too.many") : DaemonBundle.message("method.is.overridden.too.many");
    }
    PsiMethod[] overridings=processor.toArray(new PsiMethod[processor.getCollection().size()]);
    if (overridings.length == 0)     return null;
    Comparator<PsiMethod> comparator=new MethodCellRenderer(false).getComparator();
    Arrays.sort(overridings,comparator);
    String start=isAbstract ? DaemonBundle.message("method.is.implemented.header") : DaemonBundle.message("method.is.overriden.header");
    @NonNls String pattern="&nbsp;&nbsp;&nbsp;&nbsp;{1}";
    return composeText(overridings,start,pattern);
  }
 else {
    return null;
  }
}
