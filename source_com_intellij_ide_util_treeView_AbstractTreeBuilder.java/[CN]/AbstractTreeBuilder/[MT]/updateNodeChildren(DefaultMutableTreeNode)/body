{
  myTreeStructure.commit();
  boolean wasExpanded=myTree.isExpanded(new TreePath(node.getPath()));
  final boolean wasLeaf=node.getChildCount() == 0;
  final NodeDescriptor descriptor=(NodeDescriptor)node.getUserObject();
  if (descriptor == null)   return;
  if (myUnbuiltNodes.contains(node)) {
    if (isAlwaysShowPlus(descriptor))     return;
    Object element=descriptor.getElement();
    if (myTreeStructure.isToBuildChildrenInBackground(element))     return;
    Object[] children=myTreeStructure.getChildElements(descriptor.getElement());
    if (children.length == 0) {
      for (int i=0; i < node.getChildCount(); i++) {
        if (node.getChildAt(i) instanceof LoadingNode) {
          myTreeModel.removeNodeFromParent((MutableTreeNode)node.getChildAt(i));
          break;
        }
      }
      myUnbuiltNodes.remove(node);
    }
    return;
  }
  Object element=descriptor.getElement();
  if (myTreeStructure.isToBuildChildrenInBackground(element)) {
    Runnable updateRunnable=new Runnable(){
      public void run(){
        descriptor.update();
        Object element=descriptor.getElement();
        if (element == null)         return;
        myTreeStructure.getChildElements(element);
      }
    }
;
    Runnable postRunnable=new Runnable(){
      public void run(){
        descriptor.update();
        Object element=descriptor.getElement();
        if (element != null) {
          myUnbuiltNodes.remove(node);
          myUpdater.addSubtreeToUpdateByElement(element);
          myUpdater.performUpdate();
          for (int i=0; i < node.getChildCount(); i++) {
            TreeNode child=node.getChildAt(i);
            if (child instanceof LoadingNode) {
              if (TreeBuilderUtil.isNodeOrChildSelected(myTree,node)) {
                myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(node)));
              }
              myTreeModel.removeNodeFromParent((MutableTreeNode)child);
              break;
            }
          }
        }
      }
    }
;
    String text=" searching...";
    for (int i=0; i < node.getChildCount(); i++) {
      TreeNode child=node.getChildAt(i);
      if (child instanceof LoadingNode && text.equals(((LoadingNode)child).getUserObject())) {
        return;
      }
    }
    LoadingNode loadingNode=new LoadingNode(text);
    myTreeModel.insertNodeInto(loadingNode,node,node.getChildCount());
    addTaskToWorker(updateRunnable,true,postRunnable);
    return;
  }
  Object[] children=myTreeStructure.getChildElements(descriptor.getElement());
  Map<Object,Integer> elementToIndexMap=new LinkedHashMap<Object,Integer>();
  for (int i=0; i < children.length; i++) {
    Object child=children[i];
    elementToIndexMap.put(child,new Integer(i));
  }
  ArrayList<TreeNode> childNodes=TreeUtil.childrenToArray(node);
  for (int i=0; i < childNodes.size(); i++) {
    DefaultMutableTreeNode childNode=(DefaultMutableTreeNode)childNodes.get(i);
    if (childNode instanceof LoadingNode)     continue;
    NodeDescriptor childDescr=(NodeDescriptor)childNode.getUserObject();
    if (childDescr == null) {
      boolean isInMap=myElementToNodeMap.containsValue(childNode);
      LOG.error("childDescr == null, builder=" + this + ", childNode="+ childNode.getClass()+ ", isInMap = "+ isInMap+ ", node = "+ node);
      continue;
    }
    Object oldElement=childDescr.getElement();
    if (oldElement == null) {
      LOG.error("oldElement == null, builder=" + this + ", childDescr="+ childDescr);
      continue;
    }
    boolean changes=childDescr.update();
    Object newElement=childDescr.getElement();
    Integer index=newElement != null ? elementToIndexMap.get(newElement) : null;
    if (index != null) {
      if (childDescr.getIndex() != index.intValue()) {
        changes=true;
      }
      childDescr.setIndex(index.intValue());
    }
    if (newElement != null && changes) {
      updateNodeImageAndPosition(childNode);
    }
    if (!oldElement.equals(newElement)) {
      removeMapping(oldElement,childNode);
      if (newElement != null) {
        createMapping(newElement,childNode);
      }
    }
    if (index == null) {
      int selectedIndex=-1;
      if (TreeBuilderUtil.isNodeOrChildSelected(myTree,childNode)) {
        selectedIndex=node.getIndex(childNode);
      }
      myTreeModel.removeNodeFromParent(childNode);
      disposeNode(childNode);
      if (selectedIndex >= 0) {
        if (node.getChildCount() > 0) {
          if (node.getChildCount() > selectedIndex) {
            TreeNode newChildNode=node.getChildAt(selectedIndex);
            myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(newChildNode)));
          }
 else {
            TreeNode newChild=node.getChildAt(node.getChildCount() - 1);
            myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(newChild)));
          }
        }
 else {
          myTree.addSelectionPath(new TreePath(myTreeModel.getPathToRoot(node)));
        }
      }
    }
 else {
      elementToIndexMap.remove(newElement);
      updateNodeChildren(childNode);
    }
    if (node.equals(myRootNode)) {
      myTreeModel.nodeChanged(myRootNode);
    }
  }
  ArrayList<TreeNode> nodesToInsert=new ArrayList<TreeNode>();
  for (Iterator<Object> iterator=elementToIndexMap.keySet().iterator(); iterator.hasNext(); ) {
    Object child=iterator.next();
    Integer index=elementToIndexMap.get(child);
    final NodeDescriptor childDescr=myTreeStructure.createDescriptor(child,descriptor);
    if (childDescr == null) {
      LOG.error("childDescr == null, treeStructure = " + myTreeStructure + ", child = "+ child);
      continue;
    }
    childDescr.setIndex(index.intValue());
    childDescr.update();
    if (childDescr.getElement() == null) {
      LOG.error("childDescr.getElement() == null, child = " + child + ", builder = "+ this);
      continue;
    }
    final DefaultMutableTreeNode childNode=new DefaultMutableTreeNode(childDescr);
    nodesToInsert.add(childNode);
    createMapping(child,childNode);
  }
  insertNodesInto(nodesToInsert,node);
  for (int i=0; i < nodesToInsert.size(); i++) {
    DefaultMutableTreeNode childNode=(DefaultMutableTreeNode)nodesToInsert.get(i);
    addLoadingNode(childNode);
    updateNodeChildren(childNode);
  }
  if (wasExpanded) {
    myTree.expandPath(new TreePath(node.getPath()));
  }
  if (wasExpanded || wasLeaf) {
    final Alarm alarm=new Alarm(Alarm.ThreadToUse.SHARED_THREAD);
    alarm.addRequest(new Runnable(){
      public void run(){
        myTree.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
      }
    }
,WAIT_CURSOR_DELAY);
    if (wasLeaf && isAutoExpandNode(descriptor)) {
      myTree.expandPath(new TreePath(node.getPath()));
    }
    ArrayList<TreeNode> nodes=TreeUtil.childrenToArray(node);
    for (int i=0; i < nodes.size(); i++) {
      DefaultMutableTreeNode childNode=(DefaultMutableTreeNode)nodes.get(i);
      if (childNode instanceof LoadingNode)       continue;
      NodeDescriptor childDescr=(NodeDescriptor)childNode.getUserObject();
      if (isAutoExpandNode(childDescr)) {
        myTree.expandPath(new TreePath(childNode.getPath()));
      }
    }
    int n=alarm.cancelAllRequests();
    if (n == 0) {
      myTree.setCursor(Cursor.getDefaultCursor());
    }
  }
}
