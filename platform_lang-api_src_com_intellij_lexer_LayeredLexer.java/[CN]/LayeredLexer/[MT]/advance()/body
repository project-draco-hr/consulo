{
  if (myState == IN_LAYER_LEXER_FINISHED_STATE) {
    myState=super.getState();
    return;
  }
  if (isLayerActive()) {
    final Lexer activeLayerLexer=myCurrentLayerLexer;
    IElementType layerTokenType=activeLayerLexer.getTokenType();
    if (!isStopToken(myCurrentLayerLexer,layerTokenType)) {
      myCurrentLayerLexer.advance();
      layerTokenType=myCurrentLayerLexer.getTokenType();
    }
 else {
      layerTokenType=null;
    }
    if (layerTokenType == null) {
      int tokenEnd=myCurrentLayerLexer.getTokenEnd();
      if (!mySelfStoppingLexers.contains(myCurrentLayerLexer)) {
        myCurrentLayerLexer=null;
        super.advance();
        activateLayerIfNecessary();
      }
 else {
        myCurrentLayerLexer=null;
        if (tokenEnd != myBaseTokenEnd) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("We've got not covered gap from layered lexer: " + activeLayerLexer + "\n on token: "+ getBufferSequence().subSequence(myLayerLeftPart,myBaseTokenEnd));
          }
          myState=IN_LAYER_LEXER_FINISHED_STATE;
          myLayerLeftPart=tokenEnd;
          return;
        }
      }
    }
  }
 else {
    super.advance();
    activateLayerIfNecessary();
  }
  myState=isLayerActive() ? IN_LAYER_STATE : super.getState();
}
