{
  List<T> nulls=null;
  TreeMap<Comparable,List<T>> map=new TreeMap<Comparable,List<T>>();
  for (  T t : myNext.classify(source,context)) {
    final Comparable weight=getWeight(t);
    if (weight == null) {
      if (nulls == null)       nulls=new SmartList<T>();
      nulls.add(t);
    }
 else {
      List<T> list=map.get(weight);
      if (list == null) {
        map.put(weight,list=new SmartList<T>());
      }
      list.add(t);
    }
  }
  final Collection<List<T>> values=myNegated ? map.descendingMap().values() : map.values();
  final List<T> lastGroup=nulls == null ? Collections.<T>emptyList() : nulls;
  return new Iterable<T>(){
    @Override public Iterator<T> iterator(){
      return new Iterator<T>(){
        private Iterator<List<T>> valuesIterator=values.iterator();
        private Iterator<T> groupIterator=Collections.<T>emptyList().iterator();
        private boolean passedLast;
        @Override public boolean hasNext(){
          while (!groupIterator.hasNext() && valuesIterator.hasNext()) {
            groupIterator=valuesIterator.next().iterator();
          }
          if (!groupIterator.hasNext() && !valuesIterator.hasNext() && !passedLast) {
            passedLast=true;
            groupIterator=lastGroup.iterator();
          }
          return groupIterator.hasNext();
        }
        @Override public T next(){
          if (!hasNext()) {
            throw new AssertionError();
          }
          return groupIterator.next();
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
;
}
