{
  super(element);
  myNewType=newType;
  final PsiMethod[] constructors=targetClasses[0].getConstructors();
  final PsiMethod constructor=element.resolveConstructor();
  if (constructor == null) {
    if (constructors.length == 1 && constructors[0].getParameterList().getParametersCount() > 0 || constructors.length > 1) {
      myConflict=CONSTRUCTOR_MATCHING_SUPER_NOT_FOUND;
    }
  }
 else {
    final PsiParameter[] superParameters=constructor.getParameterList().getParameters();
    boolean foundMatchingConstructor=constructors.length == 0 && superParameters.length == 0;
    constr:     for (    PsiMethod method : constructors) {
      final PsiParameter[] parameters=method.getParameterList().getParameters();
      if (superParameters.length == parameters.length) {
        for (int i=0; i < parameters.length; i++) {
          PsiParameter parameter=parameters[i];
          if (!TypeConversionUtil.isAssignable(TypeConversionUtil.erasure(parameter.getType()),TypeConversionUtil.erasure(superParameters[i].getType()))) {
            continue constr;
          }
        }
        foundMatchingConstructor=true;
      }
    }
    if (!foundMatchingConstructor) {
      myConflict=CONSTRUCTOR_MATCHING_SUPER_NOT_FOUND;
    }
  }
  PsiType type=element.getType();
  if (type == null) {
    appendConflict("Type is unknown");
    return;
  }
 else {
    type=type.getDeepComponentType();
  }
  if (!TypeConversionUtil.isAssignable(type,newType)) {
    final String conflict="Type parameters do not agree in " + element.getText() + ". "+ "Expected "+ newType.getPresentableText()+ " but found "+ type.getPresentableText();
    appendConflict(conflict);
  }
  if (targetClasses.length > 1) {
    final String conflict="Constructor " + element.getText() + " can be replaced with any of "+ StringUtil.join(targetClasses,new Function<PsiClass,String>(){
      public String fun(      final PsiClass psiClass){
        return psiClass.getQualifiedName();
      }
    }
,", ");
    appendConflict(conflict);
  }
}
