{
  boolean pointsChanged=false;
  for (  mxPoint point : newPoints) {
    if (point == null) {
      return;
    }
  }
  if (newPoints.size() != guidePoints.size()) {
    pointsChanged=true;
  }
 else {
    if (newPoints.size() == guidePoints.size() && newPoints.size() > 1 && guidePoints.size() > 1) {
      boolean constantTranslation=true;
      boolean trivialTranslation=true;
      mxPoint newPoint0=newPoints.get(0);
      mxPoint oldPoint0=guidePoints.get(0);
      double transX=newPoint0.getX() - oldPoint0.getX();
      double transY=newPoint0.getY() - oldPoint0.getY();
      if (Math.abs(transX) > 0.01 || Math.abs(transY) > 0.01) {
        trivialTranslation=false;
      }
      for (int i=1; i < newPoints.size(); i++) {
        double nextTransX=newPoints.get(i).getX() - guidePoints.get(i).getX();
        double nextTransY=newPoints.get(i).getY() - guidePoints.get(i).getY();
        if (Math.abs(transX - nextTransX) > 0.01 || Math.abs(transY - nextTransY) > 0.01) {
          constantTranslation=false;
        }
        if (Math.abs(nextTransX) > 0.01 || Math.abs(nextTransY) > 0.01) {
          trivialTranslation=false;
        }
      }
      if (trivialTranslation) {
        pointsChanged=false;
      }
 else       if (constantTranslation) {
        pointsChanged=false;
        Collection<mxPoint[]> curves=points.values();
        for (        mxPoint[] curve : curves) {
          for (int i=0; i < curve.length; i++) {
            curve[i].setX(curve[i].getX() + transX);
            curve[i].setY(curve[i].getY() + transY);
          }
        }
        guidePoints=new ArrayList<mxPoint>(newPoints);
        minXBounds+=transX;
        minYBounds+=transY;
        maxXBounds+=transX;
        maxYBounds+=transY;
      }
 else {
        pointsChanged=true;
      }
    }
  }
  if (pointsChanged) {
    guidePoints=new ArrayList<mxPoint>(newPoints);
    points=new Hashtable<String,mxPoint[]>();
    valid=false;
  }
}
