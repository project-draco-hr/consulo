{
  String name=reference.getReferenceName();
  if (name == null)   return;
  Project project=reference.getProject();
  final ProjectFileIndex fileIndex=ProjectRootManager.getInstance(project).getFileIndex();
  PsiFile containingFile=reference.getContainingFile();
  if (containingFile == null)   return;
  VirtualFile classVFile=containingFile.getVirtualFile();
  if (classVFile == null)   return;
  final Module currentModule=fileIndex.getModuleForFile(classVFile);
  if (currentModule == null)   return;
  PsiClass[] classes=reference.getManager().getShortNamesCache().getClassesByName(name,GlobalSearchScope.allScope(project));
  for (  final PsiClass aClass : classes) {
    if (!aClass.getManager().getResolveHelper().isAccessible(aClass,reference,aClass))     continue;
    PsiFile psiFile=aClass.getContainingFile();
    if (psiFile == null)     continue;
    VirtualFile virtualFile=psiFile.getVirtualFile();
    if (virtualFile == null)     continue;
    final Module classModule=fileIndex.getModuleForFile(virtualFile);
    if (classModule != null && !ModuleRootManager.getInstance(currentModule).isDependsOn(classModule)) {
      QuickFixAction.registerQuickFixAction(info,new OrderEntryFix(){
        @NotNull public String getText(){
          return QuickFixBundle.message("orderEntry.fix.add.dependency.on.module",classModule.getName());
        }
        @NotNull public String getFamilyName(){
          return QuickFixBundle.message("orderEntry.fix.family.add.module.dependency");
        }
        public boolean isAvailable(        Project project,        Editor editor,        PsiFile file){
          return !project.isDisposed() && !classModule.isDisposed() && !currentModule.isDisposed();
        }
        public void invoke(        final Project project,        final Editor editor,        PsiFile file) throws IncorrectOperationException {
          final Runnable doit=new Runnable(){
            public void run(){
              ModifiableRootModel model=ModuleRootManager.getInstance(currentModule).getModifiableModel();
              model.addModuleOrderEntry(classModule);
              model.commit();
              new AddImportAction(project,reference,editor,aClass).execute();
            }
          }
;
          final Pair<Module,Module> circularModules=ModulesConfigurator.addingDependencyFormsCircularity(currentModule,classModule);
          if (circularModules == null) {
            doit.run();
          }
 else {
            showCircularWarningAndContinue(project,circularModules,classModule,doit);
          }
        }
      }
);
    }
    List<OrderEntry> orderEntries=fileIndex.getOrderEntriesForFile(virtualFile);
    for (    OrderEntry orderEntry : orderEntries) {
      if (orderEntry instanceof LibraryOrderEntry) {
        final LibraryOrderEntry libraryEntry=(LibraryOrderEntry)orderEntry;
        final Library library=libraryEntry.getLibrary();
        QuickFixAction.registerQuickFixAction(info,new OrderEntryFix(){
          @NotNull public String getText(){
            return QuickFixBundle.message("orderEntry.fix.add.library.to.classpath",libraryEntry.getPresentableName());
          }
          @NotNull public String getFamilyName(){
            return QuickFixBundle.message("orderEntry.fix.family.add.library.to.classpath");
          }
          public boolean isAvailable(          Project project,          Editor editor,          PsiFile file){
            return !project.isDisposed() && !currentModule.isDisposed() && libraryEntry.isValid();
          }
          public void invoke(          Project project,          Editor editor,          PsiFile file) throws IncorrectOperationException {
            ModifiableRootModel model=ModuleRootManager.getInstance(currentModule).getModifiableModel();
            model.addLibraryEntry(library);
            model.commit();
            new AddImportAction(project,reference,editor,aClass).execute();
          }
        }
);
      }
    }
  }
}
