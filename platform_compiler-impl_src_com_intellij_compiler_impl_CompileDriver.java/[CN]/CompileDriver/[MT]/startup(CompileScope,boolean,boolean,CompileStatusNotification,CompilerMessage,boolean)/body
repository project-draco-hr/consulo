{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final boolean useExtProcessBuild=useOutOfProcessBuild();
  final String contentName=forceCompile ? CompilerBundle.message("compiler.content.name.compile") : CompilerBundle.message("compiler.content.name.make");
  final CompilerTask compileTask=new CompilerTask(myProject,contentName,ApplicationManager.getApplication().isUnitTestMode(),true,true,isCompilationStartedAutomatically(scope));
  StatusBar.Info.set("",myProject,"Compiler");
  if (useExtProcessBuild) {
    myProject.save();
    if (!ApplicationManager.getApplication().isUnitTestMode()) {
      ApplicationManager.getApplication().saveSettings();
    }
  }
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  FileDocumentManager.getInstance().saveAllDocuments();
  final DependencyCache dependencyCache=useExtProcessBuild ? null : createDependencyCache();
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,compileTask,scope,dependencyCache,!isRebuild && !forceCompile,isRebuild);
  if (!useExtProcessBuild) {
    for (    Map.Entry<Pair<IntermediateOutputCompiler,Module>,Pair<VirtualFile,VirtualFile>> entry : myGenerationCompilerModuleToOutputDirMap.entrySet()) {
      final Pair<VirtualFile,VirtualFile> outputs=entry.getValue();
      final Pair<IntermediateOutputCompiler,Module> key=entry.getKey();
      final Module module=key.getSecond();
      compileContext.assignModule(outputs.getFirst(),module,false,key.getFirst());
      compileContext.assignModule(outputs.getSecond(),module,true,key.getFirst());
    }
    attachAdditionalOutputDirectories(compileContext);
  }
  final Runnable compileWork=new Runnable(){
    @Override public void run(){
      if (compileContext.getProgressIndicator().isCanceled()) {
        if (callback != null) {
          callback.finished(true,0,0,compileContext);
        }
        return;
      }
      try {
        if (myProject.isDisposed()) {
          return;
        }
        LOG.info("COMPILATION STARTED");
        if (message != null) {
          compileContext.addMessage(message);
        }
        doCompile(compileContext,isRebuild,forceCompile,callback,checkCachesVersion);
      }
  finally {
        FileUtil.delete(CompilerPaths.getRebuildMarkerFile(myProject));
      }
    }
  }
;
  compileTask.start(compileWork,new Runnable(){
    @Override public void run(){
      if (isRebuild) {
        final int rv=Messages.showOkCancelDialog(myProject,"You are about to rebuild the whole project.\nRun 'Make Project' instead?","Confirm Project Rebuild","Make","Rebuild",Messages.getQuestionIcon());
        if (rv == 0) {
          startup(scope,false,false,callback,null,checkCachesVersion);
          return;
        }
      }
      startup(scope,isRebuild,forceCompile,callback,message,checkCachesVersion);
    }
  }
);
}
