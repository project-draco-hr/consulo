{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final boolean useExtProcessBuild=useOutOfProcessBuild();
  final String contentName=forceCompile ? CompilerBundle.message("compiler.content.name.compile") : CompilerBundle.message("compiler.content.name.make");
  final CompilerTask compileTask=new CompilerTask(myProject,contentName,ApplicationManager.getApplication().isUnitTestMode(),true,true,isCompilationStartedAutomatically(scope));
  StatusBar.Info.set("",myProject,"Compiler");
  if (useExtProcessBuild) {
    myProject.save();
    if (!ApplicationManager.getApplication().isUnitTestMode()) {
      ApplicationManager.getApplication().saveSettings();
    }
  }
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  FileDocumentManager.getInstance().saveAllDocuments();
  final DependencyCache dependencyCache=useExtProcessBuild ? null : createDependencyCache();
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,compileTask,scope,dependencyCache,!isRebuild && !forceCompile,isRebuild);
  if (!useExtProcessBuild) {
    for (    Map.Entry<Pair<IntermediateOutputCompiler,Module>,Pair<VirtualFile,VirtualFile>> entry : myGenerationCompilerModuleToOutputDirMap.entrySet()) {
      final Pair<VirtualFile,VirtualFile> outputs=entry.getValue();
      final Pair<IntermediateOutputCompiler,Module> key=entry.getKey();
      final Module module=key.getSecond();
      compileContext.assignModule(outputs.getFirst(),module,false,key.getFirst());
      compileContext.assignModule(outputs.getSecond(),module,true,key.getFirst());
    }
    attachAdditionalOutputDirectories(compileContext);
  }
  final Runnable compileWork;
  if (useExtProcessBuild) {
    compileWork=new Runnable(){
      @Override public void run(){
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        if (indicator.isCanceled() || myProject.isDisposed()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        try {
          LOG.info("COMPILATION STARTED (BUILD PROCESS)");
          if (message != null) {
            compileContext.addMessage(message);
          }
          final boolean beforeTasksOk=executeCompileTasks(compileContext,true);
          final int errorCount=compileContext.getMessageCount(CompilerMessageCategory.ERROR);
          if (!beforeTasksOk || errorCount > 0) {
            COMPILE_SERVER_BUILD_STATUS.set(compileContext,errorCount > 0 ? ExitStatus.ERRORS : ExitStatus.CANCELLED);
            return;
          }
          final RequestFuture future=compileInExternalProcess(compileContext,false);
          if (future != null) {
            while (!future.waitFor(200L,TimeUnit.MILLISECONDS)) {
              if (indicator.isCanceled()) {
                future.cancel(false);
              }
            }
            if (!executeCompileTasks(compileContext,false)) {
              COMPILE_SERVER_BUILD_STATUS.set(compileContext,ExitStatus.CANCELLED);
            }
            if (compileContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
              COMPILE_SERVER_BUILD_STATUS.set(compileContext,ExitStatus.ERRORS);
            }
          }
        }
 catch (        Throwable e) {
          LOG.error(e);
        }
 finally {
          CompilerCacheManager.getInstance(myProject).flushCaches();
          final long duration=notifyCompilationCompleted(compileContext,callback,COMPILE_SERVER_BUILD_STATUS.get(compileContext),true);
          CompilerUtil.logDuration("\tCOMPILATION FINISHED (BUILD PROCESS); Errors: " + compileContext.getMessageCount(CompilerMessageCategory.ERROR) + "; warnings: "+ compileContext.getMessageCount(CompilerMessageCategory.WARNING),duration);
        }
      }
    }
;
  }
 else {
    compileWork=new Runnable(){
      @Override public void run(){
        if (compileContext.getProgressIndicator().isCanceled()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        try {
          if (myProject.isDisposed()) {
            return;
          }
          LOG.info("COMPILATION STARTED");
          if (message != null) {
            compileContext.addMessage(message);
          }
          doCompile(compileContext,isRebuild,forceCompile,callback,checkCachesVersion);
        }
  finally {
          FileUtil.delete(CompilerPaths.getRebuildMarkerFile(myProject));
        }
      }
    }
;
  }
  compileTask.start(compileWork,new Runnable(){
    @Override public void run(){
      if (isRebuild) {
        final int rv=Messages.showOkCancelDialog(myProject,"You are about to rebuild the whole project.\nRun 'Make Project' instead?","Confirm Project Rebuild","Make","Rebuild",Messages.getQuestionIcon());
        if (rv == 0) {
          startup(scope,false,false,callback,null,checkCachesVersion);
          return;
        }
      }
      startup(scope,isRebuild,forceCompile,callback,message,checkCachesVersion);
    }
  }
);
}
