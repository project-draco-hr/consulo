{
  try {
    final Module[] scopeModules=scope.getAffectedModules();
    final List<String> modulesWithoutOutputPathSpecified=new ArrayList<String>();
    boolean isProjectCompilePathSpecified=true;
    final Set<File> nonExistingOutputPaths=new HashSet<File>();
    final CompilerManager compilerManager=CompilerManager.getInstance(myProject);
    for (    final Module module : scopeModules) {
      if (!compilerManager.isValidationEnabled(module)) {
        continue;
      }
      boolean isEmpty=true;
      for (      ContentFolderTypeProvider contentFolderType : ContentFolderTypeProvider.filter(ContentFolderScopes.productionAndTest())) {
        if (hasContent(module,contentFolderType)) {
          isEmpty=false;
          break;
        }
      }
      if (isEmpty) {
        continue;
      }
      for (      ContentFolderTypeProvider contentFolderType : ContentFolderTypeProvider.filter(ContentFolderScopes.productionAndTest())) {
        if (hasContent(module,contentFolderType)) {
          final String outputPath=getModuleOutputPath(module,contentFolderType);
          if (outputPath != null) {
            final File file=new File(FileUtil.toSystemDependentName(outputPath));
            if (!file.exists()) {
              nonExistingOutputPaths.add(file);
            }
          }
 else {
            modulesWithoutOutputPathSpecified.add(module.getName());
          }
        }
      }
      for (      AdditionalOutputDirectoriesProvider provider : AdditionalOutputDirectoriesProvider.EP_NAME.getExtensions()) {
        for (        String path : provider.getOutputDirectories(myProject,module)) {
          if (path == null) {
            final CompilerConfiguration extension=CompilerConfiguration.getInstance(module.getProject());
            if (extension.getCompilerOutputUrl() == null) {
              isProjectCompilePathSpecified=false;
            }
 else {
              modulesWithoutOutputPathSpecified.add(module.getName());
            }
          }
 else {
            final File file=new File(path);
            if (!file.exists()) {
              nonExistingOutputPaths.add(file);
            }
          }
        }
      }
    }
    if (!isProjectCompilePathSpecified) {
      final String message=CompilerBundle.message("error.project.output.not.specified");
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        LOG.error(message);
      }
      Messages.showMessageDialog(myProject,message,CommonBundle.getErrorTitle(),Messages.getErrorIcon());
      return false;
    }
    if (!modulesWithoutOutputPathSpecified.isEmpty()) {
      showNotSpecifiedError("error.output.not.specified",modulesWithoutOutputPathSpecified,null);
      return false;
    }
    if (!nonExistingOutputPaths.isEmpty()) {
      for (      File file : nonExistingOutputPaths) {
        final boolean succeeded=file.mkdirs();
        if (!succeeded) {
          if (file.exists()) {
            continue;
          }
          Messages.showMessageDialog(myProject,CompilerBundle.message("error.failed.to.create.directory",file.getPath()),CommonBundle.getErrorTitle(),Messages.getErrorIcon());
          return false;
        }
      }
      final Boolean refreshSuccess=new WriteAction<Boolean>(){
        @Override protected void run(        Result<Boolean> result) throws Throwable {
          LocalFileSystem.getInstance().refreshIoFiles(nonExistingOutputPaths);
          Boolean res=Boolean.TRUE;
          for (          File file : nonExistingOutputPaths) {
            if (LocalFileSystem.getInstance().findFileByIoFile(file) == null) {
              res=Boolean.FALSE;
              break;
            }
          }
          result.setResult(res);
        }
      }
.execute().getResultObject();
      if (!refreshSuccess.booleanValue()) {
        return false;
      }
      dropScopesCaches();
    }
    if (checkOutputAndSourceIntersection && myShouldClearOutputDirectory) {
      if (!validateOutputAndSourcePathsIntersection()) {
        return false;
      }
      CompilerPathsEx.CLEAR_ALL_OUTPUTS_KEY.set(scope,myShouldClearOutputDirectory);
    }
 else {
      CompilerPathsEx.CLEAR_ALL_OUTPUTS_KEY.set(scope,false);
    }
    final Compiler[] allCompilers=compilerManager.getCompilers(Compiler.class);
    for (    Compiler compiler : allCompilers) {
      if (!compiler.validateConfiguration(scope)) {
        LOG.info("Validation with compiler " + compiler.getDescription() + " is failed.");
        return false;
      }
    }
    return true;
  }
 catch (  Throwable e) {
    LOG.info(e);
    return false;
  }
}
