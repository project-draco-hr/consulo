{
  myAllowSyncStrategy=allowSyncStrategy;
  DefaultTreeModel treeModel=new DefaultTreeModel(root);
  treeModel.nodeStructureChanged(root);
  final AnAction quickDocAction=ActionManager.getInstance().getAction(IdeActions.ACTION_QUICK_JAVADOC);
  myTreeCellRenderer=new MyTreeCellRenderer();
  myTree=new CheckboxTree(myTreeCellRenderer,root){
    protected boolean shouldShowBusyIconIfNeeded(){
      return true;
    }
    public boolean isPathEditable(    TreePath path){
      return isEditable() && path.getLastPathComponent() instanceof DefaultMutableTreeNode;
    }
    @Override protected void onNodeStateChanged(    CheckedTreeNode node){
      if (node instanceof EditableTreeNode) {
        ((EditableTreeNode)node).fireOnSelectionChange(node.isChecked());
      }
    }
    @Override public String getToolTipText(    MouseEvent event){
      final TreePath path=myTree.getPathForLocation(event.getX(),event.getY());
      if (path == null) {
        return "";
      }
      Object node=path.getLastPathComponent();
      if (node == null || (!(node instanceof DefaultMutableTreeNode))) {
        return "";
      }
      if (node instanceof TooltipNode) {
        return KeymapUtil.createTooltipText(((TooltipNode)node).getTooltip() + "<p style='font-style:italic;color:gray;'>Show commit details",quickDocAction) + "</p>";
      }
      return "";
    }
    @Override public boolean stopEditing(){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node instanceof EditableTreeNode) {
        JComponent editedComponent=(JComponent)node.getUserObject();
        InputVerifier verifier=editedComponent.getInputVerifier();
        if (verifier != null && !verifier.verify(editedComponent))         return false;
      }
      boolean result=super.stopEditing();
      if (myShouldRepaint) {
        refreshNode(root);
      }
      restoreSelection(node);
      return result;
    }
    @Override public void cancelEditing(){
      DefaultMutableTreeNode lastSelectedPathComponent=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      super.cancelEditing();
      if (myShouldRepaint) {
        refreshNode(root);
      }
      restoreSelection(lastSelectedPathComponent);
    }
  }
;
  myTree.setUI(new MyTreeUi());
  myTree.setBorder(new EmptyBorder(2,0,0,0));
  myTree.setEditable(true);
  myTree.setHorizontalAutoScrollingEnabled(false);
  myTree.setShowsRootHandles(root.getChildCount() > 1);
  MyTreeCellEditor treeCellEditor=new MyTreeCellEditor();
  myTree.setCellEditor(treeCellEditor);
  treeCellEditor.addCellEditorListener(new CellEditorListener(){
    @Override public void editingStopped(    ChangeEvent e){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node != null && node instanceof EditableTreeNode) {
        JComponent editedComponent=(JComponent)node.getUserObject();
        InputVerifier verifier=editedComponent.getInputVerifier();
        if (verifier != null && !verifier.verify(editedComponent)) {
          ((EditableTreeNode)node).fireOnCancel();
        }
 else {
          if (mySyncStrategy) {
            resetEditSync();
            ContainerUtil.process(getChildNodesByType(root,RepositoryNode.class,false),new Processor<RepositoryNode>(){
              @Override public boolean process(              RepositoryNode node){
                node.fireOnChange();
                return true;
              }
            }
);
          }
 else {
            ((EditableTreeNode)node).fireOnChange();
          }
        }
      }
      myTree.firePropertyChange(PushLogTreeUtil.EDIT_MODE_PROP,true,false);
    }
    @Override public void editingCanceled(    ChangeEvent e){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node != null && node instanceof EditableTreeNode) {
        ((EditableTreeNode)node).fireOnCancel();
      }
      resetEditSync();
      myTree.firePropertyChange(PushLogTreeUtil.EDIT_MODE_PROP,true,false);
    }
  }
);
  myTree.setInvokesStopCellEditing(true);
  myTree.setRootVisible(false);
  TreeUtil.collapseAll(myTree,1);
  final VcsBranchEditorListener linkMouseListener=new VcsBranchEditorListener(myTreeCellRenderer);
  linkMouseListener.installOn(myTree);
  myBalloon=new VcsCommitInfoBalloon(myTree);
  myTree.getSelectionModel().setSelectionMode(TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
  myTree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      updateChangesView();
      myBalloon.updateCommitDetails();
    }
  }
);
  myTree.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      DefaultMutableTreeNode node=(DefaultMutableTreeNode)myTree.getLastSelectedPathComponent();
      if (node != null && node instanceof RepositoryNode && myTree.isEditing()) {
        myTree.getCellEditor().getTreeCellEditorComponent(myTree,node,true,false,false,myTree.getRowForPath(TreeUtil.getPathFromRoot(node)));
      }
    }
  }
);
  myTree.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),START_EDITING);
  myTree.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,0),"");
  MyShowCommitInfoAction showCommitInfoAction=new MyShowCommitInfoAction();
  showCommitInfoAction.registerCustomShortcutSet(quickDocAction.getShortcutSet(),myTree);
  ToolTipManager.sharedInstance().registerComponent(myTree);
  PopupHandler.installPopupHandler(myTree,VcsLogActionPlaces.POPUP_ACTION_GROUP,CONTEXT_MENU);
  myChangesBrowser=new ChangesBrowser(project,null,Collections.<Change>emptyList(),null,false,false,null,ChangesBrowser.MyUseCase.LOCAL_CHANGES,null);
  myChangesBrowser.getDiffAction().registerCustomShortcutSet(myChangesBrowser.getDiffAction().getShortcutSet(),myTree);
  final EditSourceForDialogAction editSourceAction=new EditSourceForDialogAction(myChangesBrowser);
  editSourceAction.registerCustomShortcutSet(CommonShortcuts.getEditSource(),myChangesBrowser);
  myChangesBrowser.addToolbarAction(editSourceAction);
  setDefaultEmptyText();
  Splitter splitter=new Splitter(false,0.7f);
  final JComponent syncStrategyPanel=myAllowSyncStrategy ? createStrategyPanel() : null;
  myScrollPane=new JBScrollPane(myTree){
    @Override public void layout(){
      super.layout();
      if (syncStrategyPanel != null) {
        Rectangle bounds=this.getViewport().getBounds();
        int height=bounds.height - syncStrategyPanel.getPreferredSize().height;
        this.getViewport().setBounds(bounds.x,bounds.y,bounds.width,height);
        syncStrategyPanel.setBounds(bounds.x,bounds.y + height,bounds.width,syncStrategyPanel.getPreferredSize().height);
      }
    }
  }
;
  if (syncStrategyPanel != null) {
    myScrollPane.setViewport(new MyTreeViewPort(myTree,syncStrategyPanel.getPreferredSize().height));
  }
  myScrollPane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);
  myScrollPane.setOpaque(false);
  if (syncStrategyPanel != null) {
    myScrollPane.add(syncStrategyPanel);
  }
  splitter.setFirstComponent(myScrollPane);
  splitter.setSecondComponent(myChangesBrowser);
  setLayout(new BorderLayout());
  add(splitter);
  myTree.setMinimumSize(new Dimension(200,myTree.getPreferredSize().height));
  myTree.setRowHeight(0);
}
