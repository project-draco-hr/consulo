{
  final Color defaultForeground=colorsScheme.getDefaultForeground();
  final Color defaultBackground=colorsScheme.getDefaultBackground();
  return new DisposableIterator<SegmentInfo>(){
    @NotNull private final Queue<SegmentInfo> myInfos=new PriorityQueue<SegmentInfo>();
    @NotNull private final Map<SegmentInfo,DisposableIterator<List<SegmentInfo>>> myEndMarkers=new IdentityHashMap<SegmentInfo,DisposableIterator<List<SegmentInfo>>>();
{
      for (      DisposableIterator<List<SegmentInfo>> iterator : iterators) {
        extract(iterator);
      }
    }
    @Override public boolean hasNext(){
      return !myInfos.isEmpty();
    }
    @Override public SegmentInfo next(){
      SegmentInfo result=myInfos.remove();
      DisposableIterator<List<SegmentInfo>> iterator=myEndMarkers.remove(result);
      if (iterator != null) {
        extract(iterator);
      }
      while (!myInfos.isEmpty()) {
        SegmentInfo toMerge=myInfos.peek();
        if (toMerge.endOffset > result.endOffset) {
          break;
        }
        myInfos.remove();
        result=merge(result,toMerge);
        DisposableIterator<List<SegmentInfo>> it=myEndMarkers.remove(toMerge);
        if (it != null) {
          extract(it);
        }
      }
      return result;
    }
    @NotNull private SegmentInfo merge(    @NotNull SegmentInfo info1,    @NotNull SegmentInfo info2){
      Color background=info1.background;
      if (background == null || defaultBackground.equals(background)) {
        background=info2.background;
      }
      Color foreground=info1.foreground;
      if (foreground == null || defaultForeground.equals(foreground)) {
        foreground=info2.foreground;
      }
      int fontStyle=info1.fontStyle;
      if (fontStyle == Font.PLAIN) {
        fontStyle=info2.fontStyle;
      }
      return new SegmentInfo(foreground,background,info1.fontFamilyName,fontStyle,info1.startOffset,info1.endOffset);
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public void dispose(){
      for (      DisposableIterator<List<SegmentInfo>> iterator : iterators) {
        iterator.dispose();
      }
    }
    private void extract(    @NotNull DisposableIterator<List<SegmentInfo>> iterator){
      while (iterator.hasNext()) {
        List<SegmentInfo> infos=iterator.next();
        if (infos.isEmpty()) {
          continue;
        }
        myInfos.addAll(infos);
        myEndMarkers.put(infos.get(infos.size() - 1),iterator);
        break;
      }
    }
  }
;
}
