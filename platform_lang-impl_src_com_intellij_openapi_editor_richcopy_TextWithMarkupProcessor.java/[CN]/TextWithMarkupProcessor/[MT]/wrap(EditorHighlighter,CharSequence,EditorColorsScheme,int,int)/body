{
  final HighlighterIterator highlighterIterator=highlighter.createIterator(startOffset);
  return new DisposableIterator<List<SegmentInfo>>(){
    @Nullable private List<SegmentInfo> myCached;
    @Override public boolean hasNext(){
      return myCached != null || updateCached();
    }
    @Override public List<SegmentInfo> next(){
      if (myCached != null) {
        List<SegmentInfo> result=myCached;
        myCached=null;
        return result;
      }
      if (!updateCached()) {
        throw new UnsupportedOperationException();
      }
      return myCached;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public void dispose(){
    }
    private boolean updateCached(){
      if (highlighterIterator.atEnd()) {
        return false;
      }
      int tokenStart=Math.max(highlighterIterator.getStart(),startOffset);
      if (tokenStart >= endOffset) {
        return false;
      }
      if (highlighterIterator.getTokenType() == TokenType.BAD_CHARACTER) {
        highlighterIterator.advance();
        return updateCached();
      }
      TextAttributes attributes=highlighterIterator.getTextAttributes();
      int tokenEnd=Math.min(highlighterIterator.getEnd(),endOffset);
      myCached=SegmentInfo.produce(attributes,text,colorsScheme,tokenStart,tokenEnd);
      highlighterIterator.advance();
      return true;
    }
  }
;
}
