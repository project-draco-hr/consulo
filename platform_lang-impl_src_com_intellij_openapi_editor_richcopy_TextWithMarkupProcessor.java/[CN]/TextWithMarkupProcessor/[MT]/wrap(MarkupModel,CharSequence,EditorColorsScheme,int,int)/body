{
  if (!(model instanceof MarkupModelEx)) {
    return DisposableIterator.EMPTY;
  }
  final DisposableIterator<RangeHighlighterEx> iterator=((MarkupModelEx)model).overlappingIterator(startOffset,endOffset);
  final Color defaultForeground=colorsScheme.getDefaultForeground();
  final Color defaultBackground=colorsScheme.getDefaultBackground();
  return new DisposableIterator<List<SegmentInfo>>(){
    @Nullable private List<SegmentInfo> myCached;
    @Override public boolean hasNext(){
      return myCached != null || updateCached();
    }
    @Override public List<SegmentInfo> next(){
      if (myCached != null) {
        List<SegmentInfo> result=myCached;
        myCached=null;
        return result;
      }
      if (!updateCached()) {
        throw new UnsupportedOperationException();
      }
      return myCached;
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
    @Override public void dispose(){
      iterator.dispose();
    }
    private boolean updateCached(){
      if (!iterator.hasNext()) {
        return false;
      }
      RangeHighlighterEx highlighter=iterator.next();
      while (highlighter == null || !highlighter.isValid() || !isInterestedHighlightLayer(highlighter.getLayer())) {
        if (!iterator.hasNext()) {
          return false;
        }
        highlighter=iterator.next();
      }
      int tokenStart=Math.max(highlighter.getStartOffset(),startOffset);
      if (tokenStart >= endOffset) {
        return false;
      }
      TextAttributes attributes=null;
      Object tooltip=highlighter.getErrorStripeTooltip();
      if (tooltip instanceof HighlightInfo) {
        HighlightInfo info=(HighlightInfo)tooltip;
        TextAttributesKey key=info.forcedTextAttributesKey;
        if (key == null) {
          HighlightInfoType type=info.type;
          key=type.getAttributesKey();
        }
        if (key != null) {
          attributes=colorsScheme.getAttributes(key);
        }
      }
      if (attributes == null) {
        return updateCached();
      }
      Color foreground=attributes.getForegroundColor();
      Color background=attributes.getBackgroundColor();
      if ((foreground == null || defaultForeground.equals(foreground)) && (background == null || defaultBackground.equals(background)) && attributes.getFontType() == Font.PLAIN) {
        return updateCached();
      }
      int tokenEnd=Math.min(highlighter.getEndOffset(),endOffset);
      myCached=SegmentInfo.produce(attributes,charSequence,colorsScheme,tokenStart,tokenEnd);
      return true;
    }
    private boolean isInterestedHighlightLayer(    int layer){
      return layer != HighlighterLayer.CARET_ROW && layer != HighlighterLayer.SELECTION && layer != HighlighterLayer.ERROR && layer != HighlighterLayer.WARNING;
    }
  }
;
}
