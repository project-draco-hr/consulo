{
  final CountDownLatch started=new CountDownLatch(myMaxTasks);
  final CountDownLatch readyToFinish=new CountDownLatch(1);
  final Runnable wait=new Runnable(){
    @Override public void run(){
      try {
        started.countDown();
        readyToFinish.await();
      }
 catch (      InterruptedException e) {
        throw new RuntimeException(e);
      }
    }
  }
;
  List<Future> futures=ContainerUtil.map(Collections.nCopies(myMaxTasks,null),new Function<Object,Future>(){
    @Override public Future fun(    Object o){
      return submit(wait);
    }
  }
);
  try {
    if (!started.await(timeout,unit)) {
      throw new RuntimeException("Interrupted by timeout. " + this + "; Thread dump:\n"+ ThreadDumper.dumpThreadsToString());
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
 finally {
    readyToFinish.countDown();
  }
  for (  Future future : futures) {
    future.get(timeout,unit);
  }
}
