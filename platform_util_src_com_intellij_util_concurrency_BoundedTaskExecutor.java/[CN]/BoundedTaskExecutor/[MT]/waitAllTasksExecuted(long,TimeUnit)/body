{
  final CountDownLatch started=new CountDownLatch(myMaxTasks);
  final CountDownLatch readyToFinish=new CountDownLatch(1);
  List<Future> futures=ContainerUtil.map(Collections.nCopies(myMaxTasks,null),new Function<Object,Future>(){
    @Override public Future fun(    Object o){
      final LastTask wait=new LastTask(new Runnable(){
        @Override public void run(){
          try {
            started.countDown();
            readyToFinish.await();
          }
 catch (          InterruptedException e) {
            throw new RuntimeException(e);
          }
        }
      }
);
      execute(wait);
      return wait;
    }
  }
);
  try {
    if (!started.await(timeout,unit)) {
      throw new TimeoutException("Interrupted by timeout. " + this);
    }
  }
 catch (  InterruptedException e) {
    throw new RuntimeException(e);
  }
 finally {
    readyToFinish.countDown();
  }
  for (  Future future : futures) {
    future.get(timeout,unit);
  }
}
