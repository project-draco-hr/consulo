{
  if (classMember != null && RefactoringHierarchyUtil.isMemberBetween(mySuperClass,mySubclass,classMember)) {
    if (classMember.hasModifierProperty(PsiModifier.STATIC) && !willBeMoved(classMember)) {
      final boolean isAccessible;
      if (mySuperClass != null) {
        isAccessible=PsiUtil.isAccessible(classMember,mySuperClass,null);
      }
 else       if (myTargetPackage != null) {
        isAccessible=PsiUtil.isAccessibleFromPackage(classMember,myTargetPackage);
      }
 else {
        isAccessible=classMember.hasModifierProperty(PsiModifier.PUBLIC);
      }
      if (!isAccessible) {
        String message=ConflictsUtil.getDescription(myScope,false) + " uses " + ConflictsUtil.getDescription(classMember,true)+ ", which is not accessible from the superclass";
        message=ConflictsUtil.capitalize(message);
        myConflictsList.add(message);
      }
      return;
    }
    if (!myAbstractMethods.contains(classMember) && !willBeMoved(classMember)) {
      if (!existsInSuperClass(classMember)) {
        String message=ConflictsUtil.getDescription(myScope,false) + " uses " + ConflictsUtil.getDescription(classMember,true)+ ", which is not moved to the superclass";
        message=ConflictsUtil.capitalize(message);
        myConflictsList.add(message);
      }
    }
  }
}
