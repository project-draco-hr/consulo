{
  final Set<PsiElement> movedMembers=new HashSet<PsiElement>();
  final Set<PsiMethod> abstractMethods=new HashSet<PsiMethod>();
  final boolean isInterfaceTarget;
  final PsiElement targetRepresentativeElement;
  if (superClass != null) {
    isInterfaceTarget=superClass.isInterface();
    targetRepresentativeElement=superClass;
  }
 else {
    isInterfaceTarget=false;
    targetRepresentativeElement=targetDirectory;
  }
  for (int idx=0; idx < infos.length; idx++) {
    PsiElement member=infos[idx].getMember();
    if (member instanceof PsiMethod) {
      if (!infos[idx].isToAbstract() && !isInterfaceTarget) {
        movedMembers.add(member);
      }
 else {
        abstractMethods.add((PsiMethod)member);
      }
    }
 else {
      movedMembers.add(member);
    }
  }
  final LinkedHashSet<String> conflictsList=new LinkedHashSet<String>();
  if (superClass != null) {
    checkSuperclassMembers(superClass,infos,conflictsList);
    if (isInterfaceTarget) {
      checkInterfaceTarget(infos,conflictsList);
    }
  }
  List<PsiElement> checkModuleConflictsList=new ArrayList<PsiElement>();
  for (Iterator<PsiElement> it=movedMembers.iterator(); it.hasNext(); ) {
    PsiElement member=it.next();
    if (member instanceof PsiMethod || member instanceof PsiClass) {
      ConflictingUsagesOfSubClassMembers visitor=new ConflictingUsagesOfSubClassMembers(member,movedMembers,abstractMethods,subclass,superClass,superClass != null ? null : targetPackage,conflictsList,interfaceContainmentVerifier);
      member.accept(visitor);
    }
    checkModuleConflictsList.add(member);
  }
  for (Iterator<PsiMethod> iterator=abstractMethods.iterator(); iterator.hasNext(); ) {
    final PsiMethod method=iterator.next();
    checkModuleConflictsList.add(method.getParameterList());
    checkModuleConflictsList.add(method.getReturnTypeElement());
  }
  RefactoringUtil.analyzeModuleConflicts(subclass.getProject(),checkModuleConflictsList,targetRepresentativeElement,conflictsList);
  String[] conflicts=conflictsList.toArray(new String[conflictsList.size()]);
  return conflicts;
}
