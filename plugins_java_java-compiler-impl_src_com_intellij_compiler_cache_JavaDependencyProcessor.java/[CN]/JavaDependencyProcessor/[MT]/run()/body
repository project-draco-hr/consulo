{
  if (LOG.isDebugEnabled()) {
    LOG.debug("Checking dependencies for " + myJavaDependencyCache.resolve(myQName));
  }
  final boolean superListChanged=mySuperClassChanged || mySuperClassAdded || mySuperInterfaceAdded|| mySuperInterfaceRemoved|| mySuperlistGenericSignatureChanged;
  final Cache oldCache=myJavaDependencyCache.getCache();
  final Cache newCache=myJavaDependencyCache.getNewClassesCache();
  if (!myMembersChanged && oldCache.getFlags(myQName) == newCache.getFlags(myQName) && !superListChanged && !myWereAnnotationTargetsRemoved && !myRetentionPolicyChanged && !myAnnotationSemanticsChanged) {
    return;
  }
  if (myIsAnnotation) {
    if (myAnnotationSemanticsChanged) {
      final TIntHashSet visited=new TIntHashSet();
      visited.add(myQName);
      markAnnotationDependenciesRecursively(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: semantics changed for " + myJavaDependencyCache.resolve(myQName) : "",visited);
      return;
    }
    if (hasMembersWithoutDefaults(myAddedMembers)) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: added annotation type member without default " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
    if (!myRemovedMembers.isEmpty()) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: removed annotation type member " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
    if (!myChangedMembers.isEmpty()) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: changed annotation member's type " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
    if (wereAnnotationDefaultsRemoved()) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: removed annotation member's default value " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
    if (myWereAnnotationTargetsRemoved) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: removed annotation's targets " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
    if (myRetentionPolicyChanged) {
      markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: retention policy changed for " + myJavaDependencyCache.resolve(myQName) : "");
      return;
    }
  }
  final JavaDependencyCacheNavigator cacheNavigator=myJavaDependencyCache.getCacheNavigator();
  if (mySuperClassChanged || mySuperInterfaceRemoved || mySuperlistGenericSignatureChanged) {
    markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: deleted items from the superlist or changed superlist generic signature of " + myJavaDependencyCache.resolve(myQName) : "");
    cacheNavigator.walkSubClasses(myQName,new ClassInfoProcessor(){
      public boolean process(      int classQName) throws CacheCorruptedException {
        markAll(oldCache.getBackDependencies(classQName),LOG.isDebugEnabled() ? "; reason: deleted items from the superlist or changed superlist generic signature of " + myJavaDependencyCache.resolve(myQName) : "");
        return true;
      }
    }
);
    return;
  }
  final boolean isKindChanged=(JavaMakeUtil.isInterface(oldCache.getFlags(myQName)) && !JavaMakeUtil.isInterface(newCache.getFlags(myQName))) || (!JavaMakeUtil.isInterface(oldCache.getFlags(myQName)) && JavaMakeUtil.isInterface(newCache.getFlags(myQName)));
  if (isKindChanged) {
    markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: class kind changed (class/interface) " + myJavaDependencyCache.resolve(myQName) : "");
    cacheNavigator.walkSubClasses(myQName,new ClassInfoProcessor(){
      public boolean process(      int classQName) throws CacheCorruptedException {
        markAll(oldCache.getBackDependencies(classQName),LOG.isDebugEnabled() ? "; reason: class kind changed (class/interface) " + myJavaDependencyCache.resolve(myQName) : "");
        return true;
      }
    }
);
    return;
  }
  boolean becameFinal=!ClsUtil.isFinal(oldCache.getFlags(myQName)) && ClsUtil.isFinal(newCache.getFlags(myQName));
  if (becameFinal) {
    markAll(getBackDependencies(),LOG.isDebugEnabled() ? "; reason: class became final: " + myJavaDependencyCache.resolve(myQName) : "");
  }
 else {
    boolean becameAbstract=!ClsUtil.isAbstract(oldCache.getFlags(myQName)) && ClsUtil.isAbstract(newCache.getFlags(myQName));
    boolean accessRestricted=JavaMakeUtil.isMoreAccessible(oldCache.getFlags(myQName),newCache.getFlags(myQName));
    Set<MethodInfo> removedMethods=null;
    Set<MethodInfo> addedMethods=null;
    for (    Dependency backDependency : getBackDependencies()) {
      if (myJavaDependencyCache.isTargetClassInfoMarked(backDependency))       continue;
      if (accessRestricted) {
        if (myJavaDependencyCache.markTargetClassInfo(backDependency)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(backDependency.getClassQualifiedName()) + "; reason: "+ myJavaDependencyCache.resolve(myQName)+ " made less accessible");
          }
        }
        continue;
      }
      if (becameAbstract) {
        if (processClassBecameAbstract(backDependency)) {
          continue;
        }
      }
      if (isDependentOnRemovedMembers(backDependency)) {
        if (myJavaDependencyCache.markTargetClassInfo(backDependency)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(backDependency.getClassQualifiedName()) + "; reason: the class uses removed members of "+ myJavaDependencyCache.resolve(myQName));
          }
        }
        continue;
      }
      if (isDependentOnChangedMembers(backDependency)) {
        if (myJavaDependencyCache.markTargetClassInfo(backDependency)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(backDependency.getClassQualifiedName()) + "; reason: the class uses changed members of "+ myJavaDependencyCache.resolve(myQName));
          }
        }
        continue;
      }
      final Collection<Dependency.MethodRef> usedMethods=backDependency.getMethodRefs();
      if (removedMethods == null) {
        removedMethods=extractMethods(myRemovedMembers,true);
      }
      if (isDependentOnEquivalentMethods(usedMethods,removedMethods)) {
        if (myJavaDependencyCache.markTargetClassInfo(backDependency)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(backDependency.getClassQualifiedName()) + "; reason: some overloaded methods of "+ myJavaDependencyCache.resolve(myQName)+ " were removed");
          }
        }
        continue;
      }
      if (addedMethods == null) {
        addedMethods=extractMethods(myAddedMembers,true);
      }
      if (isDependentOnEquivalentMethods(usedMethods,addedMethods)) {
        if (myJavaDependencyCache.markTargetClassInfo(backDependency)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(backDependency.getClassQualifiedName()) + "; reason: some overloaded methods of "+ myJavaDependencyCache.resolve(myQName)+ " were added");
          }
        }
      }
    }
  }
  final Set<MethodInfo> methodsToCheck=new HashSet<MethodInfo>();
  extractMethods(myRemovedMembers,methodsToCheck,false);
  processInheritanceDependencies(methodsToCheck);
  extractMethods(myAddedMembers,methodsToCheck,false);
  if (!JavaMakeUtil.isAnonymous(myJavaDependencyCache.resolve(myQName))) {
    final TIntHashSet fieldNames=new TIntHashSet();
    extractFieldNames(myAddedMembers,fieldNames);
    int addedFieldsCount=fieldNames.size();
    extractFieldNames(myRemovedMembers,fieldNames);
    if (!fieldNames.isEmpty()) {
      cacheNavigator.walkSuperClasses(myQName,new ClassInfoProcessor(){
        public boolean process(        final int classQName) throws CacheCorruptedException {
          markUseDependenciesOnFields(classQName,fieldNames);
          return true;
        }
      }
);
    }
    if (addedFieldsCount > 0 && JavaMakeUtil.isInterface(oldCache.getFlags(myQName))) {
      final TIntHashSet visitedClasses=new TIntHashSet();
      visitedClasses.add(myQName);
      cacheNavigator.walkSubClasses(myQName,new ClassInfoProcessor(){
        public boolean process(        int subclassQName) throws CacheCorruptedException {
          markUseDependenciesOnFields(subclassQName,fieldNames);
          visitedClasses.add(subclassQName);
          cacheNavigator.walkSuperClasses(subclassQName,new ClassInfoProcessor(){
            public boolean process(            int superclassQName) throws CacheCorruptedException {
              if (visitedClasses.contains(superclassQName)) {
                return false;
              }
              markUseDependenciesOnFields(superclassQName,fieldNames);
              visitedClasses.add(superclassQName);
              return true;
            }
          }
);
          return true;
        }
      }
);
    }
    if (!methodsToCheck.isEmpty()) {
      cacheNavigator.walkSuperClasses(myQName,new ClassInfoProcessor(){
        public boolean process(        int classQName) throws CacheCorruptedException {
          markUseDependenciesOnEquivalentMethods(classQName,methodsToCheck,myQName);
          return true;
        }
      }
);
      cacheNavigator.walkSubClasses(myQName,new ClassInfoProcessor(){
        public boolean process(        int classQName) throws CacheCorruptedException {
          markUseDependenciesOnEquivalentMethods(classQName,methodsToCheck,myQName);
          return true;
        }
      }
);
    }
    final TIntHashSet addedOrRemovedFields=new TIntHashSet();
    final TIntHashSet addedOrRemovedMethods=new TIntHashSet();
    for (    Set<MemberInfo> infos : Arrays.asList(myAddedMembers,myRemovedMembers)) {
      for (      MemberInfo member : infos) {
        if (!member.isPrivate()) {
          if (member instanceof FieldInfo) {
            addedOrRemovedFields.add(member.getName());
          }
 else           if (member instanceof MethodInfo) {
            addedOrRemovedMethods.add(member.getName());
          }
        }
      }
    }
    if (!addedOrRemovedFields.isEmpty() || !addedOrRemovedMethods.isEmpty()) {
      cacheNavigator.walkSubClasses(myQName,new ClassInfoProcessor(){
        public boolean process(        final int subclassQName) throws CacheCorruptedException {
          if (!myJavaDependencyCache.isClassInfoMarked(subclassQName)) {
            if (referencesMembersWithNames(oldCache,subclassQName,addedOrRemovedFields,addedOrRemovedMethods)) {
              final boolean marked=myJavaDependencyCache.markClass(subclassQName);
              if (marked && LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myJavaDependencyCache.resolve(subclassQName) + "; Reason: members were added/removed in superclass with names, that may clash with the names of members of another classes that this class references");
              }
            }
          }
          return true;
        }
      }
);
    }
  }
}
