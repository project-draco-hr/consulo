{
  myDataIndexer=new DataIndexer<String,Void,FileBasedIndex.FileContent>(){
    public Map<String,Void> map(    final FileBasedIndex.FileContent inputData){
      final CharSequence content=inputData.content;
      final Ref<String> rootTagName=Ref.create(null);
      final Set<String> namespaces=new THashSet<String>();
      try {
        new XmlBuilderDriver(content).build(new XmlBuilder(){
          public void doctype(          @Nullable final CharSequence publicId,          @Nullable final CharSequence systemId,          final int startOffset,          final int endOffset){
            if (publicId != null) {
              namespaces.add(publicId.toString());
            }
            if (systemId != null) {
              namespaces.add(systemId.toString());
            }
          }
          public ProcessingOrder startTag(          final CharSequence localName,          final String namespace,          final int startoffset,          final int endoffset,          final int headerEndOffset){
            rootTagName.set(localName.toString());
            ContainerUtil.addIfNotNull(namespace,namespaces);
            throw new RootTagReachedException();
          }
          public void endTag(          final CharSequence localName,          final String namespace,          final int startoffset,          final int endoffset){
            throw new UnsupportedOperationException("Method endTag is not yet implemented in " + getClass().getName());
          }
          public void attribute(          final CharSequence name,          final CharSequence value,          final int startoffset,          final int endoffset){
          }
          public void textElement(          final CharSequence display,          final CharSequence physical,          final int startoffset,          final int endoffset){
          }
          public void entityRef(          final CharSequence ref,          final int startOffset,          final int endOffset){
          }
        }
);
      }
 catch (      RootTagReachedException e) {
      }
      final String tagName=rootTagName.get();
      if (StringUtil.isNotEmpty(tagName)) {
        final THashMap<String,Void> result=new THashMap<String,Void>();
        final DomApplicationComponent component=DomApplicationComponent.getInstance();
        for (        final DomFileDescription description : component.getFileDescriptions(tagName)) {
          final String[] strings=description.getAllPossibleRootTagNamespaces();
          if (strings.length == 0 || ContainerUtil.intersects(Arrays.asList(strings),namespaces)) {
            result.put(description.getClass().getName(),null);
          }
        }
        for (        final DomFileDescription description : component.getAcceptingOtherRootTagNameDescriptions()) {
          final String[] strings=description.getAllPossibleRootTagNamespaces();
          if (strings.length == 0 || ContainerUtil.intersects(Arrays.asList(strings),namespaces)) {
            result.put(description.getClass().getName(),null);
          }
        }
        return result;
      }
      return Collections.emptyMap();
    }
  }
;
}
