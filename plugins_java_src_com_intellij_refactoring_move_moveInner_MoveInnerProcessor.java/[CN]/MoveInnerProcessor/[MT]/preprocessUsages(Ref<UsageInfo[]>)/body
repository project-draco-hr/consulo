{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final HashMap<PsiElement,HashSet<PsiElement>> reported=new HashMap<PsiElement,HashSet<PsiElement>>();
class Visitor extends JavaRecursiveElementWalkingVisitor {
    @Override public void visitReferenceElement(    PsiJavaCodeReferenceElement reference){
      PsiElement resolved=reference.resolve();
      if (resolved instanceof PsiMember && PsiTreeUtil.isAncestor(myInnerClass,resolved,true) && becomesInaccessible((PsiMember)resolved)) {
        registerConflict(reference,resolved,reported,conflicts);
      }
    }
    @Override public void visitClass(    PsiClass aClass){
      if (aClass == myInnerClass)       return;
      super.visitClass(aClass);
    }
  }
  myOuterClass.accept(new Visitor());
  myInnerClass.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitReferenceElement(    PsiJavaCodeReferenceElement reference){
      super.visitReferenceElement(reference);
      final PsiElement resolve=reference.resolve();
      if (resolve instanceof PsiMember) {
        if (PsiTreeUtil.isAncestor(myOuterClass,resolve,true) && !PsiTreeUtil.isAncestor(myInnerClass,resolve,false)) {
          if (becomesInaccessible((PsiMember)resolve)) {
            registerConflict(reference,resolve,reported,conflicts);
          }
        }
      }
    }
  }
);
  return showConflicts(conflicts,refUsages.get());
}
