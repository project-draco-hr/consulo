{
  final IntArrayList oldOffsets=new IntArrayList(instructions.size() / 2);
  final IntArrayList newOffsets=new IntArrayList(instructions.size() / 2);
  oldOffsets.add(offset);
  newOffsets.add(-1);
synchronized (instructions) {
    final IntArrayList currentProcedureReturnOffsets=new IntArrayList();
    ControlFlowInstructionVisitor getNextOffsetVisitor=new ControlFlowInstructionVisitor(){
      @Override public void visitCallInstruction(      CallInstruction instruction,      int offset,      int nextOffset){
        instruction.execute(offset + 1);
        int newOffset=instruction.offset;
        int i;
        for (i=instruction.procBegin; i < instruction.procEnd || instructions.get(i) instanceof ReturnInstruction; i++) {
          clientVisitor.processedInstructions[i]=false;
        }
        clientVisitor.procedureEntered(instruction.procBegin,i);
        oldOffsets.add(offset);
        newOffsets.add(newOffset);
        oldOffsets.add(newOffset);
        newOffsets.add(-1);
        currentProcedureReturnOffsets.add(offset + 1);
      }
      @Override public void visitReturnInstruction(      ReturnInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.execute(false);
        if (newOffset != -1) {
          oldOffsets.add(offset);
          newOffsets.add(newOffset);
          oldOffsets.add(newOffset);
          newOffsets.add(-1);
        }
      }
      @Override public void visitBranchingInstruction(      BranchingInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.offset;
        oldOffsets.add(offset);
        newOffsets.add(newOffset);
        oldOffsets.add(newOffset);
        newOffsets.add(-1);
      }
      @Override public void visitConditionalBranchingInstruction(      ConditionalBranchingInstruction instruction,      int offset,      int nextOffset){
        int newOffset=instruction.offset;
        oldOffsets.add(offset);
        newOffsets.add(newOffset);
        oldOffsets.add(offset);
        newOffsets.add(offset + 1);
        oldOffsets.add(newOffset);
        newOffsets.add(-1);
        oldOffsets.add(offset + 1);
        newOffsets.add(-1);
      }
      @Override public void visitInstruction(      Instruction instruction,      int offset,      int nextOffset){
        int newOffset=offset + 1;
        oldOffsets.add(offset);
        newOffsets.add(newOffset);
        oldOffsets.add(newOffset);
        newOffsets.add(-1);
      }
    }
;
    while (!oldOffsets.isEmpty()) {
      offset=oldOffsets.remove(oldOffsets.size() - 1);
      int newOffset=newOffsets.remove(newOffsets.size() - 1);
      if (offset >= endOffset) {
        continue;
      }
      Instruction instruction=instructions.get(offset);
      if (clientVisitor.processedInstructions[offset]) {
        if (newOffset != -1) {
          instruction.accept(clientVisitor,offset,newOffset);
        }
        if (!currentProcedureReturnOffsets.isEmpty() && currentProcedureReturnOffsets.get(currentProcedureReturnOffsets.size() - 1) - 1 == offset) {
          currentProcedureReturnOffsets.remove(currentProcedureReturnOffsets.size() - 1);
        }
        continue;
      }
      if (!currentProcedureReturnOffsets.isEmpty()) {
        int returnOffset=currentProcedureReturnOffsets.get(currentProcedureReturnOffsets.size() - 1);
        CallInstruction callInstruction=(CallInstruction)instructions.get(returnOffset - 1);
synchronized (callInstruction.stack) {
          if (callInstruction.procBegin <= offset && offset < callInstruction.procEnd + 2 && (callInstruction.stack.size() == 0 || callInstruction.stack.peekReturnOffset() != returnOffset)) {
            callInstruction.stack.push(returnOffset,callInstruction);
          }
        }
      }
      clientVisitor.processedInstructions[offset]=true;
      instruction.accept(getNextOffsetVisitor,offset,newOffset);
    }
  }
}
