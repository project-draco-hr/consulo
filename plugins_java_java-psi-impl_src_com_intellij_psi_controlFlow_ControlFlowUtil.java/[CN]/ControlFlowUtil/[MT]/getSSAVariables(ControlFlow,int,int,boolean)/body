{
  List<Instruction> instructions=flow.getInstructions();
  Collection<PsiVariable> writtenVariables=getWrittenVariables(flow,from,to,false);
  ArrayList<PsiVariable> result=new ArrayList<PsiVariable>(1);
  variables:   for (  PsiVariable psiVariable : writtenVariables) {
    final List<SSAInstructionState> queue=new ArrayList<SSAInstructionState>();
    queue.add(new SSAInstructionState(0,from));
    Set<SSAInstructionState> processedStates=new THashSet<SSAInstructionState>();
    while (!queue.isEmpty()) {
      final SSAInstructionState state=queue.remove(0);
      if (state.getWriteCount() > 1)       continue variables;
      if (!processedStates.contains(state)) {
        processedStates.add(state);
        int i=state.getInstructionIdx();
        if (i < to) {
          Instruction instruction=instructions.get(i);
          if (instruction instanceof ReturnInstruction) {
            int[] offsets=((ReturnInstruction)instruction).getPossibleReturnOffsets();
            for (            int offset : offsets) {
              queue.add(new SSAInstructionState(state.getWriteCount(),Math.min(offset,to)));
            }
          }
 else           if (instruction instanceof GoToInstruction) {
            int nextOffset=((GoToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
          }
 else           if (instruction instanceof ThrowToInstruction) {
            int nextOffset=((ThrowToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
          }
 else           if (instruction instanceof ConditionalGoToInstruction) {
            int nextOffset=((ConditionalGoToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else           if (instruction instanceof ConditionalThrowToInstruction) {
            int nextOffset=((ConditionalThrowToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else           if (instruction instanceof WriteVariableInstruction) {
            WriteVariableInstruction write=(WriteVariableInstruction)instruction;
            queue.add(new SSAInstructionState(state.getWriteCount() + (write.variable == psiVariable ? 1 : 0),i + 1));
          }
 else           if (instruction instanceof ReadVariableInstruction) {
            ReadVariableInstruction read=(ReadVariableInstruction)instruction;
            if (read.variable == psiVariable && state.getWriteCount() == 0)             continue variables;
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else {
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
        }
 else         if (!reportVarsIfNonInitializingPathExists && state.getWriteCount() == 0)         continue variables;
      }
    }
    result.add(psiVariable);
  }
  return result;
}
