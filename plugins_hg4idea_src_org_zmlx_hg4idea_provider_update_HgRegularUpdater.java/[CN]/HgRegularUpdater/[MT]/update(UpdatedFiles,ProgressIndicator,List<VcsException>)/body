{
  indicator.setText(HgVcsMessages.message("hg4idea.progress.updating",repoRoot.getPath()));
  String defaultPath=HgUtil.getRepositoryDefaultPath(project,repoRoot);
  if (StringUtil.isEmptyOrSpaces(defaultPath)) {
    throw new VcsException(HgVcsMessages.message("hg4idea.warning.no-default-update-path",repoRoot.getPath()));
  }
  List<HgRevisionNumber> branchHeadsBeforePull=new HgHeadsCommand(project,repoRoot).execute();
  if (branchHeadsBeforePull.size() > 1) {
    reportWarning(warnings,HgVcsMessages.message("hg4idea.update.warning.multipleHeadsBeforeUpdate",repoRoot.getPath()));
  }
  if (shouldPull()) {
    boolean pullResult=pull(repoRoot,indicator);
    if (!pullResult) {
      return false;
    }
  }
  if (shouldUpdate()) {
    List<HgRevisionNumber> parentsBeforeUpdate=new HgWorkingCopyRevisionsCommand(project).parents(repoRoot);
    if (parentsBeforeUpdate.size() > 1) {
      throw new VcsException(HgVcsMessages.message("hg4idea.update.error.uncommittedMerge",repoRoot.getPath()));
    }
    indicator.setText2(HgVcsMessages.message("hg4idea.progress.countingHeads"));
    List<HgRevisionNumber> branchHeadsAfterPull=new HgHeadsCommand(project,repoRoot).execute();
    List<HgRevisionNumber> pulledBranchHeads=determinePulledBranchHeads(branchHeadsBeforePull,branchHeadsAfterPull);
    List<HgRevisionNumber> remainingOriginalBranchHeads=determingRemainingOriginalBranchHeads(branchHeadsBeforePull,branchHeadsAfterPull);
    if (branchHeadsAfterPull.size() > 1 && shouldMerge()) {
      abortOnLocalChanges();
      abortOnMultiplePulledHeads(pulledBranchHeads);
      abortOnMultipleLocalHeads(remainingOriginalBranchHeads);
      HgCommandResult mergeResult=doMerge(updatedFiles,indicator,pulledBranchHeads.get(0));
      if (shouldCommitAfterMerge()) {
        commitOrWarnAboutConflicts(warnings,mergeResult);
      }
    }
 else {
      update(repoRoot,indicator,updatedFiles,warnings);
    }
    resolvePossibleConflicts(updatedFiles);
  }
  return true;
}
