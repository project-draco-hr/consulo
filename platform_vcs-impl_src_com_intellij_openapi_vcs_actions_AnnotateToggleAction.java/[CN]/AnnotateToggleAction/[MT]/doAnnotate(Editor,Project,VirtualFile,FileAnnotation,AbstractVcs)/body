{
  final UpToDateLineNumberProvider getUpToDateLineNumber=new UpToDateLineNumberProviderImpl(editor.getDocument(),project);
  editor.getGutter().closeAllAnnotations();
  Collection<ActiveAnnotationGutter> annotations=editor.getUserData(KEY_IN_EDITOR);
  if (annotations == null) {
    annotations=new HashSet<ActiveAnnotationGutter>();
    editor.putUserData(KEY_IN_EDITOR,annotations);
  }
  final EditorGutterComponentEx editorGutter=(EditorGutterComponentEx)editor.getGutter();
  final HighlightAnnotationsActions highlighting=new HighlightAnnotationsActions(project,file,fileAnnotation,editorGutter);
  final List<AnnotationFieldGutter> gutters=new ArrayList<AnnotationFieldGutter>();
  final AnnotationSourceSwitcher switcher=fileAnnotation.getAnnotationSourceSwitcher();
  final List<AnAction> additionalActions=new ArrayList<AnAction>();
  if (vcs.getCommittedChangesProvider() != null) {
    additionalActions.add(new ShowDiffFromAnnotation(getUpToDateLineNumber,fileAnnotation,vcs,file));
  }
  additionalActions.add(new CopyRevisionNumberAction(fileAnnotation));
  final AnnotationPresentation presentation=new AnnotationPresentation(highlighting,switcher,editorGutter,gutters,additionalActions.toArray(new AnAction[additionalActions.size()]));
  for (  AnAction action : additionalActions) {
    if (action instanceof LineNumberListener) {
      presentation.addLineNumberListener((LineNumberListener)action);
    }
  }
  final Map<String,Color> bgColorMap=Registry.is("vcs.show.colored.annotations") ? computeBgColors(fileAnnotation) : null;
  final Map<String,Integer> historyIds=Registry.is("vcs.show.history.numbers") ? computeLineNumbers(fileAnnotation) : null;
  if (switcher != null) {
    switcher.switchTo(switcher.getDefaultSource());
    final LineAnnotationAspect revisionAspect=switcher.getRevisionAspect();
    final CurrentRevisionAnnotationFieldGutter currentRevisionGutter=new CurrentRevisionAnnotationFieldGutter(fileAnnotation,editor,revisionAspect,presentation,bgColorMap);
    final MergeSourceAvailableMarkerGutter mergeSourceGutter=new MergeSourceAvailableMarkerGutter(fileAnnotation,editor,null,presentation,bgColorMap);
    presentation.addSourceSwitchListener(currentRevisionGutter);
    presentation.addSourceSwitchListener(mergeSourceGutter);
    currentRevisionGutter.consume(switcher.getDefaultSource());
    mergeSourceGutter.consume(switcher.getDefaultSource());
    gutters.add(currentRevisionGutter);
    gutters.add(mergeSourceGutter);
  }
  final LineAnnotationAspect[] aspects=fileAnnotation.getAspects();
  for (  LineAnnotationAspect aspect : aspects) {
    final AnnotationFieldGutter gutter=new AnnotationFieldGutter(fileAnnotation,editor,aspect,presentation,bgColorMap);
    gutter.setAspectValueToBgColorMap(bgColorMap);
    gutters.add(gutter);
  }
  if (historyIds != null) {
    gutters.add(new HistoryIdColumn(fileAnnotation,editor,presentation,bgColorMap,historyIds));
  }
  gutters.add(new HighlightedAdditionalColumn(fileAnnotation,editor,null,presentation,highlighting,bgColorMap));
  final AnnotateActionGroup actionGroup=new AnnotateActionGroup(gutters,editorGutter);
  presentation.addAction(actionGroup,1);
  presentation.addAction(new ShowHideAdditionalInfoAction(gutters,editorGutter,actionGroup));
  gutters.add(new ExtraFieldGutter(fileAnnotation,editor,presentation,bgColorMap,actionGroup));
  for (  AnnotationFieldGutter gutter : gutters) {
    final AnnotationGutterLineConvertorProxy proxy=new AnnotationGutterLineConvertorProxy(getUpToDateLineNumber,gutter);
    if (gutter.isGutterAction()) {
      editor.getGutter().registerTextAnnotation(proxy,proxy);
    }
 else {
      editor.getGutter().registerTextAnnotation(proxy);
    }
    annotations.add(gutter);
  }
}
