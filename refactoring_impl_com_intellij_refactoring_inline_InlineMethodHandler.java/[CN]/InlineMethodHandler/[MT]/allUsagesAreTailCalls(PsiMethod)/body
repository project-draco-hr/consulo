{
  final List<PsiReference> nonTailCallUsages=new ArrayList<PsiReference>();
  boolean result=ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
    public void run(){
      ReferencesSearch.search(method).forEach(new Processor<PsiReference>(){
        public boolean process(        final PsiReference psiReference){
          ProgressManager.getInstance().checkCanceled();
          if (!isTailCall(psiReference)) {
            nonTailCallUsages.add(psiReference);
            return false;
          }
          return true;
        }
      }
);
    }
  }
,RefactoringBundle.message("inline.method.checking.tail.calls.progress"),true,method.getProject());
  return result && nonTailCallUsages.isEmpty();
}
