{
  final PsiElement[] psiElements=new PsiElement[elements.length];
  List<VirtualFile> readOnly=new ArrayList<VirtualFile>();
  List<String> names=new ArrayList<String>();
  for (int idx=0; idx < elements.length; idx++) {
    PsiElement element=elements[idx];
    if (element instanceof PsiDirectory) {
      PsiPackage aPackage=((PsiDirectory)element).getPackage();
      LOG.assertTrue(aPackage != null);
      if (aPackage.getQualifiedName().length() == 0) {
        String message=RefactoringBundle.message("move.package.refactoring.cannot.be.applied.to.default.package");
        CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("move.tltle"),message,HelpID.getMoveHelpID(element),project);
        return;
      }
      element=checkMovePackage(project,aPackage,readOnly);
      if (element == null)       return;
    }
 else     if (element instanceof PsiPackage) {
      element=checkMovePackage(project,(PsiPackage)element,readOnly);
      if (element == null)       return;
    }
 else     if (element instanceof PsiClass) {
      PsiClass aClass=(PsiClass)element;
      if (aClass instanceof PsiAnonymousClass) {
        String message=RefactoringBundle.message("move.class.refactoring.cannot.be.applied.to.anonymous.classes");
        CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("move.tltle"),message,HelpID.getMoveHelpID(element),project);
        return;
      }
      if (!(aClass.getParent() instanceof PsiFile)) {
        String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("moving.local.classes.is.not.supported"));
        CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("move.tltle"),message,HelpID.getMoveHelpID(element),project);
        return;
      }
      final PsiFile file=aClass.getContainingFile();
      String name=file instanceof PsiJavaFile && ((PsiJavaFile)file).getClasses().length > 1 ? aClass.getName() + "." + StdFileTypes.JAVA.getDefaultExtension() : file.getName();
      if (names.contains(name)) {
        String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("there.are.going.to.be.multiple.destination.files.with.the.same.name"));
        CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("move.tltle"),message,HelpID.getMoveHelpID(element),project);
        return;
      }
      names.add(name);
      if (!aClass.isWritable()) {
        readOnly.add(aClass.getContainingFile().getVirtualFile());
      }
    }
    psiElements[idx]=element;
  }
  if (!readOnly.isEmpty()) {
    if (!successfullyCheckedOut(project,readOnly)) {
      String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("some.files.or.directories.are.read.only"));
      Messages.showErrorDialog(project,message,RefactoringBundle.message("move.tltle"));
      return;
    }
  }
  final String initialTargetPackageName=getInitialTargetPackageName(initialTargetElement,psiElements);
  final PsiDirectory initialTargetDirectory=getInitialTargetDirectory(initialTargetElement,psiElements);
  final boolean isTargetDirectoryFixed=getContainerDirectory(initialTargetElement) != null;
  boolean searchTextOccurences=false;
  for (int i=0; i < psiElements.length && !searchTextOccurences; i++) {
    PsiElement psiElement=psiElements[i];
    searchTextOccurences=RefactoringUtil.isSearchTextOccurencesEnabled(psiElement);
  }
  final MoveClassesOrPackagesDialog moveDialog=new MoveClassesOrPackagesDialog(project,searchTextOccurences,psiElements,moveCallback);
  boolean searchInComments=RefactoringSettings.getInstance().MOVE_SEARCH_IN_COMMENTS;
  boolean searchForTextOccurences=RefactoringSettings.getInstance().MOVE_SEARCH_FOR_TEXT;
  moveDialog.setData(psiElements,initialTargetPackageName,initialTargetDirectory,isTargetDirectoryFixed,searchInComments,searchForTextOccurences,HelpID.getMoveHelpID(psiElements[0]));
  moveDialog.show();
}
