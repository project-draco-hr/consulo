{
  if (file.isDirectory()) {
    if (!(file instanceof NewVirtualFile) || ManagingFS.getInstance().areChildrenLoaded(file)) {
      for (      VirtualFile child : file.getChildren()) {
        invalidateIndex(child);
      }
    }
  }
 else {
    boolean shouldLoadContent=false;
    final List<String> toUpdate=new ArrayList<String>(myIndices.size());
    for (    String indexId : myIndices.keySet()) {
      if (getInputFilter(indexId).acceptInput(file) && IndexingStamp.isFileIndexed(file,indexId,getIndexCreationStamp(indexId))) {
        toUpdate.add(indexId);
        if (myNeedContentLoading.contains(indexId)) {
          shouldLoadContent=true;
        }
      }
    }
    if (toUpdate.size() > 0) {
      includeToUpdateSet(file,true);
      final FileContent fc=new FileContent(file,shouldLoadContent ? loadContent(file) : null);
      final FutureTask<?> future=(FutureTask<?>)myInvalidationService.submit(new Runnable(){
        public void run(){
          for (          String indexId : toUpdate) {
            try {
              updateSingleIndex(indexId,file,null,fc);
            }
 catch (            StorageException e) {
              LOG.error(e);
            }
          }
        }
      }
);
      myFutureInvalidations.offer(future);
    }
  }
}
