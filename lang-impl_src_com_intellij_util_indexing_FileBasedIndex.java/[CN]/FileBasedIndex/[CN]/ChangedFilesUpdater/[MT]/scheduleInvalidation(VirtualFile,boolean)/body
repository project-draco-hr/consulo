{
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      for (      VirtualFile child : file.getChildren()) {
        scheduleInvalidation(child,saveContent);
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    FileContent fileContent=null;
    IndexingStamp.flushCache();
    for (    ID<?,?> indexId : myNotRequiringContentIndices) {
      if (shouldUpdateIndex(file,indexId)) {
        try {
          if (fileContent == null) {
            fileContent=new FileContent(file);
          }
          updateSingleIndex(indexId,file,null,fileContent);
        }
 catch (        StorageException e) {
          LOG.info(e);
          requestRebuild(indexId);
        }
      }
    }
    if (!isTooLarge(file)) {
      final List<ID<?,?>> affectedIndices=new ArrayList<ID<?,?>>(myIndices.size());
      for (      ID<?,?> indexId : myIndices.keySet()) {
        if (needsFileContentLoading(indexId) && shouldUpdateIndex(file,indexId)) {
          if (saveContent) {
            try {
              myFileContentAttic.offer(file);
              iterateIndexableFiles(file,new Processor<VirtualFile>(){
                public boolean process(                final VirtualFile file){
                  w.lock();
                  try {
                    myFilesToUpdate.add(file);
                  }
  finally {
                    w.unlock();
                  }
                  return true;
                }
              }
);
            }
 catch (            IOException e) {
              LOG.info(e);
              for (              ID<?,?> id : myIndices.keySet()) {
                if (needsFileContentLoading(id) && shouldUpdateIndex(file,id)) {
                  requestRebuild(indexId);
                }
              }
            }
            break;
          }
 else {
            affectedIndices.add(indexId);
          }
        }
      }
      if (!affectedIndices.isEmpty()) {
        byte[] content=myFileContentAttic.remove(file);
        try {
          if (content == null) {
            content=file.contentsToByteArray();
          }
        }
 catch (        IOException e) {
          content=ArrayUtil.EMPTY_BYTE_ARRAY;
        }
        final FileContent fc=new FileContent(file,content);
        final InvalidationTask invalidator=new InvalidationTask(file){
          public void run(){
            Throwable unexpectedError=null;
            for (            ID<?,?> indexId : affectedIndices) {
              try {
                updateSingleIndex(indexId,file,null,fc);
              }
 catch (              StorageException e) {
                LOG.info(e);
                requestRebuild(indexId);
              }
catch (              ProcessCanceledException ignored) {
              }
catch (              Throwable e) {
                LOG.info(e);
                if (unexpectedError == null) {
                  unexpectedError=e;
                }
              }
            }
            IndexingStamp.flushCache();
            if (unexpectedError != null) {
              LOG.error(unexpectedError);
            }
          }
        }
;
        w.lock();
        try {
          myFutureInvalidations.offer(invalidator);
        }
  finally {
          w.unlock();
        }
      }
    }
  }
}
