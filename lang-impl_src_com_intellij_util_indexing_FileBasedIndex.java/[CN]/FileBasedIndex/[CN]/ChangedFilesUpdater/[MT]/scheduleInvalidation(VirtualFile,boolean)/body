{
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      for (      VirtualFile child : file.getChildren()) {
        scheduleInvalidation(child,saveContent);
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    final boolean isTooLarge=SingleRootFileViewProvider.isTooLarge(file);
    final List<ID<?,?>> affectedIndices=new ArrayList<ID<?,?>>(myIndices.size());
    FileContent fileContent=null;
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (shouldUpdateIndex(file,indexId)) {
        if (myNeedContentLoading.contains(indexId)) {
          if (!isTooLarge) {
            affectedIndices.add(indexId);
          }
        }
 else {
          try {
            if (fileContent == null) {
              fileContent=new FileContent(file);
            }
            updateSingleIndex(indexId,file,null,fileContent);
          }
 catch (          StorageException e) {
            LOG.info(e);
            requestRebuild(indexId);
          }
        }
      }
    }
    IndexingStamp.flushCache();
    if (!affectedIndices.isEmpty()) {
      if (saveContent) {
        myFileContentAttic.offer(file);
        iterateIndexableFiles(file,new Processor<VirtualFile>(){
          public boolean process(          final VirtualFile file){
            myFilesToUpdate.add(file);
            return true;
          }
        }
);
      }
 else {
        byte[] content=myFileContentAttic.remove(file);
        try {
          if (content == null) {
            content=file.contentsToByteArray();
          }
        }
 catch (        IOException e) {
          content=ArrayUtil.EMPTY_BYTE_ARRAY;
        }
        final FileContent fc=new FileContent(file,content);
synchronized (myFutureInvalidations) {
          final InvalidationTask invalidator=new InvalidationTask(file){
            public void run(){
              Throwable unexpectedError=null;
              for (              ID<?,?> indexId : affectedIndices) {
                try {
                  updateSingleIndex(indexId,file,null,fc);
                }
 catch (                StorageException e) {
                  LOG.info(e);
                  requestRebuild(indexId);
                }
catch (                ProcessCanceledException ignored) {
                }
catch (                Throwable e) {
                  LOG.info(e);
                  if (unexpectedError == null) {
                    unexpectedError=e;
                  }
                }
              }
              IndexingStamp.flushCache();
              if (unexpectedError != null) {
                LOG.error(unexpectedError);
              }
            }
          }
;
          myFutureInvalidations.offer(invalidator);
        }
      }
    }
  }
}
