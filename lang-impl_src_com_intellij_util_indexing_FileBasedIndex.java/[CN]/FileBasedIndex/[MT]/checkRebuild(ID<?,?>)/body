{
  final boolean reallyRemoved=myRequiresRebuild.remove(indexId);
  if (!reallyRemoved) {
    return;
  }
  getIndex(indexId).clear();
  try {
    rewriteVersion(getVersionFile(indexId),myIndexIdToVersionMap.get(indexId));
  }
 catch (  IOException e) {
    LOG.error(e);
  }
  final Project[] projects=ProjectManager.getInstance().getOpenProjects();
  final FileSystemSynchronizer synchronizer=new FileSystemSynchronizer();
  synchronizer.setCancelable(false);
  for (  Project project : projects) {
    synchronizer.registerCacheUpdater(new UnindexedFilesUpdater(project,ProjectRootManager.getInstance(project),this));
  }
  final Application application=ApplicationManager.getApplication();
  if (application.isDispatchThread()) {
    new Task.Modal(null,"Updating index",false){
      public void run(      @NotNull final ProgressIndicator indicator){
        synchronizer.execute();
      }
    }
.queue();
  }
 else {
    final Semaphore semaphore=new Semaphore();
    semaphore.down();
    Runnable runnable=new Runnable(){
      public void run(){
        new Task.Backgroundable(null,"Updating index",false){
          public void run(          @NotNull final ProgressIndicator indicator){
            try {
              synchronizer.execute();
            }
  finally {
              semaphore.up();
            }
          }
        }
.queue();
      }
    }
;
    if (application.isUnitTestMode()) {
      application.invokeLater(runnable,ModalityState.NON_MODAL);
    }
 else {
      SwingUtilities.invokeLater(runnable);
    }
    semaphore.waitFor();
  }
}
