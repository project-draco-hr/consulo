{
  myChangedFilesUpdater.forceUpdate();
  final FileDocumentManager fdManager=FileDocumentManager.getInstance();
  final Document[] documents=fdManager.getUnsavedDocuments();
  if (documents.length > 0) {
    setDataBufferingEnabled(true);
    myUnsavedDataIndexingSemaphore.down();
    try {
      for (      Document document : documents) {
        final VirtualFile vFile=fdManager.getFile(document);
        if (!vFile.isValid()) {
          continue;
        }
        if (isUncomitted(document))         continue;
        final long currentDocStamp=document.getModificationStamp();
        if (currentDocStamp != getLastIndexedStamp(document).getAndSet(currentDocStamp)) {
          CharSequence lastIndexed=myLastIndexedUnsavedContent.get(document);
          if (lastIndexed == null) {
            lastIndexed=loadContent(vFile);
          }
          final FileContent oldFc=new FileContent(vFile,lastIndexed);
          final FileContent newFc=new FileContent(vFile,document.getText());
          for (          ID<?,?> indexId : myIndices.keySet()) {
            if (getInputFilter(indexId).acceptInput(vFile)) {
              final int inputId=Math.abs(getFileId(vFile));
              if (CachesBasedRefSearcher.DEBUG) {
                System.out.println("FileBasedIndex.indexUnsavedDocuments");
                System.out.println("indexId = " + indexId);
                System.out.println("Indexing inputId = " + inputId);
                System.out.println("file = " + vFile.getPresentableUrl());
                System.out.println("IndexInfrastructure.getIndexRootDir(indexId) = " + IndexInfrastructure.getIndexRootDir(indexId));
              }
              getIndex(indexId).update(inputId,newFc,oldFc);
            }
          }
          myLastIndexedUnsavedContent.put(document,newFc.content);
        }
      }
    }
  finally {
      myUnsavedDataIndexingSemaphore.up();
      myUnsavedDataIndexingSemaphore.waitFor();
    }
  }
}
