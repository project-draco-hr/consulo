{
  myVfManager=vfManager;
  final MessageBusConnection connection=bus.connect();
  connection.subscribe(PsiDocumentTransactionListener.TOPIC,new PsiDocumentTransactionListener(){
    public void transactionStarted(    final Document doc,    final PsiFile file){
      if (file != null) {
        myTransactionMap.put(doc,file);
        myUpToDateIndices.clear();
      }
    }
    public void transactionCompleted(    final Document doc,    final PsiFile file){
      myTransactionMap.remove(doc);
    }
  }
);
  connection.subscribe(AppTopics.FILE_TYPES,new FileTypeListener(){
    public void beforeFileTypesChanged(    final FileTypeEvent event){
      cleanupProcessedFlag();
      if (ApplicationManager.getApplication().isUnitTestMode()) {
        requestRebuild(StubUpdatingIndex.INDEX_ID);
      }
    }
    public void fileTypesChanged(    final FileTypeEvent event){
    }
  }
);
  ApplicationManager.getApplication().addApplicationListener(new ApplicationAdapter(){
    public void writeActionStarted(    Object action){
      myUpToDateIndices.clear();
    }
  }
);
  final File workInProgressFile=getMarkerFile();
  if (workInProgressFile.exists()) {
    FileUtil.delete(PathManager.getIndexRoot());
  }
  try {
    final FileBasedIndexExtension[] extensions=Extensions.getExtensions(FileBasedIndexExtension.EXTENSION_POINT_NAME);
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      myRebuildStatus.put(extension.getName(),new AtomicInteger(OK));
    }
    final File corruptionMarker=new File(PathManager.getIndexRoot(),CORRUPTION_MARKER_NAME);
    final boolean currentVersionCorrupted=corruptionMarker.exists();
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      registerIndexer(extension,currentVersionCorrupted);
    }
    FileUtil.delete(corruptionMarker);
    dropUnregisteredIndices();
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (myRebuildStatus.get(indexId).compareAndSet(REQUIRES_REBUILD,OK)) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          requestRebuild(indexId);
          LOG.error(e);
        }
      }
    }
    myChangedFilesUpdater=new ChangedFilesUpdater();
    connection.subscribe(VirtualFileManager.VFS_CHANGES,new BulkVirtualFileListenerAdapter(myChangedFilesUpdater){
      public void before(      final List<? extends VFileEvent> events){
        if (ApplicationManager.getApplication().isDispatchThread()) {
          new Task.Modal(null,"Preparing index invalidation...",false){
            public void run(            @NotNull ProgressIndicator indicator){
              indicator.setIndeterminate(true);
              deliverBeforeEvents(events);
            }
          }
.queue();
        }
 else {
          deliverBeforeEvents(events);
        }
      }
      private void deliverBeforeEvents(      List<? extends VFileEvent> events){
        super.before(events);
      }
    }
);
    vfManager.registerRefreshUpdater(myChangedFilesUpdater);
    myFileContentAttic=new FileContentStorage(new File(PathManager.getIndexRoot(),"updates.tmp"));
  }
  finally {
    workInProgressFile.createNewFile();
    saveRegisteredInices(myIndices.keySet());
  }
}
