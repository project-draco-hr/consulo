{
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(mySuperClass,myMemberInfos);
  for (  PsiClass targetClass : myTargetClasses) {
    for (    MemberInfo info : myMemberInfos) {
      final PsiMember member=info.getMember();
      pushDownConflicts.checkMemberPlacementInTargetClassConflict(targetClass,member);
    }
  }
  final MultiMap<PsiElement,String> conflictsMap=pushDownConflicts.getConflicts();
  for (  PsiElement element : conflictsMap.keySet()) {
    conflicts.put(element,conflictsMap.get(element));
  }
  if (myCurrentInheritor != null) {
    ReferencesSearch.search(myCurrentInheritor).forEach(new Processor<PsiReference>(){
      @Override public boolean process(      PsiReference reference){
        final PsiElement element=reference.getElement();
        if (element != null) {
          final PsiElement parent=element.getParent();
          if (parent instanceof PsiNewExpression) {
            final PsiClass aClass=PsiUtil.resolveClassInType(getPlaceExpectedType(parent));
            if (aClass == mySuperClass) {
              conflicts.putValue(parent,"Instance of target type is passed to a place where super class is expected.");
              return false;
            }
          }
        }
        return true;
      }
    }
);
  }
  checkConflicts(refUsages,conflicts);
  return showConflicts(conflicts,refUsages.get());
}
