{
  new PushDownProcessor(mySuperClass.getProject(),myMemberInfos,mySuperClass,new DocCommentPolicy(myPolicy)){
    @Override protected boolean showConflicts(    MultiMap<PsiElement,String> conflicts,    UsageInfo[] usages){
      return true;
    }
    @Override protected void performRefactoring(    UsageInfo[] pushDownUsages){
      if (myCurrentInheritor != null) {
        encodeRefs();
        pushDownToClass(myCurrentInheritor);
      }
 else {
        super.performRefactoring(pushDownUsages);
      }
      CommonRefactoringUtil.sortDepthFirstRightLeftOrder(usages);
      for (      UsageInfo usageInfo : usages) {
        if (!(usageInfo instanceof ReplaceExtendsListUsageInfo || usageInfo instanceof RemoveImportUsageInfo)) {
          try {
            ((FixableUsageInfo)usageInfo).fixUsage();
          }
 catch (          IncorrectOperationException e) {
            LOG.info(e);
          }
        }
      }
      replaceInnerTypeUsages();
      for (      UsageInfo usage : usages) {
        if (usage instanceof ReplaceExtendsListUsageInfo || usage instanceof RemoveImportUsageInfo) {
          ((FixableUsageInfo)usage).fixUsage();
        }
      }
      if (myCurrentInheritor == null) {
        try {
          mySuperClass.delete();
        }
 catch (        IncorrectOperationException e) {
          LOG.error(e);
        }
      }
    }
  }
.run();
}
