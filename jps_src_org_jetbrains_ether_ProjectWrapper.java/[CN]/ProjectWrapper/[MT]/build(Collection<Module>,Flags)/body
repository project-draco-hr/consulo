{
  boolean incremental=flags.incremental();
  final List<ModuleChunk> chunks=myProjectBuilder.getChunks(flags.tests()).getChunkList();
  for (  final ModuleChunk c : chunks) {
    final Set<Module> chunkModules=c.getElements();
    if (!DefaultGroovyMethods.intersect(modules,chunkModules).isEmpty()) {
      final Set<String> removedSources=new HashSet<String>();
      if (incremental) {
        final Set<String> chunkSources=new HashSet<String>();
        final Set<String> outdatedSources=new HashSet<String>();
        for (        Module m : chunkModules) {
          final ModuleWrapper mw=getModule(m.getName());
          outdatedSources.addAll(mw.getOutdatedFiles(flags.tests()));
          chunkSources.addAll(mw.getSources(flags.tests()));
          removedSources.addAll(mw.getRemovedFiles(flags.tests()));
        }
        final BuildStatus result=iterativeCompile(c,chunkSources,outdatedSources,removedSources,flags);
        incremental=result == BuildStatus.INCREMENTAL;
        if (result == BuildStatus.FAILURE) {
          return result;
        }
      }
 else {
        new Logger(flags){
          @Override public void log(          PrintStream stream){
            stream.println("Compiling chunk " + c.getName() + " non-incrementally.");
          }
        }
.log();
        for (        Module m : chunkModules) {
          final ModuleWrapper mw=getModule(m.getName());
          removedSources.addAll(flags.tests() ? mw.getRemovedTests() : mw.getRemovedSources());
        }
        final Set<Module> toClean=new HashSet<Module>();
        for (        Module m : chunkModules) {
          if (!cleared.contains(m)) {
            toClean.add(m);
          }
        }
        if (!toClean.isEmpty() && !flags.tests()) {
          builder.clearChunk(new ModuleChunk(toClean),null,ProjectWrapper.this);
          cleared.addAll(toClean);
        }
        Mappings delta;
        try {
          delta=new Mappings(getMapDir());
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
        final Callbacks.Backend deltaCallback=delta.getCallback();
        try {
          builder.buildChunk(c,flags.tests(),null,deltaCallback,ProjectWrapper.this);
        }
 catch (        Exception e) {
          e.printStackTrace();
          return BuildStatus.FAILURE;
        }
        final Set<String> allFiles=new HashSet<String>();
        for (        Module m : c.getElements()) {
          final ModuleWrapper module=getModule(m.getName());
          affectedFiles.removeAll(module.getSources(flags.tests()));
          allFiles.addAll(module.getSources(flags.tests()));
        }
        final Collection<File> files=new HashSet<File>();
        for (        String f : allFiles) {
          files.add(new File(f));
        }
        dependencyMapping.integrate(delta,files,removedSources);
        for (        Module m : chunkModules) {
          Reporter.reportBuildSuccess(m,flags.tests());
        }
      }
    }
  }
  return BuildStatus.INCREMENTAL;
}
