{
  boolean incremental=flags.incremental();
  final List<ModuleChunk> chunks=myProject.getChunks(tests);
  for (  ModuleChunk c : chunks) {
    final Set<Module> chunkModules=c.getElements();
    if (!DefaultGroovyMethods.intersect(modules,chunkModules).isEmpty()) {
      if (incremental) {
        final Set<StringCache.S> chunkSources=new HashSet<StringCache.S>();
        final Set<StringCache.S> outdatedSources=new HashSet<StringCache.S>();
        final Set<StringCache.S> removedSources=new HashSet<StringCache.S>();
        for (        Module m : chunkModules) {
          final ModuleWrapper mw=getModule(m.getName());
          outdatedSources.addAll(tests ? mw.getOutdatedTests() : mw.getOutdatedSources());
          chunkSources.addAll(tests ? mw.getTests() : mw.getSources());
          removedSources.addAll(tests ? mw.getRemovedTests() : mw.getRemovedSources());
        }
        incremental=iterativeCompile(c,tests,chunkSources,outdatedSources,removedSources,flags);
      }
 else {
        final Set<Module> toClean=new HashSet<Module>();
        for (        Module m : chunkModules) {
          if (!cleared.contains(m)) {
            toClean.add(m);
          }
        }
        if (!toClean.isEmpty()) {
          builder.clearChunk(new ModuleChunk(toClean),null,ProjectWrapper.this);
          cleared.addAll(toClean);
        }
        builder.buildChunk(c,tests,null,backendCallback,ProjectWrapper.this);
        for (        Module m : c.getElements()) {
          final ModuleWrapper module=getModule(m.getName());
          affectedFiles.removeAll(tests ? module.getTests() : module.getSources());
        }
      }
    }
  }
}
