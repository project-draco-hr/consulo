{
  final Collection<StringCache.S> filesToCompile=DefaultGroovyMethods.intersect(affectedFiles,sources);
  if (outdated != null) {
    filesToCompile.addAll(outdated);
  }
  filesToCompile.removeAll(compiledFiles);
  if (!filesToCompile.isEmpty()) {
    final Set<StringCache.S> outputFiles=new HashSet<StringCache.S>();
    for (    StringCache.S f : filesToCompile) {
      for (      ClassRepr cr : dependencyMapping.getClasses(f)) {
        outputFiles.add(cr.fileName);
      }
    }
    if (removed != null) {
      for (      StringCache.S f : removed) {
        for (        ClassRepr cr : dependencyMapping.getClasses(f)) {
          outputFiles.add(cr.fileName);
        }
      }
    }
    if (!outputFiles.isEmpty()) {
      builder.clearChunk(chunk,outputFiles,ProjectWrapper.this);
    }
    final Mappings delta=new Mappings(ProjectWrapper.this);
    final Callbacks.Backend deltaBackend=delta.getCallback();
    builder.buildChunk(chunk,tests,filesToCompile,deltaBackend,ProjectWrapper.this);
    compiledFiles.addAll(filesToCompile);
    affectedFiles.removeAll(filesToCompile);
    final boolean incremental=dependencyMapping.differentiate(delta,removed,compiledFiles,affectedFiles);
    dependencyMapping.integrate(delta,removed);
    if (!incremental) {
      affectedFiles.addAll(sources);
      iterativeCompile(chunk,tests,sources,null,null);
      return false;
    }
    return iterativeCompile(chunk,tests,sources,null,null);
  }
 else {
    for (    Module m : chunk.getElements()) {
      Reporter.reportBuildSuccess(m,tests);
    }
  }
  return true;
}
