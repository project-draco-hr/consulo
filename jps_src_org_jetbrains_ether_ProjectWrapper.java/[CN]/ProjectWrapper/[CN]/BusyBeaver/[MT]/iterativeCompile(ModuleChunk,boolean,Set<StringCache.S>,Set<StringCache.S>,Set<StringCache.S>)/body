{
  final Collection<StringCache.S> filesToCompile=DefaultGroovyMethods.intersect(affectedFiles,sources);
  final Set<StringCache.S> safeFiles=new HashSet<StringCache.S>();
  if (outdated != null) {
    filesToCompile.addAll(outdated);
    for (    StringCache.S f : outdated) {
      if (f.value.endsWith(".form")) {
        final StringCache.S sourceFileName=dependencyMapping.getJavaByForm(f);
        if (!filesToCompile.contains(sourceFileName)) {
          safeFiles.add(sourceFileName);
          filesToCompile.add(sourceFileName);
        }
      }
 else       if (f.value.endsWith(".java")) {
        final StringCache.S formFileName=dependencyMapping.getFormByJava(f);
        if (formFileName != null) {
          filesToCompile.add(formFileName);
        }
      }
    }
  }
  filesToCompile.removeAll(compiledFiles);
  if (!filesToCompile.isEmpty()) {
    final Set<StringCache.S> outputFiles=new HashSet<StringCache.S>();
    for (    StringCache.S f : filesToCompile) {
      for (      ClassRepr cr : dependencyMapping.getClasses(f)) {
        outputFiles.add(cr.fileName);
      }
    }
    if (removed != null) {
      for (      StringCache.S f : removed) {
        for (        ClassRepr cr : dependencyMapping.getClasses(f)) {
          outputFiles.add(cr.fileName);
        }
      }
    }
    if (!outputFiles.isEmpty()) {
      builder.clearChunk(chunk,outputFiles,ProjectWrapper.this);
    }
    final Mappings delta=new Mappings(ProjectWrapper.this);
    final Callbacks.Backend deltaBackend=delta.getCallback();
    builder.buildChunk(chunk,tests,filesToCompile,deltaBackend,ProjectWrapper.this);
    compiledFiles.addAll(filesToCompile);
    affectedFiles.removeAll(filesToCompile);
    final boolean incremental=dependencyMapping.differentiate(delta,removed,compiledFiles,affectedFiles,safeFiles);
    dependencyMapping.integrate(delta,removed);
    if (!incremental) {
      affectedFiles.addAll(sources);
      iterativeCompile(chunk,tests,sources,null,null);
      return false;
    }
    return iterativeCompile(chunk,tests,sources,null,null);
  }
 else {
    for (    Module m : chunk.getElements()) {
      Reporter.reportBuildSuccess(m,tests);
    }
  }
  return true;
}
