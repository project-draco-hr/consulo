{
  final Collection<StringCache.S> filesToCompile=DefaultGroovyMethods.intersect(affectedFiles,sources);
  final Set<StringCache.S> safeFiles=new HashSet<StringCache.S>();
  if (outdated != null) {
    for (    StringCache.S s : outdated) {
      assert(s != null);
    }
    filesToCompile.addAll(outdated);
    for (    StringCache.S f : outdated) {
      if (f.value.endsWith(".form")) {
        final StringCache.S sourceFileName=dependencyMapping.getJavaByForm(f);
        if (sourceFileName != null && !filesToCompile.contains(sourceFileName)) {
          safeFiles.add(sourceFileName);
          filesToCompile.add(sourceFileName);
        }
      }
 else       if (f.value.endsWith(".java")) {
        final StringCache.S formFileName=dependencyMapping.getFormByJava(f);
        if (formFileName != null) {
          filesToCompile.add(formFileName);
        }
      }
    }
  }
  filesToCompile.removeAll(compiledFiles);
  if (!filesToCompile.isEmpty() || removed != null) {
    final Set<StringCache.S> outputFiles=new HashSet<StringCache.S>();
    for (    StringCache.S f : filesToCompile) {
      final Set<ClassRepr> classes=dependencyMapping.getClasses(f);
      if (classes != null)       for (      ClassRepr cr : classes) {
        outputFiles.add(cr.fileName);
      }
    }
    if (removed != null) {
      for (      StringCache.S f : removed) {
        final Set<ClassRepr> classes=dependencyMapping.getClasses(f);
        if (classes != null) {
          for (          ClassRepr cr : classes) {
            outputFiles.add(cr.fileName);
          }
        }
      }
    }
    if (!outputFiles.isEmpty()) {
      new Logger(flags){
        @Override public void log(        PrintStream stream){
          stream.println("Cleaning output files:");
          logMany(stream,outputFiles);
          stream.println("End of files");
        }
      }
.log();
      builder.clearChunk(chunk,outputFiles,ProjectWrapper.this);
    }
    final Mappings delta=new Mappings(ProjectWrapper.this);
    final Callbacks.Backend deltaBackend=delta.getCallback();
    new Logger(flags){
      @Override public void log(      PrintStream stream){
        stream.println("Compiling files:");
        logMany(stream,filesToCompile);
        stream.println("End of files");
      }
    }
.log();
    builder.buildChunk(chunk,tests,filesToCompile,deltaBackend,ProjectWrapper.this);
    compiledFiles.addAll(filesToCompile);
    affectedFiles.removeAll(filesToCompile);
    final boolean incremental=dependencyMapping.differentiate(delta,removed,compiledFiles,affectedFiles,safeFiles);
    dependencyMapping.integrate(delta,removed);
    if (!incremental) {
      affectedFiles.addAll(sources);
      iterativeCompile(chunk,tests,sources,null,null,flags);
      return false;
    }
    return iterativeCompile(chunk,tests,sources,null,null,flags);
  }
 else {
    for (    Module m : chunk.getElements()) {
      Reporter.reportBuildSuccess(m,tests);
    }
  }
  return true;
}
