{
  if (psiClass.hasModifierProperty(PsiModifier.ABSTRACT)) {
    return RefactoringBundle.message("inline.to.anonymous.no.abstract");
  }
  if (ClassInheritorsSearch.search(psiClass).findFirst() != null) {
    return RefactoringBundle.message("inline.to.anonymous.no.inheritors");
  }
  final PsiClass[] interfaces=psiClass.getInterfaces();
  if (interfaces.length > 1) {
    return RefactoringBundle.message("inline.to.anonymous.no.multiple.interfaces");
  }
  if (interfaces.length == 1) {
    final PsiClass superClass=psiClass.getSuperClass();
    if (superClass != null && !CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) {
      return RefactoringBundle.message("inline.to.anonymous.no.superclass.and.interface");
    }
  }
  final PsiMethod[] methods=psiClass.getMethods();
  for (  PsiMethod method : methods) {
    if (!method.isConstructor() && method.findSuperMethods().length == 0) {
      if (!ReferencesSearch.search(method).forEach(new CheckAncestorProcessor(psiClass))) {
        return "Class cannot be inlined because it has usages of methods not inherited from its superclass or interface";
      }
    }
  }
  final PsiField[] fields=psiClass.getFields();
  for (  PsiField field : fields) {
    if (!ReferencesSearch.search(field).forEach(new CheckAncestorProcessor(psiClass))) {
      return "Class cannot be inlined because it has usages of fields not inherited from its superclass";
    }
  }
  return null;
}
