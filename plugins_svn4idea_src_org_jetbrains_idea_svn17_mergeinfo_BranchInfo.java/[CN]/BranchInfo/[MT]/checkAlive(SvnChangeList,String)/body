{
  final SVNInfo info=getInfo(new File(branchPath));
  if (info == null || info.getURL() == null || (!SVNPathUtil.isAncestor(myBranchUrl,info.getURL().toString()))) {
    return SvnMergeInfoCache17.MergeCheckResult.NOT_MERGED;
  }
  final String subPathUnderBranch=SVNPathUtil.getRelativePath(myBranchUrl,info.getURL().toString());
  final MultiMap<SvnMergeInfoCache17.MergeCheckResult,String> result=new MultiMap<SvnMergeInfoCache17.MergeCheckResult,String>();
  checkPaths(list.getNumber(),list.getAddedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS;
  }
  checkPaths(list.getNumber(),list.getDeletedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS;
  }
  checkPaths(list.getNumber(),list.getChangedPaths(),branchPath,subPathUnderBranch,result);
  if (result.containsKey(SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache17.MergeCheckResult.NOT_EXISTS;
  }
 else   if (result.containsKey(SvnMergeInfoCache17.MergeCheckResult.NOT_MERGED)) {
    myPartlyMerged.put(list.getNumber(),result.get(SvnMergeInfoCache17.MergeCheckResult.NOT_MERGED));
    return SvnMergeInfoCache17.MergeCheckResult.NOT_MERGED;
  }
  return SvnMergeInfoCache17.MergeCheckResult.MERGED;
}
