{
  final VirtualFile eventFile=event.getFile();
  if ((LOG.isDebugEnabled() && eventFile.isDirectory()) || ourDebugMode) {
    final String message="Processing file deletion: " + eventFile.getPresentableUrl();
    LOG.debug(message);
    if (ourDebugMode) {
      System.out.println(message);
    }
  }
  final Set<String> pathsToMark=new HashSet<String>();
  processRecursively(eventFile,true,new FileProcessor(){
    private final TIntArrayList myAssociatedProjectIds=new TIntArrayList();
    public void execute(    final VirtualFile file){
      final String filePath=file.getPath();
      pathsToMark.add(filePath);
      myAssociatedProjectIds.clear();
      try {
        final OutputFileInfo outputInfo=loadOutputInfo(file);
        if (outputInfo != null) {
          final String srcPath=outputInfo.getSourceFilePath();
          final VirtualFile srcFile=srcPath != null ? LocalFileSystem.getInstance().findFileByPath(srcPath) : null;
          if (srcFile != null) {
            final SourceFileInfo srcInfo=loadSourceInfo(srcFile);
            if (srcInfo != null) {
              final boolean srcWillBeDeleted=VfsUtil.isAncestor(eventFile,srcFile,false);
              for (              int projectId : srcInfo.getProjectIds().toArray()) {
                if (isSuspended(projectId)) {
                  continue;
                }
                if (srcInfo.isAssociated(projectId,filePath)) {
                  myAssociatedProjectIds.add(projectId);
                  if (srcWillBeDeleted) {
                    if (LOG.isDebugEnabled() || ourDebugMode) {
                      final String message="Unschedule recompilation because of deletion " + srcFile.getPresentableUrl();
                      LOG.debug(message);
                      if (ourDebugMode) {
                        System.out.println(message);
                      }
                    }
                    removeSourceForRecompilation(projectId,Math.abs(getFileId(srcFile)));
                  }
 else {
                    addSourceForRecompilation(projectId,srcFile,srcInfo);
                  }
                }
              }
            }
          }
        }
        final SourceFileInfo srcInfo=loadSourceInfo(file);
        if (srcInfo != null) {
          final TIntHashSet projects=srcInfo.getProjectIds();
          if (!projects.isEmpty()) {
            final ScheduleOutputsForDeletionProc deletionProc=new ScheduleOutputsForDeletionProc(file.getUrl());
            deletionProc.setRootBeingDeleted(eventFile);
            final int sourceFileId=Math.abs(getFileId(file));
            for (            int projectId : projects.toArray()) {
              if (isSuspended(projectId)) {
                continue;
              }
              if (srcInfo.isAssociated(projectId,filePath)) {
                myAssociatedProjectIds.add(projectId);
              }
              srcInfo.processOutputPaths(projectId,deletionProc);
              if (LOG.isDebugEnabled() || ourDebugMode) {
                final String message="Unschedule recompilation because of deletion " + file.getPresentableUrl();
                LOG.debug(message);
                if (ourDebugMode) {
                  System.out.println(message);
                }
              }
              removeSourceForRecompilation(projectId,sourceFileId);
            }
          }
        }
      }
  finally {
        myAssociatedProjectIds.forEach(new TIntProcedure(){
          public boolean execute(          int projectId){
            unmarkOutputPathForDeletion(projectId,filePath);
            return true;
          }
        }
);
      }
    }
  }
);
  if (!pathsToMark.isEmpty()) {
    notifyFilesDeleted(pathsToMark);
  }
}
