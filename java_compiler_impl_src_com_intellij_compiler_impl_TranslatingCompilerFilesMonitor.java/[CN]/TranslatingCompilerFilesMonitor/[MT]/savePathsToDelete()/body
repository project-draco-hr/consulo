{
  final File file=new File(CompilerPaths.getCompilerSystemDirectory(),PATHS_TO_DELETE_FILENAME);
  try {
    FileUtil.createParentDirs(file);
    final DataOutputStream os=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
    try {
synchronized (myDataLock) {
        mySuspendedProjects.forEach(new TIntProcedure(){
          @Override public boolean execute(          int projectId){
            myOutputsToDelete.remove(projectId);
            return true;
          }
        }
);
        final int[] keys=myOutputsToDelete.keys();
        os.writeInt(keys.length);
        for (        int projectId : keys) {
          final Map<String,SourceUrlClassNamePair> projectOutputs=myOutputsToDelete.get(projectId);
          os.writeInt(projectId);
          if (projectOutputs != null) {
            os.writeInt(projectOutputs.size());
            for (            Map.Entry<String,SourceUrlClassNamePair> entry : projectOutputs.entrySet()) {
              CompilerIOUtil.writeString(entry.getKey(),os);
              final SourceUrlClassNamePair pair=entry.getValue();
              CompilerIOUtil.writeString(pair.getSourceUrl(),os);
              CompilerIOUtil.writeString(pair.getClassName(),os);
            }
          }
 else {
            os.writeInt(0);
          }
        }
      }
    }
  finally {
      os.close();
synchronized (myProjectOutputRoots) {
        myProjectOutputRoots.clear();
      }
      myOutputRootsStorage.close();
    }
  }
 catch (  IOException e) {
    LOG.error(e);
  }
}
