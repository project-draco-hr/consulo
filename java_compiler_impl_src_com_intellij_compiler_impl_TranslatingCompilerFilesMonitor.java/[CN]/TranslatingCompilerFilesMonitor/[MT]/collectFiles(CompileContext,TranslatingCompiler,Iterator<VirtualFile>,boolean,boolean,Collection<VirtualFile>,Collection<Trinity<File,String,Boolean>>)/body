{
  final Project project=context.getProject();
  final int projectId=getProjectId(project);
  final CompilerConfiguration configuration=CompilerConfiguration.getInstance(project);
  final boolean _forceCompile=forceCompile || isRebuild;
  final Set<VirtualFile> selectedForRecompilation=new HashSet<VirtualFile>();
synchronized (mySourcesToRecompile) {
    final TIntHashSet pathsToRecompile=mySourcesToRecompile.get(projectId);
    if (_forceCompile || pathsToRecompile != null && !pathsToRecompile.isEmpty()) {
      if (ourDebugMode) {
        System.out.println("Analysing potentially recompilable files for " + compiler.getDescription());
      }
      while (scopeSrcIterator.hasNext()) {
        final VirtualFile file=scopeSrcIterator.next();
        if (!file.isValid()) {
          if (LOG.isDebugEnabled() || ourDebugMode) {
            LOG.debug("Skipping invalid file " + file.getPresentableUrl());
            if (ourDebugMode) {
              System.out.println("\t SKIPPED(INVALID) " + file.getPresentableUrl());
            }
          }
          continue;
        }
        final int fileId=getFileId(file);
        if (_forceCompile) {
          if (compiler.isCompilableFile(file,context) && !configuration.isExcludedFromCompilation(file)) {
            toCompile.add(file);
            if (ourDebugMode) {
              System.out.println("\t INCLUDED " + file.getPresentableUrl());
            }
            selectedForRecompilation.add(file);
            if (pathsToRecompile == null || !pathsToRecompile.contains(fileId)) {
              addSourceForRecompilation(projectId,file,null);
            }
          }
 else {
            if (ourDebugMode) {
              System.out.println("\t NOT COMPILABLE OR EXCLUDED " + file.getPresentableUrl());
            }
          }
        }
 else         if (pathsToRecompile.contains(fileId)) {
          if (compiler.isCompilableFile(file,context) && !configuration.isExcludedFromCompilation(file)) {
            toCompile.add(file);
            if (ourDebugMode) {
              System.out.println("\t INCLUDED " + file.getPresentableUrl());
            }
            selectedForRecompilation.add(file);
          }
 else {
            if (ourDebugMode) {
              System.out.println("\t NOT COMPILABLE OR EXCLUDED " + file.getPresentableUrl());
            }
          }
        }
 else {
          if (ourDebugMode) {
            System.out.println("\t NOT INCLUDED " + file.getPresentableUrl());
          }
        }
      }
    }
  }
  if (!isRebuild) {
synchronized (myOutputsToDelete) {
      final Map<String,SourceUrlClassNamePair> outputsToDelete=myOutputsToDelete.get(projectId);
      if (outputsToDelete != null) {
        final VirtualFileManager vfm=VirtualFileManager.getInstance();
        final LocalFileSystem lfs=LocalFileSystem.getInstance();
        final List<String> zombieEntries=new ArrayList<String>();
        for (        String outputPath : outputsToDelete.keySet()) {
          final SourceUrlClassNamePair classNamePair=outputsToDelete.get(outputPath);
          final String sourceUrl=classNamePair.getSourceUrl();
          final VirtualFile srcFile=vfm.findFileByUrl(sourceUrl);
          final boolean sourcePresent=srcFile != null;
          if (sourcePresent) {
            if (!compiler.isCompilableFile(srcFile,context)) {
              continue;
            }
            if (!selectedForRecompilation.contains(srcFile)) {
              continue;
            }
          }
          if (lfs.findFileByPath(outputPath) != null) {
            final File file=new File(outputPath);
            toDelete.add(new Trinity<File,String,Boolean>(file,classNamePair.getClassName(),Boolean.valueOf(sourcePresent)));
            if (LOG.isDebugEnabled() || ourDebugMode) {
              final String message="Found file to delete: " + file;
              LOG.debug(message);
              if (ourDebugMode) {
                System.out.println(message);
              }
            }
          }
 else {
            if (LOG.isDebugEnabled() || ourDebugMode) {
              final String message="Found zombie entry marked for deletion: " + outputPath;
              LOG.debug(message);
              if (ourDebugMode) {
                System.out.println(message);
              }
            }
            zombieEntries.add(outputPath);
          }
        }
        for (        String path : zombieEntries) {
          unmarkOutputPathForDeletion(path);
        }
      }
    }
  }
}
