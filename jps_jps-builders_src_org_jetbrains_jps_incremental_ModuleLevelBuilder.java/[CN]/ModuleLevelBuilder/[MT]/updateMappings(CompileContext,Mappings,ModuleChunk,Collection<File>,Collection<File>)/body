{
  try {
    boolean additionalPassRequired=false;
    final Set<String> removedPaths=getRemovedPaths(context);
    final Mappings globalMappings=context.getDataManager().getMappings();
synchronized (globalMappings) {
      if (!context.isProjectRebuild() && context.shouldDifferentiate(chunk,context.isCompilingTests())) {
        final Set<File> allCompiledFiles=getAllCompiledFilesContainer(context);
        final Set<File> allAffectedFiles=getAllAffectedFilesContainer(context);
        allAffectedFiles.addAll(filesToCompile);
        allCompiledFiles.addAll(successfullyCompiled);
        allAffectedFiles.removeAll(successfullyCompiled);
        final HashSet<File> affectedBeforeDif=new HashSet<File>(allAffectedFiles);
        final boolean incremental=globalMappings.differentiate(delta,removedPaths,successfullyCompiled,allCompiledFiles,allAffectedFiles);
        if (LOG.isDebugEnabled()) {
          LOG.debug("Differentiate Results:");
          LOG.debug("   Compiled Files:");
          for (          final File c : allCompiledFiles) {
            LOG.debug("      " + c.getAbsolutePath());
          }
          LOG.debug("   Affected Files:");
          for (          final File c : allAffectedFiles) {
            LOG.debug("      " + c.getAbsolutePath());
          }
          LOG.debug("End Of Differentiate Results.");
        }
        if (incremental) {
          final Set<File> newlyAffectedFiles=new HashSet<File>(allAffectedFiles);
          newlyAffectedFiles.removeAll(affectedBeforeDif);
          newlyAffectedFiles.removeAll(allCompiledFiles);
          if (!newlyAffectedFiles.isEmpty()) {
            for (            File file : newlyAffectedFiles) {
              context.markDirty(file);
            }
            additionalPassRequired=context.isMake() && chunkContainsAffectedFiles(context,chunk,newlyAffectedFiles);
          }
        }
 else {
          additionalPassRequired=context.isMake();
          context.markDirtyRecursively(chunk);
        }
      }
      globalMappings.integrate(delta,successfullyCompiled,removedPaths);
    }
    return additionalPassRequired;
  }
 catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException) {
      throw ((IOException)cause);
    }
    throw e;
  }
}
