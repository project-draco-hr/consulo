{
  if (context.errorsDetected()) {
    return false;
  }
  try {
    boolean additionalPassRequired=false;
    final Set<String> removedPaths=getRemovedPaths(context);
    final Mappings globalMappings=context.getDataManager().getMappings();
    if (!context.isProjectRebuild() && context.shouldDifferentiate(chunk,context.isCompilingTests())) {
      context.processMessage(new ProgressMessage("Checking dependencies"));
      final Set<File> allCompiledFiles=getAllCompiledFilesContainer(context);
      final Set<File> allAffectedFiles=getAllAffectedFilesContainer(context);
      allAffectedFiles.addAll(filesToCompile);
      allCompiledFiles.addAll(successfullyCompiled);
      allAffectedFiles.removeAll(successfullyCompiled);
      final HashSet<File> affectedBeforeDif=new HashSet<File>(allAffectedFiles);
      final ModulesBasedFileFilter moduleBasedFilter=new ModulesBasedFileFilter(context,chunk);
      final boolean incremental=globalMappings.differentiate(delta,removedPaths,filesToCompile,allCompiledFiles,allAffectedFiles,moduleBasedFilter);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Differentiate Results:");
        LOG.debug("   Compiled Files:");
        for (        final File c : allCompiledFiles) {
          LOG.debug("      " + c.getAbsolutePath());
        }
        LOG.debug("   Affected Files:");
        for (        final File c : allAffectedFiles) {
          LOG.debug("      " + c.getAbsolutePath());
        }
        LOG.debug("End Of Differentiate Results.");
      }
      if (incremental) {
        final Set<File> newlyAffectedFiles=new HashSet<File>(allAffectedFiles);
        newlyAffectedFiles.removeAll(affectedBeforeDif);
        newlyAffectedFiles.removeAll(allCompiledFiles);
        final String infoMessage="Dependency analysis found " + newlyAffectedFiles.size() + " affected files";
        LOG.info(infoMessage);
        context.processMessage(new ProgressMessage(infoMessage));
        if (!newlyAffectedFiles.isEmpty()) {
          if (LOG.isDebugEnabled()) {
            final List<Pair<File,Module>> wrongFiles=checkAffectedFilesInCorrectModules(context,newlyAffectedFiles,moduleBasedFilter);
            if (!wrongFiles.isEmpty()) {
              LOG.debug("Wrong affected files for module chunk " + chunk.getName() + ": ");
              for (              Pair<File,Module> pair : wrongFiles) {
                final String name=pair.second != null ? pair.second.getName() : "null";
                LOG.debug("\t[" + name + "] "+ pair.first.getPath());
              }
            }
          }
          for (          File file : newlyAffectedFiles) {
            context.markDirtyIfNotDeleted(file);
          }
          additionalPassRequired=context.isMake() && chunkContainsAffectedFiles(context,chunk,newlyAffectedFiles);
        }
      }
 else {
        context.processMessage(new ProgressMessage("Marking " + chunk.getName() + " and dependants for recompilation"));
        additionalPassRequired=context.isMake();
        context.markDirtyRecursively(chunk);
      }
    }
    context.processMessage(new ProgressMessage("Updating dependency information"));
    globalMappings.integrate(delta,successfullyCompiled,removedPaths);
    return additionalPassRequired;
  }
 catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException) {
      throw ((IOException)cause);
    }
    throw e;
  }
 finally {
    context.processMessage(new ProgressMessage(""));
  }
}
