{
  final PsiClass[] superTypes=aClass.getSupers();
  final int startMethodIndex=allMethods.size();
  for (int i=0; i < superTypes.length; i++) {
    PsiClass superType=superTypes[i];
    final PsiMethod superMethod;
    if (method instanceof PsiMethod) {
      superMethod=MethodSignatureUtil.findMethodBySignature(superType,(PsiMethod)method,false);
    }
 else {
      superMethod=MethodSignatureUtil.findMethodBySignature(superType,(MethodSignature)method,false);
    }
    if (superMethod == null) {
      getMethodHierarchy(method,superType,map,allMethods);
    }
 else {
      if (PsiUtil.isAccessible(superMethod,aClass,aClass)) {
        allMethods.add(superMethod);
      }
    }
  }
  final int endMethodIndex=allMethods.size();
  map.put(method,new ArrayList(allMethods.subList(startMethodIndex,endMethodIndex)));
  for (int i=startMethodIndex; i < endMethodIndex; i++) {
    final PsiMethod superMethod=(PsiMethod)allMethods.get(i);
    if (map.get(superMethod) == null) {
      getMethodHierarchy(superMethod,superMethod.getContainingClass(),map,allMethods);
    }
  }
}
