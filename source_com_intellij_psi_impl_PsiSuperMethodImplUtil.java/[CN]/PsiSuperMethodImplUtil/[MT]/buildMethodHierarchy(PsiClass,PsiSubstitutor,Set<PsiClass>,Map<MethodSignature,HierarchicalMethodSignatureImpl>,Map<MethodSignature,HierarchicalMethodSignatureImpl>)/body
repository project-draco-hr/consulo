{
  if (visited.contains(aClass))   return;
  visited.add(aClass);
  final PsiMethod[] methods=aClass.getMethods();
  Map<MethodSignature,HierarchicalMethodSignatureImpl> toRestore=new THashMap<MethodSignature,HierarchicalMethodSignatureImpl>();
  for (  PsiMethod method : methods) {
    final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,substitutor);
    final HierarchicalMethodSignatureImpl signatureHierarchical=new HierarchicalMethodSignatureImpl(signature);
    final HierarchicalMethodSignatureImpl existing=signatures.get(signature);
    if (existing != null && !existing.getMethod().isConstructor() && !aClass.equals(existing.getMethod().getContainingClass())) {
      existing.addSuperSignature(signatureHierarchical);
      toRestore.put(signature,existing);
    }
 else {
      result.put(signature,signatureHierarchical);
    }
    signatures.put(signature,signatureHierarchical);
  }
  final PsiClassType[] superTypes=aClass.getSuperTypes();
  for (  final PsiClassType superType : superTypes) {
    final PsiClassType.ClassResolveResult superTypeResolveResult=superType.resolveGenerics();
    PsiClass superClass=superTypeResolveResult.getElement();
    if (superClass == null)     continue;
    PsiSubstitutor finalSubstitutor=PsiClassImplUtil.obtainFinalSubstitutor(superClass,superTypeResolveResult.getSubstitutor(),aClass,substitutor);
    buildMethodHierarchy(superClass,finalSubstitutor,visited,signatures,result);
  }
  signatures.putAll(toRestore);
}
