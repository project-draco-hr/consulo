{
  Map<MethodSignatureBackedByPsiMethod,HierarchicalMethodSignatureImpl> result=new LinkedHashMap<MethodSignatureBackedByPsiMethod,HierarchicalMethodSignatureImpl>();
  final Map<MethodSignature,List<PsiMethod>> sameParameterErasureMethods=new THashMap<MethodSignature,List<PsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  Map<MethodSignatureBackedByPsiMethod,HierarchicalMethodSignatureImpl> map=new THashMap<MethodSignatureBackedByPsiMethod,HierarchicalMethodSignatureImpl>(new TObjectHashingStrategy<MethodSignatureBackedByPsiMethod>(){
    public int computeHashCode(    MethodSignatureBackedByPsiMethod object){
      return MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.computeHashCode(object);
    }
    public boolean equals(    MethodSignatureBackedByPsiMethod o1,    MethodSignatureBackedByPsiMethod o2){
      if (!MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.equals(o1,o2))       return false;
      List<PsiMethod> list=sameParameterErasureMethods.get(o1);
      boolean toCheckReturnType=list != null && list.size() > 1;
      if (toCheckReturnType) {
        PsiType returnType1=o1.getMethod().getReturnType();
        PsiType returnType2=o2.getMethod().getReturnType();
        if (returnType1 == null && returnType2 == null)         return true;
        if (returnType1 == null || returnType2 == null)         return false;
        final PsiType type1=returnType1 instanceof PsiPrimitiveType ? returnType1 : PsiType.VOID;
        final PsiType type2=returnType2 instanceof PsiPrimitiveType ? returnType2 : PsiType.VOID;
        return type1.equals(type2);
      }
 else {
        return true;
      }
    }
  }
);
  for (  PsiMethod method : aClass.getMethods()) {
    if (!includePrivates && method.hasModifierProperty(PsiModifier.PRIVATE))     continue;
    final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,substitutor);
    HierarchicalMethodSignatureImpl newH=new HierarchicalMethodSignatureImpl(signature);
    List<PsiMethod> list=sameParameterErasureMethods.get(signature);
    if (list == null) {
      list=new SmartList<PsiMethod>();
      sameParameterErasureMethods.put(signature,list);
    }
    list.add(method);
    result.put(signature,newH);
    map.put(signature,newH);
  }
  for (  PsiClassType superType : aClass.getSuperTypes()) {
    PsiClassType.ClassResolveResult superTypeResolveResult=superType.resolveGenerics();
    PsiClass superClass=superTypeResolveResult.getElement();
    if (superClass == null)     continue;
    PsiSubstitutor finalSubstitutor=obtainFinalSubstitutor(superClass,superTypeResolveResult.getSubstitutor(),aClass,substitutor);
    if (!visited.add(superClass))     continue;
    Map<MethodSignatureBackedByPsiMethod,HierarchicalMethodSignatureImpl> superResult=newbuildMethodHierarchy(superClass,finalSubstitutor,false,visited);
    visited.remove(superClass);
    for (    MethodSignatureBackedByPsiMethod superSignature : superResult.keySet()) {
      HierarchicalMethodSignatureImpl hierarchicalMethodSignature=superResult.get(superSignature);
      if (!PsiUtil.isAccessible(hierarchicalMethodSignature.getMethod(),aClass,aClass))       continue;
      HierarchicalMethodSignatureImpl existing=map.get(superSignature);
      if (existing == null) {
        map.put(superSignature,copy(hierarchicalMethodSignature));
      }
 else       if (isSuperMethod(aClass,existing,hierarchicalMethodSignature)) {
        mergeSupers(existing,hierarchicalMethodSignature);
      }
 else       if (!result.containsKey(superSignature)) {
        result.put(superSignature,hierarchicalMethodSignature);
      }
    }
  }
  for (  MethodSignatureBackedByPsiMethod methodSignature : map.keySet()) {
    HierarchicalMethodSignatureImpl hierarchicalMethodSignature=map.get(methodSignature);
    if (result.get(methodSignature) == null && PsiUtil.isAccessible(hierarchicalMethodSignature.getMethod(),aClass,aClass)) {
      result.put(methodSignature,hierarchicalMethodSignature);
    }
  }
  return result;
}
