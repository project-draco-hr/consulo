{
  if (isInterrupted())   return new LoadAlgorithm.Result<CommitHashPlusParents>(true,0,myRepeatingLoadConsumer.getLast());
  myRepeatingLoadConsumer.reset();
  int count=340;
  boolean shouldFull=!myHaveStructureFilter;
  if (LoadAlgorithm.LoadType.TEST.equals(loadType)) {
    count=ourFirstLoadCount;
  }
 else   if (LoadAlgorithm.LoadType.SHORT.equals(loadType) || LoadAlgorithm.LoadType.SHORT_START.equals(loadType)) {
    shouldFull=false;
  }
 else   if (LoadAlgorithm.LoadType.FULL_PREVIEW.equals(loadType)) {
    count=ourPreload;
  }
  long start;
  boolean isOver=false;
  while (true) {
    start=System.currentTimeMillis();
    step(count,shouldFull,continuation);
    if (isInterrupted())     return new LoadAlgorithm.Result<CommitHashPlusParents>(true,0,myRepeatingLoadConsumer.getLast());
    final List<AbstractHash> lastParents=myRepeatingLoadConsumer.getLast() == null ? null : myRepeatingLoadConsumer.getLast().getParents();
    isOver=lastParents == null || lastParents.isEmpty() || (myRepeatingLoadConsumer.getTotalRecordsInPack() < count);
    if (isOver) {
      myId.finished();
      myStepType=StepType.FINISHED;
      break;
    }
    if (myRepeatingLoadConsumer.sincePoint() == 0) {
      count*=2;
      myRepeatingLoadConsumer.reset();
    }
 else {
      break;
    }
  }
  final long end=System.currentTimeMillis();
  if (!isOver && (myRepeatingLoadConsumer.getLast() != null)) {
    myId.registerTime(myRepeatingLoadConsumer.getLast().getTime());
  }
  return new LoadAlgorithm.Result<CommitHashPlusParents>(isOver,end - start,myRepeatingLoadConsumer.getLast());
}
