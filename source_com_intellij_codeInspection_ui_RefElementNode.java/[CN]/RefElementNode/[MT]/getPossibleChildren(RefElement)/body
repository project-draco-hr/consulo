{
  final TreeNode[] pathToRoot=getPath();
  final HashSet<RefElement> newChildren=new HashSet<RefElement>();
  if (!refElement.isValid())   return newChildren;
  Iterator<RefElement> outReferences=refElement.getOutReferences().iterator();
  while (outReferences.hasNext()) {
    RefElement refCallee=outReferences.next();
    if (refCallee.isSuspicious()) {
      if (notInPath(pathToRoot,refCallee))       newChildren.add(refCallee);
    }
  }
  if (refElement instanceof RefMethod) {
    RefMethod refMethod=(RefMethod)refElement;
    if (!refMethod.isStatic() && !refMethod.isConstructor() && !refMethod.getOwnerClass().isAnonymous()) {
      for (Iterator<RefMethod> iterator=refMethod.getDerivedMethods().iterator(); iterator.hasNext(); ) {
        RefMethod refDerived=iterator.next();
        if (refDerived.isSuspicious()) {
          if (notInPath(pathToRoot,refDerived))           newChildren.add(refDerived);
        }
      }
    }
  }
 else   if (refElement instanceof RefClass) {
    RefClass refClass=(RefClass)refElement;
    for (Iterator<RefClass> iterator=refClass.getSubClasses().iterator(); iterator.hasNext(); ) {
      RefClass subClass=iterator.next();
      if ((subClass.isInterface() || subClass.isAbstract()) && subClass.isSuspicious()) {
        if (notInPath(pathToRoot,subClass))         newChildren.add(subClass);
      }
    }
    if (refClass.getDefaultConstructor() != null && refClass.getDefaultConstructor() instanceof RefImplicitConstructor) {
      Set<RefElement> fromConstructor=getPossibleChildren(refClass.getDefaultConstructor());
      newChildren.addAll(fromConstructor);
    }
  }
  return newChildren;
}
