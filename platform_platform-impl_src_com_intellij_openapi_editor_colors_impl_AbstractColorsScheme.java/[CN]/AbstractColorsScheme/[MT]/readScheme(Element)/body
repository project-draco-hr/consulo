{
  myDeprecatedBackgroundColor=null;
  if (SCHEME_ELEMENT.equals(node.getName())) {
    setName(node.getAttributeValue(NAME_ATTR));
    int readVersion=Integer.parseInt(node.getAttributeValue(VERSION_ATTR,"0"));
    if (readVersion > CURR_VERSION)     throw new InvalidDataException("Unsupported color scheme version: " + readVersion);
    myVersion=readVersion;
    String isDefaultScheme=node.getAttributeValue(DEFAULT_SCHEME_ATTR);
    if (isDefaultScheme == null || !Boolean.parseBoolean(isDefaultScheme)) {
      String parentSchemeName=node.getAttributeValue(PARENT_SCHEME_ATTR);
      if (parentSchemeName == null)       parentSchemeName=DEFAULT_SCHEME_NAME;
      myParentScheme=myDefaultColorSchemesManager.getScheme(parentSchemeName);
    }
    for (    final Object o : node.getChildren()) {
      Element childNode=(Element)o;
      String childName=childNode.getName();
      if (OPTION_ELEMENT.equals(childName)) {
        readSettings(childNode);
      }
 else       if (EDITOR_FONT.equals(childName)) {
        readFontSettings(childNode,myFontPreferences);
      }
 else       if (CONSOLE_FONT.equals(childName)) {
        readFontSettings(childNode,myConsoleFontPreferences);
      }
 else       if (COLORS_ELEMENT.equals(childName)) {
        readColors(childNode);
      }
 else       if (ATTRIBUTES_ELEMENT.equals(childName)) {
        readAttributes(childNode);
      }
    }
    if (myDeprecatedBackgroundColor != null) {
      TextAttributes textAttributes=myAttributesMap.get(HighlighterColors.TEXT);
      if (textAttributes == null) {
        textAttributes=new TextAttributes(Color.black,myDeprecatedBackgroundColor,null,EffectType.BOXED,Font.PLAIN);
        myAttributesMap.put(HighlighterColors.TEXT,textAttributes);
      }
 else {
        textAttributes.setBackgroundColor(myDeprecatedBackgroundColor);
      }
    }
    if (myConsoleFontPreferences.getFontFamilies().isEmpty()) {
      myFontPreferences.copyTo(myConsoleFontPreferences);
    }
    initFonts();
  }
}
