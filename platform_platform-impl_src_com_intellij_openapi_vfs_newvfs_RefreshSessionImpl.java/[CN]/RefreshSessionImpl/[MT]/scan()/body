{
  List<VirtualFile> workQueue=myWorkQueue;
  myWorkQueue=new ArrayList<VirtualFile>();
  boolean haveEventsToFire=myFinishRunnable != null || !myEvents.isEmpty();
  if (!workQueue.isEmpty()) {
    final LocalFileSystem fileSystem=LocalFileSystem.getInstance();
    final FileWatcher watcher;
    if (fileSystem instanceof LocalFileSystemImpl) {
      LocalFileSystemImpl fs=(LocalFileSystemImpl)fileSystem;
      fs.markSuspiciousFilesDirty(workQueue);
      watcher=fs.getFileWatcher();
    }
 else {
      watcher=null;
    }
    long t=0;
    if (LOG.isDebugEnabled()) {
      LOG.debug("scanning " + workQueue);
      t=System.currentTimeMillis();
    }
    for (    VirtualFile file : workQueue) {
      if (myCancelled)       break;
      NewVirtualFile nvf=(NewVirtualFile)file;
      if (!myIsRecursive && (!myIsAsync || (watcher != null && !watcher.isWatched(nvf)))) {
        nvf.markDirty();
      }
      RefreshWorker worker=myWorker=new RefreshWorker(nvf,myIsRecursive);
      worker.scan();
      List<VFileEvent> events=worker.getEvents();
      if (myEvents.addAll(events)) {
        haveEventsToFire=true;
      }
    }
    if (t != 0) {
      t=System.currentTimeMillis() - t;
      LOG.debug((myCancelled ? "cancelled, " : "done, ") + t + " ms, events "+ myEvents);
    }
  }
  myWorker=null;
  iHaveEventsToFire=haveEventsToFire;
}
