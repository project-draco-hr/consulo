{
  List<VirtualFile> workQueue=myWorkQueue;
  myWorkQueue=new ArrayList<VirtualFile>();
  boolean haveEventsToFire=myFinishRunnable != null || !myEvents.isEmpty();
  if (!workQueue.isEmpty()) {
    LocalFileSystemImpl fs=(LocalFileSystemImpl)LocalFileSystem.getInstance();
    fs.markSuspiciousFilesDirty(workQueue);
    FileWatcher watcher=fs.getFileWatcher();
    for (    VirtualFile file : workQueue) {
      if (myCancelled)       break;
      NewVirtualFile nvf=(NewVirtualFile)file;
      if (!myIsRecursive && (!myIsAsync || !watcher.isWatched(nvf))) {
        nvf.markDirty();
      }
      RefreshWorker worker=myWorker=new RefreshWorker(file,myIsRecursive);
      long t=LOG.isDebugEnabled() ? System.currentTimeMillis() : 0;
      worker.scan();
      List<VFileEvent> events=worker.getEvents();
      if (t != 0) {
        t=System.currentTimeMillis() - t;
        LOG.debug(file + " scanned in " + t+ " ms, events: "+ events);
      }
      myEvents.addAll(events);
      if (!events.isEmpty())       haveEventsToFire=true;
    }
  }
  myWorker=null;
  iHaveEventsToFire=haveEventsToFire;
}
