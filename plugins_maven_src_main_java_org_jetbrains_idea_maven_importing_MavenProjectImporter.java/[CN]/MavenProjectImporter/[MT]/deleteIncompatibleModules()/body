{
  final Pair<List<Pair<MavenProject,Module>>,List<Pair<MavenProject,Module>>> incompatible=collectIncompatibleModulesWithProjects();
  final List<Pair<MavenProject,Module>> incompatibleMavenized=incompatible.first;
  final List<Pair<MavenProject,Module>> incompatibleNotMavenized=incompatible.second;
  if (incompatibleMavenized.isEmpty() && incompatibleNotMavenized.isEmpty())   return false;
  boolean changed=false;
  for (  Pair<MavenProject,Module> each : incompatibleMavenized) {
    myFileToModuleMapping.remove(each.first.getFile());
    myModuleModel.disposeModule(each.second);
    changed|=true;
  }
  if (incompatibleNotMavenized.isEmpty())   return changed;
  final int[] result=new int[1];
  MavenUtil.invokeAndWait(myProject,myModelsProvider.getModalityStateForQuestionDialogs(),new Runnable(){
    public void run(){
      String message=ProjectBundle.message("maven.import.incompatible.modules",incompatibleNotMavenized.size(),formatProjectsWithModules(incompatibleNotMavenized));
      String[] options={ProjectBundle.message("maven.import.incompatible.modules.recreate"),ProjectBundle.message("maven.import.incompatible.modules.ignore")};
      result[0]=Messages.showOkCancelDialog(myProject,message,ProjectBundle.message("maven.project.import.title"),options[0],options[1],Messages.getQuestionIcon());
    }
  }
);
  if (result[0] == 0) {
    for (    Pair<MavenProject,Module> each : incompatibleNotMavenized) {
      myFileToModuleMapping.remove(each.first.getFile());
      myModuleModel.disposeModule(each.second);
    }
    changed|=true;
  }
 else {
    myProjectsTree.setIgnoredState(MavenUtil.collectFirsts(incompatibleNotMavenized),true,true);
    changed|=false;
  }
  return changed;
}
