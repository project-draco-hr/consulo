{
  while (true) {
    if (myProject.isDisposed() || myInnerIndicator.isCanceled()) {
      return;
    }
    try {
      final FileContent fileContent=myQueue.take(myInnerIndicator);
      if (fileContent == null) {
        myFinished.set(Boolean.TRUE);
        return;
      }
      final Runnable action=new Runnable(){
        public void run(){
          myInnerIndicator.checkCanceled();
          if (!myProject.isDisposed()) {
            final VirtualFile file=fileContent.getVirtualFile();
            myProgressUpdater.consume(file);
            mySession.processFile(fileContent);
          }
        }
      }
;
      try {
        ProgressManager.getInstance().runProcess(new Runnable(){
          @Override public void run(){
            if (myProcessInReadAction) {
              myApplication.runReadAction(action);
            }
 else {
              action.run();
            }
          }
        }
,new DelegatingProgressIndicator(myInnerIndicator){
          boolean myStarted;
          @Override public void start(){
            myStarted=true;
          }
          @Override public void stop(){
            myStarted=false;
          }
          @Override public boolean isRunning(){
            return myStarted;
          }
        }
);
      }
 catch (      ProcessCanceledException e) {
        myQueue.pushback(fileContent);
        return;
      }
 finally {
        myQueue.release(fileContent);
      }
    }
 catch (    ProcessCanceledException e) {
      return;
    }
  }
}
