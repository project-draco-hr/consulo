{
  while (true) {
    if (myProject.isDisposed() || myInnerIndicator.isCanceled()) {
      return;
    }
    try {
      final FileContent fileContent=myQueue.take(myInnerIndicator);
      if (fileContent == null) {
        myFinished.set(true);
        return;
      }
      final Runnable action=new Runnable(){
        @Override public void run(){
          myInnerIndicator.checkCanceled();
          if (!myProject.isDisposed()) {
            final VirtualFile file=fileContent.getVirtualFile();
            try {
              myProgressUpdater.consume(file);
              if (!file.isDirectory() && !Boolean.TRUE.equals(file.getUserData(FAILED_TO_INDEX))) {
                myProcessor.consume(fileContent);
              }
            }
 catch (            ProcessCanceledException e) {
              throw e;
            }
catch (            Throwable e) {
              LOG.error("Error while indexing " + file.getPresentableUrl() + "\n"+ "To reindex this file IDEA has to be restarted",e);
              file.putUserData(FAILED_TO_INDEX,Boolean.TRUE);
            }
          }
        }
      }
;
      try {
        ProgressManager.getInstance().runProcess(new Runnable(){
          @Override public void run(){
            if (myProcessInReadAction) {
              if (!ApplicationManagerEx.getApplicationEx().tryRunReadAction(action)) {
                throw new ProcessCanceledException();
              }
            }
 else {
              action.run();
            }
          }
        }
,ProgressWrapper.wrap(myInnerIndicator));
      }
 catch (      ProcessCanceledException e) {
        myQueue.pushBack(fileContent);
        return;
      }
 finally {
        myQueue.release(fileContent);
      }
    }
 catch (    ProcessCanceledException e) {
      return;
    }
  }
}
