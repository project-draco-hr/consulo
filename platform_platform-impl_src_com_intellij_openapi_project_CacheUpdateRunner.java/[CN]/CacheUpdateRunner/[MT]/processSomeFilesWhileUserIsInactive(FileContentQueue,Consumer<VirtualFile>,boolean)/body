{
  final ProgressIndicatorBase innerIndicator=new ProgressIndicatorBase();
  final ApplicationAdapter canceller=new ApplicationAdapter(){
    @Override public void beforeWriteActionStart(    Object action){
      innerIndicator.cancel();
    }
  }
;
  final Application application=ApplicationManager.getApplication();
  application.addApplicationListener(canceller);
  final Ref<Boolean> isFinished=new Ref<Boolean>(Boolean.FALSE);
  try {
    int threadsCount=Registry.intValue("caches.indexerThreadsCount");
    if (threadsCount == -1) {
      threadsCount=Math.min(Runtime.getRuntime().availableProcessors(),4);
    }
    if (threadsCount == 1) {
      Runnable process=new MyRunnable(innerIndicator,queue,isFinished,progressUpdater,processInReadAction,application);
      ProgressManager.getInstance().runProcess(process,innerIndicator);
    }
 else {
      final Job<Object> job=JobScheduler.getInstance().createJob("Indexing",Thread.NORM_PRIORITY);
      final Ref[] finishedRefs=new Ref[threadsCount];
      for (int i=0; i < threadsCount; i++) {
        final Ref<Boolean> ref=new Ref<Boolean>(Boolean.FALSE);
        finishedRefs[i]=ref;
        Runnable process=new MyRunnable(innerIndicator,queue,ref,progressUpdater,processInReadAction,application);
        job.addTask(process);
      }
      try {
        job.scheduleAndWaitForResults();
        boolean allFinished=true;
        for (        Ref ref : finishedRefs) {
          if (!(Boolean)ref.get()) {
            allFinished=false;
            break;
          }
        }
        isFinished.set(allFinished);
      }
 catch (      Throwable throwable) {
        LOG.error(throwable);
      }
    }
  }
  finally {
    application.removeApplicationListener(canceller);
  }
  return isFinished.get();
}
