{
  indicator.checkCanceled();
  final FileContentQueue queue=new FileContentQueue(files,indicator);
  final double total=files.size();
  queue.startLoading();
  Consumer<VirtualFile> progressUpdater=new Consumer<VirtualFile>(){
    final Set<VirtualFile> processed=new THashSet<VirtualFile>();
    private boolean fileNameWasShown;
    @Override public void consume(    VirtualFile virtualFile){
      indicator.checkCanceled();
synchronized (processed) {
        boolean added=processed.add(virtualFile);
        indicator.setFraction(processed.size() / total);
        if (!added || (virtualFile.isValid() && virtualFile.getLength() > FILE_SIZE_TO_SHOW_THRESHOLD)) {
          indicator.setText2(virtualFile.getPresentableUrl());
          fileNameWasShown=true;
        }
 else         if (fileNameWasShown) {
          indicator.setText2("");
          fileNameWasShown=false;
        }
      }
    }
  }
;
  while (!project.isDisposed()) {
    indicator.checkCanceled();
    if (processSomeFilesWhileUserIsInactive(queue,progressUpdater,processInReadAction,project,processor)) {
      break;
    }
  }
  if (project.isDisposed()) {
    indicator.cancel();
    indicator.checkCanceled();
  }
}
