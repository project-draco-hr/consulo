{
  List<TextChangeImpl> changes=myDeferredChangesStorage.getChanges();
  if (changes.isEmpty()) {
    return;
  }
  lock.lock();
  try {
    char[] beforeMerge=null;
    if (myDebug) {
      beforeMerge=new char[myArray.length];
      System.arraycopy(myArray,0,beforeMerge,0,myArray.length);
    }
    BulkChangesMerger changesMerger=BulkChangesMerger.INSTANCE;
    final boolean inPlace;
    if (myArray.length < length()) {
      myArray=changesMerger.mergeToCharArray(myArray,myCount,changes);
      inPlace=false;
    }
 else {
      changesMerger.mergeInPlace(myArray,myCount,changes);
      inPlace=true;
    }
    myCount+=myDeferredShift;
    myDeferredShift=0;
    myDeferredChangesStorage.clear();
    myHasDeferredChanges=false;
    myDeferredChangeMode=false;
    myStringRef=null;
    if (myDebug) {
      for (int i=0, max=length(); i < max; i++) {
        if (myArray[i] != myDebugArray.myArray[i]) {
          dumpDebugInfo("flushDeferredChanged(). Index " + i + ", expected: '"+ myDebugArray.myArray[i]+ "', actual '"+ myArray[i]+ "'. Text before merge: '"+ Arrays.toString(beforeMerge)+ "', merge inplace: "+ inPlace);
          break;
        }
      }
    }
  }
  finally {
    lock.unlock();
  }
  assertConsistency();
}
