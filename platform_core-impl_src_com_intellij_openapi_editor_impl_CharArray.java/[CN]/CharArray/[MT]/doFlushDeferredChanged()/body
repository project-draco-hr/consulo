{
  TextChangesStorage storage=myDeferredChangesStorage.get();
  List<TextChangeImpl> changes=storage.getChanges();
  if (changes.isEmpty()) {
    return;
  }
  char[] beforeMerge=null;
  final boolean inPlace;
  if (myDebugDeferredProcessing) {
    beforeMerge=new char[myArray.length];
    System.arraycopy(myArray,0,beforeMerge,0,myArray.length);
  }
  BulkChangesMerger changesMerger=BulkChangesMerger.INSTANCE;
  if (myArray.length < length()) {
    myArray=changesMerger.mergeToCharArray(myArray,myCount,changes);
    inPlace=false;
  }
 else {
    changesMerger.mergeInPlace(myArray,myCount,changes);
    inPlace=true;
  }
  if (myDebugDeferredProcessing) {
    for (int i=0, max=length(); i < max; i++) {
      if (myArray[i] != myDebugArray.myArray[i]) {
        dumpDebugInfo(String.format("flushDeferredChanged(). Index %d, expected: '%c', actual '%c'. Text before merge: '%s', merge inplace: %b",i,myDebugArray.myArray[i],myArray[i],Arrays.toString(beforeMerge),inPlace));
        break;
      }
    }
  }
  myCount+=myDeferredShift;
  myDeferredShift=0;
  storage.clear();
  myDeferredChangeMode=false;
}
