def run_wsgi(self, req):
    self.refresh(req)
    req.url = req.env['SCRIPT_NAME']
    if (not req.url.endswith('/')):
        req.url += '/'
    if ('REPO_NAME' in req.env):
        req.url += (req.env['REPO_NAME'] + '/')
    if ('PATH_INFO' in req.env):
        parts = req.env['PATH_INFO'].strip('/').split('/')
        repo_parts = req.env.get('REPO_NAME', '').split('/')
        if (parts[:len(repo_parts)] == repo_parts):
            parts = parts[len(repo_parts):]
        query = '/'.join(parts)
    else:
        query = req.env['QUERY_STRING'].split('&', 1)[0]
        query = query.split(';', 1)[0]
    cmd = req.form.get('cmd', [''])[0]
    if (cmd and (cmd in protocol.__all__)):
        if query:
            raise ErrorResponse(HTTP_NOT_FOUND)
        try:
            if (cmd in perms):
                try:
                    self.check_perm(req, perms[cmd])
                except ErrorResponse as inst:
                    if (cmd == 'unbundle'):
                        req.drain()
                    raise
            method = getattr(protocol, cmd)
            return method(self.repo, req)
        except ErrorResponse as inst:
            req.respond(inst, protocol.HGTYPE)
            if (not inst.message):
                return []
            return (('0\n%s\n' % inst.message),)
    args = query.split('/', 2)
    if (('cmd' not in req.form) and args and args[0]):
        cmd = args.pop(0)
        style = cmd.rfind('-')
        if (style != (-1)):
            req.form['style'] = [cmd[:style]]
            cmd = cmd[(style + 1):]
        if hasattr(webcommands, cmd):
            req.form['cmd'] = [cmd]
        else:
            cmd = ''
        if (cmd == 'static'):
            req.form['file'] = ['/'.join(args)]
        else:
            if (args and args[0]):
                node = args.pop(0)
                req.form['node'] = [node]
            if args:
                req.form['file'] = args
        ua = req.env.get('HTTP_USER_AGENT', '')
        if ((cmd == 'rev') and ('mercurial' in ua)):
            req.form['style'] = ['raw']
        if (cmd == 'archive'):
            fn = req.form['node'][0]
            for (type_, spec) in self.archive_specs.iteritems():
                ext = spec[2]
                if fn.endswith(ext):
                    req.form['node'] = [fn[:(- len(ext))]]
                    req.form['type'] = [type_]
    try:
        tmpl = self.templater(req)
        ctype = tmpl('mimetype', encoding=encoding.encoding)
        ctype = templater.stringify(ctype)
        if (cmd != 'static'):
            self.check_perm(req, None)
        if (cmd == ''):
            req.form['cmd'] = [tmpl.cache['default']]
            cmd = req.form['cmd'][0]
        if (cmd not in webcommands.__all__):
            msg = ('no such method: %s' % cmd)
            raise ErrorResponse(HTTP_BAD_REQUEST, msg)
        elif ((cmd == 'file') and ('raw' in req.form.get('style', []))):
            self.ctype = ctype
            content = webcommands.rawfile(self, req, tmpl)
        else:
            content = getattr(webcommands, cmd)(self, req, tmpl)
            req.respond(HTTP_OK, ctype)
        return content
    except error.LookupError as err:
        req.respond(HTTP_NOT_FOUND, ctype)
        msg = str(err)
        if ('manifest' not in msg):
            msg = ('revision not found: %s' % err.name)
        return tmpl('error', error=msg)
    except (error.RepoError, error.RevlogError) as inst:
        req.respond(HTTP_SERVER_ERROR, ctype)
        return tmpl('error', error=str(inst))
    except ErrorResponse as inst:
        req.respond(inst, ctype)
        return tmpl('error', error=inst.message)
