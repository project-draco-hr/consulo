{
  if (!mySucceeded)   return;
  if (foundByName.isEmpty()) {
    mySucceeded=false;
    return;
  }
  final List<FilePatchInProgress> results=new LinkedList<FilePatchInProgress>();
  final Set<VirtualFile> keysToRemove=new HashSet<VirtualFile>(myVariants.keySet());
  for (  VirtualFile file : foundByName) {
    final FilePatchInProgress filePatchInProgress=processMatch(patch,file);
    if (filePatchInProgress != null) {
      final VirtualFile base=filePatchInProgress.getBase();
      if (myCheckExistingVariants && (!myVariants.containsKey(base)))       continue;
      keysToRemove.remove(base);
      results.add(filePatchInProgress);
    }
  }
  if (myCheckExistingVariants) {
    for (    VirtualFile file : keysToRemove) {
      myVariants.remove(file);
    }
    if (myVariants.isEmpty()) {
      mySucceeded=false;
      return;
    }
  }
  final Collection<VirtualFile> exactMatch=filterVariants(patch,foundByName);
  for (  FilePatchInProgress filePatchInProgress : results) {
    filePatchInProgress.setAutoBases(exactMatch);
    myVariants.putValue(filePatchInProgress.getBase(),filePatchInProgress);
  }
  myCheckExistingVariants=true;
}
