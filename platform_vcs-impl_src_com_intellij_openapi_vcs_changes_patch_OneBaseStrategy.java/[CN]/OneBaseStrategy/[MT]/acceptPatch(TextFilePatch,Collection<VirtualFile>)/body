{
  if (!mySucceeded)   return;
  if (foundByName.isEmpty()) {
    mySucceeded=false;
    return;
  }
  final List<TextFilePatchInProgress> results=new LinkedList<>();
  final Set<VirtualFile> keysToRemove=new HashSet<>(myVariants.keySet());
  for (  VirtualFile file : foundByName) {
    final TextFilePatchInProgress textFilePatchInProgress=processMatch(patch,file);
    if (textFilePatchInProgress != null) {
      final VirtualFile base=textFilePatchInProgress.getBase();
      if (myCheckExistingVariants && (!myVariants.containsKey(base)))       continue;
      keysToRemove.remove(base);
      results.add(textFilePatchInProgress);
    }
  }
  if (myCheckExistingVariants) {
    for (    VirtualFile file : keysToRemove) {
      myVariants.remove(file);
    }
    if (myVariants.isEmpty()) {
      mySucceeded=false;
      return;
    }
  }
  final Collection<VirtualFile> exactMatch=filterVariants(patch,foundByName);
  for (  TextFilePatchInProgress textFilePatchInProgress : results) {
    textFilePatchInProgress.setAutoBases(exactMatch);
    myVariants.putValue(textFilePatchInProgress.getBase(),textFilePatchInProgress);
  }
  myCheckExistingVariants=true;
}
