{
  final List<Pair<FilePath,WorkingCopyFormat>> deletedFiles=new ArrayList<Pair<FilePath,WorkingCopyFormat>>();
  final Collection<FilePath> filesToProcess=new ArrayList<FilePath>();
  List<VcsException> exceptions=new ArrayList<VcsException>();
  final AbstractVcsHelper vcsHelper=AbstractVcsHelper.getInstance(project);
  try {
    fillDeletedFiles(project,deletedFiles,filesToProcess);
    if (deletedFiles.isEmpty() && filesToProcess.isEmpty() || myUndoingMove)     return;
    SvnVcs vcs=SvnVcs.getInstance(project);
    final VcsShowConfirmationOption.Value value=vcs.getDeleteConfirmation().getValue();
    if (value != VcsShowConfirmationOption.Value.DO_NOTHING_SILENTLY) {
      if (!deletedFiles.isEmpty()) {
        final Collection<FilePath> confirmed=promptAboutDeletion(deletedFiles,vcs,value,vcsHelper);
        if (confirmed != null) {
          filesToProcess.addAll(confirmed);
        }
      }
      if (filesToProcess != null && !filesToProcess.isEmpty()) {
        runInBackground(project,"Deleting files from Subversion",createDeleteRunnable(project,vcs,filesToProcess,exceptions));
      }
      final List<FilePath> deletedFilesFiles=ObjectsConvertor.convert(deletedFiles,new Convertor<Pair<FilePath,WorkingCopyFormat>,FilePath>(){
        @Override public FilePath convert(        Pair<FilePath,WorkingCopyFormat> o){
          return o.getFirst();
        }
      }
);
      for (      FilePath file : deletedFilesFiles) {
        final FilePath parent=file.getParentPath();
        if (parent != null) {
          myFilesToRefresh.add(parent.getVirtualFile());
        }
      }
      if (filesToProcess != null) {
        deletedFilesFiles.removeAll(filesToProcess);
      }
      for (      FilePath file : deletedFilesFiles) {
        FileUtil.delete(file.getIOFile());
      }
    }
  }
 catch (  SVNException e) {
    exceptions.add(new VcsException(e));
  }
  if (!exceptions.isEmpty()) {
    vcsHelper.showErrors(exceptions,SvnBundle.message("delete.files.errors.title"));
  }
}
