{
  final GitLineHandler pullHandler=makePullHandler(myRoot);
  final GitRebaseProblemDetector rebaseConflictDetector=new GitRebaseProblemDetector();
  pullHandler.addLineListener(rebaseConflictDetector);
  GitTask pullTask=new GitTask(myProject,pullHandler,"git pull");
  pullTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicReference<GitUpdateResult> updateResult=new AtomicReference<GitUpdateResult>();
  pullTask.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      updateResult.set(GitUpdateResult.SUCCESS);
    }
    @Override protected void onCancel(){
      cancel();
      updateResult.set(GitUpdateResult.CANCEL);
    }
    @Override protected void onFailure(){
      if (rebaseConflictDetector.isMergeConflict()) {
        final boolean allMerged=new GitMergeConflictResolver(myProject,true,"Can't continue rebase","Then you may continue or abort rebase."){
          @Override protected boolean proceedIfNothingToMerge() throws VcsException {
            return myRebaser.continueRebase(myRoot);
          }
          @Override protected boolean proceedAfterAllMerged() throws VcsException {
            return myRebaser.continueRebase(myRoot);
          }
        }
.mergeFiles(Collections.singleton(myRoot));
        updateResult.set(allMerged ? GitUpdateResult.SUCCESS : GitUpdateResult.INCOMPLETE);
      }
 else {
        GitUIUtil.notifyImportantError(myProject,"Error rebasing",GitUIUtil.stringifyErrors(pullHandler.errors()));
        updateResult.set(GitUpdateResult.ERROR);
      }
    }
  }
);
  return updateResult.get();
}
