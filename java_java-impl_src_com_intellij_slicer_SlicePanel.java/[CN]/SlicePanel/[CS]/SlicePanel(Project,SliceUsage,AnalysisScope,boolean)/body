{
  super(new BorderLayout());
  myProject=project;
  myTree=createTree();
  DuplicateMap targetEqualUsages=new DuplicateMap();
  final SliceTreeBuilder[] builder={null};
  final SliceNode rootNode=new SliceRootNode(project,targetEqualUsages,scope,root){
    @Override protected SliceTreeBuilder getTreeBuilder(){
      return builder[0];
    }
  }
;
  builder[0]=new SliceTreeBuilder(myTree,project,dataFlowToThis,rootNode);
  builder[0].setCanYieldUpdate(!ApplicationManager.getApplication().isUnitTestMode());
  Disposer.register(this,builder[0]);
  builder[0].addSubtreeToUpdate((DefaultMutableTreeNode)myTree.getModel().getRoot(),new Runnable(){
    public void run(){
      if (isDisposed || builder[0].isDisposed() || myProject.isDisposed())       return;
      builder[0].expand(rootNode,new Runnable(){
        public void run(){
          if (isDisposed || builder[0].isDisposed() || myProject.isDisposed())           return;
          builder[0].select(rootNode.myCachedChildren.get(0));
        }
      }
);
      treeSelectionChanged();
    }
  }
);
  myBuilder=builder[0];
  layoutPanel();
}
