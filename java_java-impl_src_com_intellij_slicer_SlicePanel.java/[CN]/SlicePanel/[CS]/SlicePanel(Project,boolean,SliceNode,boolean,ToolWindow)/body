{
  super(new BorderLayout());
  myToolWindow=toolWindow;
  final ToolWindowManagerListener listener=new ToolWindowManagerListener(){
    ToolWindowAnchor myAnchor=toolWindow.getAnchor();
    public void toolWindowRegistered(    @NotNull String id){
    }
    public void stateChanged(){
      if (!project.isOpen())       return;
      if (toolWindow.getAnchor() != myAnchor) {
        myAnchor=myToolWindow.getAnchor();
        layoutPanel();
      }
    }
  }
;
  ToolWindowManagerEx.getInstanceEx(project).addToolWindowManagerListener(listener);
  Disposer.register(this,new Disposable(){
    public void dispose(){
      ToolWindowManagerEx.getInstanceEx(project).removeToolWindowManagerListener(listener);
    }
  }
);
  ApplicationManager.getApplication().assertIsDispatchThread();
  myProject=project;
  myTree=createTree();
  myBuilder=new SliceTreeBuilder(myTree,project,dataFlowToThis,rootNode,splitByLeafExpressions);
  myBuilder.setCanYieldUpdate(!ApplicationManager.getApplication().isUnitTestMode());
  Disposer.register(this,myBuilder);
  myBuilder.addSubtreeToUpdate((DefaultMutableTreeNode)myTree.getModel().getRoot(),new Runnable(){
    public void run(){
      if (isDisposed || myBuilder.isDisposed() || myProject.isDisposed())       return;
      final SliceNode rootNode=myBuilder.getRootSliceNode();
      myBuilder.expand(rootNode,new Runnable(){
        public void run(){
          if (isDisposed || myBuilder.isDisposed() || myProject.isDisposed())           return;
          myBuilder.select(rootNode.myCachedChildren.get(0));
        }
      }
);
      treeSelectionChanged();
    }
  }
);
  layoutPanel();
}
