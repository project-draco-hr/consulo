{
  if (!FileModificationService.getInstance().preparePsiElementForWrite(file))   return;
  final List<CommonProblemDescriptor> descriptions=ProgressManager.getInstance().runProcess(new Computable<List<CommonProblemDescriptor>>(){
    @Override public List<CommonProblemDescriptor> compute(){
      return InspectionRunningUtil.runInspectionOnFile(file,myTool);
    }
  }
,new EmptyProgressIndicator());
  Collections.sort(descriptions,new Comparator<CommonProblemDescriptor>(){
    @Override public int compare(    final CommonProblemDescriptor o1,    final CommonProblemDescriptor o2){
      final ProblemDescriptorImpl d1=(ProblemDescriptorImpl)o1;
      final ProblemDescriptorImpl d2=(ProblemDescriptorImpl)o2;
      return d2.getTextRange().getStartOffset() - d1.getTextRange().getStartOffset();
    }
  }
);
  boolean fixesWereAvailable=false;
  for (  CommonProblemDescriptor descriptor : descriptions) {
    final QuickFix[] fixes=descriptor.getFixes();
    if (fixes != null && fixes.length > 0) {
      fixesWereAvailable=true;
      for (      QuickFix<CommonProblemDescriptor> fix : fixes) {
        if (fix != null && fix.getClass().isAssignableFrom(myQuickfixClass)) {
          final PsiElement element=((ProblemDescriptor)descriptor).getPsiElement();
          if (element != null && element.isValid()) {
            fix.applyFix(project,descriptor);
            PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());
          }
          break;
        }
      }
    }
  }
  if (!fixesWereAvailable) {
    CommonRefactoringUtil.showErrorHint(project,editor,"No fixes are available in batch mode",CommonBundle.getWarningTitle(),null);
  }
}
