{
  try {
    if (!myFilesToCompile.isEmpty()) {
      final Map<Module,List<VirtualFile>> moduleToFilesMap=buildModuleToFilesMap(myFilesToCompile);
      myProcessedFilesCount=0;
      try {
        final ModuleChunk chunk=new ModuleChunk(myCompileContext,myChunk,moduleToFilesMap);
        setPresentableNameFor(chunk);
        final List<OutputDir> outs=getOutputDirsToCompileTo(chunk);
        for (        final OutputDir outputDir : outs) {
          chunk.setSourcesFilter(outputDir.getKind());
          doCompile(chunk,outputDir.getPath());
        }
      }
 catch (      IOException e) {
        throw new CompilerException(e.getMessage(),e);
      }
    }
  }
 catch (  SecurityException e) {
    throw new CompilerException(CompilerBundle.message("error.compiler.process.not.started",e.getMessage()),e);
  }
catch (  IllegalArgumentException e) {
    throw new CompilerException(e.getMessage(),e);
  }
 finally {
    CompilerUtil.logDuration(myCompiler.getId() + " running",myCompilationDuration);
  }
  myFilesToRecompile.removeAll(mySuccesfullyCompiledJavaFiles);
  if (myFilesToRecompile.size() > 0) {
    mySink.add(null,Collections.<TranslatingCompiler.OutputItem>emptyList(),myFilesToRecompile.toArray(new VirtualFile[myFilesToRecompile.size()]));
  }
}
