{
  boolean hasUsages=false;
  for (  PsiReference reference : ReferencesSearch.search(aClass)) {
    final PsiElement element=reference.getElement();
    if (element == null)     continue;
    if (!PsiTreeUtil.isAncestor(aClass,element,false)) {
      hasUsages=true;
    }
    final PsiElement parentElement=element.getParent();
    if (parentElement != null) {
      final PsiElement grandPa=parentElement.getParent();
      if (grandPa instanceof PsiClassObjectAccessExpression) {
        return "Class cannot be inlined because it has usages of its class literal";
      }
      if (ourCatchClausePattern.accepts(parentElement)) {
        return "Class cannot be inlined because it is used in a 'catch' clause";
      }
    }
    if (ourThrowsClausePattern.accepts(element)) {
      return "Class cannot be inlined because it is used in a 'throws' clause";
    }
    if (parentElement instanceof PsiThisExpression) {
      return "Class cannot be inlined because it is used as a 'this' qualifier";
    }
    if (parentElement instanceof PsiNewExpression) {
      final PsiNewExpression newExpression=(PsiNewExpression)parentElement;
      final PsiMethod[] constructors=aClass.getConstructors();
      if (constructors.length == 0) {
        PsiExpressionList newArgumentList=newExpression.getArgumentList();
        if (newArgumentList != null && newArgumentList.getExpressions().length > 0) {
          return "Class cannot be inlined because a call to its constructor is unresolved";
        }
      }
 else {
        final JavaResolveResult resolveResult=newExpression.resolveMethodGenerics();
        if (!resolveResult.isValidResult()) {
          return "Class cannot be inlined because a call to its constructor is unresolved";
        }
      }
    }
  }
  if (!hasUsages) {
    return RefactoringBundle.message("class.is.never.used");
  }
  return null;
}
