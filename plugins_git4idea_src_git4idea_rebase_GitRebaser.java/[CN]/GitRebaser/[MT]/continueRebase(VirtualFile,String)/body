{
  final GitLineHandler rh=new GitLineHandler(myProject,root,GitCommand.REBASE);
  rh.addParameters(startOperation);
  final GitRebaseProblemDetector rebaseConflictDetector=new GitRebaseProblemDetector();
  rh.addLineListener(rebaseConflictDetector);
  final GitTask rebaseTask=new GitTask(myProject,rh,"git rebase " + startOperation);
  rebaseTask.setExecuteResultInAwt(false);
  rebaseTask.setProgressAnalyzer(new GitStandardProgressAnalyzer());
  final AtomicBoolean result=new AtomicBoolean();
  rebaseTask.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
      result.set(true);
    }
    @Override protected void onCancel(){
      result.set(false);
    }
    @Override protected void onFailure(){
      if (rebaseConflictDetector.isMergeConflict()) {
        result.set(new GitMergeConflictResolver(myProject,true,"Can't continue rebase","Then you may <b>continue rebase</b>. <br/> You also may <b>abort rebase</b> to restore the original branch and stop rebasing."){
          @Override protected boolean proceedIfNothingToMerge(){
            return continueRebase(root,"--continue");
          }
          @Override protected boolean proceedAfterAllMerged(){
            return continueRebase(root,"--continue");
          }
        }
.mergeFiles(Collections.singleton(root)));
      }
 else       if (rebaseConflictDetector.isNoChangeError()) {
        mySkippedCommits.add(GitRebaseUtils.getCurrentRebaseCommit(root));
        result.set(continueRebase(root,"--skip"));
      }
 else {
        result.set(false);
        GitUIUtil.notifyImportantError(myProject,"Error rebasing",GitUIUtil.stringifyErrors(rh.errors()));
      }
    }
  }
);
  return result.get();
}
