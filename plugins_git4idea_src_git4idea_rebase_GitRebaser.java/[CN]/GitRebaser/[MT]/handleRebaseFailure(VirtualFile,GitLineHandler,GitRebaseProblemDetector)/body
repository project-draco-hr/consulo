{
  if (rebaseConflictDetector.isMergeConflict()) {
    return new GitMergeConflictResolver(myProject,true,"Merge conflicts detected. Resolve them before continuing rebase.","Can't continue rebase","Then you may <b>continue rebase</b>. <br/> You also may <b>abort rebase</b> to restore the original branch and stop rebasing."){
      @Override protected boolean proceedIfNothingToMerge(){
        return continueRebase(root,"--continue");
      }
      @Override protected boolean proceedAfterAllMerged(){
        return continueRebase(root,"--continue");
      }
    }
.mergeFiles(Collections.singleton(root));
  }
 else   if (rebaseConflictDetector.isNoChangeError()) {
    mySkippedCommits.add(GitRebaseUtils.getCurrentRebaseCommit(root));
    return continueRebase(root,"--skip");
  }
 else {
    GitUIUtil.notifyImportantError(myProject,"Error rebasing",GitUIUtil.stringifyErrors(h.errors()));
    return false;
  }
}
