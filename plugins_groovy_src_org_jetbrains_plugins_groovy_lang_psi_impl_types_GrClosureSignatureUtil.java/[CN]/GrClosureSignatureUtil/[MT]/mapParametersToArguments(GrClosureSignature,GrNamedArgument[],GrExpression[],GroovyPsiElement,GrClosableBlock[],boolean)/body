{
  List<InnerArg> innerArgs=new ArrayList<InnerArg>();
  boolean hasNamedArgs=namedArgs.length > 0;
  GrClosureParameter[] params=signature.getParameters();
  if (hasNamedArgs) {
    if (params.length == 0)     return null;
    PsiType type=params[0].getType();
    if (InheritanceUtil.isInheritor(type,CommonClassNames.JAVA_UTIL_MAP)) {
      innerArgs.add(new InnerArg(new GrMapType(context.getResolveScope()),namedArgs));
    }
 else {
      return null;
    }
  }
  for (  GrExpression expression : expressionArgs) {
    PsiType type=expression.getType();
    if (expression instanceof GrNewExpression && com.intellij.psi.util.PsiUtil.resolveClassInType(type) == null) {
      type=null;
    }
    type=TypeConversionUtil.erasure(type);
    innerArgs.add(new InnerArg(type,expression));
  }
  for (  GrClosableBlock closureArgument : closureArguments) {
    innerArgs.add(new InnerArg(TypeConversionUtil.erasure(closureArgument.getType()),closureArgument));
  }
  final ArgInfo<InnerArg>[] innerMap=mapParametersToArguments(signature,innerArgs.toArray(new InnerArg[innerArgs.size()]),new Function<InnerArg,PsiType>(){
    @Override public PsiType fun(    InnerArg o){
      return o.type;
    }
  }
,context,partial);
  if (innerMap == null)   return null;
  ArgInfo<PsiElement>[] map=new ArgInfo[innerMap.length];
  int i=0;
  if (hasNamedArgs) {
    map[i]=new ArgInfo<PsiElement>(innerMap[i].args.iterator().next().list,true);
    i++;
  }
  for (; i < innerMap.length; i++) {
    final ArgInfo<InnerArg> innerArg=innerMap[i];
    List<PsiElement> argList=new ArrayList<PsiElement>();
    for (    InnerArg arg : innerArg.args) {
      argList.addAll(arg.list);
    }
    boolean multiArg=innerArg.isMultiArg || argList.size() > 1;
    map[i]=new ArgInfo<PsiElement>(argList,multiArg);
  }
  return map;
}
