{
  if (notOptional > args.length - curArg)   return null;
  if (notOptional == args.length - curArg)   skipOptionals=true;
  while (curArg < args.length) {
    if (skipOptionals) {
      while (curParam < paramLength && params[curParam].isOptional())       curParam++;
    }
    if (curParam == paramLength)     break;
    if (params[curParam].isOptional()) {
      if (TypesUtil.isAssignable(params[curParam].getType(),types[curArg],manager,scope)) {
        ArgInfo[] copy=mapInternal(curParam + 1,curArg + 1,false,notOptional,copyMap(map));
        if (copy != null)         return copy;
      }
      skipOptionals=true;
    }
 else {
      if (!TypesUtil.isAssignableByMethodCallConversion(params[curParam].getType(),types[curArg],manager,scope))       return null;
      map[curParam]=new ArgInfo(Collections.<PsiElement>singletonList(args[curArg]),false);
      notOptional--;
      curArg++;
      curParam++;
    }
  }
  map[paramLength]=new ArgInfo(new ArrayList<PsiElement>(args.length - curArg),true);
  for (; curArg < args.length; curArg++) {
    if (!TypesUtil.isAssignableByMethodCallConversion(vararg,types[curArg],manager,scope))     return null;
    map[paramLength].args.add(args[curArg]);
  }
  return map;
}
