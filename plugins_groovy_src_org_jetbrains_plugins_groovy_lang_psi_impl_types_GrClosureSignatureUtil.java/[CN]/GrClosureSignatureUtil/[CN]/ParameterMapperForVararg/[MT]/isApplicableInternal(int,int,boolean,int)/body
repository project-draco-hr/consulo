{
  int startParam=curParam;
  if (notOptional > args.length - curArg)   return false;
  if (notOptional == args.length - curArg)   skipOptionals=true;
  while (curArg < args.length) {
    if (skipOptionals) {
      while (curParam < paramLength && params[curParam].isOptional())       curParam++;
    }
    if (curParam == paramLength)     break;
    if (params[curParam].isOptional()) {
      if (TypesUtil.isAssignable(params[curParam].getType(),types[curArg],context,false) && isApplicableInternal(curParam + 1,curArg + 1,false,notOptional)) {
        map[curParam]=new ArgInfo<Arg>(args[curArg]);
        return true;
      }
      skipOptionals=true;
    }
 else {
      if (!TypesUtil.isAssignable(params[curParam].getType(),types[curArg],context,false)) {
        for (int i=startParam; i < curParam; i++)         map[i]=null;
        return false;
      }
      map[curParam]=new ArgInfo<Arg>(args[curArg]);
      notOptional--;
      curArg++;
      curParam++;
    }
  }
  List<Arg> varargs=new ArrayList<Arg>();
  for (; curArg < args.length; curArg++) {
    if (!TypesUtil.isAssignable(vararg,types[curArg],context,false)) {
      for (int i=startParam; i < curParam; i++)       map[i]=null;
      return false;
    }
    varargs.add(args[curArg]);
  }
  map[paramLength]=new ArgInfo<Arg>(varargs,true);
  return true;
}
