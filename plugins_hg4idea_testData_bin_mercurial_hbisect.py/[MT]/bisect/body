def bisect(changelog, state):
    "find the next node (if any) for testing during a bisect search.\n    returns a (nodes, number, good) tuple.\n\n    'nodes' is the final result of the bisect if 'number' is 0.\n    Otherwise 'number' indicates the remaining possible candidates for\n    the search and 'nodes' contains the next bisect target.\n    'good' is True if bisect is searching for a first good changeset, False\n    if searching for a first bad one.\n    "
    clparents = changelog.parentrevs
    skip = set([changelog.rev(n) for n in state['skip']])

    def buildancestors(bad, good):
        badrev = min([changelog.rev(n) for n in bad])
        goodrevs = [changelog.rev(n) for n in good]
        goodrev = min(goodrevs)
        ancestors = ([None] * (len(changelog) + 1))
        ancestors[goodrev] = []
        for rev in xrange((goodrev + 1), len(changelog)):
            for prev in clparents(rev):
                if (ancestors[prev] == []):
                    ancestors[rev] = []
        for node in goodrevs:
            ancestors[node] = None
        for rev in xrange(len(changelog), (-1), (-1)):
            if (ancestors[rev] is None):
                for prev in clparents(rev):
                    ancestors[prev] = None
        if (ancestors[badrev] is None):
            return (badrev, None)
        return (badrev, ancestors)
    good = 0
    (badrev, ancestors) = buildancestors(state['bad'], state['good'])
    if (not ancestors):
        good = 1
        (badrev, ancestors) = buildancestors(state['good'], state['bad'])
    bad = changelog.node(badrev)
    if (not ancestors):
        raise util.Abort((_('Inconsistent state, %s:%s is good and bad') % (badrev, short(bad))))
    children = {}
    visit = [badrev]
    candidates = []
    while visit:
        rev = visit.pop(0)
        if (ancestors[rev] == []):
            candidates.append(rev)
            for prev in clparents(rev):
                if (prev != (-1)):
                    if (prev in children):
                        children[prev].append(rev)
                    else:
                        children[prev] = [rev]
                        visit.append(prev)
    candidates.sort()
    tot = len(candidates)
    unskipped = [c for c in candidates if ((c not in skip) and (c != badrev))]
    if ((tot == 1) or (not unskipped)):
        return ([changelog.node(rev) for rev in candidates], 0, good)
    perfect = (tot // 2)
    best_rev = None
    best_len = (-1)
    poison = set()
    for rev in candidates:
        if (rev in poison):
            poison.update(children.get(rev, []))
            continue
        a = (ancestors[rev] or [rev])
        ancestors[rev] = None
        x = len(a)
        y = (tot - x)
        value = min(x, y)
        if ((value > best_len) and (rev not in skip)):
            best_len = value
            best_rev = rev
            if (value == perfect):
                break
        if ((y < perfect) and (rev not in skip)):
            poison.update(children.get(rev, []))
            continue
        for c in children.get(rev, []):
            if ancestors[c]:
                ancestors[c] = list(set((ancestors[c] + a)))
            else:
                ancestors[c] = (a + [c])
    assert (best_rev is not None)
    best_node = changelog.node(best_rev)
    return ([best_node], tot, good)
