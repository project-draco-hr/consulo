{
  if (!GithubUtil.testGitExecutable(project)) {
    return;
  }
  BasicAction.saveAll();
  final List<RepositoryInfo> availableRepos=GithubUtil.getAvailableRepos(project,false);
  if (availableRepos == null) {
    return;
  }
  Collections.sort(availableRepos,new Comparator<RepositoryInfo>(){
    @Override public int compare(    final RepositoryInfo r1,    final RepositoryInfo r2){
      final int comparedOwners=r1.getOwner().compareTo(r2.getOwner());
      return comparedOwners != 0 ? comparedOwners : r1.getName().compareTo(r2.getName());
    }
  }
);
  final GitCloneDialog dialog=new GitCloneDialog(project);
  for (int i=availableRepos.size() - 1; i >= 0; i--) {
    dialog.prependToHistory(availableRepos.get(i).getUrl());
  }
  dialog.show();
  if (!dialog.isOK()) {
    return;
  }
  dialog.rememberSettings();
  final VirtualFile destinationParent=LocalFileSystem.getInstance().findFileByIoFile(new File(dialog.getParentDirectory()));
  if (destinationParent == null) {
    return;
  }
  final String sourceRepositoryURL=dialog.getSourceRepositoryURL();
  final String directoryName=dialog.getDirectoryName();
  final String parentDirectory=dialog.getParentDirectory();
  Git git=ServiceManager.getService(Git.class);
  GitCheckoutProvider.clone(project,git,listener,destinationParent,sourceRepositoryURL,directoryName,parentDirectory);
}
