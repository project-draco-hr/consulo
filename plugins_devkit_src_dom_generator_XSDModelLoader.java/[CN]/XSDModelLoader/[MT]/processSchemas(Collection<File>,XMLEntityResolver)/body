{
  Map<String,NamespaceDesc> nsdMap=model.nsdMap;
  Map<String,TypeDesc> jtMap=model.jtMap;
  final NamespaceDesc nsdDef=nsdMap.get("");
  final ArrayList<XSModel> models=new ArrayList<XSModel>();
  final HashMap<String,XSTypeDefinition> types=new HashMap<String,XSTypeDefinition>();
  for (  File schemaFile : schemas) {
    String fileName=schemaFile.getPath();
    if (schemaFile.isDirectory() || !fileName.endsWith(".xsd")) {
      Util.log("skipping " + fileName);
      continue;
    }
    Util.log("loading " + fileName + "..");
    final XSModel model=loadSchema(schemaFile,resolver);
    if (model == null)     continue;
    final StringList namespaceList=model.getNamespaces();
    for (int i=0; i < namespaceList.getLength(); i++) {
      String ns=namespaceList.item(i);
      if (!nsdMap.containsKey(ns)) {
        Util.log("Adding default namespace desc for: " + ns);
        NamespaceDesc nsd=new NamespaceDesc(ns,nsdDef);
        nsdMap.put(ns,nsd);
      }
    }
    models.add(model);
    final XSNamedMap typeDefMap=model.getComponents(XSConstants.TYPE_DEFINITION);
    for (int i=0; i < typeDefMap.getLength(); i++) {
      XSTypeDefinition o=(XSTypeDefinition)typeDefMap.item(i);
      NamespaceDesc nsd=nsdMap.get(o.getNamespace());
      if (nsd != null && nsd.skip)       continue;
      final String key=o.getName() + "," + o.getNamespace();
      types.put(key,o);
    }
    final XSNamedMap elementDeclMap=model.getComponents(XSConstants.ELEMENT_DECLARATION);
    for (int i=0; i < elementDeclMap.getLength(); i++) {
      XSElementDeclaration o=(XSElementDeclaration)elementDeclMap.item(i);
      if (o.getTypeDefinition().getAnonymous() && (o.getTypeDefinition() instanceof XSComplexTypeDefinition)) {
        XSComplexTypeDefinition ctd=makeTypeFromAnonymous(o);
        NamespaceDesc nsd=nsdMap.get(o.getNamespace());
        if (nsd != null && nsd.skip)         continue;
        final String key=ctd.getName() + "," + ctd.getNamespace();
        types.put(key,ctd);
      }
    }
  }
  Util.log(types.size() + " elements loaded, processing..");
  ArrayList<XSTypeDefinition> toProcess=new ArrayList<XSTypeDefinition>(types.values());
  ArrayList<XSComplexTypeDefinition> toAdd=new ArrayList<XSComplexTypeDefinition>();
  for (ListIterator<XSTypeDefinition> it=toProcess.listIterator(); it.hasNext(); ) {
    XSTypeDefinition td=it.next();
    Util.log("processing " + td.getName() + ","+ td.getNamespace()+ "..");
    if (checkComplexType(td)) {
      processType((XSComplexTypeDefinition)td,models,jtMap,nsdMap,toAdd);
    }
 else     if (checkEnumType(td)) {
      processEnumType(td,jtMap,nsdMap);
    }
    if (toAdd.size() != 0) {
      for (      XSComplexTypeDefinition o : toAdd) {
        final String key=o.getName() + "," + o.getNamespace();
        if (!types.containsKey(key)) {
          Util.log("  adding " + o.getName() + ","+ o.getNamespace());
          types.put(key,o);
          it.add(o);
          it.previous();
        }
 else {
          Util.logwarn(key + " already exists");
        }
      }
      toAdd.clear();
    }
  }
}
