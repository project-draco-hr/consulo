{
  XSModelGroupDefinition def=null;
  for (  XSModel xsModel : models) {
    XSNamedMap map=xsModel.getComponents(XSConstants.MODEL_GROUP_DEFINITION);
    for (int i=0; i < map.getLength(); i++) {
      XSModelGroupDefinition mg=(XSModelGroupDefinition)map.item(i);
      final XSModelGroup xsModelGroup=mg.getModelGroup();
      if (xsModelGroup == modelGroup || xsModelGroup.toString().equals(modelGroup.toString())) {
        def=mg;
        break;
      }
    }
  }
  if (def == null)   return null;
  if (!nsdMap.containsKey(def.getNamespace())) {
    Util.log("Namespace desc not found for: " + def);
  }
  String typeName=toJavaTypeName(def,nsdMap);
  final String typeQName=model.toJavaQualifiedTypeName(def,nsdMap,false);
  TypeDesc td=jtMap.get(typeQName);
  if (td != null) {
    if (td.type == TypeDesc.TypeEnum.GROUP_INTERFACE) {
      return td;
    }
 else {
      Util.logerr("type-group conflict: " + typeName);
      return null;
    }
  }
 else {
    td=new TypeDesc(def.getName(),def.getNamespace(),typeName,TypeDesc.TypeEnum.GROUP_INTERFACE);
  }
  XSAnnotation ann=def.getAnnotation();
  td.documentation=parseAnnotationString("Type " + def.getNamespace() + ":"+ def.getName()+ " documentation",ann == null ? null : ann.getAnnotationString());
  td.type=TypeDesc.TypeEnum.GROUP_INTERFACE;
  LinkedList<PEntry> plist=new LinkedList<PEntry>();
  for (int i=0; i < def.getModelGroup().getParticles().getLength(); i++) {
    XSParticle p=(XSParticle)def.getModelGroup().getParticles().item(i);
    plist.add(new PEntry(p,false));
  }
  processParticles(def,plist,nsdMap,jtMap,td,models,null,null);
  jtMap.put(typeQName,td);
  return td;
}
