{
  VirtualFile file;
  try {
    file=patch.findFileToPatch(context);
  }
 catch (  IOException e) {
    Messages.showErrorDialog(project,"Error when searching for file to patch: " + patch.getBeforeName() + ": "+ e.getMessage(),"Apply Patch");
    return ApplyPatchStatus.FAILURE;
  }
  if (file == null) {
    Messages.showErrorDialog(project,"Cannot find file to patch: " + patch.getBeforeName(),"Apply Patch");
    return ApplyPatchStatus.FAILURE;
  }
  try {
    return patch.apply(file,context);
  }
 catch (  ApplyPatchException ex) {
    if (!patch.isNewFile() && !patch.isDeletedFile()) {
      final DefaultPatchBaseVersionProvider provider=new DefaultPatchBaseVersionProvider(project);
      if (provider.canProvideContent(file,patch.getBeforeVersionId())) {
        final StringBuilder newText=new StringBuilder();
        final Ref<CharSequence> contentRef=new Ref<CharSequence>();
        final Ref<ApplyPatchStatus> statusRef=new Ref<ApplyPatchStatus>();
        provider.getBaseVersionContent(file,patch.getBeforeVersionId(),new Processor<CharSequence>(){
          public boolean process(          final CharSequence text){
            newText.setLength(0);
            try {
              statusRef.set(patch.applyModifications(text,newText));
            }
 catch (            ApplyPatchException ex) {
              return true;
            }
            contentRef.set(text);
            return false;
          }
        }
);
        ApplyPatchStatus status=statusRef.get();
        if (status != null) {
          if (status != ApplyPatchStatus.ALREADY_APPLIED) {
            return showMergeDialog(project,file,contentRef.get(),newText.toString());
          }
 else {
            return status;
          }
        }
      }
    }
    Messages.showErrorDialog(project,VcsBundle.message("patch.apply.error",patch.getBeforeName(),ex.getMessage()),VcsBundle.message("patch.apply.dialog.title"));
  }
catch (  Exception ex) {
    LOG.error(ex);
  }
  return ApplyPatchStatus.FAILURE;
}
