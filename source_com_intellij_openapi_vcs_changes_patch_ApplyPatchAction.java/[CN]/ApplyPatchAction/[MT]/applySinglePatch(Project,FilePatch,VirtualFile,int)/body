{
  VirtualFile file=patch.findFileToPatch(baseDirectory,stripLeadingDirectories);
  if (file == null) {
    Messages.showErrorDialog(project,"Cannot find file to patch: " + patch.getBeforeName(),"Apply Patch");
    return ApplyPatchStatus.FAILURE;
  }
  try {
    return patch.apply(file);
  }
 catch (  ApplyPatchException ex) {
    if (!patch.isNewFile() && !patch.isDeletedFile()) {
      PatchBaseVersionProvider provider=findBaseVersionProvider(project,patch,file);
      if (provider != null) {
        final StringBuilder newText=new StringBuilder();
        final Ref<CharSequence> contentRef=new Ref<CharSequence>();
        final Ref<ApplyPatchStatus> statusRef=new Ref<ApplyPatchStatus>();
        provider.getBaseVersionContent(file,patch.getBeforeVersionId(),new Processor<CharSequence>(){
          public boolean process(          final CharSequence text){
            newText.setLength(0);
            try {
              statusRef.set(patch.applyModifications(text,newText));
            }
 catch (            ApplyPatchException ex) {
              return true;
            }
            contentRef.set(text);
            return false;
          }
        }
);
        ApplyPatchStatus status=statusRef.get();
        if (status != null) {
          if (status != ApplyPatchStatus.ALREADY_APPLIED) {
            return showMergeDialog(project,file,contentRef.get(),newText.toString());
          }
 else {
            return status;
          }
        }
      }
    }
    Messages.showErrorDialog(project,"Failed to apply patch because of conflicts: " + patch.getBeforeName(),VcsBundle.message("patch.apply.dialog.title"));
  }
catch (  Exception ex) {
    LOG.error(ex);
  }
  return ApplyPatchStatus.FAILURE;
}
