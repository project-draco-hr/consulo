{
  final int oldEndOffset=myEnd;
  if (newEndOffset == oldEndOffset)   return;
  if (myStart >= newEndOffset) {
    InitialInfoBuilder.assertInvalidRanges(myStart,newEndOffset,model,"some block intersects with whitespace");
  }
  myEnd=newEndOffset;
  TextRange range=new TextRange(myStart,myEnd);
  CharSequence oldText=myInitial;
  myInitial=model.getText(range);
  if (!coveredByBlock(model)) {
    coveredByBlock(model);
    InitialInfoBuilder.assertInvalidRanges(myStart,myEnd,model,"nonempty text is not covered by block");
  }
  if (newEndOffset > oldEndOffset) {
    refreshStateOnEndOffsetIncrease(newEndOffset,oldEndOffset,options.TAB_SIZE);
  }
 else {
    refreshStateOnEndOffsetDecrease(oldText,newEndOffset,oldEndOffset,options.TAB_SIZE);
  }
  if (getLineFeeds() > 0)   myFlags|=CONTAINS_LF_INITIALLY;
 else   myFlags&=~CONTAINS_LF_INITIALLY;
  final int totalSpaces=getTotalSpaces();
  if (totalSpaces > 0)   myFlags|=CONTAINS_SPACES_INITIALLY;
 else   myFlags&=~CONTAINS_SPACES_INITIALLY;
}
