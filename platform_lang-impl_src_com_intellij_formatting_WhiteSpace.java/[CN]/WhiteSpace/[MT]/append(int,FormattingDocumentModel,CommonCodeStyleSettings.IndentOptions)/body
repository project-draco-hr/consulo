{
  final int oldEndOffset=myEnd;
  if (newEndOffset == oldEndOffset)   return;
  if (myStart >= newEndOffset) {
    InitialInfoBuilder.assertInvalidRanges(myStart,newEndOffset,model,"some block intersects with whitespace");
  }
  myEnd=newEndOffset;
  TextRange range=new TextRange(myStart,myEnd);
  CharSequence oldText=myInitial;
  myInitial=model.getText(range);
  if (!coveredByBlock(model)) {
    InitialInfoBuilder.assertInvalidRanges(myStart,myEnd,model,"nonempty text is not covered by block");
  }
  if (newEndOffset > oldEndOffset) {
    refreshStateOnEndOffsetIncrease(newEndOffset,oldEndOffset,options.TAB_SIZE);
  }
 else {
    refreshStateOnEndOffsetDecrease(oldText,newEndOffset,oldEndOffset,options.TAB_SIZE);
  }
  IndentInside indent=IndentInside.getLastLineIndent(myInitial);
  myInitialLastLinesSpaces=indent.whiteSpaces;
  myInitialLastLinesTabs=indent.tabs;
  setFlag(CONTAINS_LF_INITIALLY_MASK,getLineFeeds() > 0);
  final int totalSpaces=getTotalSpaces();
  setFlag(CONTAINS_SPACES_INITIALLY_MASK,totalSpaces > 0);
}
