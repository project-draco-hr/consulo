{
  final HashSet<PsiClass> movedClasses=new HashSet<PsiClass>();
  final HashMap<PsiClass,HashSet<PsiElement>> reportedClassToContainers=new com.intellij.util.containers.HashMap<PsiClass,HashSet<PsiElement>>();
  final PackageWrapper aPackage=myTargetPackage;
  for (  UsageInfo usage : usages) {
    if (usage instanceof MoveRenameUsageInfo && !(usage instanceof NonCodeUsageInfo) && ((MoveRenameUsageInfo)usage).referencedElement instanceof PsiClass) {
      PsiClass aClass=(PsiClass)((MoveRenameUsageInfo)usage).referencedElement;
      if (!movedClasses.contains(aClass)) {
        movedClasses.add(aClass);
      }
      String visibility=VisibilityUtil.getVisibilityModifier(aClass.getModifierList());
      if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {
        if (PsiTreeUtil.getParentOfType(usage.getElement(),PsiImportStatement.class) != null)         continue;
        PsiElement container=ConflictsUtil.getContainer(usage.getElement());
        if (container == null)         continue;
        HashSet<PsiElement> reported=reportedClassToContainers.get(aClass);
        if (reported == null) {
          reported=new HashSet<PsiElement>();
          reportedClassToContainers.put(aClass,reported);
        }
        if (!reported.contains(container)) {
          reported.add(container);
          PsiFile containingFile=usage.getElement().getContainingFile();
          if (containingFile != null && !isInsideMoved(usage.getElement())) {
            PsiDirectory directory=containingFile.getContainingDirectory();
            if (directory != null) {
              PsiPackage usagePackage=directory.getPackage();
              if (aPackage != null && usagePackage != null && !aPackage.equalToPackage(usagePackage)) {
                final String message=RefactoringBundle.message("a.package.local.class.0.will.no.longer.be.accessible.from.1",ConflictsUtil.htmlEmphasize(aClass.getName()),ConflictsUtil.getDescription(container,true));
                conflicts.add(message);
              }
            }
          }
        }
      }
    }
  }
  final MyClassInstanceReferenceVisitor instanceReferenceVisitor=new MyClassInstanceReferenceVisitor(conflicts);
  for (  final PsiClass aClass : movedClasses) {
    String visibility=VisibilityUtil.getVisibilityModifier(aClass.getModifierList());
    if (PsiModifier.PACKAGE_LOCAL.equals(visibility)) {
      findInstancesOfPackageLocal(aClass,usages,instanceReferenceVisitor);
    }
 else {
      findPublicClassConflicts(aClass,instanceReferenceVisitor);
    }
  }
}
