{
  GitSimpleHandler h=new GitSimpleHandler(myProject,GitUtil.getGitRoot(repositoryFilePath),GitCommand.ANNOTATE);
  h.setNoSSH(true);
  h.setStdoutSuppressed(true);
  h.setCharset(file.getCharset());
  h.addParameters("-p","-l","-t","-M");
  if (revision == null) {
    h.addParameters("HEAD");
  }
 else {
    h.addParameters(revision.getRevisionNumber().asString());
  }
  h.endOptions();
  h.addRelativePaths(repositoryFilePath);
  String output=h.run();
  GitFileAnnotation annotation=new GitFileAnnotation(myProject,file,revision == null);
class CommitInfo {
    Date date;
    String author;
    GitRevisionNumber revision;
  }
  HashMap<String,CommitInfo> commits=new HashMap<String,CommitInfo>();
  for (StringScanner s=new StringScanner(output); s.hasMoreData(); ) {
    String commitHash=s.spaceToken();
    if (commitHash.equals(GitRevisionNumber.NOT_COMMITTED_HASH)) {
      commitHash=null;
    }
    s.spaceToken();
    int lineNum=Integer.parseInt(s.spaceToken());
    s.nextLine();
    CommitInfo commit=commits.get(commitHash);
    if (commit != null) {
      while (s.hasMoreData() && !s.startsWith('\t')) {
        s.nextLine();
      }
    }
 else {
      commit=new CommitInfo();
      while (s.hasMoreData() && !s.startsWith('\t')) {
        String key=s.spaceToken();
        String value=s.line();
        if (commitHash != null && AUTHOR_KEY.equals(key)) {
          commit.author=value;
        }
        if (commitHash != null && COMMITTER_TIME_KEY.equals(key)) {
          commit.date=GitUtil.parseTimestamp(value);
          commit.revision=new GitRevisionNumber(commitHash,commit.date);
        }
      }
      commits.put(commitHash,commit);
    }
    if (!s.hasMoreData()) {
      continue;
    }
    s.skipChars(1);
    String line=s.line(true);
    annotation.appendLineInfo(commit.date,commit.revision,commit.author,line,lineNum);
  }
  annotation.addLogEntries(revisions);
  return annotation;
}
