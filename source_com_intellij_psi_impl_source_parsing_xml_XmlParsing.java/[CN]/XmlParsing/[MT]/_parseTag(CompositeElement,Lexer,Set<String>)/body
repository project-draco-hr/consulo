{
  if (lexer.getTokenType() != XML_START_TAG_START) {
    return false;
  }
  CompositeElement tag=Factory.createCompositeElement(XML_TAG);
  TreeUtil.addChildren(parent,tag);
  addToken(tag,lexer);
  if (lexer.getTokenType() != XML_TAG_NAME) {
    return true;
  }
  String openedName=StringFactory.createStringFromConstantArray(lexer.getBuffer(),lexer.getTokenStart(),lexer.getTokenEnd() - lexer.getTokenStart());
  addToken(tag,lexer);
  parseAttributeList(tag,lexer);
  while (lexer.getTokenType() == XML_BAD_CHARACTER || lexer.getTokenType() == XML_NAME) {
    addToken(tag,lexer);
    parseAttributeList(tag,lexer);
  }
  TreeElement tagEnd=null;
  if (lexer.getTokenType() == XML_TAG_END) {
    tagEnd=addToken(tag,lexer);
    boolean setFlag=false;
    if (!names.contains(openedName)) {
      names.add(openedName);
      setFlag=true;
    }
    while (true) {
      if (parseProcessingInstruction(tag,lexer)) {
      }
 else       if (_parseTag(tag,lexer,names)) {
      }
 else       if (lexer.getTokenType() == XML_DATA_CHARACTERS) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_CDATA_START) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_CDATA_END) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_CHAR_ENTITY_REF) {
        addToken(tag,lexer);
      }
 else       if (lexer.getTokenType() == XML_ENTITY_REF_TOKEN) {
        TreeUtil.addChildren(tag,parseEntityRef(lexer));
      }
 else {
        break;
      }
    }
    if (setFlag) {
      names.remove(openedName);
    }
    long pos=ParseUtil.savePosition(lexer);
    if (lexer.getTokenType() != XML_END_TAG_START) {
      TreeUtil.insertAfter(tagEnd,Factory.createErrorElement("Element is not closed"));
      return false;
    }
    TreeElement endTagStart=ParseUtil.createTokenElement(lexer,myContext.getCharTable());
    lexer.advance();
    if (lexer.getTokenType() != XML_TAG_NAME) {
      TreeUtil.addChildren(tag,endTagStart);
      return true;
    }
    String closingName=StringFactory.createStringFromConstantArray(lexer.getBuffer(),lexer.getTokenStart(),lexer.getTokenEnd() - lexer.getTokenStart());
    if (!closingName.equals(openedName) && names.contains(closingName)) {
      ParseUtil.restorePosition(lexer,pos);
      if (tagEnd != null) {
        final TreeElement start=tagEnd.getTreeNext();
        tagEnd.setTreeNext(null);
        if (start != null) {
          TreeUtil.addChildren(parent,start);
        }
      }
      TreeUtil.insertAfter(tagEnd,Factory.createErrorElement("Element is not closed"));
      return true;
    }
    TreeUtil.addChildren(tag,endTagStart);
    addToken(tag,lexer);
    if (lexer.getTokenType() != XML_TAG_END) {
      return true;
    }
    addToken(tag,lexer);
  }
 else   if (lexer.getTokenType() == XML_EMPTY_ELEMENT_END) {
    addToken(tag,lexer);
  }
 else {
    TreeUtil.insertAfter(tag.lastChild,Factory.createErrorElement("Element is not closed"));
  }
  return true;
}
