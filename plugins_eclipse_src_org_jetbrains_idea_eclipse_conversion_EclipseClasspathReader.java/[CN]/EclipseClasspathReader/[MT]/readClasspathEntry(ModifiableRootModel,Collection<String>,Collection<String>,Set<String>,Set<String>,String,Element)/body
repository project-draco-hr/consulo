{
  String kind=element.getAttributeValue(EclipseXml.KIND_ATTR);
  if (kind == null) {
    throw new ConversionException("Missing classpathentry/@kind");
  }
  String path=element.getAttributeValue(EclipseXml.PATH_ATTR);
  if (path == null) {
    throw new ConversionException("Missing classpathentry/@path");
  }
  final boolean exported=EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));
  if (kind.equals(EclipseXml.SRC_KIND)) {
    if (path.startsWith("/")) {
      final String moduleName=path.substring(1);
      refsToModules.add(moduleName);
      rootModel.addInvalidModuleEntry(moduleName).setExported(exported);
    }
 else {
      String srcUrl=VfsUtil.pathToUrl(myRootPath + "/" + path);
      final boolean isTestFolder=testPattern != null && testPattern.length() > 0 && path.matches(testPattern);
      if (EclipseProjectFinder.isExternalResource(myRootPath,path)) {
        final String varName=EclipseProjectFinder.extractPathVariableName(path);
        usedVariables.add(varName);
        final String toPathVariableFormat=getVariableRelatedPath(varName,path.length() > varName.length() ? path.substring(varName.length()) : null);
        srcUrl=VfsUtil.pathToUrl(PathMacroManager.getInstance(rootModel.getModule()).expandPath(toPathVariableFormat));
        EclipseModuleManager.getInstance(rootModel.getModule()).registerEclipseLinkedSrcVarPath(srcUrl,path);
        rootModel.addContentEntry(srcUrl).addSourceFolder(srcUrl,isTestFolder);
      }
 else {
        getContentEntry().addSourceFolder(srcUrl,isTestFolder);
      }
      rearrangeOrderEntryOfType(rootModel,ModuleSourceOrderEntry.class);
    }
  }
 else   if (kind.equals(EclipseXml.OUTPUT_KIND)) {
    setupOutput(rootModel,myRootPath + "/" + path);
  }
 else   if (kind.equals(EclipseXml.LIB_KIND)) {
    final String libName=getPresentableName(path);
    final Library library=rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);
    final Library.ModifiableModel modifiableModel=library.getModifiableModel();
    modifiableModel.addRoot(expandEclipsePath2Url(path,rootModel,myCurrentRoots),OrderRootType.CLASSES);
    final String sourcePath=element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);
    if (sourcePath != null) {
      modifiableModel.addRoot(expandEclipsePath2Url(sourcePath,rootModel,myCurrentRoots),OrderRootType.SOURCES);
    }
    EJavadocUtil.appendJavadocRoots(element,rootModel,myCurrentRoots,modifiableModel);
    modifiableModel.commit();
    setLibraryEntryExported(rootModel,exported,library);
  }
 else   if (kind.equals(EclipseXml.VAR_KIND)) {
    int slash=path.indexOf("/");
    if (slash == 0) {
      throw new ConversionException("Incorrect 'classpathentry/var@path' format");
    }
    final String libName=getPresentableName(path);
    final Library library=rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);
    final Library.ModifiableModel modifiableModel=library.getModifiableModel();
    final String url=eclipseVariabledPath2Url(rootModel,usedVariables,path,0);
    modifiableModel.addRoot(url,OrderRootType.CLASSES);
    EclipseModuleManager.getInstance(rootModel.getModule()).registerEclipseVariablePath(url,path);
    final String srcPathAttr=element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);
    if (srcPathAttr != null) {
      final String srcUrl=eclipseVariabledPath2Url(rootModel,usedVariables,srcPathAttr,srcVarStart(srcPathAttr));
      modifiableModel.addRoot(srcUrl,OrderRootType.SOURCES);
      EclipseModuleManager.getInstance(rootModel.getModule()).registerEclipseSrcVariablePath(srcUrl,srcPathAttr);
    }
    EJavadocUtil.appendJavadocRoots(element,rootModel,myCurrentRoots,modifiableModel);
    modifiableModel.commit();
    setLibraryEntryExported(rootModel,exported,library);
  }
 else   if (kind.equals(EclipseXml.CON_KIND)) {
    if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {
      addNamedLibrary(rootModel,unknownLibraries,exported,IdeaXml.ECLIPSE_LIBRARY,LibraryTablesRegistrar.APPLICATION_LEVEL);
    }
 else     if (path.startsWith(EclipseXml.JRE_CONTAINER)) {
      final String jdkName=getLastPathComponent(path);
      if (jdkName == null) {
        rootModel.inheritSdk();
      }
 else {
        final Sdk moduleJdk=ProjectJdkTable.getInstance().findJdk(jdkName);
        if (moduleJdk != null) {
          rootModel.setSdk(moduleJdk);
        }
 else {
          rootModel.setInvalidSdk(jdkName,IdeaXml.JAVA_SDK_TYPE);
          unknownJdks.add(jdkName);
        }
      }
      rearrangeOrderEntryOfType(rootModel,JdkOrderEntry.class);
    }
 else     if (path.startsWith(EclipseXml.USER_LIBRARY)) {
      addNamedLibrary(rootModel,unknownLibraries,exported,getPresentableName(path),LibraryTablesRegistrar.PROJECT_LEVEL);
    }
 else     if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {
      final String junitName=IdeaXml.JUNIT + getPresentableName(path);
      final Library library=rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);
      final Library.ModifiableModel modifiableModel=library.getModifiableModel();
      modifiableModel.addRoot(getJunitClsUrl(junitName.contains("4")),OrderRootType.CLASSES);
      modifiableModel.commit();
    }
 else {
      EclipseModuleManager.getInstance(rootModel.getModule()).registerUnknownCons(path);
      addNamedLibrary(rootModel,new ArrayList<String>(),exported,path,LibraryTablesRegistrar.APPLICATION_LEVEL);
    }
  }
 else {
    throw new ConversionException("Unknown classpathentry/@kind: " + kind);
  }
}
