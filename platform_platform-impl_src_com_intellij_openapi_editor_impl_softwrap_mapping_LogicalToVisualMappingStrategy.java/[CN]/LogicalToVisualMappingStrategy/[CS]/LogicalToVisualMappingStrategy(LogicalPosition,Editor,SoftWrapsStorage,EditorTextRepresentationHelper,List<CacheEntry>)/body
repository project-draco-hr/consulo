{
  super(new Computable<Pair<CacheEntry,VisualPosition>>(){
    @Override public Pair<CacheEntry,VisualPosition> compute(){
      int start=0;
      int end=cache.size() - 1;
      while (start <= end) {
        int i=(end + start) >>> 1;
        CacheEntry cacheEntry=cache.get(i);
        if (cacheEntry.endLogicalLine < logical.line || (cacheEntry.endLogicalLine == logical.line && storage.getSoftWrap(cacheEntry.endOffset) != null && cacheEntry.endLogicalColumn <= logical.column)) {
          start=i + 1;
          continue;
        }
        if (cacheEntry.startLogicalLine > logical.line || (cacheEntry.startLogicalLine == logical.line && cacheEntry.startLogicalColumn > logical.column)) {
          end=i - 1;
          continue;
        }
        if (cacheEntry.endLogicalLine == logical.line && cacheEntry.endLogicalColumn == logical.column && i < cache.size() - 1) {
          CacheEntry nextLineCacheEntry=cache.get(i + 1);
          if (nextLineCacheEntry.startLogicalLine == logical.line && nextLineCacheEntry.startLogicalColumn == logical.column) {
            return new Pair<CacheEntry,VisualPosition>(nextLineCacheEntry,null);
          }
        }
        return new Pair<CacheEntry,VisualPosition>(cacheEntry,null);
      }
      throw new IllegalStateException(String.format("Can't map logical position (%s) to visual position. Reason: no cached information information about target visual " + "line is found. Registered entries: %s",logical,cache));
    }
  }
,editor,storage,representationHelper);
  myTargetLogical=logical;
}
