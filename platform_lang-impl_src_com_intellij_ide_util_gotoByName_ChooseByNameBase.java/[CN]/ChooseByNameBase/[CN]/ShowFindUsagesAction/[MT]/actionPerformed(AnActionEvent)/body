{
  cancelListUpdater();
  final UsageViewPresentation presentation=new UsageViewPresentation();
  final String prefixPattern=myFindUsagesTitle + " \'" + myTextField.getText().trim()+ "\'";
  final String nonPrefixPattern=myFindUsagesTitle + " \'*" + myTextField.getText().trim()+ "*\'";
  presentation.setCodeUsagesString(prefixPattern);
  presentation.setUsagesInGeneratedCodeString(prefixPattern + " in generated code");
  presentation.setDynamicUsagesString(nonPrefixPattern);
  presentation.setTabName(prefixPattern);
  presentation.setTabText(prefixPattern);
  presentation.setTargetsNodeText("Unsorted " + StringUtil.toLowerCase(prefixPattern.toLowerCase()));
  final Object[][] elements=getElements();
  final List<PsiElement> targets=new ArrayList<PsiElement>();
  final List<Usage> usages=new ArrayList<Usage>();
  fillUsages(Arrays.asList(elements[0]),usages,targets,false);
  fillUsages(Arrays.asList(elements[1]),usages,targets,true);
  if (myListModel.contains(EXTRA_ELEM)) {
    final String text=myTextField.getText();
    final boolean everywhere=myCheckBox.isSelected();
    final LinkedHashSet<Object> prefixMatchElementsArray=new LinkedHashSet<Object>();
    final LinkedHashSet<Object> nonPrefixMatchElementsArray=new LinkedHashSet<Object>();
    hideHint();
    ProgressManager.getInstance().run(new Task.Modal(myProject,prefixPattern,true){
      private ChooseByNameBase.CalcElementsThread myCalcUsagesThread;
      @Override public void run(      @NotNull final ProgressIndicator indicator){
        ensureNamesLoaded(everywhere);
        indicator.setIndeterminate(true);
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          @Override public void run(){
            final boolean[] overFlow={false};
            myCalcUsagesThread=new CalcElementsThread(text,everywhere,null,ModalityState.NON_MODAL,false){
              private final AtomicBoolean userAskedToAbort=new AtomicBoolean();
              @Override protected boolean isOverflow(              @NotNull Set<Object> elementsArray){
                if (elementsArray.size() > UsageLimitUtil.USAGES_LIMIT - myMaximumListSizeLimit && !userAskedToAbort.getAndSet(true)) {
                  final UsageLimitUtil.Result ret=UsageLimitUtil.showTooManyUsagesWarning(myProject,UsageViewBundle.message("find.excessive.usage.count.prompt",elementsArray.size() + myMaximumListSizeLimit,StringUtil.pluralize(presentation.getUsagesWord())),presentation);
                  if (ret == UsageLimitUtil.Result.ABORT) {
                    overFlow[0]=true;
                    return true;
                  }
                }
                return false;
              }
            }
;
            boolean anyPlace=isSearchInAnyPlace();
            setSearchInAnyPlace(false);
            myCalcUsagesThread.addElementsByPattern(text,prefixMatchElementsArray,indicator,everywhere);
            setSearchInAnyPlace(anyPlace);
            if (anyPlace && !overFlow[0]) {
              myCalcUsagesThread.addElementsByPattern(text,nonPrefixMatchElementsArray,indicator,everywhere);
              nonPrefixMatchElementsArray.removeAll(prefixMatchElementsArray);
            }
            indicator.setText("Prepare...");
            fillUsages(prefixMatchElementsArray,usages,targets,false);
            fillUsages(nonPrefixMatchElementsArray,usages,targets,true);
          }
        }
);
      }
      @Override public void onSuccess(){
        showUsageView(targets,usages,presentation);
      }
      @Override public void onCancel(){
        myCalcUsagesThread.cancel();
      }
    }
);
  }
 else {
    hideHint();
    showUsageView(targets,usages,presentation);
  }
}
