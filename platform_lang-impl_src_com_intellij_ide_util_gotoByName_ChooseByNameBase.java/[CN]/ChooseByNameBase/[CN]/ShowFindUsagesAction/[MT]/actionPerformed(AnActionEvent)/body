{
  cancelCalcElementsThread();
  cancelListUpdater();
  final UsageViewPresentation presentation=new UsageViewPresentation();
  final String pattern=myFindUsagesTitle + " \'" + myTextField.getText().trim()+ "\'";
  presentation.setCodeUsagesString(pattern);
  presentation.setTabName(pattern);
  presentation.setTabText(pattern);
  presentation.setTargetsNodeText("Unsorted " + StringUtil.toLowerCase(pattern.toLowerCase()));
  final PsiElement[] elements=getElements();
  final List<UsageInfo> usageInfos=new ArrayList<UsageInfo>();
  final List<PsiElement> targets=new ArrayList<PsiElement>();
  for (  PsiElement element : elements) {
    if (element.getTextRange() != null) {
      usageInfos.add(new UsageInfo(element));
    }
 else {
      targets.add(element);
    }
  }
  final UsageInfoToUsageConverter.TargetElementsDescriptor descriptor=new UsageInfoToUsageConverter.TargetElementsDescriptor(elements);
  final UsageViewImpl usageView=(UsageViewImpl)UsageViewManager.getInstance(myProject).showUsages(targets.isEmpty() ? UsageTarget.EMPTY_ARRAY : PsiElement2UsageTargetAdapter.convert(targets.toArray(new PsiElement[targets.size()])),UsageInfoToUsageConverter.convert(descriptor,usageInfos.toArray(new UsageInfo[usageInfos.size()])),presentation);
  if (myListModel.contains(EXTRA_ELEM)) {
    final String text=myTextField.getText();
    final boolean checkboxState=myCheckBox.isSelected();
    final HashSet<Object> elementsArray=new HashSet<Object>();
    hideHint();
    ProgressManager.getInstance().run(new Task.Modal(myProject,pattern,true){
      private ChooseByNameBase.CalcElementsThread myCalcElementsThread;
      @Override public void run(      @NotNull ProgressIndicator indicator){
        ensureNamesLoaded(checkboxState);
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            myCalcElementsThread=new CalcElementsThread(text,checkboxState,null,ModalityState.NON_MODAL,true){
              @Override protected boolean isOverflow(              Set<Object> elementsArray){
                return false;
              }
            }
;
            myCalcElementsThread.addElementsByPattern(text,elementsArray,new Computable<Boolean>(){
              public Boolean compute(){
                return false;
              }
            }
);
          }
        }
);
      }
      @Override public void onSuccess(){
        for (        Object o : elementsArray) {
          if (o instanceof PsiElement) {
            if (ArrayUtil.find(elements,(PsiElement)o) > -1) {
              continue;
            }
            usageView.appendUsage(UsageInfoToUsageConverter.convert(descriptor,new UsageInfo((PsiElement)o)));
          }
        }
      }
      @Override public void onCancel(){
        if (myCalcElementsThread != null) {
          myCalcElementsThread.cancel();
        }
        usageView.close();
      }
    }
);
  }
 else {
    hideHint();
  }
}
