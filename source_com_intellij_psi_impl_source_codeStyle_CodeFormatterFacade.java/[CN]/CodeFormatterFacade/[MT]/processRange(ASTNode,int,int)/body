{
  final FileType fileType=myHelper.getFileType();
  if (useBlockFormatter(fileType)) {
    TextRange range=new TextRange(startOffset,endOffset);
    final PsiFile containingFile=SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile();
    final PsiBasedFormattingModel model=new PsiBasedFormattingModel(containingFile);
    try {
      Formatter.getInstance().format(model,createBlock(containingFile),mySettings,mySettings.getIndentOptions(fileType),range);
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
    return element;
  }
  if (useNewFormatter(fileType)) {
    PseudoTextBuilder pseudoTextBuilder=((LanguageFileType)fileType).getLanguage().getFormatter();
    if (pseudoTextBuilder == null) {
      return element;
    }
 else {
      try {
        final PseudoText pseudoText=pseudoTextBuilder.build(myHelper.getProject(),mySettings,SourceTreeToPsiMap.treeElementToPsi(element));
        final PomModel model=myHelper.getProject().getModel();
        final TreeAspect aspect=model.getModelAspect(TreeAspect.class);
        model.runTransaction(new PomTransactionBase(SourceTreeToPsiMap.treeElementToPsi(element)){
          public PomModelEvent runInner() throws IncorrectOperationException {
            final PomModelEvent result=new PomModelEvent(model);
            final FileElement fileElement=getFileElement(element);
            GeneralCodeFormatter.createSimpleInstance(pseudoText,mySettings,fileType,startOffset,endOffset,result).format();
            TreeUtil.clearCaches(fileElement);
            return result;
          }
          private FileElement getFileElement(          final ASTNode element){
            return (FileElement)SourceTreeToPsiMap.psiElementToTree(SourceTreeToPsiMap.treeElementToPsi(element).getContainingFile());
          }
        }
,aspect);
      }
 catch (      ProcessCanceledException processCanceledException) {
        throw processCanceledException;
      }
catch (      Exception e) {
        LOG.error(e);
      }
      formatComments(element,startOffset,endOffset);
      return element;
    }
  }
  final TextRange range=element.getTextRange();
  final int elementStartOffset=range.getStartOffset();
  return processRange(element,new int[]{startOffset - elementStartOffset,endOffset - elementStartOffset});
}
