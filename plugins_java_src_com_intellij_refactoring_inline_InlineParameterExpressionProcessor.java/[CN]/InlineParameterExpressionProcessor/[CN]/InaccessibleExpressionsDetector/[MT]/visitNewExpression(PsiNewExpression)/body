{
  super.visitNewExpression(expression);
  final PsiJavaCodeReferenceElement reference=expression.getClassOrAnonymousClassReference();
  if (reference != null) {
    final PsiElement resolved=reference.resolve();
    if (resolved instanceof PsiClass) {
      final PsiClass refClass=(PsiClass)resolved;
      final String classUnavailableMessage="Parameter initializer depends on " + RefactoringUIUtil.getDescription(refClass,true) + " which is not available inside method and cannot be inlined";
      if (!PsiUtil.isAccessible(refClass,myMethod,null)) {
        myConflicts.putValue(expression,classUnavailableMessage);
      }
 else {
        final PsiClass methodContainingClass=myMethod.getContainingClass();
        LOG.assertTrue(methodContainingClass != null);
        if (!PsiTreeUtil.isAncestor(myMethod,refClass,false)) {
          PsiElement parent=refClass;
          while ((parent=parent.getParent()) instanceof PsiClass) {
            if (!PsiUtil.isAccessible((PsiClass)parent,myMethod,null)) {
              break;
            }
          }
          if (!(parent instanceof PsiFile)) {
            myConflicts.putValue(expression,classUnavailableMessage);
          }
        }
      }
    }
  }
}
