{
  PsiParameter[] parameters=targetMethod.getParameterList().getParameters();
  List<ParameterInfoImpl> result=new ArrayList<ParameterInfoImpl>();
  if (expressions.length < parameters.length) {
    int ei=0;
    int pi=0;
    while (ei < expressions.length && pi < parameters.length) {
      PsiExpression expression=expressions[ei];
      PsiParameter parameter=parameters[pi];
      PsiType paramType=substitutor.substitute(parameter.getType());
      if (TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression)) {
        result.add(new ParameterInfoImpl(pi,parameter.getName(),PsiUtil.convertAnonymousToBaseType(paramType)));
        pi++;
        ei++;
      }
 else {
        pi++;
      }
    }
    if (result.size() != expressions.length)     return null;
  }
 else   if (expressions.length > parameters.length) {
    Set<String> existingNames=new HashSet<String>();
    for (    PsiParameter parameter : parameters) {
      existingNames.add(parameter.getName());
    }
    int ei=0;
    int pi=0;
    while (ei < expressions.length || pi < parameters.length) {
      PsiExpression expression=ei < expressions.length ? expressions[ei] : null;
      PsiParameter parameter=pi < parameters.length ? parameters[pi] : null;
      PsiType paramType=parameter == null ? null : substitutor.substitute(parameter.getType());
      boolean parameterAssignable=paramType != null && (expression == null || TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression));
      if (parameterAssignable) {
        result.add(new ParameterInfoImpl(pi,parameter.getName(),parameter.getType()));
        pi++;
        ei++;
      }
 else       if (expression != null) {
        PsiType exprType=RefactoringUtil.getTypeByExpression(expression);
        if (exprType == null)         return null;
        JavaCodeStyleManager codeStyleManager=JavaCodeStyleManager.getInstance(expression.getProject());
        String name=suggestUniqueParameterName(codeStyleManager,expression,exprType,existingNames);
        result.add(new ParameterInfoImpl(-1,name,exprType,expression.getText().replace('\n',' ')));
        ei++;
      }
    }
    if (result.size() != expressions.length)     return null;
  }
 else {
    for (int i=0; i < parameters.length; i++) {
      PsiParameter parameter=parameters[i];
      PsiExpression expression=expressions[i];
      PsiType paramType=substitutor.substitute(parameter.getType());
      if (TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression)) {
        result.add(new ParameterInfoImpl(i,parameter.getName(),paramType));
      }
 else {
        PsiType exprType=RefactoringUtil.getTypeByExpression(expression);
        if (exprType == null)         return null;
        result.add(new ParameterInfoImpl(i,parameter.getName(),exprType));
      }
    }
    boolean isSilly=true;
    for (int i=0; i < result.size(); i++) {
      PsiParameter parameter=parameters[i];
      PsiType paramType=substitutor.substitute(parameter.getType());
      ParameterInfoImpl parameterInfo=result.get(i);
      String typeText=parameterInfo.getTypeText();
      if (!paramType.equalsToText(typeText)) {
        isSilly=false;
        break;
      }
    }
    if (isSilly)     return null;
  }
  return result.toArray(new ParameterInfoImpl[result.size()]);
}
