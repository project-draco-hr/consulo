{
  final Class[] patternClasses=getPatternClasses(supportId);
  final Set<Method> staticMethods=new THashSet<Method>(ContainerUtil.concat(patternClasses,new Function<Class,Collection<? extends Method>>(){
    public Collection<Method> fun(    final Class aClass){
      return ContainerUtil.findAll(ReflectionCache.getMethods(aClass),new Condition<Method>(){
        public boolean value(        final Method method){
          return Modifier.isStatic(method.getModifiers()) && Modifier.isPublic(method.getModifiers()) && !Modifier.isAbstract(method.getModifiers())&& ElementPattern.class.isAssignableFrom(method.getReturnType());
        }
      }
);
    }
  }
));
  try {
    return createElementPatternNoGroovy(text,new Function<Frame,Object>(){
      public Object fun(      final Frame frame){
        try {
          return invokeMethod(frame.target,frame.methodName,frame.params.toArray(),staticMethods);
        }
 catch (        Throwable throwable) {
          throw new RuntimeException(throwable);
        }
      }
    }
);
  }
 catch (  Exception ex) {
    final Throwable cause=ex.getCause() != null ? ex.getCause() : ex;
    Configuration.LOG.warn("error processing place: " + displayName + " ["+ text+ "]",cause);
    return null;
  }
}
