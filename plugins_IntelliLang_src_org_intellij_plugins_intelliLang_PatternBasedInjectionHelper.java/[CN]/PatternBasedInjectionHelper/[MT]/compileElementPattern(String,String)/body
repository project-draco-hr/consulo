{
  final Class[] patternClasses=getPatternClasses(supportId);
  final Set<Method> staticMethods=new THashSet<Method>(ContainerUtil.concat(patternClasses,new Function<Class,Collection<? extends Method>>(){
    public Collection<Method> fun(    final Class aClass){
      return ContainerUtil.findAll(ReflectionCache.getMethods(aClass),new Condition<Method>(){
        public boolean value(        final Method method){
          return Modifier.isStatic(method.getModifiers()) && Modifier.isPublic(method.getModifiers()) && !Modifier.isAbstract(method.getModifiers())&& ElementPattern.class.isAssignableFrom(method.getReturnType());
        }
      }
);
    }
  }
));
  return createElementPatternNoGroovy(text,new Function<Frame,Object>(){
    public Object fun(    final Frame frame){
      try {
        return invokeMethod(frame.target,frame.methodName,frame.params.toArray(),staticMethods);
      }
 catch (      Throwable throwable) {
        throw new IllegalArgumentException(text,throwable);
      }
    }
  }
);
}
