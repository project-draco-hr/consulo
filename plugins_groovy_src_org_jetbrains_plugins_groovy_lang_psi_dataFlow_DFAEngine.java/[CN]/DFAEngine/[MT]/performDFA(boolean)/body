{
  long startTime=System.currentTimeMillis();
  ArrayList<E> info=new ArrayList<E>(myFlow.length);
  CallEnvironment env=new MyCallEnvironment(myFlow.length);
  for (int i=0; i < myFlow.length; i++) {
    info.add(myDfa.initial());
  }
  boolean[] visited=new boolean[myFlow.length];
  final boolean forward=myDfa.isForward();
  int[] order=ControlFlowBuilderUtil.postorder(myFlow);
  for (int i=forward ? 0 : myFlow.length - 1; forward ? i < myFlow.length : i >= 0; ) {
    Instruction instr=myFlow[order[i]];
    if (!visited[instr.num()]) {
      Queue<Instruction> workList=new LinkedList<Instruction>();
      workList.add(instr);
      visited[instr.num()]=true;
      while (!workList.isEmpty()) {
        if (timeout && System.currentTimeMillis() - startTime > ourTimeLimit)         return null;
        ProgressManager.checkCanceled();
        final Instruction curr=workList.remove();
        final int num=curr.num();
        final E oldE=info.get(num);
        E newE=join(curr,info,env);
        myDfa.fun(newE,curr);
        if (!mySemilattice.eq(newE,oldE)) {
          info.set(num,newE);
          for (          Instruction next : getNext(curr,env)) {
            workList.add(next);
            visited[next.num()]=true;
          }
        }
      }
    }
    if (forward)     i++;
 else     i--;
  }
  return info;
}
