{
  ArrayList<E> info=new ArrayList<E>(myFlow.length);
  ArrayList<Stack<CallInstruction>> env=new ArrayList<Stack<CallInstruction>>(myFlow.length);
  for (int i=0; i < myFlow.length; i++) {
    info.add(myDfa.initial());
    env.add(new Stack<CallInstruction>());
  }
  boolean[] visited=new boolean[myFlow.length];
  final boolean forward=myDfa.isForward();
  for (int i=forward ? 0 : myFlow.length - 1; forward ? i < myFlow.length : i >= 0; ) {
    Instruction instr=myFlow[i];
    if (!visited[instr.num() - 1]) {
      Queue<Instruction> worklist=new LinkedList<Instruction>();
      worklist.add(instr);
      visited[instr.num() - 1]=true;
      while (!worklist.isEmpty()) {
        final Instruction curr=worklist.remove();
        final int num=curr.num() - 1;
        final E oldE=info.get(num);
        E newE=join(curr,info,env);
        myDfa.fun(newE,curr);
        if (!mySemilattice.eq(newE,oldE)) {
          info.set(num,newE);
          for (          Instruction next : getNext(curr,env)) {
            worklist.add(next);
            visited[next.num() - 1]=true;
          }
        }
      }
    }
    if (forward)     i++;
 else     i--;
  }
  return info;
}
