{
  char yy_lookahead;
  int yy_anchor=YY_NO_ANCHOR;
  int yy_state=yy_state_dtrans[yy_lexical_state];
  int yy_next_state=YY_NO_STATE;
  int yy_last_accept_state=YY_NO_STATE;
  boolean yy_initial=true;
  int yy_this_accept;
  yy_buffer_start=yy_buffer_index;
  yy_this_accept=yy_acpt[yy_state];
  if (YY_NOT_ACCEPT != yy_this_accept) {
    yy_last_accept_state=yy_state;
    yy_buffer_end=yy_buffer_index;
  }
  while (true) {
    if (yy_buffer_index < yy_buffer_length) {
      yy_lookahead=yy_buffer[yy_buffer_index++];
      if (yy_lookahead < 0 || yy_lookahead > 127) {
        if (Character.isJavaIdentifierStart(yy_lookahead)) {
          yy_lookahead='A';
        }
 else         if (Character.isJavaIdentifierPart(yy_lookahead)) {
          yy_lookahead='9';
        }
 else {
          yy_lookahead='#';
        }
      }
    }
 else {
      yy_lookahead=YYEOF;
    }
    yy_next_state=YY_F;
    if (YYEOF != yy_lookahead) {
      yy_next_state=yy_nxt[yy_rmap[yy_state]][yy_cmap[yy_lookahead]];
    }
    if (YY_F != yy_next_state) {
      yy_state=yy_next_state;
      yy_initial=false;
      yy_this_accept=yy_acpt[yy_state];
      if (YY_NOT_ACCEPT != yy_this_accept) {
        yy_last_accept_state=yy_state;
        yy_buffer_end=yy_buffer_index;
      }
    }
 else {
      if (YYEOF == yy_lookahead && true == yy_initial) {
        myTokenType=null;
        return;
      }
 else       if (YY_NO_STATE == yy_last_accept_state) {
        throw (new Error("Lexical Error: Unmatched Input."));
      }
 else {
        yy_buffer_index=yy_buffer_end;
        yy_anchor=yy_acpt[yy_last_accept_state];
        if (0 != (YY_END & yy_anchor)) {
          --yy_buffer_end;
        }
        if (0 != (YY_START & yy_anchor)) {
          ++yy_buffer_start;
        }
switch (yy_last_accept_state) {
case 0:
{
            myTokenType=XmlTokenType.XML_DATA_CHARACTERS;
            return;
          }
case -2:
        break;
case 1:
{
        myTokenType=XmlTokenType.XML_WHITE_SPACE;
        return;
      }
case -3:
    break;
case 2:
{
    myTokenType=XmlTokenType.XML_START_TAG_START;
    yy_lexical_state=START_TAG_NAME;
    return;
  }
case -4:
break;
case 4:
{
myTokenType=XmlTokenType.XML_END_TAG_START;
yy_lexical_state=END_TAG_NAME;
return;
}
case -5:
break;
case 5:
{
myTokenType=XmlTokenType.XML_COMMENT_START;
yy_lexical_state=COMMENT;
return;
}
case -6:
break;
case 6:
{
myTokenType=XmlTokenType.XML_DOCTYPE_START;
yy_lexical_state=DOC_TYPE;
return;
}
case -7:
break;
case 7:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -8:
break;
case 8:
{
myTokenType=XmlTokenType.XML_DOCTYPE_END;
yy_lexical_state=YYINITIAL;
return;
}
case -9:
break;
case 9:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -10:
break;
case 10:
{
myTokenType=XmlTokenType.XML_NAME;
return;
}
case -11:
break;
case 11:
{
myTokenType=XmlTokenType.XML_DOCTYPE_PUBLIC;
return;
}
case -12:
break;
case 12:
{
myTokenType=XmlTokenType.XML_COMMENT_CHARACTERS;
return;
}
case -13:
break;
case 13:
{
myTokenType=XmlTokenType.XML_COMMENT_END;
yy_lexical_state=YYINITIAL;
return;
}
case -14:
break;
case 14:
{
myTokenType=XmlTokenType.XML_NAME;
yy_lexical_state=TAG_ATTRIBUTES;
return;
}
case -15:
break;
case 15:
{
yy_lexical_state=YYINITIAL;
--yy_buffer_index;
break;
}
case -16:
break;
case 16:
{
myTokenType=XmlTokenType.XML_DATA_CHARACTERS;
return;
}
case -17:
break;
case 17:
{
myTokenType=XmlTokenType.XML_NAME;
return;
}
case -18:
break;
case 18:
{
yy_lexical_state=YYINITIAL;
--yy_buffer_index;
}
case -19:
break;
case 19:
{
myTokenType=XmlTokenType.XML_EQ;
yy_lexical_state=ATTRIBUTE_VALUE_START;
return;
}
case -20:
break;
case 20:
{
myTokenType=XmlTokenType.XML_TAG_END;
yy_lexical_state=YYINITIAL;
return;
}
case -21:
break;
case 21:
{
myTokenType=XmlTokenType.XML_EMPTY_ELEMENT_END;
yy_lexical_state=YYINITIAL;
return;
}
case -22:
break;
case 22:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
yy_lexical_state=TAG_ATTRIBUTES;
return;
}
case -23:
break;
case 23:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER;
yy_lexical_state=ATTRIBUTE_VALUE_DQ;
return;
}
case -24:
break;
case 24:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER;
yy_lexical_state=ATTRIBUTE_VALUE_SQ;
return;
}
case -25:
break;
case 25:
{
myTokenType=XmlTokenType.XML_TAG_END;
yy_lexical_state=YYINITIAL;
return;
}
case -26:
break;
case 26:
{
myTokenType=XmlTokenType.XML_EMPTY_ELEMENT_END;
yy_lexical_state=YYINITIAL;
return;
}
case -27:
break;
case 27:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -28:
break;
case 28:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER;
yy_lexical_state=TAG_ATTRIBUTES;
return;
}
case -29:
break;
case 29:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -30:
break;
case 30:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -31:
break;
case 31:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -32:
break;
case 32:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER;
yy_lexical_state=TAG_ATTRIBUTES;
return;
}
case -33:
break;
case 33:
{
myTokenType=XmlTokenType.XML_DATA_CHARACTERS;
return;
}
case -34:
break;
case 35:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -35:
break;
case 36:
{
myTokenType=XmlTokenType.XML_COMMENT_CHARACTERS;
return;
}
case -36:
break;
case 37:
{
myTokenType=XmlTokenType.XML_DATA_CHARACTERS;
return;
}
case -37:
break;
case 38:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
yy_lexical_state=TAG_ATTRIBUTES;
return;
}
case -38:
break;
case 39:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -39:
break;
case 40:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -40:
break;
case 41:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -41:
break;
case 42:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -42:
break;
case 44:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -43:
break;
case 45:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -44:
break;
case 46:
{
myTokenType=XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN;
return;
}
case -45:
break;
case 48:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -46:
break;
case 50:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -47:
break;
case 52:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -48:
break;
case 54:
{
myTokenType=XmlTokenType.XML_BAD_CHARACTER;
return;
}
case -49:
break;
default :
yy_error(YY_E_INTERNAL,false);
case -1:
}
yy_initial=true;
yy_state=yy_state_dtrans[yy_lexical_state];
yy_next_state=YY_NO_STATE;
yy_last_accept_state=YY_NO_STATE;
yy_buffer_start=yy_buffer_index;
yy_this_accept=yy_acpt[yy_state];
if (YY_NOT_ACCEPT != yy_this_accept) {
yy_last_accept_state=yy_state;
}
}
}
}
}
