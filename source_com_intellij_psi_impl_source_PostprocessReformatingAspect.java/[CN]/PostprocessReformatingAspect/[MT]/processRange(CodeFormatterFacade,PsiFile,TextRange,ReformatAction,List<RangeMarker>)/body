{
switch (accumulatedRangeAction) {
case REFORMAT:
    processReformat(codeFormatter,psiFile,accumulatedTextRange);
  break;
case REINDENT:
{
  final Document document=psiFile.getViewProvider().getDocument();
  final CharSequence charsSequence=document.getCharsSequence().subSequence(accumulatedTextRange.getStartOffset(),accumulatedTextRange.getEndOffset());
  final TextRange[] whitespaces=CharArrayUtil.getIndents(charsSequence,accumulatedTextRange.getStartOffset());
  if (whitespaces.length > 0 && isHeadingWhitespace(whitespaces[whitespaces.length - 1],charsSequence,accumulatedTextRange.getStartOffset())) {
    final int indentAdjustment=getIndentAdjustment(psiFile,whitespaces[whitespaces.length - 1]);
    if (indentAdjustment != 0)     adjustIndentationInRange(psiFile,document,whitespaces,indentAdjustment);
  }
  TextRange mergedRange=null;
  for (  final RangeMarker postIndentReformatRange : postIndentReformatRanges) {
    if (mergedRange == null)     mergedRange=new TextRange(postIndentReformatRange.getStartOffset(),postIndentReformatRange.getEndOffset());
 else     if (mergedRange.getStartOffset() <= postIndentReformatRange.getEndOffset())     mergedRange=new TextRange(Math.min(mergedRange.getStartOffset(),postIndentReformatRange.getStartOffset()),Math.max(mergedRange.getEndOffset(),postIndentReformatRange.getEndOffset()));
 else     processReformat(codeFormatter,psiFile,mergedRange);
  }
  if (mergedRange != null)   processReformat(codeFormatter,psiFile,mergedRange);
  postIndentReformatRanges.clear();
  break;
}
}
}
