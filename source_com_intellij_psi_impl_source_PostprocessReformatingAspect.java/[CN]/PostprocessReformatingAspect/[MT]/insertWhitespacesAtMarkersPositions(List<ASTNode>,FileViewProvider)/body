{
  for (  final ASTNode node : new ArrayList<ASTNode>(astNodes)) {
    final FileElement fileElement=TreeUtil.getFileElement((TreeElement)node);
    if (fileElement != null && ((PsiFile)fileElement.getPsi()).getViewProvider() == key) {
      ((TreeElement)node).acceptTree(new RecursiveTreeElementVisitor(){
        protected boolean visitNode(        TreeElement element){
          if (element.getElementType() == ElementType.REFORMAT_MARKER) {
            final ASTNode prev=TreeUtil.prevLeaf(element);
            ASTNode next=TreeUtil.nextLeaf(element);
            if ((prev == null || prev.getElementType() != ElementType.WHITE_SPACE) && (next == null || next.getElementType() != ElementType.WHITE_SPACE)) {
switch (getSpaceRequirements(prev,next)) {
case MUST_NOT:
                element.getTreeParent().removeChild(element);
              break;
case MAY:
            return false;
case MUST:
{
            final LeafElement generatedWhitespace=Factory.createSingleLeafElement(ElementType.WHITE_SPACE,new char[]{' '},0,1,null,key.getManager());
            element.getTreeParent().replaceChild(element,generatedWhitespace);
            astNodes.add(generatedWhitespace);
            break;
          }
case MUST_LINE_BREAK:
{
          final LeafElement generatedWhitespace=Factory.createSingleLeafElement(ElementType.WHITE_SPACE,new char[]{' '},0,1,null,key.getManager());
          element.getTreeParent().replaceChild(element,generatedWhitespace);
          astNodes.add(generatedWhitespace);
          break;
        }
    }
  }
 else {
    element.getTreeParent().removeChild(element);
    boolean nextToWhitespace=false;
    if (prev != null && prev.getElementType() == ElementType.WHITE_SPACE) {
      nextToWhitespace=true;
      astNodes.add(prev);
      CodeEditUtil.setNodeGenerated(prev,true);
    }
    if (next != null && next.getElementType() == ElementType.WHITE_SPACE) {
      if (!nextToWhitespace) {
        if (prev != null && ElementType.COMMENT_BIT_SET.contains(prev.getElementType()) && next.getText().indexOf('\n') < 0) {
          final String whitespaceText="\n" + next.getText();
          final LeafElement generatedWhitespace=Factory.createSingleLeafElement(ElementType.WHITE_SPACE,whitespaceText.toCharArray(),0,whitespaceText.length(),null,key.getManager());
          next.getTreeParent().replaceChild(next,generatedWhitespace);
          next=generatedWhitespace;
        }
        astNodes.add(next);
        CodeEditUtil.setNodeGenerated(next,true);
      }
 else       next.getTreeParent().removeChild(next);
    }
  }
  astNodes.remove(element);
  return false;
}
return true;
}
}
);
}
 else astNodes.remove(node);
}
}
