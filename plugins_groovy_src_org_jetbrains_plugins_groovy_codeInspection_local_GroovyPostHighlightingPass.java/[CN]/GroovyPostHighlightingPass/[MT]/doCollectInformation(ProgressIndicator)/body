{
  final InspectionProfile profile=InspectionProjectProfileManager.getInstance(myProject).getInspectionProfile();
  final boolean deadCodeEnabled=profile.isToolEnabled(HighlightDisplayKey.find(GroovyUnusedDeclarationInspection.SHORT_NAME),myFile);
  ProjectFileIndex fileIndex=ProjectRootManager.getInstance(myProject).getFileIndex();
  VirtualFile virtualFile=myFile.getViewProvider().getVirtualFile();
  if (!fileIndex.isInContent(virtualFile)) {
    return;
  }
  final UnusedDeclarationInspection deadCodeInspection=(UnusedDeclarationInspection)profile.getUnwrappedTool(UnusedDeclarationInspection.SHORT_NAME,myFile);
  final GlobalUsageHelper usageHelper=new GlobalUsageHelper(){
    public boolean isCurrentFileAlreadyChecked(){
      return false;
    }
    public boolean isLocallyUsed(    @NotNull PsiNamedElement member){
      return false;
    }
    @Override public boolean shouldCheckUsages(    @NotNull PsiMember member){
      return deadCodeInspection == null || !deadCodeInspection.isEntryPoint(member);
    }
  }
;
  final List<HighlightInfo> unusedDeclarations=new ArrayList<HighlightInfo>();
  final Map<GrParameter,Boolean> usedParams=new HashMap<GrParameter,Boolean>();
  myFile.accept(new PsiRecursiveElementWalkingVisitor(){
    @Override public void visitElement(    PsiElement element){
      if (element instanceof GrReferenceElement) {
        for (        GroovyResolveResult result : ((GrReferenceElement)element).multiResolve(true)) {
          PsiElement resolved=result.getElement();
          if (resolved instanceof GrParameter && resolved.getContainingFile() == myFile) {
            usedParams.put((GrParameter)resolved,Boolean.TRUE);
          }
        }
      }
      if (deadCodeEnabled && element instanceof GrNamedElement && !PostHighlightingPass.isImplicitUsage((GrNamedElement)element,progress)) {
        PsiElement nameId=((GrNamedElement)element).getNameIdentifierGroovy();
        if (nameId.getNode().getElementType() == GroovyTokenTypes.mIDENT) {
          String name=((GrNamedElement)element).getName();
          if (element instanceof GrTypeDefinition && !PostHighlightingPass.isClassUsed((GrTypeDefinition)element,progress,usageHelper)) {
            HighlightInfo highlightInfo=PostHighlightingPass.createUnusedSymbolInfo(nameId,"Class " + name + " is unused",HighlightInfoType.UNUSED_SYMBOL);
            QuickFixAction.registerQuickFixAction(highlightInfo,new SafeDeleteFix(element));
            unusedDeclarations.add(highlightInfo);
          }
 else           if (element instanceof GrMethod) {
            GrMethod method=(GrMethod)element;
            if (!PostHighlightingPass.isMethodReferenced(method,progress,usageHelper)) {
              String message=(method.isConstructor() ? "Constructor" : "Method") + " " + name+ " is unused";
              HighlightInfo highlightInfo=PostHighlightingPass.createUnusedSymbolInfo(nameId,message,HighlightInfoType.UNUSED_SYMBOL);
              QuickFixAction.registerQuickFixAction(highlightInfo,new SafeDeleteFix(method));
              unusedDeclarations.add(highlightInfo);
            }
          }
 else           if (element instanceof GrField && isFieldUnused((GrField)element,progress,usageHelper)) {
            HighlightInfo highlightInfo=PostHighlightingPass.createUnusedSymbolInfo(nameId,"Property " + name + " is unused",HighlightInfoType.UNUSED_SYMBOL);
            QuickFixAction.registerQuickFixAction(highlightInfo,new SafeDeleteFix(element));
            unusedDeclarations.add(highlightInfo);
          }
 else           if (element instanceof GrParameter) {
            if (!usedParams.containsKey(element)) {
              usedParams.put((GrParameter)element,Boolean.FALSE);
            }
          }
        }
      }
      super.visitElement(element);
    }
  }
);
  final Set<GrImportStatement> unusedImports=new HashSet<GrImportStatement>(PsiUtil.getValidImportStatements(myFile));
  unusedImports.removeAll(GroovyImportOptimizer.findUsedImports(myFile));
  myUnusedImports=unusedImports;
  if (deadCodeEnabled) {
    for (    GrParameter parameter : usedParams.keySet()) {
      if (usedParams.get(parameter))       continue;
      PsiElement scope=parameter.getDeclarationScope();
      if (scope instanceof GrMethod) {
        GrMethod method=(GrMethod)scope;
        if ((method.isConstructor() || method.hasModifierProperty(PsiModifier.PRIVATE) || method.hasModifierProperty(PsiModifier.STATIC)|| !method.hasModifierProperty(PsiModifier.ABSTRACT) && !isOverriddenOrOverrides(method)) && !method.hasModifierProperty(PsiModifier.NATIVE) && !HighlightMethodUtil.isSerializationRelatedMethod(method,method.getContainingClass())&& !PsiClassImplUtil.isMainOrPremainMethod(method)) {
          HighlightInfo highlightInfo=PostHighlightingPass.createUnusedSymbolInfo(parameter.getNameIdentifierGroovy(),"Parameter " + parameter.getName() + " is unused",HighlightInfoType.UNUSED_SYMBOL);
          QuickFixAction.registerQuickFixAction(highlightInfo,new RemoveUnusedGrParameterFix(parameter));
          unusedDeclarations.add(highlightInfo);
        }
      }
 else       if (scope instanceof GrClosableBlock) {
      }
    }
  }
  myUnusedDeclarations=unusedDeclarations;
  if (!unusedImports.isEmpty() && CodeInsightSettings.getInstance().OPTIMIZE_IMPORTS_ON_THE_FLY) {
    final VirtualFile vfile=myFile.getVirtualFile();
    if (vfile != null && ProjectRootManager.getInstance(myFile.getProject()).getFileIndex().isInSource(vfile)) {
      final GrImportStatement[] imports=myFile.getImportStatements();
      if (imports.length > 0) {
        final int offset=myEditor.getCaretModel().getOffset();
        if (imports[0].getTextRange().getStartOffset() <= offset && offset <= imports[imports.length - 1].getTextRange().getEndOffset()) {
          return;
        }
      }
      myOptimizeRunnable=new GroovyImportOptimizer().processFile(myFile);
    }
  }
}
