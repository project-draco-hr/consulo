{
  return new Callbacks.Backend(){
    private final Set<StringCache.S> affected=new HashSet<StringCache.S>();
    public Set<StringCache.S> getAffectedFiles(){
      return affected;
    }
    public void begin(){
      affected.clear();
    }
    public void end(){
    }
    public void associate(    final String classFileName,    final String sourceFileName,    final ClassReader cr){
      final StringCache.S classFileNameS=StringCache.get(project.getRelativePath(classFileName));
      final StringCache.S sourceFileNameS=StringCache.get(project.getRelativePath(sourceFileName));
      final Pair<ClassRepr,Set<UsageRepr.Usage>> result=ClassfileAnalyzer.analyze(classFileNameS,cr);
      final ClassRepr repr=result.fst;
      final Set<UsageRepr.Usage> localUsages=result.snd;
      for (      UsageRepr.Usage u : localUsages) {
        updateDependency(sourceFileNameS,classToSourceFile.get(u.owner));
      }
      if (repr != null) {
        classToSourceFile.put(repr.name,sourceFileNameS);
        updateSourceToClasses(sourceFileNameS,repr);
      }
      if (!localUsages.isEmpty()) {
        updateSourceToUsages(sourceFileNameS,localUsages);
      }
    }
    public void associate(    final Set<ClassRepr> classes,    final Set<UsageRepr.Usage> usages,    final String sourceFileName){
      final StringCache.S sourceFileNameS=StringCache.get(sourceFileName);
      sourceFileToClasses.put(sourceFileNameS,classes);
      sourceFileToUsages.put(sourceFileNameS,usages);
      for (      ClassRepr r : classes) {
        classToSourceFile.put(r.name,sourceFileNameS);
      }
      for (      UsageRepr.Usage u : usages) {
        updateDependency(sourceFileNameS,classToSourceFile.get(u.owner));
      }
    }
  }
;
}
