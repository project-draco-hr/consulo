{
  if (TreeUtil.isLeafOrCollapsedChameleon(root))   return;
  final List<ASTNode> comments=new SmartList<ASTNode>();
  ((TreeElement)root).acceptTree(new RecursiveTreeElementWalkingVisitor(false){
    @Override protected void visitNode(    TreeElement child){
      IElementType type=child.getElementType();
      if (type == JavaDocElementType.DOC_COMMENT || type == JavaTokenType.END_OF_LINE_COMMENT || type == JavaTokenType.C_STYLE_COMMENT) {
        comments.add(child);
      }
      if (TreeUtil.isLeafOrCollapsedChameleon(child))       return;
      super.visitNode(child);
    }
  }
);
  boolean docCommentBound=false;
  Iterator<ASTNode> iterator=comments.iterator();
  while (iterator.hasNext()) {
    ASTNode child=iterator.next();
    IElementType type=child.getElementType();
    if (type == JavaDocElementType.DOC_COMMENT) {
      if (bindDocComment((TreeElement)child)) {
        iterator.remove();
        docCommentBound=true;
      }
    }
 else     if (type == JavaTokenType.END_OF_LINE_COMMENT || type == JavaTokenType.C_STYLE_COMMENT) {
      if (bindTrailingComment((TreeElement)child))       iterator.remove();
    }
  }
  if (!docCommentBound) {
    for (    ASTNode child : comments) {
      if (child.getElementType() == JavaTokenType.END_OF_LINE_COMMENT || child.getElementType() == JavaTokenType.C_STYLE_COMMENT) {
        TreeElement next=(TreeElement)TreeUtil.skipElements(child,PRECEDING_COMMENT_OR_SPACE_BIT_SET);
        bindPrecedingComment((TreeElement)child,next);
      }
    }
  }
}
