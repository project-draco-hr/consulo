{
  Map<MethodSignature,HierarchicalMethodSignature> result=new LinkedHashMap<MethodSignature,HierarchicalMethodSignature>();
  final Map<MethodSignature,List<PsiMethod>> sameParameterErasureMethods=new THashMap<MethodSignature,List<PsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  Map<MethodSignature,HierarchicalMethodSignatureImpl> map=new THashMap<MethodSignature,HierarchicalMethodSignatureImpl>(new TObjectHashingStrategy<MethodSignature>(){
    public int computeHashCode(    MethodSignature signature){
      return MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.computeHashCode(signature);
    }
    public boolean equals(    MethodSignature o1,    MethodSignature o2){
      if (!MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.equals(o1,o2))       return false;
      List<PsiMethod> list=sameParameterErasureMethods.get(o1);
      boolean toCheckReturnType=list != null && list.size() > 1;
      if (!toCheckReturnType)       return true;
      PsiType returnType1=((MethodSignatureBackedByPsiMethod)o1).getMethod().getReturnType();
      PsiType returnType2=((MethodSignatureBackedByPsiMethod)o2).getMethod().getReturnType();
      if (returnType1 == null && returnType2 == null)       return true;
      if (returnType1 == null || returnType2 == null)       return false;
      PsiType erasure1=TypeConversionUtil.erasure(o1.getSubstitutor().substitute(returnType1));
      PsiType erasure2=TypeConversionUtil.erasure(o2.getSubstitutor().substitute(returnType2));
      return erasure1.equals(erasure2);
    }
  }
);
  for (  PsiMethod method : aClass.getMethods()) {
    if (!includePrivates && method.hasModifierProperty(PsiModifier.PRIVATE))     continue;
    final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,substitutor,isInRawContext);
    HierarchicalMethodSignatureImpl newH=new HierarchicalMethodSignatureImpl(signature);
    List<PsiMethod> list=sameParameterErasureMethods.get(signature);
    if (list == null) {
      list=new SmartList<PsiMethod>();
      sameParameterErasureMethods.put(signature,list);
    }
    list.add(method);
    result.put(signature,newH);
    map.put(signature,newH);
  }
  for (  PsiClassType superType : aClass.getSuperTypes()) {
    PsiClassType.ClassResolveResult superTypeResolveResult=superType.resolveGenerics();
    PsiClass superClass=superTypeResolveResult.getElement();
    if (superClass == null)     continue;
    if (!visited.add(superClass))     continue;
    final PsiSubstitutor superSubstitutor=superTypeResolveResult.getSubstitutor();
    PsiSubstitutor finalSubstitutor=obtainFinalSubstitutor(superClass,superSubstitutor,substitutor);
    final boolean isInRawContextSuper=(isInRawContext || PsiUtil.isRawSubstitutor(superClass,superSubstitutor)) && superClass.getTypeParameters().length != 0;
    Map<MethodSignature,HierarchicalMethodSignature> superResult=buildMethodHierarchy(superClass,finalSubstitutor,false,visited,isInRawContextSuper);
    visited.remove(superClass);
    for (    Map.Entry<MethodSignature,HierarchicalMethodSignature> entry : superResult.entrySet()) {
      HierarchicalMethodSignature hierarchicalMethodSignature=entry.getValue();
      if (!PsiUtil.isAccessible(hierarchicalMethodSignature.getMethod(),aClass,aClass))       continue;
      MethodSignature superSignature=entry.getKey();
      HierarchicalMethodSignatureImpl existing=map.get(superSignature);
      if (existing == null) {
        map.put(superSignature,copy(hierarchicalMethodSignature));
      }
 else       if (isReturnTypeIsMoreSpecificThan(hierarchicalMethodSignature,existing) && isSuperMethod(aClass,hierarchicalMethodSignature,existing)) {
        HierarchicalMethodSignatureImpl newSuper=copy(hierarchicalMethodSignature);
        mergeSupers(newSuper,existing);
        map.put(superSignature,newSuper);
      }
 else       if (isSuperMethod(aClass,existing,hierarchicalMethodSignature)) {
        mergeSupers(existing,hierarchicalMethodSignature);
      }
 else       if (!result.containsKey(superSignature)) {
        result.put(superSignature,hierarchicalMethodSignature);
      }
    }
  }
  for (  Map.Entry<MethodSignature,HierarchicalMethodSignatureImpl> entry : map.entrySet()) {
    HierarchicalMethodSignatureImpl hierarchicalMethodSignature=entry.getValue();
    MethodSignature methodSignature=entry.getKey();
    if (result.get(methodSignature) == null && PsiUtil.isAccessible(hierarchicalMethodSignature.getMethod(),aClass,aClass)) {
      result.put(methodSignature,hierarchicalMethodSignature);
    }
  }
  return result;
}
