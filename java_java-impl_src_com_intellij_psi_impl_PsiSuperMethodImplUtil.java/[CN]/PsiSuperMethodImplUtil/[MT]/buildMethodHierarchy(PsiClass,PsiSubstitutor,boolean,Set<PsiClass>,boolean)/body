{
  Map<MethodSignature,HierarchicalMethodSignature> result=new LinkedHashMap<MethodSignature,HierarchicalMethodSignature>();
  final Map<MethodSignature,List<PsiMethod>> sameParameterErasureMethods=new THashMap<MethodSignature,List<PsiMethod>>(MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY);
  Map<MethodSignature,HierarchicalMethodSignatureImpl> map=new THashMap<MethodSignature,HierarchicalMethodSignatureImpl>(new TObjectHashingStrategy<MethodSignature>(){
    public int computeHashCode(    MethodSignature signature){
      return MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.computeHashCode(signature);
    }
    public boolean equals(    MethodSignature o1,    MethodSignature o2){
      if (!MethodSignatureUtil.METHOD_PARAMETERS_ERASURE_EQUALITY.equals(o1,o2))       return false;
      List<PsiMethod> list=sameParameterErasureMethods.get(o1);
      boolean toCheckReturnType=list != null && list.size() > 1;
      if (!toCheckReturnType)       return true;
      PsiType returnType1=((MethodSignatureBackedByPsiMethod)o1).getMethod().getReturnType();
      PsiType returnType2=((MethodSignatureBackedByPsiMethod)o2).getMethod().getReturnType();
      if (returnType1 == null && returnType2 == null)       return true;
      if (returnType1 == null || returnType2 == null)       return false;
      PsiType erasure1=TypeConversionUtil.erasure(o1.getSubstitutor().substitute(returnType1));
      PsiType erasure2=TypeConversionUtil.erasure(o2.getSubstitutor().substitute(returnType2));
      return erasure1.equals(erasure2);
    }
  }
);
  for (  PsiMethod method : aClass.getMethods()) {
    if (!includePrivates && method.hasModifierProperty(PsiModifier.PRIVATE))     continue;
    final MethodSignatureBackedByPsiMethod signature=MethodSignatureBackedByPsiMethod.create(method,substitutor,isInRawContext);
    HierarchicalMethodSignatureImpl newH=new HierarchicalMethodSignatureImpl(signature);
    List<PsiMethod> list=sameParameterErasureMethods.get(signature);
    if (list == null) {
      list=new SmartList<PsiMethod>();
      sameParameterErasureMethods.put(signature,list);
    }
    list.add(method);
    result.put(signature,newH);
    map.put(signature,newH);
  }
  for (  PsiClassType superType : aClass.getSuperTypes()) {
    PsiClassType.ClassResolveResult superTypeResolveResult=superType.resolveGenerics();
    PsiClass superClass=superTypeResolveResult.getElement();
    if (superClass == null)     continue;
    if (!visited.add(superClass))     continue;
    final PsiSubstitutor superSubstitutor=superTypeResolveResult.getSubstitutor();
    PsiSubstitutor finalSubstitutor=obtainFinalSubstitutor(superClass,superSubstitutor,substitutor);
    final boolean isInRawContextSuper=(isInRawContext || PsiUtil.isRawSubstitutor(superClass,superSubstitutor)) && superClass.getTypeParameters().length != 0;
    Map<MethodSignature,HierarchicalMethodSignature> superResult=buildMethodHierarchy(superClass,finalSubstitutor,false,visited,isInRawContextSuper);
    visited.remove(superClass);
    List<Pair<MethodSignature,HierarchicalMethodSignature>> flattened=new ArrayList<Pair<MethodSignature,HierarchicalMethodSignature>>();
    for (    Map.Entry<MethodSignature,HierarchicalMethodSignature> entry : superResult.entrySet()) {
      HierarchicalMethodSignature hms=entry.getValue();
      MethodSignature signature=entry.getKey();
      PsiClass containingClass=hms.getMethod().getContainingClass();
      List<HierarchicalMethodSignature> supers=new ArrayList<HierarchicalMethodSignature>(hms.getSuperSignatures());
      for (      HierarchicalMethodSignature aSuper : supers) {
        PsiClass superContainingClass=aSuper.getMethod().getContainingClass();
        if (containingClass != null && superContainingClass != null && !containingClass.isInheritor(superContainingClass,true)) {
          flattened.add(new Pair<MethodSignature,HierarchicalMethodSignature>(signature,aSuper));
        }
      }
      putInMap(aClass,result,map,hms,signature);
    }
    for (    Pair<MethodSignature,HierarchicalMethodSignature> pair : flattened) {
      putInMap(aClass,result,map,pair.second,pair.first);
    }
  }
  for (  Map.Entry<MethodSignature,HierarchicalMethodSignatureImpl> entry : map.entrySet()) {
    HierarchicalMethodSignatureImpl hierarchicalMethodSignature=entry.getValue();
    MethodSignature methodSignature=entry.getKey();
    if (result.get(methodSignature) == null && PsiUtil.isAccessible(hierarchicalMethodSignature.getMethod(),aClass,aClass)) {
      result.put(methodSignature,hierarchicalMethodSignature);
    }
  }
  return result;
}
