{
  final PsiClass psiClass=PsiTreeUtil.getParentOfType(referenceParameterList,PsiClass.class);
  LOG.assertTrue(psiClass != null);
  final PsiClass superClass=psiClass.getSuperClass();
  LOG.assertTrue(superClass != null);
  myLabeler.getTypeEvaluator().setType(new TypeMigrationUsageInfo(superClass),migrationType);
  final Map<PsiElement,Pair<PsiReference[],PsiType>> roots=new HashMap<PsiElement,Pair<PsiReference[],PsiType>>();
  markTypeParameterUsages(psiClass,migrationType,referenceParameterList,roots);
  final Set<PsiElement> processed=new HashSet<PsiElement>();
  for (  Map.Entry<PsiElement,Pair<PsiReference[],PsiType>> entry : roots.entrySet()) {
    final PsiElement member=entry.getKey();
    final PsiType type=entry.getValue().second;
    if (member instanceof PsiParameter && ((PsiParameter)member).getDeclarationScope() instanceof PsiMethod) {
      myLabeler.migrateMethodCallExpressions(type,(PsiParameter)member,psiClass);
    }
    final PsiReference[] references=entry.getValue().first;
    for (    PsiReference usage : references) {
      myLabeler.migrateRootUsageExpression(usage,processed);
    }
  }
}
