{
  Set<PsiField> constants=new THashSet<PsiField>();
  for (Iterator<PsiExpression> iterator=foundExpr.iterator(); iterator.hasNext(); ) {
    PsiExpression expression=iterator.next();
    if (expression.getParent() instanceof PsiField) {
      final PsiField field=(PsiField)expression.getParent();
      if (field.getInitializer() == expression && field.hasModifierProperty(PsiModifier.FINAL) && field.hasModifierProperty(PsiModifier.STATIC)) {
        constants.add(field);
        iterator.remove();
      }
    }
  }
  for (Iterator<PsiField> iterator=constants.iterator(); iterator.hasNext(); ) {
    final PsiField constant=iterator.next();
    final PsiClass containingClass=constant.getContainingClass();
    if (containingClass == null)     continue;
    boolean isAccessible=PsiManager.getInstance(constant.getProject()).getResolveHelper().isAccessible(constant,originalExpression,containingClass);
    if (!isAccessible && containingClass.getQualifiedName() == null) {
      continue;
    }
    final LocalQuickFix replaceQuickFix=new LocalQuickFix(){
      public String getName(){
        return "Replace with '" + PsiFormatUtil.formatVariable(constant,PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_FQ_NAME | PsiFormatUtil.SHOW_NAME,PsiSubstitutor.EMPTY) + "'";
      }
      public void applyFix(      final Project project,      ProblemDescriptor descriptor){
        if (!CodeInsightUtil.prepareFileForWrite(originalExpression.getContainingFile()))         return;
        try {
          final PsiReferenceExpression reference=createReferenceTo(constant,originalExpression);
          originalExpression.replace(reference);
        }
 catch (        IncorrectOperationException e) {
          LOG.error(e);
        }
      }
    }
;
    String msg="Duplicate constant found";
    ProblemDescriptor problemDescriptor=manager.createProblemDescriptor(originalExpression,msg,replaceQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
    allProblems.add(problemDescriptor);
  }
}
