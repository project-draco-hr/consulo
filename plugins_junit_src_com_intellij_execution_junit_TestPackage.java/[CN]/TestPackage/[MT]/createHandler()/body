{
  final JUnitProcessHandler handler=super.createHandler();
  final MySearchForTestsTask[] tasks=new MySearchForTestsTask[1];
  handler.addProcessListener(new ProcessAdapter(){
    @Override public void startNotified(    ProcessEvent event){
      super.startNotified(event);
      final JUnitConfiguration.Data data=myConfiguration.getPersistentData();
      final TestClassFilter filter;
      try {
        filter=getClassFilter(data);
      }
 catch (      CantRunException e) {
        return;
      }
      tasks[0]=findTestsWithProgress(new FindCallback(){
        public void found(        @NotNull final Collection<PsiClass> classes,        final boolean isJunit4){
          addClassesListToJavaParameters(classes,new Function<PsiElement,String>(){
            @Nullable public String fun(            PsiElement element){
              if (element instanceof PsiClass) {
                return JavaExecutionUtil.getRuntimeQualifiedName((PsiClass)element);
              }
 else               if (element instanceof PsiMethod) {
                PsiMethod method=(PsiMethod)element;
                return JavaExecutionUtil.getRuntimeQualifiedName(method.getContainingClass()) + "," + method.getName();
              }
 else {
                return null;
              }
            }
          }
,data.getPackageName(),false,isJunit4);
        }
      }
,filter);
    }
    @Override public void processTerminated(    ProcessEvent event){
      handler.removeProcessListener(this);
      if (mySearchForTestsIndicator != null && !mySearchForTestsIndicator.isCanceled()) {
        mySearchForTestsIndicator.cancel();
        if (tasks[0] != null) {
          tasks[0].connect();
        }
      }
    }
  }
);
  return handler;
}
