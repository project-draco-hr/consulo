{
  final JUnitProcessHandler handler=super.createHandler();
  final MySearchForTestsTask[] tasks=new MySearchForTestsTask[1];
  handler.addProcessListener(new ProcessAdapter(){
    @Override public void startNotified(    ProcessEvent event){
      super.startNotified(event);
      final JUnitConfiguration.Data data=myConfiguration.getPersistentData();
      final TestClassFilter filter;
      try {
        filter=getClassFilter(data);
      }
 catch (      CantRunException e) {
        return;
      }
      tasks[0]=findTestsWithProgress(new FindCallback(){
        public void found(        @NotNull final Collection<PsiClass> classes,        final boolean isJunit4){
          try {
            addClassesListToJavaParameters(classes,new Function<PsiElement,String>(){
              @Nullable public String fun(              PsiElement element){
                if (element instanceof PsiClass) {
                  return JavaExecutionUtil.getRuntimeQualifiedName((PsiClass)element);
                }
 else                 if (element instanceof PsiMethod) {
                  PsiMethod method=(PsiMethod)element;
                  return JavaExecutionUtil.getRuntimeQualifiedName(method.getContainingClass()) + "," + method.getName();
                }
 else {
                  return null;
                }
              }
            }
,getPackage(data).getQualifiedName(),false,isJunit4);
          }
 catch (          CantRunException e) {
          }
        }
      }
,filter);
    }
    @Override public void processTerminated(    ProcessEvent event){
      handler.removeProcessListener(this);
      if (mySearchForTestsIndicator != null && !mySearchForTestsIndicator.isCanceled()) {
        if (tasks[0] != null) {
          tasks[0].finish();
        }
      }
    }
  }
);
  return handler;
}
