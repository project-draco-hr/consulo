{
  boolean expressionPossible=!isInAnnotation && !isInClass;
  if (modifiersParsed && mLT == builder.getTokenType()) {
    TypeParameters.parse(builder);
    PsiBuilder.Marker checkMarker=builder.mark();
    if (TypeSpec.parse(builder,true,expressionPossible) == fail) {
      checkMarker.rollbackTo();
    }
 else {
      checkMarker.drop();
    }
    IElementType decl=VariableDefinitions.parseDefinitions(builder,isInClass,false,false,true,modifiersParsed,false,parser);
    if (WRONGWAY.equals(decl)) {
      return WRONGWAY;
    }
    return METHOD_DEFINITION;
  }
  if (modifiersParsed) {
    PsiBuilder.Marker checkMarker=builder.mark();
    ReferenceElement.ReferenceElementResult typeResult=TypeSpec.parse(builder,false,expressionPossible);
    if (typeResult == fail) {
      checkMarker.rollbackTo();
      if (isInAnnotation) {
        builder.error(GroovyBundle.message("type.expected"));
      }
      IElementType varDecl=VariableDefinitions.parse(builder,isInClass,modifiersParsed,parser);
      if (WRONGWAY.equals(varDecl)) {
        return WRONGWAY;
      }
      return varDecl;
    }
 else {
      IElementType varDeclarationTop=VariableDefinitions.parse(builder,isInClass,modifiersParsed,false,parser);
      if (WRONGWAY.equals(varDeclarationTop)) {
        if (typeResult == mustBeType) {
          checkMarker.drop();
          return VARIABLE_DEFINITION_ERROR;
        }
        checkMarker.rollbackTo();
        if (isInAnnotation) {
          builder.error(GroovyBundle.message("type.expected"));
        }
        return VariableDefinitions.parse(builder,isInClass,modifiersParsed,false,parser);
      }
 else {
        checkMarker.drop();
        return varDeclarationTop;
      }
    }
  }
 else {
    String text=builder.getTokenText();
    if (!builder.eof() && !TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType()) && text != null && StringUtil.isNotEmpty(text) && (Character.isLowerCase((text.charAt(0))) || !Character.isLetter(text.charAt(0))) && (ParserUtils.lookAhead(builder,mIDENT,mIDENT) || ParserUtils.lookAhead(builder,mIDENT,mLPAREN))) {
      return WRONGWAY;
    }
    boolean typeParsed=false;
    if (!ParserUtils.lookAhead(builder,mIDENT,mLPAREN)) {
      typeParsed=TypeSpec.parse(builder,true,expressionPossible) != fail;
      if (!typeParsed) {
        builder.error(GroovyBundle.message("type.specification.expected"));
        return WRONGWAY;
      }
    }
    IElementType varDef=VariableDefinitions.parseDefinitions(builder,isInClass,false,false,false,typeParsed,false,parser);
    if (varDef != WRONGWAY) {
      return varDef;
    }
    if (isInClass && typeParsed) {
      return null;
    }
    return WRONGWAY;
  }
}
