{
  final List<AbstractFilePatchInProgress> patchesToSelect=changes2patches(myChangesTreeList.getSelectedChanges());
  final List<AbstractFilePatchInProgress.PatchChange> changes=getAllChanges();
  final Collection<AbstractFilePatchInProgress.PatchChange> included=getIncluded(doInitCheck,changes);
  myChangesTreeList.setChangesToDisplay(changes);
  myChangesTreeList.setIncludedChanges(included);
  if (doInitCheck) {
    myChangesTreeList.expandAll();
  }
  myChangesTreeList.repaint();
  if ((!doInitCheck) && patchesToSelect != null) {
    final List<AbstractFilePatchInProgress.PatchChange> toSelect=new ArrayList<>(patchesToSelect.size());
    for (    AbstractFilePatchInProgress.PatchChange change : changes) {
      if (patchesToSelect.contains(change.getPatchInProgress())) {
        toSelect.add(change);
      }
    }
    myChangesTreeList.select(toSelect);
  }
  myContainBasedChanges=false;
  for (  AbstractFilePatchInProgress patch : myPatches) {
    if (patch.baseExistsOrAdded()) {
      myContainBasedChanges=true;
      break;
    }
  }
}
