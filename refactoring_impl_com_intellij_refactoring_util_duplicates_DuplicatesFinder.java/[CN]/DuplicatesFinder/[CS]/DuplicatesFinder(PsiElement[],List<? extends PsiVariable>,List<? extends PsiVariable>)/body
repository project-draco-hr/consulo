{
  LOG.assertTrue(pattern.length > 0);
  myPattern=pattern;
  myPatternAsList=Arrays.asList(myPattern);
  myParameters=parameters;
  myOutputParameters=outputParameters;
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(pattern[0]);
  try {
    final ControlFlow controlFlow=ControlFlowFactory.getInstance(codeFragment.getProject()).getControlFlow(codeFragment,new LocalsControlFlowPolicy(codeFragment),false);
    int startOffset;
    int i=0;
    do {
      startOffset=controlFlow.getStartOffset(pattern[i++]);
    }
 while (startOffset < 0 && i < pattern.length);
    int endOffset;
    int j=pattern.length - 1;
    do {
      endOffset=controlFlow.getEndOffset(pattern[j--]);
    }
 while (endOffset < 0 && j >= 0);
    IntArrayList exitPoints=new IntArrayList();
    final ArrayList<PsiStatement> exitStatements=new ArrayList<PsiStatement>();
    ControlFlowUtil.findExitPointsAndStatements(controlFlow,startOffset,endOffset,exitPoints,exitStatements,ControlFlowUtil.DEFAULT_EXIT_STATEMENTS_CLASSES);
    myMultipleExitPoints=exitPoints.size() > 1;
    if (myMultipleExitPoints) {
      myParameters=new ArrayList<PsiVariable>(myParameters);
      removeParametersUsedInExitsOnly(codeFragment,exitStatements,controlFlow,startOffset,endOffset);
    }
  }
 catch (  AnalysisCanceledException e) {
  }
}
