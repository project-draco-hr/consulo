{
  LOG.assertTrue(pattern.length > 0);
  myPattern=pattern;
  myPatternAsList=Arrays.asList(myPattern);
  myParameters=parameters;
  myOutputParameters=outputParameters;
  mySkipStaticContext=maintainStaticContext && !RefactoringUtil.isInStaticContext(myPattern[0]);
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(pattern[0]);
  ControlFlowAnalyzer analyzer=new ControlFlowAnalyzer(codeFragment,new LocalsControlFlowPolicy(codeFragment),false);
  try {
    final ControlFlow controlFlow=analyzer.buildControlFlow();
    IntArrayList exitPoints=new IntArrayList();
    final ArrayList<PsiStatement> exitStatements=new ArrayList<PsiStatement>();
    ControlFlowUtil.findExitPointsAndStatements(controlFlow,controlFlow.getStartOffset(pattern[0]),controlFlow.getEndOffset(pattern[pattern.length - 1]),exitPoints,exitStatements,ControlFlowUtil.DEFAULT_EXIT_STATEMENTS_CLASSES);
    myMultipleExitPoints=exitPoints.size() > 1;
  }
 catch (  AnalysisCanceledException e) {
  }
}
