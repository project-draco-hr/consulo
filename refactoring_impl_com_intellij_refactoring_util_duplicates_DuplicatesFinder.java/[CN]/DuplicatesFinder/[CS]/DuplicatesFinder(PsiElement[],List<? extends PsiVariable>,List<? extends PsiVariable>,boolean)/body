{
  LOG.assertTrue(pattern.length > 0);
  myPattern=pattern;
  myPatternAsList=Arrays.asList(myPattern);
  myParameters=parameters;
  myOutputParameters=outputParameters;
  mySkipStaticContext=maintainStaticContext && !RefactoringUtil.isInStaticContext(myPattern[0]);
  final PsiElement codeFragment=ControlFlowUtil.findCodeFragment(pattern[0]);
  ControlFlowAnalyzer analyzer=new ControlFlowAnalyzer(codeFragment,new LocalsControlFlowPolicy(codeFragment),false);
  try {
    final ControlFlow controlFlow=analyzer.buildControlFlow();
    IntArrayList exitPoints=new IntArrayList();
    final ArrayList<PsiStatement> exitStatements=new ArrayList<PsiStatement>();
    int startOffset;
    int i=0;
    do {
      startOffset=controlFlow.getStartOffset(pattern[i++]);
    }
 while (startOffset < 0);
    int endOffset;
    int j=pattern.length - 1;
    do {
      endOffset=controlFlow.getEndOffset(pattern[j--]);
    }
 while (endOffset < 0);
    ControlFlowUtil.findExitPointsAndStatements(controlFlow,startOffset,endOffset,exitPoints,exitStatements,ControlFlowUtil.DEFAULT_EXIT_STATEMENTS_CLASSES);
    myMultipleExitPoints=exitPoints.size() > 1;
    if (myMultipleExitPoints) {
      removeParametersUsedInExitsOnly(codeFragment,exitStatements,controlFlow,startOffset,endOffset);
    }
  }
 catch (  AnalysisCanceledException e) {
  }
}
