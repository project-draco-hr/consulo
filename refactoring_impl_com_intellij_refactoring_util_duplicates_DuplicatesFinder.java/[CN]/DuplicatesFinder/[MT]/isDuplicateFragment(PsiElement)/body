{
  if (PsiTreeUtil.isAncestor(myPattern[0],candidate,false))   return null;
  PsiElement sibling=candidate;
  ArrayList<PsiElement> candidates=new ArrayList<PsiElement>();
  for (  final PsiElement element : myPattern) {
    if (sibling == null)     return null;
    if (!canBeEquivalent(element,sibling))     return null;
    candidates.add(sibling);
    sibling=PsiTreeUtil.skipSiblingsForward(sibling,PsiWhiteSpace.class,PsiComment.class);
  }
  LOG.assertTrue(myPattern.length == candidates.size());
  if (myPattern.length == 1 && myPattern[0] instanceof PsiExpression) {
    if (candidates.get(0) instanceof PsiExpression) {
      final PsiExpression candidateExpression=(PsiExpression)candidates.get(0);
      if (PsiUtil.isAccessedForWriting(candidateExpression))       return null;
      final PsiType patternType=((PsiExpression)myPattern[0]).getType();
      final PsiType candidateType=candidateExpression.getType();
      PsiSubstitutor substitutor=PsiSubstitutor.EMPTY;
      final PsiMethod method=PsiTreeUtil.getParentOfType(myPattern[0],PsiMethod.class);
      if (method != null) {
        final PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(candidate.getProject()).getResolveHelper();
        substitutor=resolveHelper.inferTypeArguments(method.getTypeParameters(),new PsiType[]{patternType},new PsiType[]{candidateType},PsiUtil.getLanguageLevel(method));
      }
      if (!canTypesBeEquivalent(substitutor.substitute(patternType),candidateType))       return null;
    }
 else {
      return null;
    }
  }
  final Match match=new Match(candidates.get(0),candidates.get(candidates.size() - 1));
  for (int i=0; i < myPattern.length; i++) {
    if (!matchPattern(myPattern[i],candidates.get(i),candidates,match))     return null;
  }
  if (checkPostVariableUsages(candidates,match))   return null;
  return match;
}
