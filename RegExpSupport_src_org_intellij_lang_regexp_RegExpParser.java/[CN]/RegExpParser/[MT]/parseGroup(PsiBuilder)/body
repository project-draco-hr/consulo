{
  final IElementType type=builder.getTokenType();
  final PsiBuilder.Marker marker=builder.mark();
  if (RegExpTT.GROUPS.contains(type)) {
    builder.advanceLexer();
    if (!parsePattern(builder)) {
      patternExpected(builder);
    }
 else {
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
    }
    marker.done(RegExpElementTypes.GROUP);
  }
 else   if (type == RegExpTT.SET_OPTIONS) {
    builder.advanceLexer();
    final PsiBuilder.Marker o=builder.mark();
    if (builder.getTokenType() == RegExpTT.OPTIONS_ON) {
      builder.advanceLexer();
    }
    if (builder.getTokenType() == RegExpTT.OPTIONS_OFF) {
      builder.advanceLexer();
    }
    o.done(RegExpElementTypes.OPTIONS);
    if (builder.getTokenType() == RegExpTT.COLON) {
      builder.advanceLexer();
      if (!parsePattern(builder)) {
        patternExpected(builder);
      }
 else {
        checkMatches(builder,RegExpTT.GROUP_END,"Unclosed group");
      }
      marker.done(RegExpElementTypes.GROUP);
    }
 else {
      checkMatches(builder,RegExpTT.GROUP_END,"Unclosed options group");
      marker.done(RegExpElementTypes.SET_OPTIONS);
    }
  }
 else   if (type == StringEscapesTokenTypes.INVALID_CHARACTER_ESCAPE_TOKEN) {
    builder.error("Illegal/unsupported escape sequence");
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else   if (RegExpTT.CHARACTERS.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else   if (RegExpTT.BOUNDARIES.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.BOUNDARY);
  }
 else   if (type == RegExpTT.BACKREF) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.BACKREF);
  }
 else   if (type == RegExpTT.PROPERTY) {
    parseProperty(builder);
    marker.done(RegExpElementTypes.PROPERTY);
  }
 else   if (RegExpTT.SIMPLE_CLASSES.contains(type)) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.SIMPLE_CLASS);
  }
 else   if (type == RegExpTT.CLASS_BEGIN) {
    marker.drop();
    return parseClass(builder);
  }
 else   if (type == RegExpTT.LBRACE && myAllowDanglingMetacharacters) {
    builder.advanceLexer();
    marker.done(RegExpElementTypes.CHAR);
  }
 else {
    marker.drop();
    return null;
  }
  return marker;
}
