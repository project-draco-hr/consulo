{
  if (!settings.isKeepOverloadedMethodsTogether())   return;
  cullOverloadedMethods(contents,true);
  LOG.debug("entered handleOverloadedMethods(): move overloaded methods together");
  cullOverloadedMethods(contents,false);
  List<ClassContentsEntry> copy=new ArrayList<ClassContentsEntry>(contents);
  for (  ClassContentsEntry rangeEntry : copy) {
    if (rangeEntry instanceof IRelatableEntry) {
      MethodEntry current=(MethodEntry)rangeEntry;
      if (current.overloadedMethods.size() > 0) {
        List<MethodEntry> newList=new ArrayList<MethodEntry>(current.overloadedMethods.size() + 1);
        newList.add(current);
switch (settings.getOverloadedOrder()) {
case RearrangerSettings.OVERLOADED_ORDER_RETAIN_ORIGINAL:
          newList.addAll(current.overloadedMethods);
        break;
case RearrangerSettings.OVERLOADED_ORDER_ASCENDING_PARAMETERS:
case RearrangerSettings.OVERLOADED_ORDER_DESCENDING_PARAMETERS:
      for (      MethodEntry entry : current.overloadedMethods) {
        boolean inserted=false;
        for (int index=0; index < newList.size(); index++) {
          MethodEntry me=newList.get(index);
          if (settings.getOverloadedOrder() == RearrangerSettings.OVERLOADED_ORDER_ASCENDING_PARAMETERS ? me.getnParameters() > entry.getnParameters() : me.getnParameters() < entry.getnParameters()) {
            newList.add(index,entry);
            inserted=true;
            break;
          }
        }
        if (!inserted) {
          newList.add(entry);
        }
      }
    break;
}
current.overloadedMethods.clear();
int index=contents.indexOf(current);
if (newList.get(0) != current) {
  contents.set(index,((MethodEntry)newList.get(0)));
}
newList.remove(0);
for (int j=0; j < newList.size(); j++) {
  contents.add(index + j + 1,((MethodEntry)newList.get(j)));
}
}
}
}
}
