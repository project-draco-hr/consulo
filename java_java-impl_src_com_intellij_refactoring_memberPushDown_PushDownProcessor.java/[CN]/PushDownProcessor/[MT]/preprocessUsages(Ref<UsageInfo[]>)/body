{
  UsageInfo[] usagesIn=refUsages.get();
  final PushDownConflicts pushDownConflicts=new PushDownConflicts(myClass,myMemberInfos);
  pushDownConflicts.checkSourceClassConflicts();
  if (usagesIn.length == 0) {
    String noInheritors=myClass.isInterface() ? RefactoringBundle.message("interface.0.does.not.have.inheritors",myClass.getQualifiedName()) : RefactoringBundle.message("class.0.does.not.have.inheritors",myClass.getQualifiedName());
    final String message=noInheritors + "\n" + RefactoringBundle.message("push.down.will.delete.members");
    final int answer=Messages.showYesNoCancelDialog(message,JavaPushDownHandler.REFACTORING_NAME,Messages.getWarningIcon());
    if (answer == DialogWrapper.OK_EXIT_CODE) {
      myCreateClassDlg=CreateSubclassAction.chooseSubclassToCreate(myClass);
      if (myCreateClassDlg != null) {
        pushDownConflicts.checkTargetClassConflicts(null,false,myCreateClassDlg.getTargetDirectory());
        return showConflicts(pushDownConflicts.getConflicts());
      }
 else {
        return false;
      }
    }
 else     if (answer != 1)     return false;
  }
  for (  UsageInfo usage : usagesIn) {
    final PsiElement element=usage.getElement();
    if (element instanceof PsiClass) {
      pushDownConflicts.checkTargetClassConflicts((PsiClass)element,usagesIn.length > 1,element);
    }
  }
  return showConflicts(pushDownConflicts.getConflicts());
}
