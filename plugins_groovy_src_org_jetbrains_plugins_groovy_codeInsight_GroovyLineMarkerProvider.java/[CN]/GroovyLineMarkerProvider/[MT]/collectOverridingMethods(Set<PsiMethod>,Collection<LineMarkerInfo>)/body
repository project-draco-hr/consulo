{
  final Set<PsiElement> overridden=new HashSet<PsiElement>();
  Set<PsiClass> classes=new THashSet<PsiClass>();
  for (  PsiMethod method : methods) {
    ProgressManager.checkCanceled();
    final PsiClass parentClass=method.getContainingClass();
    if (parentClass != null && !"java.lang.Object".equals(parentClass.getQualifiedName())) {
      classes.add(parentClass);
    }
  }
  for (  final PsiClass aClass : classes) {
    try {
      AllOverridingMethodsSearch.search(aClass).forEach(new Processor<Pair<PsiMethod,PsiMethod>>(){
        @Override public boolean process(        final Pair<PsiMethod,PsiMethod> pair){
          ProgressManager.checkCanceled();
          final PsiMethod superMethod=pair.getFirst();
          if (isCorrectTarget(superMethod) && isCorrectTarget(pair.getSecond())) {
            if (methods.remove(superMethod)) {
              if (superMethod instanceof PsiMirrorElement) {
              }
              overridden.add(PsiImplUtil.handleMirror(superMethod));
            }
          }
          return !methods.isEmpty();
        }
      }
);
    }
 catch (    IndexNotReadyException ignored) {
    }
  }
  for (  PsiElement element : overridden) {
    final Icon icon=OVERRIDEN_METHOD_MARKER_RENDERER;
    element=PsiImplUtil.handleMirror(element);
    PsiElement range;
    if (element instanceof GrNamedElement) {
      range=((GrNamedElement)element).getNameIdentifierGroovy();
    }
 else {
      range=element;
    }
    final MarkerType type;
    if (element instanceof GrField) {
      type=GroovyMarkerTypes.OVERRIDEN_PROPERTY_TYPE;
    }
 else {
      type=GroovyMarkerTypes.OVERRIDEN_METHOD;
    }
    LineMarkerInfo info=new LineMarkerInfo<PsiElement>(range,range.getTextRange(),icon,Pass.UPDATE_OVERRIDEN_MARKERS,type.getTooltip(),type.getNavigationHandler(),GutterIconRenderer.Alignment.RIGHT);
    result.add(info);
  }
}
