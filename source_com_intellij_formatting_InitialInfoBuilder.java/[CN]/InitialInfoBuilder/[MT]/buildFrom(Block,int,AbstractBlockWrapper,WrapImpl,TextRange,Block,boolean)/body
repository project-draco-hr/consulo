{
  final WrapImpl wrap=(WrapImpl)rootBlock.getWrap();
  if (wrap != null) {
    wrap.registerParent(currentWrapParent);
    currentWrapParent=wrap;
  }
  final int blockStartOffset=textRange.getStartOffset();
  if (parent != null) {
    if (textRange.getStartOffset() < parent.getStartOffset()) {
      assertInvalidRanges(textRange.getStartOffset(),parent.getStartOffset(),myModel,"child block start is less than parent block start");
    }
    if (textRange.getEndOffset() > parent.getEndOffset()) {
      assertInvalidRanges(textRange.getEndOffset(),parent.getEndOffset(),myModel,"child block end is after parent block end");
    }
  }
  myCurrentWhiteSpace.append(blockStartOffset,myModel,myOptions);
  boolean isReadOnly=isReadOnly(textRange,rootBlockIsRightBlock);
  ReadOnlyBlockInformationProvider previousProvider=myReadOnlyBlockInformationProvider;
  try {
    if (rootBlock instanceof ReadOnlyBlockInformationProvider) {
      myReadOnlyBlockInformationProvider=(ReadOnlyBlockInformationProvider)rootBlock;
    }
    if (isReadOnly) {
      return processSimpleBlock(rootBlock,parent,isReadOnly,textRange,index,parentBlock);
    }
 else {
      final List<Block> subBlocks=rootBlock.getSubBlocks();
      if (subBlocks.isEmpty() || myReadOnlyBlockInformationProvider != null && myReadOnlyBlockInformationProvider.isReadOnly(rootBlock)) {
        final AbstractBlockWrapper wrapper=processSimpleBlock(rootBlock,parent,isReadOnly,textRange,index,parentBlock);
        if (subBlocks.size() > 0) {
          wrapper.setIndent((IndentImpl)subBlocks.get(0).getIndent());
        }
        return wrapper;
      }
 else {
        return processCompositeBlock(rootBlock,parent,textRange,index,subBlocks,currentWrapParent,rootBlockIsRightBlock);
      }
    }
  }
  finally {
    myReadOnlyBlockInformationProvider=previousProvider;
  }
}
