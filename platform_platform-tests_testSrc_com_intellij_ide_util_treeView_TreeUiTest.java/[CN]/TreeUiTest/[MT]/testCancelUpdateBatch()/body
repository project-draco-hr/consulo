{
  buildStructure(myRoot);
  myAlwaysShowPlus.add(new NodeElement("com"));
  myAlwaysShowPlus.add(new NodeElement("jetbrains"));
  myAlwaysShowPlus.add(new NodeElement("org"));
  myAlwaysShowPlus.add(new NodeElement("xunit"));
  final Ref<Boolean> cancelled=new Ref<Boolean>(false);
  myElementUpdateHook=new ElementUpdateHook(){
    @Override public void onElementAction(    String action,    Object element){
      NodeElement stopElement=new NodeElement("com");
      if (cancelled.get()) {
        myCancelRequest=new AssertionError("Not supposed to update after element=" + stopElement);
        return;
      }
      if (element.equals(stopElement) && action.equals("getChildren")) {
        cancelled.set(true);
        getBuilder().cancelUpdate();
      }
    }
  }
;
  final NodeElement[] toExpand=new NodeElement[]{new NodeElement("com"),new NodeElement("jetbrains"),new NodeElement("org"),new NodeElement("xunit")};
  final ActionCallback done=new ActionCallback();
  final Ref<ProgressIndicator> indicatorRef=new Ref<ProgressIndicator>();
  invokeLaterIfNeeded(new Runnable(){
    @Override public void run(){
      getBuilder().batch(new Progressive(){
        @Override public void run(        @NotNull ProgressIndicator indicator){
          indicatorRef.set(indicator);
          expandNext(toExpand,0,indicator,done);
        }
      }
).notify(done);
    }
  }
);
  waitBuilderToCome(new Condition(){
    @Override public boolean value(    Object o){
      return done.isProcessed() || myCancelRequest != null;
    }
  }
);
  assertNull(myCancelRequest);
  assertTrue(done.isRejected());
  assertTrue(indicatorRef.get().isCanceled());
  assertFalse(getBuilder().getUi().isCancelProcessed());
}
