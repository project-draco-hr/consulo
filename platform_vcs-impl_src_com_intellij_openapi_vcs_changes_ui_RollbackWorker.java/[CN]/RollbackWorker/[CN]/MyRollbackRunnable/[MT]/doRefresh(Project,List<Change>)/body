{
  final String actionName=VcsBundle.message("changes.action.rollback.text");
  final LocalHistoryAction action=LocalHistory.getInstance().startAction(actionName);
  final Runnable forAwtThread=new Runnable(){
    public void run(){
      action.finish();
      LocalHistory.getInstance().putSystemLabel(myProject,(myLocalHistoryActionName == null) ? actionName : myLocalHistoryActionName,-1);
      final VcsDirtyScopeManager manager=PeriodicalTasksCloser.getInstance().safeGetComponent(project,VcsDirtyScopeManager.class);
      for (      Change change : changesToRefresh) {
        if ((!change.isIsReplaced()) && Comparing.equal(change.getBeforeRevision(),change.getAfterRevision())) {
          manager.fileDirty(change.getBeforeRevision().getFile());
        }
 else {
          if (change.getBeforeRevision() != null) {
            final FilePath parent=change.getBeforeRevision().getFile().getParentPath();
            if (parent != null) {
              manager.dirDirtyRecursively(parent);
            }
          }
          if (change.getAfterRevision() != null) {
            final FilePath parent=change.getAfterRevision().getFile().getParentPath();
            if (parent != null) {
              manager.dirDirtyRecursively(parent);
            }
          }
        }
      }
      myAfterRefresh.run();
    }
  }
;
  RefreshVFsSynchronously.updateChangesForRollback(changesToRefresh);
  WaitForProgressToShow.runOrInvokeLaterAboveProgress(forAwtThread,null,project);
}
