{
  final String actionName=VcsBundle.message("changes.action.rollback.text");
  final LocalHistoryAction action=LocalHistory.getInstance().startAction(actionName);
  final Runnable forAwtThread=new Runnable(){
    public void run(){
      action.finish();
      LocalHistory.getInstance().putSystemLabel(myProject,(myLocalHistoryActionName == null) ? actionName : myLocalHistoryActionName,-1);
      final VcsDirtyScopeManager manager=PeriodicalTasksCloser.getInstance().safeGetComponent(project,VcsDirtyScopeManager.class);
      for (      Change change : changesToRefresh) {
        final ContentRevision beforeRevision=change.getBeforeRevision();
        final ContentRevision afterRevision=change.getAfterRevision();
        if ((!change.isIsReplaced()) && beforeRevision != null && Comparing.equal(beforeRevision,afterRevision)) {
          manager.fileDirty(beforeRevision.getFile());
        }
 else {
          if (beforeRevision != null) {
            final FilePath parent=beforeRevision.getFile().getParentPath();
            if (parent != null) {
              manager.dirDirtyRecursively(parent);
            }
          }
          if (afterRevision != null) {
            final FilePath parent=afterRevision.getFile().getParentPath();
            if (parent != null) {
              manager.dirDirtyRecursively(parent);
            }
          }
        }
      }
      myAfterRefresh.run();
    }
  }
;
  RefreshVFsSynchronously.updateChangesForRollback(changesToRefresh);
  WaitForProgressToShow.runOrInvokeLaterAboveProgress(forAwtThread,null,project);
}
