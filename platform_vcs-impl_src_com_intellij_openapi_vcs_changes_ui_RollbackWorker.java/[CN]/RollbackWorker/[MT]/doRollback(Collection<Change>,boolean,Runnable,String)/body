{
  final ChangeListManager changeListManager=ChangeListManager.getInstance(myProject);
  final Runnable notifier=changeListManager.prepareForChangeDeletion(changes);
  final Runnable afterRefresh=new Runnable(){
    public void run(){
      InvokeAfterUpdateMode updateMode=myInvokedFromModalContext ? InvokeAfterUpdateMode.SYNCHRONOUS_CANCELLABLE : InvokeAfterUpdateMode.SILENT;
      changeListManager.invokeAfterUpdate(new Runnable(){
        public void run(){
          notifier.run();
          if (afterVcsRefreshInAwt != null) {
            afterVcsRefreshInAwt.run();
          }
        }
      }
,updateMode,"Refresh changelists after update",ModalityState.current());
    }
  }
;
  final Runnable rollbackAction=new MyRollbackRunnable(changes,deleteLocallyAddedFiles,afterRefresh,localHistoryActionName);
  if (ApplicationManager.getApplication().isDispatchThread() && !myInvokedFromModalContext) {
    ProgressManager.getInstance().run(new Task.Backgroundable(myProject,myOperationName,true,new PerformInBackgroundOption(){
      public boolean shouldStartInBackground(){
        return VcsConfiguration.getInstance(myProject).PERFORM_ROLLBACK_IN_BACKGROUND;
      }
      public void processSentToBackground(){
        VcsConfiguration.getInstance(myProject).PERFORM_ROLLBACK_IN_BACKGROUND=true;
      }
    }
){
      public void run(      @NotNull ProgressIndicator indicator){
        rollbackAction.run();
      }
    }
);
  }
 else   if (myInvokedFromModalContext) {
    ProgressManager.getInstance().run(new Task.Modal(myProject,myOperationName,true){
      @Override public void run(      @NotNull ProgressIndicator indicator){
        DumbService.allowStartingDumbModeInside(DumbModePermission.MAY_START_BACKGROUND,rollbackAction);
      }
    }
);
  }
 else {
    rollbackAction.run();
  }
  ((ChangeListManagerImpl)changeListManager).showLocalChangesInvalidated();
}
