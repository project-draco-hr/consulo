{
  path=getLastCommitName(project,path);
  final VirtualFile finalRoot=(root == null ? GitUtil.getGitRoot(path) : root);
  final GitLogParser logParser=new GitLogParser(project,GitLogParser.NameStatus.NAME,HASH,COMMIT_TIME,AUTHOR_NAME,AUTHOR_EMAIL,COMMITTER_NAME,COMMITTER_EMAIL,PARENTS,SUBJECT,BODY,RAW_BODY,AUTHOR_TIME);
  final AtomicReference<String> firstCommit=new AtomicReference<String>("HEAD");
  final AtomicReference<String> firstCommitParent=new AtomicReference<String>("HEAD");
  final AtomicReference<FilePath> currentPath=new AtomicReference<FilePath>(path);
  final AtomicReference<GitLineHandler> logHandler=new AtomicReference<GitLineHandler>();
  final Consumer<GitLogRecord> resultAdapter=new Consumer<GitLogRecord>(){
    public void consume(    GitLogRecord record){
      if (record == null) {
        exceptionConsumer.consume(new VcsException("revision details are null."));
        return;
      }
      record.setUsedHandler(logHandler.get());
      final GitRevisionNumber revision=new GitRevisionNumber(record.getHash(),record.getDate());
      firstCommit.set(record.getHash());
      final String[] parentHashes=record.getParentsHashes();
      if (parentHashes == null || parentHashes.length < 1) {
        firstCommitParent.set(null);
      }
 else {
        firstCommitParent.set(parentHashes[0]);
      }
      final String message=record.getFullMessage();
      FilePath revisionPath;
      try {
        final List<FilePath> paths=record.getFilePaths(finalRoot);
        if (paths.size() > 0) {
          revisionPath=paths.get(0);
        }
 else {
          revisionPath=currentPath.get();
        }
        final Pair<String,String> authorPair=Pair.create(record.getAuthorName(),record.getAuthorEmail());
        final Pair<String,String> committerPair=record.getCommitterName() == null ? null : Pair.create(record.getCommitterName(),record.getCommitterEmail());
        consumer.consume(new GitFileRevision(project,revisionPath,revision,Pair.create(authorPair,committerPair),message,null,new Date(record.getAuthorTimeStamp() * 1000),false));
      }
 catch (      VcsException e) {
        exceptionConsumer.consume(e);
      }
    }
  }
;
  while (currentPath.get() != null && firstCommitParent.get() != null) {
    logHandler.set(getLogHandler(project,finalRoot,logParser,currentPath.get(),firstCommitParent.get(),parameters));
    final MyTokenAccumulator accumulator=new MyTokenAccumulator(logParser);
    final Semaphore semaphore=new Semaphore();
    logHandler.get().addLineListener(new GitLineHandlerAdapter(){
      @Override public void onLineAvailable(      String line,      Key outputType){
        final GitLogRecord record=accumulator.acceptLine(line);
        if (record != null) {
          resultAdapter.consume(record);
        }
      }
      @Override public void startFailed(      Throwable exception){
        try {
          exceptionConsumer.consume(new VcsException(exception));
        }
  finally {
          semaphore.up();
        }
      }
      @Override public void processTerminated(      int exitCode){
        try {
          super.processTerminated(exitCode);
          final GitLogRecord record=accumulator.processLast();
          if (record != null) {
            resultAdapter.consume(record);
          }
        }
  finally {
          semaphore.up();
        }
      }
    }
);
    semaphore.down();
    logHandler.get().start();
    semaphore.waitFor();
    currentPath.set(getFirstCommitRenamePath(project,finalRoot,firstCommit.get(),currentPath.get()));
  }
}
