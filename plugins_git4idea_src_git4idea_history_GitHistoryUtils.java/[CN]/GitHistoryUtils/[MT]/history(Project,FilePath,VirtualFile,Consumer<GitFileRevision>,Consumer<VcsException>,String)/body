{
  final FilePath filePath=getLastCommitName(project,path);
  final VirtualFile finalRoot;
  try {
    finalRoot=(root == null ? GitUtil.getGitRoot(filePath) : root);
  }
 catch (  VcsException e) {
    exceptionConsumer.consume(e);
    return;
  }
  final GitLogParser logParser=new GitLogParser(project,GitLogParser.NameStatus.STATUS,HASH,COMMIT_TIME,AUTHOR_NAME,AUTHOR_EMAIL,COMMITTER_NAME,COMMITTER_EMAIL,PARENTS,SUBJECT,BODY,RAW_BODY,AUTHOR_TIME);
  final AtomicReference<String> firstCommit=new AtomicReference<String>("HEAD");
  final AtomicReference<String> firstCommitParent=new AtomicReference<String>("HEAD");
  final AtomicReference<FilePath> currentPath=new AtomicReference<FilePath>(filePath);
  final AtomicReference<GitLineHandler> logHandler=new AtomicReference<GitLineHandler>();
  final AtomicBoolean skipFurtherOutput=new AtomicBoolean();
  final Consumer<GitLogRecord> resultAdapter=new Consumer<GitLogRecord>(){
    public void consume(    GitLogRecord record){
      if (skipFurtherOutput.get()) {
        return;
      }
      if (record == null) {
        exceptionConsumer.consume(new VcsException("revision details are null."));
        return;
      }
      record.setUsedHandler(logHandler.get());
      final GitRevisionNumber revision=new GitRevisionNumber(record.getHash(),record.getDate());
      firstCommit.set(record.getHash());
      final String[] parentHashes=record.getParentsHashes();
      if (parentHashes == null || parentHashes.length < 1) {
        firstCommitParent.set(null);
      }
 else {
        firstCommitParent.set(parentHashes[0]);
      }
      final String message=record.getFullMessage();
      FilePath revisionPath;
      try {
        final List<FilePath> paths=record.getFilePaths(finalRoot);
        if (paths.size() > 0) {
          revisionPath=paths.get(0);
        }
 else {
          revisionPath=currentPath.get();
        }
        final Pair<String,String> authorPair=Pair.create(record.getAuthorName(),record.getAuthorEmail());
        final Pair<String,String> committerPair=record.getCommitterName() == null ? null : Pair.create(record.getCommitterName(),record.getCommitterEmail());
        Collection<String> parents=parentHashes == null ? Collections.<String>emptyList() : Arrays.asList(parentHashes);
        consumer.consume(new GitFileRevision(project,revisionPath,revision,Pair.create(authorPair,committerPair),message,null,new Date(record.getAuthorTimeStamp() * 1000),parents));
        List<GitLogStatusInfo> statusInfos=record.getStatusInfos();
        if (statusInfos.isEmpty()) {
          return;
        }
        if (statusInfos.get(0).getType() == GitChangeType.ADDED && !filePath.isDirectory()) {
          skipFurtherOutput.set(true);
        }
      }
 catch (      VcsException e) {
        exceptionConsumer.consume(e);
      }
    }
  }
;
  final AtomicBoolean criticalFailure=new AtomicBoolean();
  while (currentPath.get() != null && firstCommitParent.get() != null) {
    logHandler.set(getLogHandler(project,finalRoot,logParser,currentPath.get(),firstCommitParent.get(),parameters));
    final MyTokenAccumulator accumulator=new MyTokenAccumulator(logParser);
    final Semaphore semaphore=new Semaphore();
    logHandler.get().addLineListener(new GitLineHandlerAdapter(){
      @Override public void onLineAvailable(      String line,      Key outputType){
        final GitLogRecord record=accumulator.acceptLine(line);
        if (record != null) {
          resultAdapter.consume(record);
        }
      }
      @Override public void startFailed(      Throwable exception){
        try {
          exceptionConsumer.consume(new VcsException(exception));
        }
  finally {
          criticalFailure.set(true);
          semaphore.up();
        }
      }
      @Override public void processTerminated(      int exitCode){
        try {
          super.processTerminated(exitCode);
          final GitLogRecord record=accumulator.processLast();
          if (record != null) {
            resultAdapter.consume(record);
          }
        }
 catch (        Throwable t) {
          LOG.error(t);
          exceptionConsumer.consume(new VcsException("Internal error " + t.getMessage(),t));
          criticalFailure.set(true);
        }
 finally {
          semaphore.up();
        }
      }
    }
);
    semaphore.down();
    logHandler.get().start();
    semaphore.waitFor();
    if (criticalFailure.get()) {
      return;
    }
    try {
      FilePath firstCommitRenamePath;
      firstCommitRenamePath=getFirstCommitRenamePath(project,finalRoot,firstCommit.get(),currentPath.get());
      currentPath.set(firstCommitRenamePath);
      skipFurtherOutput.set(false);
    }
 catch (    VcsException e) {
      LOG.warn("Tried to get first commit rename path",e);
      exceptionConsumer.consume(e);
      return;
    }
  }
}
