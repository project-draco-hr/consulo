{
  path=getLastCommitName(project,path);
  final VirtualFile root=GitUtil.getGitRoot(path);
  final GitLineHandler h=new GitLineHandler(project,root,GitCommand.LOG);
  h.setNoSSH(true);
  h.setStdoutSuppressed(true);
  h.addParameters(parameters);
  h.addParameters("--pretty=format:%x01%h%x00%ct%x00%p","--encoding=UTF-8");
  h.endOptions();
  h.addRelativePaths(path);
  h.addLineListener(new GitLineHandlerListener(){
    @Override public void onLineAvailable(    final String line,    final Key outputType){
      if (ProcessOutputTypes.STDOUT.equals(outputType)) {
        if (line.startsWith("\u0001")) {
          final StringTokenizer tk2=new StringTokenizer(line.substring(1),"\u0000",false);
          final String hash=tk2.nextToken();
          final long time;
          if (tk2.hasMoreTokens()) {
            final String dateString=tk2.nextToken();
            time=Long.parseLong(dateString.trim());
          }
 else {
            time=0;
          }
          final String[] parents;
          if (tk2.hasMoreTokens()) {
            parents=tk2.nextToken().split(" ");
          }
 else {
            parents=ArrayUtil.EMPTY_STRING_ARRAY;
          }
          consumer.consume(new CommitHashPlusParents(hash,parents,time));
        }
      }
    }
    @Override public void processTerminated(    int exitCode){
    }
    @Override public void startFailed(    Throwable exception){
    }
  }
);
  h.start();
  return new Runnable(){
    @Override public void run(){
      h.cancel();
    }
  }
;
}
