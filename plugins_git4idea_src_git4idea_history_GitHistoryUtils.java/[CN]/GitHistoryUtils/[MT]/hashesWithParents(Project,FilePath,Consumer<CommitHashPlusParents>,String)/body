{
  path=getLastCommitName(project,path);
  final VirtualFile root=GitUtil.getGitRoot(path);
  final GitLineHandler h=new GitLineHandler(project,root,GitCommand.LOG);
  final GitLogParser parser=new GitLogParser(SHORT_HASH,COMMIT_TIME,SHORT_PARENTS);
  h.setNoSSH(true);
  h.setStdoutSuppressed(true);
  h.addParameters(parameters);
  h.addParameters(parser.getPretty(),"--encoding=UTF-8");
  h.endOptions();
  h.addRelativePaths(path);
  final Semaphore semaphore=new Semaphore();
  h.addLineListener(new GitLineHandlerListener(){
    @Override public void onLineAvailable(    final String line,    final Key outputType){
      if (ProcessOutputTypes.STDOUT.equals(outputType)) {
        GitLogRecord record=parser.parseOneRecord(line);
        String hash=record.getShortHash();
        String[] parents=record.getParentsShortHashes();
        long time=record.getLongTimeStamp();
        consumer.consume(new CommitHashPlusParents(hash,parents,time));
      }
    }
    @Override public void processTerminated(    int exitCode){
      semaphore.up();
    }
    @Override public void startFailed(    Throwable exception){
    }
  }
);
  semaphore.down();
  h.start();
  semaphore.waitFor();
  return new Runnable(){
    @Override public void run(){
      h.cancel();
    }
  }
;
}
