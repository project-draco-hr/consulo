{
  path=getLastCommitName(project,path);
  final VirtualFile root=GitUtil.getGitRoot(path);
  GitLineHandler h=new GitLineHandler(project,root,GitCommand.LOG);
  final GitLogParser parser=new GitLogParser(HASH,COMMIT_TIME,AUTHOR_NAME,AUTHOR_EMAIL,COMMITTER_NAME,COMMITTER_EMAIL,SUBJECT,BODY);
  h.setNoSSH(true);
  h.setStdoutSuppressed(true);
  h.addParameters("-M","--follow","--name-only",parser.getPretty(),"--encoding=UTF-8");
  parser.setNameInOutput(false);
  h.endOptions();
  h.addRelativePaths(path);
  final MyTokenAccumulator accumulator=new MyTokenAccumulator(parser);
  final Consumer<GitLogRecord> resultAdapter=new Consumer<GitLogRecord>(){
    public void consume(    GitLogRecord record){
      if (record == null) {
        exceptionConsumer.consume(new VcsException("revision details are null."));
        return;
      }
      final GitRevisionNumber revision=new GitRevisionNumber(record.getHash(),record.getDate());
      final String message=record.getFullMessage();
      FilePath revisionPath=new FilePathImpl(root);
      try {
        final List<FilePath> paths=record.getFilePaths(root);
        if (paths.size() > 0) {
          revisionPath=paths.get(0);
        }
        final Pair<String,String> authorPair=Pair.create(record.getAuthorName(),record.getAuthorEmail());
        final Pair<String,String> committerPair=record.getCommitterName() == null ? null : Pair.create(record.getCommitterName(),record.getCommitterEmail());
        consumer.consume(new GitFileRevision(project,revisionPath,revision,Pair.create(authorPair,committerPair),message,null));
      }
 catch (      VcsException e) {
        exceptionConsumer.consume(e);
      }
    }
  }
;
  final Semaphore semaphore=new Semaphore();
  h.addLineListener(new GitLineHandlerAdapter(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      final GitLogRecord record=accumulator.acceptLine(line);
      if (record != null) {
        resultAdapter.consume(record);
      }
    }
    @Override public void startFailed(    Throwable exception){
      exceptionConsumer.consume(new VcsException(exception));
    }
    @Override public void processTerminated(    int exitCode){
      super.processTerminated(exitCode);
      final GitLogRecord record=accumulator.processLast();
      if (record != null) {
        resultAdapter.consume(record);
      }
      semaphore.up();
    }
  }
);
  semaphore.down();
  h.start();
  semaphore.waitFor();
}
