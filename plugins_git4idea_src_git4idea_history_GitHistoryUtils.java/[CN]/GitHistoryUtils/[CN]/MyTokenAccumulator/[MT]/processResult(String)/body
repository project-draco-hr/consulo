{
  final int commentStartIdx=line.indexOf(ourCommentStartMark);
  if (commentStartIdx == -1) {
    LOG.info("Git history: no comment mark in line: '" + line + "'");
    java.util.StringTokenizer tk=new java.util.StringTokenizer(line,TOKEN_DELIMITER,false);
    final List<String> result=new ArrayList<String>();
    while (tk.hasMoreElements()) {
      final String token=tk.nextToken();
      result.add(token);
    }
    return LowLevelRevisionDetails.fillDetails(result);
  }
  final String start=line.substring(0,commentStartIdx);
  final java.util.StringTokenizer tk=new java.util.StringTokenizer(start,TOKEN_DELIMITER,false);
  final List<String> result=new ArrayList<String>();
  while (tk.hasMoreElements()) {
    final String token=tk.nextToken();
    result.add(token);
  }
  final LowLevelRevisionDetails revisionDetails=LowLevelRevisionDetails.fillDetails(result);
  final String commentAndPath=line.substring(commentStartIdx + ourCommentStartMark.length());
  final int commentEndIdx=commentAndPath.indexOf(ourCommentEndMark);
  if (commentEndIdx > -1) {
    revisionDetails.comment=replaceDelimitersByNewlines(commentAndPath.substring(0,commentEndIdx));
    revisionDetails.path=replaceDelimitersByNewlines(commentAndPath.substring(commentEndIdx + ourCommentEndMark.length()));
  }
 else {
    exceptions.add(new VcsException("git log output is uncomplete"));
    revisionDetails.comment=replaceDelimitersByNewlines(commentAndPath);
    revisionDetails.path="";
  }
  return revisionDetails;
}
