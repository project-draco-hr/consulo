{
  final int[] widths=new int[info.getCellCount()];
  for (int i=0; i < widths.length; i++) {
    widths[i]=myMinCellSize;
  }
  for (int i=info.getComponentCount() - 1; i >= 0; i--) {
    if (info.getSpan(i) != 1) {
      continue;
    }
    int size=min ? getMin2(info,i) : Math.max(info.getMinimumWidth(i),info.getPreferredWidth(i));
    final int gap=countGap(info,info.getCell(i),info.getSpan(i));
    size=Math.max(size - gap,0);
    widths[info.getCell(i)]=Math.max(widths[info.getCell(i)],size);
  }
  updateSizesFromChildren(info,min,widths);
  final boolean[] toProcess=new boolean[info.getCellCount()];
  for (int i=info.getComponentCount() - 1; i >= 0; i--) {
    int size=min ? getMin2(info,i) : Math.max(info.getMinimumWidth(i),info.getPreferredWidth(i));
    final int span=info.getSpan(i);
    final int cell=info.getCell(i);
    final int gap=countGap(info,cell,span);
    size=Math.max(size - gap,0);
    Arrays.fill(toProcess,false);
    int curSize=0;
    for (int j=0; j < span; j++) {
      curSize+=widths[j + cell];
      toProcess[j + cell]=true;
    }
    if (curSize >= size) {
      continue;
    }
    final boolean[] higherPriorityCells=new boolean[toProcess.length];
    getCellsWithHigherPriorities(info,toProcess,higherPriorityCells,false,widths);
    distribute(higherPriorityCells,info,size - curSize,widths);
  }
  return widths;
}
