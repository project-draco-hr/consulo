{
  if (SystemInfo.isWindows && op == WatcherOp.RECDIRTY && path.length() == 3 && Character.isLetter(path.charAt(0))) {
    VirtualFile root=LocalFileSystem.getInstance().findFileByPath(path);
    if (root != null) {
synchronized (myLock) {
        myDirtyPaths.dirtyPathsRecursive.add(root.getPresentableUrl());
      }
    }
    notifyOnEvent();
    return;
  }
  if (op == WatcherOp.CHANGE) {
synchronized (myLock) {
      ++myChangeRequests;
      if ((myChangeRequests & 0x3fff) == 0) {
        LOG.info("Change requests:" + myChangeRequests + ", filtered:"+ myFilteredRequests);
      }
      for (int i=0; i < myLastChangedPaths.length; ++i) {
        int last=myLastChangedPathIndex - i - 1;
        if (last < 0)         last+=myLastChangedPaths.length;
        String lastChangedPath=myLastChangedPaths[last];
        if (lastChangedPath != null && lastChangedPath.equals(path)) {
          ++myFilteredRequests;
          return;
        }
      }
      myLastChangedPaths[myLastChangedPathIndex++]=path;
      if (myLastChangedPathIndex == myLastChangedPaths.length)       myLastChangedPathIndex=0;
    }
  }
  int length=path.length();
  if (length > 1 && path.charAt(length - 1) == '/')   path=path.substring(0,length - 1);
  boolean exactPath=op != WatcherOp.DIRTY && op != WatcherOp.RECDIRTY;
  Collection<String> paths=checkWatchable(path,exactPath,false);
  if (paths.isEmpty()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Not watchable, filtered: " + path);
    }
    return;
  }
synchronized (myLock) {
switch (op) {
case STATS:
case CHANGE:
      myDirtyPaths.dirtyPaths.addAll(paths);
    break;
case CREATE:
case DELETE:
  for (  String p : paths) {
    String parentPath=new File(p).getParent();
    myDirtyPaths.dirtyPaths.add(parentPath != null ? parentPath : p);
  }
break;
case DIRTY:
myDirtyPaths.dirtyDirectories.addAll(paths);
break;
case RECDIRTY:
myDirtyPaths.dirtyPathsRecursive.addAll(paths);
break;
default :
LOG.error("Unexpected op: " + op);
}
}
notifyOnEvent();
}
