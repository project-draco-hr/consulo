{
  if (SystemInfo.isWindows && op == WatcherOp.RECDIRTY && path.length() == 3 && Character.isLetter(path.charAt(0))) {
    final VirtualFile root=LocalFileSystem.getInstance().findFileByPath(path);
    if (root instanceof NewVirtualFile) {
      ((NewVirtualFile)root).markDirtyRecursively();
    }
    notifyOnEvent();
    return;
  }
synchronized (myLock) {
    final boolean checkParent=!(op == WatcherOp.DIRTY || op == WatcherOp.RECDIRTY);
    final Collection<String> paths=checkWatchable(path,checkParent);
    if (paths.isEmpty()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Not watchable, filtered: " + path);
      }
      return;
    }
switch (op) {
case STATS:
case CHANGE:
      myDirtyPaths.addAll(paths);
    break;
case CREATE:
case DELETE:
  for (  String p : paths) {
    final File parent=new File(p).getParentFile();
    myDirtyPaths.add(parent != null ? parent.getPath() : p);
  }
break;
case DIRTY:
myDirtyDirs.addAll(paths);
break;
case RECDIRTY:
myDirtyRecursivePaths.addAll(paths);
break;
default :
LOG.error("Unexpected op: " + op);
}
notifyOnEvent();
}
}
