{
  SET_ROOTS_LOCK.lock();
  try {
synchronized (LOCK) {
      if (myRecursiveWatchRoots.equals(recursive) && myFlatWatchRoots.equals(flat))       return;
    }
    final List<Pair<String,String>> mapping=new ArrayList<Pair<String,String>>();
    long t=System.nanoTime();
    final List<String> checkedRecursive=checkPaths(recursive,mapping);
    final List<String> checkedFlat=checkPaths(flat,mapping);
    t=(System.nanoTime() - t) / 1000;
    LOG.info((recursive.size() + flat.size()) + " paths checked, " + mapping.size()+ " mapped, "+ t+ " mks");
    if (isAlive()) {
      try {
        writeLine(ROOTS_COMMAND);
        for (        String path : checkedRecursive) {
          writeLine(path);
        }
        for (        String path : checkedFlat) {
          writeLine("|" + path);
        }
        writeLine("#");
      }
 catch (      IOException e) {
        LOG.error(e);
      }
    }
synchronized (LOCK) {
      myRecursiveWatchRoots=recursive;
      myFlatWatchRoots=flat;
      myMapping.clear();
      myCanonicalMapping=mapping;
    }
  }
  finally {
    SET_ROOTS_LOCK.unlock();
  }
}
