{
  SET_ROOTS_LOCK.lock();
  try {
synchronized (LOCK) {
      if (myRecursiveWatchRoots.equals(recursive) && myFlatWatchRoots.equals(flat))       return;
    }
    final List<Pair<String,String>> mapping=new ArrayList<Pair<String,String>>();
    long t=System.nanoTime();
    final List<String> checkedRecursive=checkPaths(recursive,mapping);
    final List<String> checkedFlat=checkPaths(flat,mapping);
    t=(System.nanoTime() - t) / 1000;
    LOG.info((recursive.size() + flat.size()) + " paths checked, " + mapping.size()+ " mapped, "+ t+ " mks");
synchronized (LOCK) {
      try {
        myRecursiveWatchRoots=recursive;
        myFlatWatchRoots=flat;
        myCanonicalMapping.clear();
        if (isAlive()) {
          myMapping.clear();
          myCanonicalMapping=mapping;
          writeLine(ROOTS_COMMAND);
          for (          String path : checkedRecursive) {
            writeLine(path);
          }
          for (          String path : checkedFlat) {
            writeLine("|" + path);
          }
          writeLine("#");
        }
      }
 catch (      IOException e) {
        LOG.error(e);
      }
    }
  }
  finally {
    SET_ROOTS_LOCK.unlock();
  }
}
