{
  LOG.assertTrue(atToken(JavaFxTokenTypes.LBRACK));
  final PsiBuilder.Marker marker=myBuilder.mark();
  nextToken();
  if (atToken(JavaFxTokenTypes.RBRACK)) {
    nextToken();
    marker.done(JavaFxElementTypes.SEQUENCE_LITERAL);
    return;
  }
  parseValueExpression();
  if (atToken(JavaFxTokenTypes.RANGE)) {
    nextToken();
    if (atToken(JavaFxTokenTypes.LT)) {
      nextToken();
    }
    parseValueExpression();
    if (atToken(JavaFxTokenTypes.STEP_KEYWORD)) {
      nextToken();
      parseValueExpression();
    }
    checkMatches(JavaFxTokenTypes.RBRACK,JavaFxBundle.message("rbrack.expected"));
    marker.done(JavaFxElementTypes.RANGE_EXPRESSION);
  }
 else {
    while (!atToken(JavaFxTokenTypes.RBRACK)) {
      if (myBuilder.eof()) {
        myBuilder.error(JavaFxBundle.message("rbrack.expected"));
        marker.done(JavaFxElementTypes.SEQUENCE_LITERAL);
        return;
      }
      if (atToken(JavaFxTokenTypes.COMMA)) {
        nextToken();
        if (atToken(JavaFxTokenTypes.RBRACK)) {
          break;
        }
      }
 else {
        if (myPreviousTokenType != JavaFxTokenTypes.RBRACE) {
          myBuilder.error(JavaFxBundle.message("rbrack.or.comma.expected"));
        }
      }
      if (!parseValueExpressionOptional()) {
        myBuilder.error(JavaFxBundle.message("rbrack.or.comma.expected"));
        break;
      }
    }
    checkMatches(JavaFxTokenTypes.RBRACK,JavaFxBundle.message("rbrack.expected"));
    marker.done(JavaFxElementTypes.SEQUENCE_LITERAL);
  }
}
