{
  if (member instanceof PsiClass && getModifier().equals(PsiModifier.PUBLIC)) {
    final PsiClass aClass=(PsiClass)member;
    final PsiElement parent=aClass.getParent();
    if (!(parent instanceof PsiJavaFile)) {
      return MultiMap.emptyInstance();
    }
    final PsiJavaFile javaFile=(PsiJavaFile)parent;
    final String name=FileUtil.getNameWithoutExtension(javaFile.getName());
    final String className=aClass.getName();
    if (name.equals(className)) {
      MultiMap.emptyInstance();
    }
    final MultiMap<PsiElement,String> conflicts=new MultiMap();
    conflicts.putValue(aClass,IntentionPowerPackBundle.message("0.is.declared.in.1.but.when.public.should.be.declared.in.a.file.named.2",RefactoringUIUtil.getDescription(aClass,false),RefactoringUIUtil.getDescription(javaFile,false),CommonRefactoringUtil.htmlEmphasize(className + ".java")));
    return conflicts;
  }
  final PsiModifierList modifierList=member.getModifierList();
  if (modifierList == null || modifierList.hasModifierProperty(PsiModifier.PRIVATE)) {
    return MultiMap.emptyInstance();
  }
  final MultiMap<PsiElement,String> conflicts=new MultiMap();
  if (member instanceof PsiMethod) {
    final PsiMethod method=(PsiMethod)member;
    SuperMethodsSearch.search(method,method.getContainingClass(),true,false).forEach(new Processor<MethodSignatureBackedByPsiMethod>(){
      @Override public boolean process(      MethodSignatureBackedByPsiMethod methodSignature){
        final PsiMethod superMethod=methodSignature.getMethod();
        if (!hasCompatibleVisibility(superMethod,true)) {
          conflicts.putValue(superMethod,IntentionPowerPackBundle.message("0.will.have.incompatible.access.privileges.with.super.1",RefactoringUIUtil.getDescription(method,false),RefactoringUIUtil.getDescription(superMethod,true)));
        }
        return true;
      }
    }
);
    OverridingMethodsSearch.search(method).forEach(new Processor<PsiMethod>(){
      @Override public boolean process(      PsiMethod overridingMethod){
        if (!isVisibleFromOverridingMethod(method,overridingMethod)) {
          conflicts.putValue(overridingMethod,IntentionPowerPackBundle.message("0.will.no.longer.be.visible.from.overriding.1",RefactoringUIUtil.getDescription(method,false),RefactoringUIUtil.getDescription(overridingMethod,true)));
        }
 else         if (!hasCompatibleVisibility(overridingMethod,false)) {
          conflicts.putValue(overridingMethod,IntentionPowerPackBundle.message("0.will.have.incompatible.access.privileges.with.overriding.1",RefactoringUIUtil.getDescription(method,false),RefactoringUIUtil.getDescription(overridingMethod,true)));
        }
        return false;
      }
    }
);
  }
  final PsiModifierList modifierListCopy=(PsiModifierList)modifierList.copy();
  modifierListCopy.setModifierProperty(getModifier(),true);
  final Query<PsiReference> search=ReferencesSearch.search(member,member.getResolveScope());
  search.forEach(new Processor<PsiReference>(){
    @Override public boolean process(    PsiReference reference){
      final PsiElement element=reference.getElement();
      if (!JavaResolveUtil.isAccessible(member,member.getContainingClass(),modifierListCopy,element,null,null)) {
        final PsiElement context=PsiTreeUtil.getParentOfType(element,PsiMethod.class,PsiField.class,PsiClass.class,PsiFile.class);
        conflicts.putValue(element,RefactoringBundle.message("0.with.1.visibility.is.not.accessible.from.2",RefactoringUIUtil.getDescription(member,false),PsiBundle.visibilityPresentation(getModifier()),RefactoringUIUtil.getDescription(context,true)));
      }
      return true;
    }
  }
);
  return conflicts;
}
