{
  final PsiExpression expression=(PsiExpression)element;
  final PsiManager psiManager=expression.getManager();
  final PsiConstantEvaluationHelper helper=JavaPsiFacade.getInstance(psiManager.getProject()).getConstantEvaluationHelper();
  final Object value=helper.computeConstantExpression(expression);
  @NonNls final String newExpression;
  if (value instanceof String) {
    final String string=(String)value;
    newExpression='"' + StringUtil.escapeStringCharacters(string) + '"';
  }
 else   if (value instanceof Character) {
    newExpression='\'' + StringUtil.escapeStringCharacters(value.toString()) + '\'';
  }
 else   if (value instanceof Long) {
    newExpression=value.toString() + 'L';
  }
 else   if (value instanceof Double) {
    double v=((Double)value).doubleValue();
    if (Double.isNaN(v))     newExpression="java.lang.Double.NaN";
 else     if (Double.isInfinite(v))     newExpression=v > 0 ? "java.lang.Double.POSITIVE_INFINITY" : "java.lang.Double.NEGATIVE_INFINITY";
 else     newExpression=Double.toString(v);
  }
 else   if (value instanceof Float) {
    float v=((Float)value).floatValue();
    if (Float.isNaN(v))     newExpression="java.lang.Float.NaN";
 else     if (Float.isInfinite(v))     newExpression=v > 0 ? "java.lang.Float.POSITIVE_INFINITY" : "java.lang.Float.NEGATIVE_INFINITY";
 else     newExpression=Float.toString(v) + "f";
  }
 else   if (value == null) {
    newExpression="null";
  }
 else {
    newExpression=String.valueOf(value);
  }
  replaceExpression(newExpression,expression);
}
