{
  if (from instanceof PsiLocalVariable) {
    return ReferencesSearch.search(from).forEach(new Processor<PsiReference>(){
      public boolean process(      PsiReference reference){
        PsiElement element=reference.getElement();
        if (element.getTextOffset() < context.getTextOffset())         return true;
        return processAssignmentTarget(element,parent,processor);
      }
    }
);
  }
  if (from instanceof PsiParameter) {
    PsiParameter parameter=(PsiParameter)from;
    PsiElement scope=parameter.getDeclarationScope();
    Collection<PsiParameter> parametersToAnalyze=new THashSet<PsiParameter>();
    if (scope instanceof PsiMethod) {
      final PsiMethod method=(PsiMethod)scope;
      int index=method.getParameterList().getParameterIndex(parameter);
      Collection<PsiMethod> superMethods=new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));
      superMethods.add(method);
      for (Iterator<PsiMethod> iterator=superMethods.iterator(); iterator.hasNext(); ) {
        SliceManager.getInstance(method.getProject()).checkCanceled();
        PsiMethod superMethod=iterator.next();
        if (superMethod instanceof PsiCompiledElement) {
          iterator.remove();
        }
      }
      final THashSet<PsiMethod> implementors=new THashSet<PsiMethod>(superMethods);
      for (      PsiMethod superMethod : superMethods) {
        SliceManager.getInstance(method.getProject()).checkCanceled();
        if (!OverridingMethodsSearch.search(superMethod,parent.getScope().toSearchScope(),true).forEach(new Processor<PsiMethod>(){
          public boolean process(          PsiMethod sub){
            SliceManager.getInstance(method.getProject()).checkCanceled();
            implementors.add(sub);
            return true;
          }
        }
))         return false;
      }
      for (      PsiMethod implementor : implementors) {
        SliceManager.getInstance(method.getProject()).checkCanceled();
        PsiParameter[] parameters=implementor.getParameterList().getParameters();
        if (index != -1 && index < parameters.length) {
          parametersToAnalyze.add(parameters[index]);
        }
      }
    }
 else {
      parametersToAnalyze.add(parameter);
    }
    for (    final PsiParameter psiParameter : parametersToAnalyze) {
      SliceManager.getInstance(from.getProject()).checkCanceled();
      if (!ReferencesSearch.search(psiParameter).forEach(new Processor<PsiReference>(){
        public boolean process(        PsiReference reference){
          SliceManager.getInstance(from.getProject()).checkCanceled();
          PsiElement element=reference.getElement();
          return processAssignmentTarget(element,parent,processor);
        }
      }
))       return false;
    }
    return true;
  }
  if (from instanceof PsiField) {
    return ReferencesSearch.search(from).forEach(new Processor<PsiReference>(){
      public boolean process(      PsiReference reference){
        SliceManager.getInstance(from.getProject()).checkCanceled();
        PsiElement element=reference.getElement();
        return processAssignmentTarget(element,parent,processor);
      }
    }
);
  }
  if (from instanceof PsiMethod) {
    PsiMethod method=(PsiMethod)from;
    Collection<PsiMethod> superMethods=new THashSet<PsiMethod>(Arrays.asList(method.findDeepestSuperMethods()));
    superMethods.add(method);
    final Set<PsiReference> processed=new THashSet<PsiReference>();
    for (    final PsiMethod containingMethod : superMethods) {
      if (!MethodReferencesSearch.search(containingMethod,parent.getScope().toSearchScope(),true).forEach(new Processor<PsiReference>(){
        public boolean process(        final PsiReference reference){
          SliceManager.getInstance(from.getProject()).checkCanceled();
synchronized (processed) {
            if (!processed.add(reference))             return true;
          }
          PsiElement element=reference.getElement().getParent();
          if (element instanceof PsiCompiledElement)           return true;
          return processAssignmentTarget(element,parent,processor);
        }
      }
)) {
        return false;
      }
    }
  }
  return true;
}
