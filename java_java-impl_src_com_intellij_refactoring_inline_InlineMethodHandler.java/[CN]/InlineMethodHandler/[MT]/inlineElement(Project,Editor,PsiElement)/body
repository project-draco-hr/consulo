{
  PsiMethod method=(PsiMethod)element.getNavigationElement();
  if (method.getBody() == null) {
    String message;
    if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {
      message=RefactoringBundle.message("refactoring.cannot.be.applied.to.abstract.methods",REFACTORING_NAME);
    }
 else {
      message=RefactoringBundle.message("refactoring.cannot.be.applied.no.sources.attached",REFACTORING_NAME);
    }
    CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_METHOD);
    return;
  }
  PsiReference reference=editor != null ? TargetElementUtilBase.findReference(editor,editor.getCaretModel().getOffset()) : null;
  if (reference != null) {
    final PsiElement refElement=reference.getElement();
    if (refElement != null && !isEnabledForLanguage(refElement.getLanguage())) {
      String message=RefactoringBundle.message("refactoring.is.not.supported.for.language","Inline of Java method",refElement.getLanguage().getDisplayName());
      CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_METHOD);
      return;
    }
  }
  boolean allowInlineThisOnly=false;
  if (InlineMethodProcessor.checkBadReturns(method) && !InlineUtil.allUsagesAreTailCalls(method)) {
    if (reference != null && InlineUtil.getTailCallType(reference) != InlineUtil.TailCallType.None) {
      allowInlineThisOnly=true;
    }
 else {
      String message=RefactoringBundle.message("refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow",REFACTORING_NAME);
      CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_METHOD);
      return;
    }
  }
  if (reference == null && checkRecursive(method)) {
    String message=RefactoringBundle.message("refactoring.is.not.supported.for.recursive.methods",REFACTORING_NAME);
    CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_METHOD);
    return;
  }
  if (method.isConstructor()) {
    if (method.isVarArgs()) {
      String message=RefactoringBundle.message("refactoring.cannot.be.applied.to.vararg.constructors",REFACTORING_NAME);
      CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_CONSTRUCTOR);
      return;
    }
    final boolean chainingConstructor=isChainingConstructor(method);
    if (!chainingConstructor) {
      if (!isThisReference(reference)) {
        String message=RefactoringBundle.message("refactoring.cannot.be.applied.to.inline.non.chaining.constructors",REFACTORING_NAME);
        CommonRefactoringUtil.showErrorHint(project,editor,message,REFACTORING_NAME,HelpID.INLINE_CONSTRUCTOR);
        return;
      }
      allowInlineThisOnly=true;
    }
    if (reference != null) {
      final PsiElement refElement=reference.getElement();
      PsiCall constructorCall=refElement instanceof PsiJavaCodeReferenceElement ? RefactoringUtil.getEnclosingConstructorCall((PsiJavaCodeReferenceElement)refElement) : null;
      if (constructorCall == null || !method.equals(constructorCall.resolveMethod()))       reference=null;
    }
  }
 else {
    if (reference != null && !method.getManager().areElementsEquivalent(method,reference.resolve())) {
      reference=null;
    }
  }
  final boolean invokedOnReference=reference != null;
  if (!invokedOnReference) {
    final VirtualFile vFile=method.getContainingFile().getVirtualFile();
    ReadonlyStatusHandler.getInstance(project).ensureFilesWritable(vFile);
  }
  PsiJavaCodeReferenceElement refElement=reference != null ? (PsiJavaCodeReferenceElement)reference.getElement() : null;
  InlineMethodDialog dialog=new InlineMethodDialog(project,method,refElement,editor,allowInlineThisOnly);
  dialog.show();
}
