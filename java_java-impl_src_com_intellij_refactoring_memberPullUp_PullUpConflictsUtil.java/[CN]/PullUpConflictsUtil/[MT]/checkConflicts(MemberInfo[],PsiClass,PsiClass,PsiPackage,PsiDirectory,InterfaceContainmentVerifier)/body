{
  final Set<PsiMember> movedMembers=new HashSet<PsiMember>();
  final Set<PsiMethod> abstractMethods=new HashSet<PsiMethod>();
  final boolean isInterfaceTarget;
  final PsiElement targetRepresentativeElement;
  if (superClass != null) {
    isInterfaceTarget=superClass.isInterface();
    targetRepresentativeElement=superClass;
  }
 else {
    isInterfaceTarget=false;
    targetRepresentativeElement=targetDirectory;
  }
  for (  MemberInfo info : infos) {
    PsiMember member=info.getMember();
    if (member instanceof PsiMethod) {
      if (!info.isToAbstract() && !isInterfaceTarget) {
        movedMembers.add(member);
      }
 else {
        abstractMethods.add((PsiMethod)member);
      }
    }
 else {
      movedMembers.add(member);
    }
  }
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  RefactoringConflictsUtil.analyzeAccessibilityConflicts(movedMembers,superClass,conflicts,null,targetRepresentativeElement);
  if (superClass != null) {
    checkSuperclassMembers(superClass,infos,conflicts);
    if (isInterfaceTarget) {
      checkInterfaceTarget(infos,conflicts);
    }
  }
  List<PsiElement> checkModuleConflictsList=new ArrayList<PsiElement>();
  for (  PsiMember member : movedMembers) {
    if (member instanceof PsiMethod || member instanceof PsiClass && !(member instanceof PsiCompiledElement)) {
      ConflictingUsagesOfSubClassMembers visitor=new ConflictingUsagesOfSubClassMembers(member,movedMembers,abstractMethods,subclass,superClass,superClass != null ? null : targetPackage,conflicts,interfaceContainmentVerifier);
      member.accept(visitor);
    }
    checkModuleConflictsList.add(member);
  }
  for (  final PsiMethod method : abstractMethods) {
    checkModuleConflictsList.add(method.getParameterList());
    checkModuleConflictsList.add(method.getReturnTypeElement());
    checkModuleConflictsList.add(method.getTypeParameterList());
  }
  RefactoringConflictsUtil.analyzeModuleConflicts(subclass.getProject(),checkModuleConflictsList,new UsageInfo[0],targetRepresentativeElement,conflicts);
  return conflicts;
}
