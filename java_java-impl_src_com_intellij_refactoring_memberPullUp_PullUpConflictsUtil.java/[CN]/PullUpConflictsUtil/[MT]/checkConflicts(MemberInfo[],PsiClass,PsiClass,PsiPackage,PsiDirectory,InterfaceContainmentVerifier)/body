{
  final Set<PsiElement> movedMembers=new HashSet<PsiElement>();
  final Set<PsiMethod> abstractMethods=new HashSet<PsiMethod>();
  final boolean isInterfaceTarget;
  final PsiElement targetRepresentativeElement;
  if (superClass != null) {
    isInterfaceTarget=superClass.isInterface();
    targetRepresentativeElement=superClass;
  }
 else {
    isInterfaceTarget=false;
    targetRepresentativeElement=targetDirectory;
  }
  for (  MemberInfo info : infos) {
    PsiElement member=info.getMember();
    if (member instanceof PsiMethod) {
      if (!info.isToAbstract() && !isInterfaceTarget) {
        movedMembers.add(member);
      }
 else {
        abstractMethods.add((PsiMethod)member);
      }
    }
 else {
      movedMembers.add(member);
    }
  }
  final LinkedHashSet<String> conflictsList=new LinkedHashSet<String>();
  if (superClass != null) {
    checkSuperclassMembers(superClass,infos,conflictsList);
    if (isInterfaceTarget) {
      checkInterfaceTarget(infos,conflictsList);
    }
  }
  List<PsiElement> checkModuleConflictsList=new ArrayList<PsiElement>();
  for (  PsiElement member : movedMembers) {
    if (member instanceof PsiMethod || member instanceof PsiClass) {
      ConflictingUsagesOfSubClassMembers visitor=new ConflictingUsagesOfSubClassMembers(member,movedMembers,abstractMethods,subclass,superClass,superClass != null ? null : targetPackage,conflictsList,interfaceContainmentVerifier);
      member.accept(visitor);
    }
    checkModuleConflictsList.add(member);
  }
  for (  final PsiMethod method : abstractMethods) {
    checkModuleConflictsList.add(method.getParameterList());
    checkModuleConflictsList.add(method.getReturnTypeElement());
    checkModuleConflictsList.add(method.getTypeParameterList());
  }
  RefactoringUtil.analyzeModuleConflicts(subclass.getProject(),checkModuleConflictsList,new UsageInfo[0],targetRepresentativeElement,conflictsList);
  return ArrayUtil.toStringArray(conflictsList);
}
