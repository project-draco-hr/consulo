{
  if (classMember != null && RefactoringHierarchyUtil.isMemberBetween(mySuperClass,mySubclass,classMember)) {
    if (classMember.hasModifierProperty(PsiModifier.STATIC) && !willBeMoved(classMember)) {
      final boolean isAccessible;
      if (mySuperClass != null) {
        isAccessible=PsiUtil.isAccessible(classMember,mySuperClass,null);
      }
 else       if (myTargetPackage != null) {
        isAccessible=PsiUtil.isAccessibleFromPackage(classMember,myTargetPackage);
      }
 else {
        isAccessible=classMember.hasModifierProperty(PsiModifier.PUBLIC);
      }
      if (!isAccessible) {
        String message=RefactoringBundle.message("0.uses.1.which.is.not.accessible.from.the.superclass",RefactoringUIUtil.getDescription(myScope,false),RefactoringUIUtil.getDescription(classMember,true));
        message=ConflictsUtil.capitalize(message);
        myConflictsList.add(message);
      }
      return;
    }
    if (!myAbstractMethods.contains(classMember) && !willBeMoved(classMember)) {
      if (!existsInSuperClass(classMember)) {
        String message=RefactoringBundle.message("0.uses.1.which.is.not.moved.to.the.superclass",RefactoringUIUtil.getDescription(myScope,false),RefactoringUIUtil.getDescription(classMember,true));
        message=ConflictsUtil.capitalize(message);
        myConflictsList.add(message);
      }
    }
  }
}
