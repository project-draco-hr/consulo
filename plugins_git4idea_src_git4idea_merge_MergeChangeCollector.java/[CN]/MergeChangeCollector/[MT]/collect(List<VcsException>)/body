{
  try {
    String root=myRoot.getPath();
    GitSimpleHandler h=new GitSimpleHandler(myProject,myRoot,GitHandler.LS_FILES);
    h.setNoSSH(true);
    h.setSilent(true);
    h.addParameters("--unmerged");
    for (    String line : h.run().split("\n")) {
      if (line.length() == 0) {
        continue;
      }
      String[] tk=line.split("[\t ]+");
      final String relative=tk[tk.length - 1];
      if (!myUnmergedPaths.add(relative)) {
        continue;
      }
      String path=root + "/" + GitUtil.unescapePath(relative);
      myUpdates.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).add(path);
    }
    h=new GitSimpleHandler(myProject,myRoot,GitHandler.DIFF);
    h.setSilent(true);
    h.setNoSSH(true);
    h.addParameters("--name-status","--diff-filter=ADMRUX",myStart.getRev());
    for (    String line : h.run().split("\n")) {
      if (line.length() == 0) {
        continue;
      }
      String[] tk=line.split("[\t ]+");
      final String relative=tk[tk.length - 1];
      if (myUnmergedPaths.contains(relative)) {
        continue;
      }
      String path=root + "/" + GitUtil.unescapePath(relative);
switch (tk[0].charAt(0)) {
case 'M':
        myUpdates.getGroupById(FileGroup.UPDATED_ID).add(path);
      break;
case 'A':
    myUpdates.getGroupById(FileGroup.CREATED_ID).add(path);
  break;
case 'D':
myUpdates.getGroupById(FileGroup.REMOVED_FROM_REPOSITORY_ID).add(path);
break;
default :
throw new IllegalStateException("Unexpected status: " + line);
}
}
}
 catch (VcsException e) {
exceptions.add(e);
}
}
