{
  try {
    String root=myRoot.getPath();
    GitSimpleHandler h=new GitSimpleHandler(myProject,myRoot,GitHandler.LS_FILES);
    h.setNoSSH(true);
    h.setSilent(true);
    h.addParameters("--unmerged");
    for (    String line : h.run().split("\n")) {
      if (line.length() == 0) {
        continue;
      }
      String[] tk=line.split("[\t ]+");
      final String relative=tk[tk.length - 1];
      if (!myUnmergedPaths.add(relative)) {
        continue;
      }
      String path=root + "/" + GitUtil.unescapePath(relative);
      myUpdates.getGroupById(FileGroup.MERGED_WITH_CONFLICT_ID).add(path);
    }
    GitRevisionNumber currentHead=GitRevisionNumber.resolve(myProject,myRoot,"HEAD");
    TreeSet<String> updated=new TreeSet<String>();
    TreeSet<String> created=new TreeSet<String>();
    TreeSet<String> removed=new TreeSet<String>();
    if (currentHead.equals(myStart)) {
      File mergeHeadsFile=new File(root,".git/MERGE_HEAD");
      try {
        String mergeHeads=new String(FileUtil.loadFileText(mergeHeadsFile,GitConfigUtil.UTF8_ENCODING));
        for (StringScanner s=new StringScanner(mergeHeads); s.hasMoreData(); ) {
          String head=s.line();
          if (head.length() == 0) {
            continue;
          }
          processDiff(root,updated,created,removed,myStart.getRev() + "..." + head);
        }
      }
 catch (      IOException e) {
        exceptions.add(new VcsException("Unable to read the file " + mergeHeadsFile + ": "+ e.getMessage(),e));
      }
    }
 else {
      processDiff(root,updated,created,removed,myStart.getRev() + "..HEAD");
    }
    addAll(FileGroup.UPDATED_ID,updated);
    addAll(FileGroup.CREATED_ID,created);
    addAll(FileGroup.REMOVED_FROM_REPOSITORY_ID,removed);
  }
 catch (  VcsException e) {
    exceptions.add(e);
  }
}
