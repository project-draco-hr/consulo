{
  final String branchAsString=branchUrl.toString();
  final String keyString=branchAsString + "@" + targetRevision;
  final Set<Long> mergeInfo=myPathMergedMap.get(keyString);
  if (mergeInfo != null) {
    return SvnMergeInfoCache.MergeCheckResult.getInstance(mergeInfo.contains(revisionAsked));
  }
  final SVNPropertyData mergeinfoProperty;
  try {
    mergeinfoProperty=myClient.doGetProperty(branchUrl,SVNProperty.MERGE_INFO,SVNRevision.UNDEFINED,SVNRevision.create(targetRevision));
  }
 catch (  SVNException e) {
    LOG.info(e);
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  if (mergeinfoProperty == null) {
    final String newTrunkUrl=SVNPathUtil.removeTail(trunkUrl).trim();
    final SVNURL newBranchUrl;
    try {
      newBranchUrl=branchUrl.removePathTail();
    }
 catch (    SVNException e) {
      LOG.info(e);
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
    final String absoluteTrunk=SVNPathUtil.append(myRepositoryRoot,newTrunkUrl);
    if ((1 >= newTrunkUrl.length()) || (myRepositoryRoot.length() >= newBranchUrl.toString().length()) || (newBranchUrl.equals(absoluteTrunk))) {
      return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
    }
    return goUpInRepo(revisionAsked,targetRevision,newBranchUrl,newTrunkUrl);
  }
  return processMergeinfoProperty(keyString,revisionAsked,mergeinfoProperty.getValue(),trunkUrl,false);
}
