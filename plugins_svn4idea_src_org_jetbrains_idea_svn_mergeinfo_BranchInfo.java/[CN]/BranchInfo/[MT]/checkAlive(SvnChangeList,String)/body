{
  final SVNInfo info=getInfo(new File(branchPath));
  if (info == null || info.getURL() == null || (!SVNPathUtil.isAncestor(myBranchUrl,info.getURL().toString()))) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  final String subPathUnderBranch=SVNPathUtil.getRelativePath(myBranchUrl,info.getURL().toString());
  final Set<SvnMergeInfoCache.MergeCheckResult> result=new HashSet<SvnMergeInfoCache.MergeCheckResult>();
  result.addAll(checkPaths(list.getNumber(),list.getAddedPaths(),branchPath,subPathUnderBranch));
  if (result.contains(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
  result.addAll(checkPaths(list.getNumber(),list.getDeletedPaths(),branchPath,subPathUnderBranch));
  if (result.contains(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
  result.addAll(checkPaths(list.getNumber(),list.getChangedPaths(),branchPath,subPathUnderBranch));
  if (result.contains(SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_EXISTS;
  }
 else   if (result.contains(SvnMergeInfoCache.MergeCheckResult.NOT_MERGED)) {
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  return SvnMergeInfoCache.MergeCheckResult.MERGED;
}
