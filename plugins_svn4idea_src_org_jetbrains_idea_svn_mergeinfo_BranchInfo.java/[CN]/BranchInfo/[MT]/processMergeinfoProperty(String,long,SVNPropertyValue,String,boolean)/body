{
  final String valueAsString=value.toString().trim();
  if (valueAsString.length() == 0) {
    myPathMergedMap.put(pathWithRevisionNumber,Collections.<Long>emptySet());
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  final Map<String,SVNMergeRangeList> map;
  try {
    map=SVNMergeInfoUtil.parseMergeInfo(new StringBuffer(replaceSeparators(value.getString())),null);
  }
 catch (  SVNException e) {
    LOG.info(e);
    return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
  }
  for (  String key : map.keySet()) {
    if ((key != null) && (trunkRelativeUrl.startsWith(key))) {
      final Set<Long> revisions=new HashSet<Long>();
      final Set<Long> nonInheritableRevisions=new HashSet<Long>();
      final SVNMergeRangeList rangesList=map.get(key);
      boolean result=false;
      for (      SVNMergeRange range : rangesList.getRanges()) {
        final long startRevision=range.getStartRevision() + 1;
        final long endRevision=range.getEndRevision();
        final boolean isInheritable=range.isInheritable();
        final boolean inInterval=(revisionAsked >= startRevision) && (revisionAsked <= endRevision);
        if ((isInheritable || self) && inInterval) {
          result=true;
        }
        for (long i=startRevision; i <= endRevision; i++) {
          if (isInheritable) {
            revisions.add(i);
          }
 else {
            nonInheritableRevisions.add(i);
          }
        }
      }
      myPathMergedMap.put(pathWithRevisionNumber,revisions);
      if (!nonInheritableRevisions.isEmpty()) {
        myNonInheritablePathMergedMap.put(pathWithRevisionNumber,nonInheritableRevisions);
      }
      return SvnMergeInfoCache.MergeCheckResult.getInstance(result);
    }
  }
  myPathMergedMap.put(pathWithRevisionNumber,Collections.<Long>emptySet());
  return SvnMergeInfoCache.MergeCheckResult.NOT_MERGED;
}
