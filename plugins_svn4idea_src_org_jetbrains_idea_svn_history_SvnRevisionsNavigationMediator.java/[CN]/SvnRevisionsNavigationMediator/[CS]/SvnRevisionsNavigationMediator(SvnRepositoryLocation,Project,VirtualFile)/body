{
  myProject=project;
  final SvnVcs vcs=SvnVcs.getInstance(project);
  myChunks=new LinkedList<List<Fragment>>();
  final SVNURL[] repositoryRoot=new SVNURL[1];
  final long[] youngRevision=new long[1];
  final SVNException[] exception=new SVNException[1];
  final boolean succeeded=ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
    @Override public void run(){
      SVNRepository repository=null;
      try {
        repository=vcs.createRepository(location.getURL());
        youngRevision[0]=repository.getLatestRevision();
        repositoryRoot[0]=repository.getRepositoryRoot(false);
      }
 catch (      SVNException e) {
        exception[0]=e;
      }
 finally {
        if (repository != null) {
          repository.closeSession();
        }
      }
    }
  }
,"Getting latest repository revision",true,myProject);
  if (exception[0] != null) {
    throw new VcsException(exception[0]);
  }
  if (!succeeded) {
    throw new ProcessCanceledException();
  }
  final Iterator<ChangesBunch> visualIterator=project.isDefault() ? null : CommittedChangesCache.getInstance(project).getBackBunchedIterator(vcs,vcsRoot,location,CHUNK_SIZE);
  final Iterator<ChangesBunch> internalIterator=project.isDefault() ? null : LoadedRevisionsCache.getInstance(project).iterator(location.getURL());
  myInternallyCached=(internalIterator == null) ? null : new InternallyCachedProvider(internalIterator,myProject);
  myVisuallyCached=(visualIterator == null) ? null : new VisuallyCachedProvider(visualIterator,myProject,location);
  myChunkFactory=new BunchFactory(myInternallyCached,myVisuallyCached,new LiveProvider(vcs,location,youngRevision[0],new SvnLogUtil(myProject,vcs,location,repositoryRoot[0])));
  myCurrentIdx=-1;
  goBack();
}
