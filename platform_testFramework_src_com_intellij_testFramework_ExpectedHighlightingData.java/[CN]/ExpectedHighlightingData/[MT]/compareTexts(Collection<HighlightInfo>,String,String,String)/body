{
  final ArrayList<HighlightInfo> list=new ArrayList<HighlightInfo>(infos);
  Collections.sort(list,new Comparator<HighlightInfo>(){
    @Override public int compare(    HighlightInfo o1,    HighlightInfo o2){
      final int start=o2.startOffset - o1.startOffset;
      return start != 0 ? start : o1.endOffset - o2.endOffset;
    }
  }
);
  StringBuilder sb=new StringBuilder();
  int end=text.length();
  HighlightInfo prev=null;
  String prevSeverity=null;
  for (  HighlightInfo info : list) {
    for (    Map.Entry<String,ExpectedHighlightingSet> entry : highlightingTypes.entrySet()) {
      final ExpectedHighlightingSet set=entry.getValue();
      if (set.enabled && set.severity == info.getSeverity() && set.endOfLine == info.isAfterEndOfLine) {
        final String severity=entry.getKey();
        if (prev != null && info.endOffset > prev.startOffset) {
          Assert.assertTrue("Overlapped highlightings: " + info + " and "+ prev,info.endOffset >= prev.endOffset);
          int offset=prevSeverity.length() * 2 + 14 + (prev.description != null ? prev.description.length() : 4) + prev.endOffset - prev.startOffset + info.endOffset - prev.endOffset;
          sb.insert(offset,"</" + severity + ">");
          sb.insert(0,text.substring(info.startOffset,prev.startOffset));
          sb.insert(0,"<" + severity + " descr=\""+ info.description+ "\">");
        }
 else {
          sb.insert(0,text.substring(info.endOffset,end));
          sb.insert(0,"<" + severity + " descr=\""+ info.description+ "\">"+ text.substring(info.startOffset,info.endOffset)+ "</"+ severity+ ">");
        }
        end=info.startOffset;
        prev=info;
        prevSeverity=severity;
        break;
      }
    }
  }
  sb.insert(0,text.substring(0,end));
  if (filePath != null && !myText.equals(sb.toString())) {
    throw new FileComparisonFailure(failMessage,myText,sb.toString(),filePath);
  }
  Assert.assertEquals(failMessage + "\n",myText,sb.toString());
  Assert.fail(failMessage);
}
