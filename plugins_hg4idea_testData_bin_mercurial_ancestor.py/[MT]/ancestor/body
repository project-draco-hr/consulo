def ancestor(a, b, pfunc):
    '\n    return a minimal-distance ancestor of nodes a and b, or None if there is no\n    such ancestor. Note that there can be several ancestors with the same\n    (minimal) distance, and the one returned is arbitrary.\n\n    pfunc must return a list of parent vertices for a given vertex\n    '
    if (a == b):
        return a
    parentcache = {}
    visit = [a, b]
    depth = {}
    while visit:
        vertex = visit[(-1)]
        pl = pfunc(vertex)
        parentcache[vertex] = pl
        if (not pl):
            depth[vertex] = 0
            visit.pop()
        else:
            for p in pl:
                if ((p == a) or (p == b)):
                    return p
                if (p not in depth):
                    visit.append(p)
            if (visit[(-1)] == vertex):
                depth[vertex] = (min([depth[p] for p in pl]) - 1)
                visit.pop()

    def ancestors(vertex):
        h = [(depth[vertex], vertex)]
        seen = set()
        while h:
            (d, n) = heapq.heappop(h)
            if (n not in seen):
                seen.add(n)
                yield (d, n)
                for p in parentcache[n]:
                    heapq.heappush(h, (depth[p], p))

    def generations(vertex):
        (sg, s) = (None, set())
        for (g, v) in ancestors(vertex):
            if (g != sg):
                if sg:
                    yield (sg, s)
                (sg, s) = (g, set((v,)))
            else:
                s.add(v)
        yield (sg, s)
    x = generations(a)
    y = generations(b)
    gx = x.next()
    gy = y.next()
    try:
        while 1:
            if (gx[0] == gy[0]):
                for v in gx[1]:
                    if (v in gy[1]):
                        return v
                gy = y.next()
                gx = x.next()
            elif (gx[0] > gy[0]):
                gy = y.next()
            else:
                gx = x.next()
    except StopIteration:
        return None
