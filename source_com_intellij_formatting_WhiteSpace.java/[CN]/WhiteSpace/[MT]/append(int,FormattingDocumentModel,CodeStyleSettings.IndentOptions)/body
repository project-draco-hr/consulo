{
  final int oldEndOffset=myTextRange.getEndOffset();
  if (newEndOffset == oldEndOffset)   return;
  if (myTextRange.getStartOffset() >= newEndOffset) {
    InitialInfoBuilder.assertInvalidRanges(myTextRange.getStartOffset(),newEndOffset,model,"some block intersects with whitespace");
  }
  myTextRange=new TextRange(myTextRange.getStartOffset(),newEndOffset);
  myInitial=model.getText(myTextRange);
  if (!coveredByBlock(model)) {
    InitialInfoBuilder.assertInvalidRanges(myTextRange.getStartOffset(),myTextRange.getEndOffset(),model,"nonempty text is not covered by block");
  }
  final int tabsize=options.TAB_SIZE;
  for (int i=oldEndOffset - myTextRange.getStartOffset(); i < newEndOffset - myTextRange.getStartOffset(); i++) {
switch (myInitial.charAt(i)) {
case '\n':
      myLineFeeds++;
    mySpaces=0;
  myIndentSpaces=0;
break;
case ' ':
mySpaces++;
break;
case '\t':
myIndentSpaces+=tabsize;
break;
}
}
myInitialLineFeeds=myLineFeeds;
myInitialSpaces=getTotalSpaces();
}
