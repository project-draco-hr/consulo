{
  final Set<HighlightInfo> gotHighlights=new THashSet<HighlightInfo>(100);
  final Set<HighlightInfo> outsideResult=new THashSet<HighlightInfo>(100);
  DaemonCodeAnalyzer daemonCodeAnalyzer=DaemonCodeAnalyzer.getInstance(myProject);
  final FileStatusMap fileStatusMap=((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap();
  HighlightVisitor[] highlightVisitors=createHighlightVisitors();
  final HighlightVisitor[] filteredVisitors=filterVisitors(highlightVisitors,myFile);
  final List<PsiElement> inside=new ArrayList<PsiElement>();
  final List<PsiElement> outside=new ArrayList<PsiElement>();
  try {
    Divider.divideInsideAndOutside(myFile,myStartOffset,myEndOffset,myPriorityRange,inside,outside,HighlightLevelUtil.AnalysisLevel.HIGHLIGHT);
    final Set<PsiFile> injected=new THashSet<PsiFile>();
    getInjectedPsiFiles(inside,outside,progress,injected);
    setProgressLimit((long)(inside.size() + outside.size()));
    final boolean forceHighlightParents=forceHighlightParents();
    if (!isDumbMode()) {
      highlightTodos(myFile,myDocument.getCharsSequence(),myStartOffset,myEndOffset,progress,myPriorityRange,gotHighlights,outsideResult);
    }
    collectHighlights(inside,new Runnable(){
      @Override public void run(){
        THashSet<HighlightInfo> injectedResult=new THashSet<HighlightInfo>();
        if (!addInjectedPsiHighlights(injected,progress,Collections.synchronizedSet(injectedResult)))         throw new ProcessCanceledException();
        final List<HighlightInfo> toApplyOutside=new ArrayList<HighlightInfo>(gotHighlights.size());
        for (        HighlightInfo info : injectedResult) {
          if (myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
            gotHighlights.add(info);
          }
 else {
            toApplyOutside.add(info);
          }
        }
        if (outsideResult.isEmpty() && toApplyOutside.isEmpty()) {
          return;
        }
        final ProperTextRange priorityIntersection=myPriorityRange.intersection(new TextRange(myStartOffset,myEndOffset));
        if ((!inside.isEmpty() || !gotHighlights.isEmpty()) && priorityIntersection != null) {
          final List<HighlightInfo> toApplyInside=new ArrayList<HighlightInfo>(gotHighlights);
          myHighlights.addAll(toApplyInside);
          gotHighlights.clear();
          gotHighlights.addAll(outsideResult);
          UIUtil.invokeLaterIfNeeded(new Runnable(){
            @Override public void run(){
              if (myProject.isDisposed())               return;
              MarkupModel markupModel=myDocument.getMarkupModel(myProject);
              UpdateHighlightersUtil.setHighlightersInRange(myProject,myDocument,priorityIntersection,getColorsScheme(),toApplyInside,(MarkupModelEx)markupModel,Pass.UPDATE_ALL);
            }
          }
);
          UIUtil.invokeLaterIfNeeded(new Runnable(){
            @Override public void run(){
              if (myProject.isDisposed() || myEditor == null)               return;
              new ShowAutoImportPass(myProject,myFile,myEditor).applyInformationToEditor();
            }
          }
);
        }
        myApplyCommand=new Runnable(){
          @Override public void run(){
            final List<HighlightInfo> insideInfos=new ArrayList<HighlightInfo>(gotHighlights.size());
            ProperTextRange range=new ProperTextRange(myStartOffset,myEndOffset);
            for (            HighlightInfo info : gotHighlights) {
              if (!range.containsRange(info.getStartOffset(),info.getEndOffset()))               continue;
              if (myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
                insideInfos.add(info);
              }
 else {
                toApplyOutside.add(info);
              }
            }
            UpdateHighlightersUtil.setHighlightersOutsideRange(myProject,myDocument,toApplyOutside,getColorsScheme(),myStartOffset,myEndOffset,myPriorityRange,Pass.UPDATE_ALL);
          }
        }
;
      }
    }
,outside,progress,filteredVisitors,gotHighlights,forceHighlightParents);
    if (myUpdateAll) {
      fileStatusMap.setErrorFoundFlag(myDocument,myErrorFound);
    }
  }
  finally {
    incVisitorUsageCount(-1);
  }
  myHighlights.addAll(gotHighlights);
}
