{
  final Set<HighlightInfo> result=new THashSet<HighlightInfo>(100);
  final Set<HighlightInfo> outsideResult=new THashSet<HighlightInfo>(100);
  DaemonCodeAnalyzer daemonCodeAnalyzer=DaemonCodeAnalyzer.getInstance(myProject);
  final FileStatusMap fileStatusMap=((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap();
  HighlightVisitor[] highlightVisitors=createHighlightVisitors();
  final HighlightVisitor[] filteredVisitors=filterVisitors(highlightVisitors,myFile);
  final List<PsiElement> inside=new ArrayList<PsiElement>();
  final List<PsiElement> outside=new ArrayList<PsiElement>();
  try {
    Divider.getInsideAndOutside(myFile,myStartOffset,myEndOffset,myPriorityRange,inside,outside,HighlightLevelUtil.AnalysisLevel.HIGHLIGHT);
    final List<PsiFile> injectedInside=new ArrayList<PsiFile>();
    final List<PsiFile> injectedOutside=new ArrayList<PsiFile>();
    divideInjectedPsiHighlights(inside,outside,progress,injectedInside,injectedOutside);
    setProgressLimit((long)(inside.size() + outside.size()));
    final boolean forceHighlightParents=forceHighlightParents();
    if (!isDumbMode()) {
      highlightTodos(myFile,myDocument.getCharsSequence(),myStartOffset,myEndOffset,progress,myPriorityRange,result,outsideResult);
    }
    collectHighlights(inside,new Runnable(){
      @Override public void run(){
        if (!addInjectedPsiHighlights(injectedInside,progress,Collections.synchronizedSet(result)))         throw new ProcessCanceledException();
        if (!outside.isEmpty() || !injectedOutside.isEmpty()) {
          if (!inside.isEmpty()) {
            final List<HighlightInfo> toApply=new ArrayList<HighlightInfo>(result.size());
            for (            HighlightInfo info : result) {
              if (myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
                toApply.add(info);
              }
 else {
                outsideResult.add(info);
              }
            }
            myHighlights.addAll(toApply);
            result.clear();
            result.addAll(outsideResult);
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              @Override public void run(){
                if (progress.isCanceled())                 return;
                MarkupModel markupModel=myDocument.getMarkupModel(myProject);
                ProperTextRange range=myPriorityRange.intersection(new TextRange(myStartOffset,myEndOffset));
                UpdateHighlightersUtil.setHighlightersInRange(range,toApply,(MarkupModelEx)markupModel,Pass.UPDATE_ALL,myDocument,myProject);
              }
            }
);
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              @Override public void run(){
                if (progress.isCanceled() || myEditor == null)                 return;
                new ShowAutoImportPass(myProject,myFile,myEditor).applyInformationToEditor();
              }
            }
);
          }
          final List<HighlightInfo> injectedOutsideInfos=Collections.synchronizedList(new ArrayList<HighlightInfo>());
          if (!addInjectedPsiHighlights(injectedOutside,progress,injectedOutsideInfos))           throw new ProcessCanceledException();
          myApplyCommand=new Runnable(){
            @Override public void run(){
              final List<HighlightInfo> insideInfos=new ArrayList<HighlightInfo>(result.size());
              final List<HighlightInfo> toApply=new ArrayList<HighlightInfo>(result.size());
              ProperTextRange range=new ProperTextRange(myStartOffset,myEndOffset);
              for (              HighlightInfo info : result) {
                if (!range.containsRange(info.getStartOffset(),info.getEndOffset()))                 continue;
                if (myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
                  insideInfos.add(info);
                }
 else {
                  toApply.add(info);
                }
              }
              toApply.addAll(injectedOutsideInfos);
              UpdateHighlightersUtil.setHighlightersToEditorOutsideRange(myProject,myDocument,toApply,myStartOffset,myEndOffset,myPriorityRange,Pass.UPDATE_ALL);
            }
          }
;
        }
      }
    }
,outside,progress,filteredVisitors,result,forceHighlightParents);
    if (myUpdateAll) {
      fileStatusMap.setErrorFoundFlag(myDocument,myErrorFound);
    }
  }
  finally {
    incVisitorUsageCount(-1);
  }
  myHighlights.addAll(result);
}
