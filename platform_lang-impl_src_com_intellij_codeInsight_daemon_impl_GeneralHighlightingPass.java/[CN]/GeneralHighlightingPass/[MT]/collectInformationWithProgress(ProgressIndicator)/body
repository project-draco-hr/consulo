{
  final Set<HighlightInfo> gotHighlights=new THashSet<HighlightInfo>(100);
  final Set<HighlightInfo> outsideResult=new THashSet<HighlightInfo>(100);
  DaemonCodeAnalyzer daemonCodeAnalyzer=DaemonCodeAnalyzer.getInstance(myProject);
  HighlightVisitor[] highlightVisitors=getHighlightVisitors();
  final List<PsiElement> inside=new ArrayList<PsiElement>();
  final List<PsiElement> outside=new ArrayList<PsiElement>();
  try {
    final HighlightVisitor[] filteredVisitors=filterVisitors(highlightVisitors,myFile);
    Divider.divideInsideAndOutside(myFile,myStartOffset,myEndOffset,myPriorityRange,inside,outside,HighlightLevelUtil.AnalysisLevel.HIGHLIGHT,false);
    setProgressLimit((long)(inside.size() + outside.size()));
    final boolean forceHighlightParents=forceHighlightParents();
    if (!isDumbMode()) {
      highlightTodos(myFile,myDocument.getCharsSequence(),myStartOffset,myEndOffset,progress,myPriorityRange,gotHighlights,outsideResult);
    }
    collectHighlights(inside,new Runnable(){
      @Override public void run(){
        Set<HighlightInfo> injectedResult=new THashSet<HighlightInfo>();
        final Set<PsiFile> injected=new THashSet<PsiFile>();
        getInjectedPsiFiles(inside,outside,progress,injected);
        if (!addInjectedPsiHighlights(injected,progress,Collections.synchronizedSet(injectedResult)))         throw new ProcessCanceledException();
        final List<HighlightInfo> injectionsOutside=new ArrayList<HighlightInfo>(gotHighlights.size());
        Set<HighlightInfo> result;
synchronized (injectedResult) {
          result=injectedResult;
        }
        for (        HighlightInfo info : result) {
          if (myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
            gotHighlights.add(info);
          }
 else {
            injectionsOutside.add(info);
          }
        }
        if (outsideResult.isEmpty() && injectionsOutside.isEmpty()) {
          return;
        }
        final ProperTextRange priorityIntersection=myPriorityRange.intersection(new TextRange(myStartOffset,myEndOffset));
        if ((!inside.isEmpty() || !gotHighlights.isEmpty()) && priorityIntersection != null) {
          final List<HighlightInfo> toApplyInside=new ArrayList<HighlightInfo>(gotHighlights);
          myHighlights.addAll(toApplyInside);
          gotHighlights.clear();
          gotHighlights.addAll(outsideResult);
          final long modificationStamp=myDocument.getModificationStamp();
          UIUtil.invokeLaterIfNeeded(new Runnable(){
            @Override public void run(){
              if (myProject.isDisposed() || modificationStamp != myDocument.getModificationStamp())               return;
              MarkupModel markupModel=DocumentMarkupModel.forDocument(myDocument,myProject,true);
              UpdateHighlightersUtil.setHighlightersInRange(myProject,myDocument,priorityIntersection,getColorsScheme(),toApplyInside,(MarkupModelEx)markupModel,Pass.UPDATE_ALL);
              if (myEditor != null) {
                new ShowAutoImportPass(myProject,myFile,myEditor).applyInformationToEditor();
              }
            }
          }
);
        }
        myApplyCommand=new Runnable(){
          @Override public void run(){
            ProperTextRange range=new ProperTextRange(myStartOffset,myEndOffset);
            List<HighlightInfo> toApply=new ArrayList<HighlightInfo>();
            for (            HighlightInfo info : gotHighlights) {
              if (!range.containsRange(info.getStartOffset(),info.getEndOffset()))               continue;
              if (!myPriorityRange.containsRange(info.getStartOffset(),info.getEndOffset())) {
                toApply.add(info);
              }
            }
            toApply.addAll(injectionsOutside);
            UpdateHighlightersUtil.setHighlightersOutsideRange(myProject,myDocument,toApply,getColorsScheme(),myStartOffset,myEndOffset,myPriorityRange,Pass.UPDATE_ALL);
          }
        }
;
      }
    }
,outside,progress,filteredVisitors,gotHighlights,forceHighlightParents);
    if (myUpdateAll) {
      ((DaemonCodeAnalyzerImpl)daemonCodeAnalyzer).getFileStatusMap().setErrorFoundFlag(myDocument,myErrorFound);
    }
  }
  finally {
    incVisitorUsageCount(-1);
  }
  myHighlights.addAll(gotHighlights);
}
