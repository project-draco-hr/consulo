{
switch (myDetectedProblem) {
case UNMERGED_FILES:
    return GitBranchUtil.proposeToResolveUnmergedFiles(myProject,myRepositories,getCommonErrorTitle(),"Couldn't checkout branch due to unmerged files.");
case LOCAL_CHANGES_OVERWRITTEN_BY_CHECKOUT:
  if (GitWouldBeOverwrittenByCheckoutDialog.showAndGetAnswer(myProject,myLocalChangesOverwrittenByCheckout)) {
    return smartCheckout(myProblematicRepositories,myStartPointReference,myNewBranch,myIndicator);
  }
return GitBranchOperationResult.error(getCommonErrorTitle(),"Local changes would be overwritten by checkout.<br/>Commit or stash the changes before checking out.");
case UNTRACKED_FILES_OVERWRITTEN_BY_CHECKOUT:
default :
throw new AssertionError("Impossible case " + myDetectedProblem);
}
}
