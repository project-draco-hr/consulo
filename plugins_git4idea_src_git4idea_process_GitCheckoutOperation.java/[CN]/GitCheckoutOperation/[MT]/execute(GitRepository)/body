{
  final GitMessageWithFilesDetector localChangesOverwrittenByCheckoutDetector=new GitMessageWithFilesDetector(GitMessageWithFilesDetector.Event.LOCAL_CHANGES_OVERWRITTEN_BY_CHECKOUT,repository.getRoot());
  GitSimpleEventDetector unmergedDetector=new GitSimpleEventDetector(GitSimpleEventDetector.Event.UNMERGED);
  GitMessageWithFilesDetector untrackedOverwrittenByCheckout=new GitMessageWithFilesDetector(GitMessageWithFilesDetector.Event.UNTRACKED_FILES_OVERWRITTEN_BY,repository.getRoot());
  GitCommandResult result=Git.checkout(repository,myStartPointReference,myNewBranch,localChangesOverwrittenByCheckoutDetector,unmergedDetector,untrackedOverwrittenByCheckout);
  if (result.success()) {
    refreshRoot(repository);
    return GitBranchOperationResult.success();
  }
 else   if (unmergedDetector.hasHappened()) {
    myDetectedProblem=Problem.UNMERGED_FILES;
    return GitBranchOperationResult.resolvable();
  }
 else   if (localChangesOverwrittenByCheckoutDetector.wasMessageDetected()) {
    myDetectedProblem=Problem.LOCAL_CHANGES_OVERWRITTEN_BY_CHECKOUT;
    List<Change> affectedChanges=getChangesAffectedByCheckout(repository,localChangesOverwrittenByCheckoutDetector.getRelativeFilePaths(),true);
    List<GitRepository> remainingRepositories=ContainerUtil.filter(myRepositories,new Condition<GitRepository>(){
      @Override public boolean value(      GitRepository repo){
        return !repo.equals(repository) && !myExecutor.getSuccessfulRepositories().contains(repo);
      }
    }
);
    Map<GitRepository,List<Change>> changesByRepository=collectChangesConflictingWithCheckout(remainingRepositories);
    myProblematicRepositories=new ArrayList<GitRepository>(changesByRepository.keySet());
    myProblematicRepositories.add(repository);
    for (    List<Change> changes : changesByRepository.values()) {
      affectedChanges.addAll(changes);
    }
    myLocalChangesOverwrittenByCheckout=affectedChanges;
    return GitBranchOperationResult.resolvable();
  }
 else   if (untrackedOverwrittenByCheckout.wasMessageDetected()) {
    LOG.info("doCheckout: untracked files would be overwritten by checkout");
    myUntrackedFilesWouldBeOverwrittenByCheckout=untrackedOverwrittenByCheckout.getFiles();
    myDetectedProblem=Problem.UNTRACKED_FILES_OVERWRITTEN_BY_CHECKOUT;
    return GitBranchOperationResult.error(getCommonErrorTitle(),result.getErrorOutputAsJoinedString());
  }
 else {
    return GitBranchOperationResult.error(getCommonErrorTitle(),result.getErrorOutputAsJoinedString());
  }
}
