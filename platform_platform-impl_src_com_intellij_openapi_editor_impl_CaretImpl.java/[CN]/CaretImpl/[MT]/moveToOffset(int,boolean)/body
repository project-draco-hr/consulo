{
  assertIsDispatchThread();
  validateCallContext();
  if (mySkipChangeRequests) {
    return;
  }
  myEditor.getCaretModel().doWithCaretMerging(new Runnable(){
    @Override public void run(){
      final LogicalPosition logicalPosition=myEditor.offsetToLogicalPosition(offset);
      CaretEvent event=moveToLogicalPosition(logicalPosition,locateBeforeSoftWrap,null,false);
      final LogicalPosition positionByOffsetAfterMove=myEditor.offsetToLogicalPosition(myOffset);
      if (!myEditor.getCaretModel().myIgnoreWrongMoves && !positionByOffsetAfterMove.equals(logicalPosition)) {
        StringBuilder debugBuffer=new StringBuilder();
        moveToLogicalPosition(logicalPosition,locateBeforeSoftWrap,debugBuffer,true);
        int textStart=Math.max(0,Math.min(offset,myOffset) - 1);
        final DocumentEx document=myEditor.getDocument();
        int textEnd=Math.min(document.getTextLength() - 1,Math.max(offset,myOffset) + 1);
        CharSequence text=document.getCharsSequence().subSequence(textStart,textEnd);
        StringBuilder positionToOffsetTrace=new StringBuilder();
        int inverseOffset=myEditor.logicalPositionToOffset(logicalPosition,positionToOffsetTrace);
        LogMessageEx.error(LOG,"caret moved to wrong offset. Please submit a dedicated ticket and attach current editor's text to it.",String.format("Requested: offset=%d, logical position='%s' but actual: offset=%d, logical position='%s' (%s). %s%n" + "interested text [%d;%d): '%s'%n debug trace: %s%nLogical position -> offset ('%s'->'%d') trace: %s",offset,logicalPosition,myOffset,myLogicalCaret,positionByOffsetAfterMove,myEditor.dumpState(),textStart,textEnd,text,debugBuffer,logicalPosition,inverseOffset,positionToOffsetTrace));
      }
      if (event != null) {
        myEditor.getCaretModel().fireCaretPositionChanged(event);
        EditorActionUtil.selectNonexpandableFold(myEditor);
      }
    }
  }
);
}
