{
  assertIsDispatchThread();
  int lineShift=above ? -1 : 1;
  final CaretImpl clone=cloneWithoutSelection();
  final int newSelectionStartOffset, newSelectionEndOffset;
  final boolean hasNewSelection;
  if (hasSelection()) {
    LogicalPosition selectionStart=myEditor.offsetToLogicalPosition(getSelectionStart());
    LogicalPosition selectionEnd=myEditor.offsetToLogicalPosition(getSelectionEnd());
    LogicalPosition newSelectionStart=new LogicalPosition(selectionStart.line + lineShift,selectionStart.column);
    LogicalPosition newSelectionEnd=new LogicalPosition(selectionEnd.line + lineShift,selectionEnd.column);
    newSelectionStartOffset=getTruncatedOffset(newSelectionStart);
    newSelectionEndOffset=getTruncatedOffset(newSelectionEnd);
    hasNewSelection=newSelectionStartOffset != newSelectionEndOffset;
  }
 else {
    newSelectionStartOffset=0;
    newSelectionEndOffset=0;
    hasNewSelection=false;
  }
  LogicalPosition oldPosition=hasSelection() && !hasNewSelection ? myEditor.offsetToLogicalPosition(getSelectionStart()) : getLogicalPosition();
  int newLine=oldPosition.line + lineShift;
  if (newLine < 0 || newLine >= myEditor.getDocument().getLineCount()) {
    Disposer.dispose(clone);
    return null;
  }
  clone.moveToLogicalPosition(new LogicalPosition(newLine,oldPosition.column),false,null,false);
  if (myEditor.getCaretModel().addCaret(clone)) {
    if (hasSelection() && hasNewSelection) {
      myEditor.getCaretModel().doWithCaretMerging(new Runnable(){
        @Override public void run(){
          clone.setSelection(Math.min(newSelectionStartOffset,newSelectionEndOffset),Math.max(newSelectionStartOffset,newSelectionEndOffset));
        }
      }
);
      if (!clone.isValid()) {
        return null;
      }
    }
    myEditor.getScrollingModel().scrollTo(clone.getLogicalPosition(),ScrollType.RELATIVE);
    return clone;
  }
 else {
    Disposer.dispose(clone);
    return null;
  }
}
