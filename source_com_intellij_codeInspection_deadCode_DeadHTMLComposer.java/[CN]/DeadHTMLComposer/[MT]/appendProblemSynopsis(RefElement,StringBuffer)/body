{
  refElement.accept(new RefVisitor(){
    public void visitField(    RefField field){
      if (field.isUsedForReading() && !field.isUsedForWriting()) {
        buf.append("Field is never assigned.");
        return;
      }
      if (!field.isUsedForReading() && field.isUsedForWriting()) {
        if (field.isOnlyAssignedInInitializer()) {
          buf.append("Field has no usages.");
          return;
        }
        buf.append("Field is assigned but never accessed.");
        return;
      }
      int nUsages=field.getInReferences().size();
      if (nUsages == 0) {
        buf.append("Field has no usages.");
      }
 else       if (nUsages == 1) {
        buf.append("Field has one usage but it is not reachable from entry points.");
      }
 else {
        buf.append("Field has ");
        appendNumereable(buf,nUsages,"usage","","s");
        buf.append(" but they are not reachable from entry points.");
      }
    }
    public void visitClass(    RefClass refClass){
      if (refClass.isAnonymous()) {
        buf.append("Anonymous class declaration context is not reachable from entry points. Class is never instantiated.");
      }
 else       if (refClass.isInterface() || refClass.isAbstract()) {
        appendClassOrInterface(buf,refClass,true);
        buf.append("&nbsp;");
        int nDerived=getImplementationsCount(refClass);
        if (nDerived == 0) {
          buf.append("is not implemented.");
        }
 else         if (nDerived == 1) {
          buf.append("has an implementation but <ul><li>it is never instantiated OR</li><li>no instantiations are reachable from entry points.</li></ul>");
        }
 else {
          buf.append("has ");
          appendNumereable(buf,nDerived,"direct or indirect implementation","","s");
          buf.append(" but <ul><li>they are never instantiated OR</li><li>no instantiations are reachable from entry points.</li></ul>");
        }
      }
 else       if (refClass.isUtilityClass()) {
        buf.append("No class references has been found. Class static initializer is not reachable.");
      }
 else {
        int nInstantiationsCount=getInstantiationsCount(refClass);
        if (nInstantiationsCount == 0) {
          int nImplementations=getImplementationsCount(refClass);
          if (nImplementations != 0) {
            buf.append("Neither the class nor ");
            appendNumereable(buf,nImplementations," its implementation","","s");
            buf.append(" are ever instantiated.");
          }
 else {
            buf.append("Class is not instantiated.");
          }
        }
 else         if (nInstantiationsCount == 1) {
          buf.append("Class has one instantiation but it is not reachable from entry points.");
        }
 else {
          buf.append("Class has ");
          appendNumereable(buf,nInstantiationsCount,"instantiation","","s");
          buf.append(" but they are not reachable from entry points.");
        }
      }
    }
    public void visitMethod(    RefMethod method){
      RefClass refClass=method.getOwnerClass();
      if (method.isLibraryOverride()) {
        buf.append("Method overrides a library method but<ul><li>its ");
        appendClassOrInterface(buf,refClass,false);
        buf.append(" is never instantiated OR</li><li>its");
        appendClassOrInterface(buf,refClass,false);
        buf.append(" instantiation is not reachable from entry points.</li></ul>");
      }
 else       if (method.isStatic() || method.isConstructor()) {
        buf.append(method.isConstructor() ? "Constructor " : "Method ");
        int nRefs=method.getInReferences().size();
        if (nRefs == 0) {
          buf.append("is never used.");
        }
 else         if (method.isConstructor() && method.isSuspiciousRecursive()) {
          buf.append("has usage(s) but they all belong to recursive calls chain that has no members reachable from entry points.");
        }
 else         if (nRefs == 1) {
          buf.append("has one usage but it is not reachable from entry points.");
        }
 else {
          buf.append("has ");
          appendNumereable(buf,nRefs,"usage","","s");
          buf.append(" usages but they are not reachable from entry points.");
        }
      }
 else       if (refClass.isSuspicious()) {
        if (method.isAbstract()) {
          buf.append("<ul><li>Abstract method is not implemented OR</li>");
          buf.append("<li>Implementation class is never instantiated OR</li>");
          buf.append("<li>An instantiation is not reachable from entry points.</li></ul>");
        }
 else {
          buf.append("<ul><li>Method owner class is never instantiated OR</li>");
          buf.append("<li>An instantiation is not reachable from entry points.</li></ul>");
        }
      }
 else {
        int nOwnRefs=method.getInReferences().size();
        int nSuperRefs=getSuperRefsCount(method);
        int nDerivedRefs=getDerivedRefsCount(method);
        if (nOwnRefs == 0 && nSuperRefs == 0 && nDerivedRefs == 0) {
          buf.append("Method is never used.");
        }
 else         if (nDerivedRefs > 0 && nSuperRefs == 0 && nOwnRefs == 0) {
          buf.append("Method is never used as a member of this ");
          appendClassOrInterface(buf,refClass,false);
          buf.append(", but only as a member of the implementation class(es).");
          buf.append("The project will stay compilable if the method is removed from the ");
          appendClassOrInterface(buf,refClass,false);
          buf.append(".");
        }
 else         if (method.isSuspiciousRecursive()) {
          buf.append("Method has usage(s) but they all belong to recursive calls chain that has no members reachable from entry points.");
        }
 else {
          buf.append("Method is not reachable from entry points.");
        }
      }
    }
  }
);
}
