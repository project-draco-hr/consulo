{
  final ProgressIndicator ind=ProgressManager.getInstance().getProgressIndicator();
  List<FilePatch> result=new ArrayList<FilePatch>();
  for (  Change c : changes) {
    checkCanceled(ind);
    final ContentRevision beforeRevision;
    final ContentRevision afterRevision;
    if (reversePatch) {
      beforeRevision=c.getAfterRevision();
      afterRevision=c.getBeforeRevision();
    }
 else {
      beforeRevision=c.getBeforeRevision();
      afterRevision=c.getAfterRevision();
    }
    if (beforeRevision != null && beforeRevision.getFile().isDirectory()) {
      continue;
    }
    if (afterRevision != null && afterRevision.getFile().isDirectory()) {
      continue;
    }
    if (beforeRevision instanceof BinaryContentRevision || afterRevision instanceof BinaryContentRevision) {
      result.add(buildBinaryPatch(basePath,(BinaryContentRevision)beforeRevision,(BinaryContentRevision)afterRevision));
      continue;
    }
    if (beforeRevision == null) {
      result.add(buildAddedFile(basePath,afterRevision,ind));
      continue;
    }
    if (afterRevision == null) {
      result.add(buildDeletedFile(basePath,beforeRevision,ind));
      continue;
    }
    final String beforeContent=beforeRevision.getContent();
    if (beforeContent == null) {
      throw new VcsException("Failed to fetch old content for changed file " + beforeRevision.getFile().getPath());
    }
    final String afterContent=afterRevision.getContent();
    if (afterContent == null) {
      throw new VcsException("Failed to fetch new content for changed file " + afterRevision.getFile().getPath());
    }
    String[] beforeLines=new LineTokenizer(beforeContent).execute();
    String[] afterLines=new LineTokenizer(afterContent).execute();
    DiffFragment[] woFormattingBlocks=DiffPolicy.LINES_WO_FORMATTING.buildFragments(beforeContent,afterContent);
    DiffFragment[] step1lineFragments=new DiffCorrection.TrueLineBlocks(ComparisonPolicy.DEFAULT).correctAndNormalize(woFormattingBlocks);
    ArrayList<LineFragment> fragments=new DiffFragmentsProcessor().process(step1lineFragments);
    if (fragments.size() > 1 || (fragments.size() == 1 && fragments.get(0).getType() != null && fragments.get(0).getType() != TextDiffTypeEnum.NONE)) {
      TextFilePatch patch=buildPatchHeading(basePath,beforeRevision,afterRevision);
      result.add(patch);
      int lastLine1=0;
      int lastLine2=0;
      while (fragments.size() > 0) {
        checkCanceled(ind);
        List<LineFragment> adjacentFragments=getAdjacentFragments(fragments);
        if (adjacentFragments.size() > 0) {
          LineFragment first=adjacentFragments.get(0);
          LineFragment last=adjacentFragments.get(adjacentFragments.size() - 1);
          final int start1=first.getStartingLine1();
          final int start2=first.getStartingLine2();
          final int end1=last.getStartingLine1() + last.getModifiedLines1();
          final int end2=last.getStartingLine2() + last.getModifiedLines2();
          int contextStart1=Math.max(start1 - CONTEXT_LINES,lastLine1);
          int contextStart2=Math.max(start2 - CONTEXT_LINES,lastLine2);
          int contextEnd1=Math.min(end1 + CONTEXT_LINES,beforeLines.length);
          int contextEnd2=Math.min(end2 + CONTEXT_LINES,afterLines.length);
          PatchHunk hunk=new PatchHunk(contextStart1,contextEnd1,contextStart2,contextEnd2);
          patch.addHunk(hunk);
          for (          LineFragment fragment : adjacentFragments) {
            checkCanceled(ind);
            for (int i=contextStart1; i < fragment.getStartingLine1(); i++) {
              addLineToHunk(hunk,beforeLines[i],PatchLine.Type.CONTEXT);
            }
            for (int i=fragment.getStartingLine1(); i < fragment.getStartingLine1() + fragment.getModifiedLines1(); i++) {
              addLineToHunk(hunk,beforeLines[i],PatchLine.Type.REMOVE);
            }
            for (int i=fragment.getStartingLine2(); i < fragment.getStartingLine2() + fragment.getModifiedLines2(); i++) {
              addLineToHunk(hunk,afterLines[i],PatchLine.Type.ADD);
            }
            contextStart1=fragment.getStartingLine1() + fragment.getModifiedLines1();
          }
          for (int i=contextStart1; i < contextEnd1; i++) {
            addLineToHunk(hunk,beforeLines[i],PatchLine.Type.CONTEXT);
          }
        }
      }
    }
 else     if (!beforeRevision.getFile().equals(afterRevision.getFile())) {
      result.add(buildMovedFile(basePath,beforeRevision,afterRevision,beforeLines));
    }
  }
  return result;
}
