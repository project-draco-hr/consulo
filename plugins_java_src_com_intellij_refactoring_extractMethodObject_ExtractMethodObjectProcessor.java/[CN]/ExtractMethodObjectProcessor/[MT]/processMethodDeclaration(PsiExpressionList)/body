{
  if (isCreateInnerClass()) {
    final String typeArguments=getMethod().hasTypeParameters() ? "<" + StringUtil.join(Arrays.asList(getMethod().getTypeParameters()),new Function<PsiTypeParameter,String>(){
      public String fun(      final PsiTypeParameter typeParameter){
        final String typeParameterName=typeParameter.getName();
        LOG.assertTrue(typeParameterName != null);
        return typeParameterName;
      }
    }
,", ") + ">" : "";
    final PsiMethodCallExpression methodCallExpression=(PsiMethodCallExpression)myElementFactory.createExpressionFromText("invoke" + expressionList.getText(),null);
    return replaceMethodCallExpression(typeArguments,methodCallExpression);
  }
 else {
    final String paramsDeclaration=getMethod().getParameterList().getText();
    final PsiType returnType=getMethod().getReturnType();
    LOG.assertTrue(returnType != null);
    final PsiCodeBlock methodBody=getMethod().getBody();
    LOG.assertTrue(methodBody != null);
    return myElementFactory.createExpressionFromText("new Object(){ \n" + "private " + returnType.getPresentableText() + " "+ myInnerClassName+ paramsDeclaration+ methodBody.getText()+ "}."+ myInnerClassName+ expressionList.getText(),null);
  }
}
