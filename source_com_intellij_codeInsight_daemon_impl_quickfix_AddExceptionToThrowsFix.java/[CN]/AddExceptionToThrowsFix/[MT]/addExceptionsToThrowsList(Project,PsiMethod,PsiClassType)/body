{
  final PsiMethod[] superMethods=getSuperMethods(targetMethod);
  boolean hasSuperMethodsWithoutExceptions=hasSuperMethodsWithoutExceptions(superMethods,unhandledExceptions);
  final boolean processSuperMethods;
  if (hasSuperMethodsWithoutExceptions && superMethods.length > 0) {
    int result=Messages.showYesNoCancelDialog("Method '" + targetMethod.getName() + "' is inherited.\n"+ "Do you want to add exceptions to method signatures in the whole method hierarchy?","Method Is Inherited",Messages.getQuestionIcon());
    if (result == 0)     processSuperMethods=true;
 else     if (result == 1)     processSuperMethods=false;
 else     return;
  }
 else {
    processSuperMethods=false;
  }
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    public void run(){
      if (!CodeInsightUtil.prepareFileForWrite(targetMethod.getContainingFile()))       return;
      if (processSuperMethods) {
        for (int i=0; i < superMethods.length; i++) {
          PsiMethod superMethod=superMethods[i];
          if (!CodeInsightUtil.prepareFileForWrite(superMethod.getContainingFile()))           return;
        }
      }
      try {
        processMethod(project,targetMethod,unhandledExceptions);
        if (processSuperMethods) {
          for (int i=0; i < superMethods.length; i++) {
            PsiMethod superMethod=superMethods[i];
            processMethod(project,superMethod,unhandledExceptions);
          }
        }
      }
 catch (      IncorrectOperationException e) {
        LOG.error(e);
      }
    }
  }
);
}
