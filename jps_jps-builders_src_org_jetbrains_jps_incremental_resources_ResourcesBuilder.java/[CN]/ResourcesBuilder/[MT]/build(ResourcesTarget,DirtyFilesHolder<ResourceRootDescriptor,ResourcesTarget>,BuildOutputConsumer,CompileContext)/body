{
  if (!isResourceProcessingEnabled(target.getModule())) {
    return;
  }
  try {
    holder.processDirtyFiles(new FileProcessor<ResourceRootDescriptor,ResourcesTarget>(){
      private final Map<ResourceRootDescriptor,Boolean> mySkippedRoots=new HashMap<ResourceRootDescriptor,Boolean>();
      public boolean apply(      ResourcesTarget target,      final File file,      final ResourceRootDescriptor sourceRoot) throws IOException {
        Boolean isSkipped=mySkippedRoots.get(sourceRoot);
        if (isSkipped == null) {
          final File outputDir=target.getOutputDir();
          isSkipped=Boolean.valueOf(outputDir == null || FileUtil.filesEqual(outputDir,sourceRoot.getRootFile()));
          mySkippedRoots.put(sourceRoot,isSkipped);
        }
        if (isSkipped.booleanValue()) {
          return true;
        }
        try {
          copyResource(context,sourceRoot,file,outputConsumer);
        }
 catch (        IOException e) {
          LOG.info(e);
          context.processMessage(new CompilerMessage("resources",BuildMessage.Kind.ERROR,e.getMessage(),FileUtil.toSystemIndependentName(file.getPath())));
          return false;
        }
        return !context.getCancelStatus().isCanceled();
      }
    }
);
    context.checkCanceled();
    context.processMessage(new ProgressMessage(""));
  }
 catch (  ProjectBuildException e) {
    throw e;
  }
catch (  Exception e) {
    throw new ProjectBuildException(e.getMessage(),e);
  }
}
