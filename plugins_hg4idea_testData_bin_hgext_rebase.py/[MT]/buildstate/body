def buildstate(repo, dest, src, base, detach):
    'Define which revisions are going to be rebased and where'
    targetancestors = set()
    detachset = set()
    if (not dest):
        branch = repo[None].branch()
        dest = repo[branch].rev()
    else:
        dest = repo[dest].rev()
    if (('qtip' in repo.tags()) and (repo[dest].hex() in [s.rev for s in repo.mq.applied])):
        raise util.Abort(_('cannot rebase onto an applied mq patch'))
    if src:
        commonbase = repo[src].ancestor(repo[dest])
        if (commonbase == repo[src]):
            raise util.Abort(_('source is ancestor of destination'))
        if (commonbase == repo[dest]):
            raise util.Abort(_('source is descendant of destination'))
        source = repo[src].rev()
        if detach:
            srcancestors = set(repo.changelog.ancestors(source))
            baseancestors = set(repo.changelog.ancestors(commonbase.rev()))
            detachset = (srcancestors - baseancestors)
            detachset.remove(commonbase.rev())
    else:
        if base:
            cwd = repo[base].rev()
        else:
            cwd = repo['.'].rev()
        if (cwd == dest):
            repo.ui.debug('source and destination are the same\n')
            return None
        targetancestors = set(repo.changelog.ancestors(dest))
        if (cwd in targetancestors):
            repo.ui.debug('source is ancestor of destination\n')
            return None
        cwdancestors = set(repo.changelog.ancestors(cwd))
        if (dest in cwdancestors):
            repo.ui.debug('source is descendant of destination\n')
            return None
        cwdancestors.add(cwd)
        rebasingbranch = (cwdancestors - targetancestors)
        source = min(rebasingbranch)
    repo.ui.debug(('rebase onto %d starting from %d\n' % (dest, source)))
    state = dict.fromkeys(repo.changelog.descendants(source), nullrev)
    state.update(dict.fromkeys(detachset, nullmerge))
    state[source] = nullrev
    return (repo['.'].rev(), repo[dest].rev(), state)
