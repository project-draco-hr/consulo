def rebase(ui, repo, **opts):
    'move changeset (and descendants) to a different branch\n\n    Rebase uses repeated merging to graft changesets from one part of\n    history (the source) onto another (the destination). This can be\n    useful for linearizing local changes relative to a master\n    development tree.\n\n    If you don\'t specify a destination changeset (``-d/--dest``),\n    rebase uses the tipmost head of the current named branch as the\n    destination. (The destination changeset is not modified by\n    rebasing, but new changesets are added as its descendants.)\n\n    You can specify which changesets to rebase in two ways: as a\n    "source" changeset or as a "base" changeset. Both are shorthand\n    for a topologically related set of changesets (the "source\n    branch"). If you specify source (``-s/--source``), rebase will\n    rebase that changeset and all of its descendants onto dest. If you\n    specify base (``-b/--base``), rebase will select ancestors of base\n    back to but not including the common ancestor with dest. Thus,\n    ``-b`` is less precise but more convenient than ``-s``: you can\n    specify any changeset in the source branch, and rebase will select\n    the whole branch. If you specify neither ``-s`` nor ``-b``, rebase\n    uses the parent of the working directory as the base.\n\n    By default, rebase recreates the changesets in the source branch\n    as descendants of dest and then destroys the originals. Use\n    ``--keep`` to preserve the original source changesets. Some\n    changesets in the source branch (e.g. merges from the destination\n    branch) may be dropped if they no longer contribute any change.\n\n    One result of the rules for selecting the destination changeset\n    and source branch is that, unlike ``merge``, rebase will do\n    nothing if you are at the latest (tipmost) head of a named branch\n    with two heads. You need to explicitly specify source and/or\n    destination (or ``update`` to the other head, if it\'s the head of\n    the intended source branch).\n\n    If a rebase is interrupted to manually resolve a merge, it can be\n    continued with --continue/-c or aborted with --abort/-a.\n    '
    originalwd = target = None
    external = nullrev
    state = {}
    skipped = set()
    targetancestors = set()
    lock = wlock = None
    try:
        lock = repo.lock()
        wlock = repo.wlock()
        destf = opts.get('dest', None)
        srcf = opts.get('source', None)
        basef = opts.get('base', None)
        contf = opts.get('continue')
        abortf = opts.get('abort')
        collapsef = opts.get('collapse', False)
        extrafn = opts.get('extrafn')
        keepf = opts.get('keep', False)
        keepbranchesf = opts.get('keepbranches', False)
        detachf = opts.get('detach', False)
        if (contf or abortf):
            if (contf and abortf):
                raise error.ParseError('rebase', _('cannot use both abort and continue'))
            if collapsef:
                raise error.ParseError('rebase', _('cannot use collapse with continue or abort'))
            if detachf:
                raise error.ParseError('rebase', _('cannot use detach with continue or abort'))
            if (srcf or basef or destf):
                raise error.ParseError('rebase', _('abort and continue do not allow specifying revisions'))
            (originalwd, target, state, collapsef, keepf, keepbranchesf, external) = restorestatus(repo)
            if abortf:
                abort(repo, originalwd, target, state)
                return
        else:
            if (srcf and basef):
                raise error.ParseError('rebase', _('cannot specify both a revision and a base'))
            if detachf:
                if (not srcf):
                    raise error.ParseError('rebase', _('detach requires a revision to be specified'))
                if basef:
                    raise error.ParseError('rebase', _('cannot specify a base with detach'))
            cmdutil.bail_if_changed(repo)
            result = buildstate(repo, destf, srcf, basef, detachf)
            if (not result):
                ui.status(_('nothing to rebase\n'))
                return
            else:
                (originalwd, target, state) = result
                if collapsef:
                    targetancestors = set(repo.changelog.ancestors(target))
                    external = checkexternal(repo, state, targetancestors)
        if keepbranchesf:
            if extrafn:
                raise error.ParseError('rebase', _('cannot use both keepbranches and extrafn'))

            def extrafn(ctx, extra):
                extra['branch'] = ctx.branch()
        if (not targetancestors):
            targetancestors = set(repo.changelog.ancestors(target))
            targetancestors.add(target)
        for rev in sorted(state):
            if (state[rev] == (-1)):
                ui.debug(('rebasing %d:%s\n' % (rev, repo[rev])))
                storestatus(repo, originalwd, target, state, collapsef, keepf, keepbranchesf, external)
                (p1, p2) = defineparents(repo, rev, target, state, targetancestors)
                if (len(repo.parents()) == 2):
                    repo.ui.debug('resuming interrupted rebase\n')
                else:
                    stats = rebasenode(repo, rev, p1, p2, state)
                    if (stats and (stats[3] > 0)):
                        raise util.Abort(_('fix unresolved conflicts with hg resolve then run hg rebase --continue'))
                updatedirstate(repo, rev, target, p2)
                if (not collapsef):
                    newrev = concludenode(repo, rev, p1, p2, extrafn=extrafn)
                else:
                    repo.dirstate.setparents(repo[p1].node())
                    newrev = None
                if (newrev is not None):
                    state[rev] = repo[newrev].rev()
                else:
                    if (not collapsef):
                        ui.note((_('no changes, revision %d skipped\n') % rev))
                        ui.debug(('next revision set to %s\n' % p1))
                        skipped.add(rev)
                    state[rev] = p1
        ui.note(_('rebase merging completed\n'))
        if collapsef:
            (p1, p2) = defineparents(repo, min(state), target, state, targetancestors)
            commitmsg = 'Collapsed revision'
            for rebased in state:
                if ((rebased not in skipped) and (state[rebased] != nullmerge)):
                    commitmsg += ('\n* %s' % repo[rebased].description())
            commitmsg = ui.edit(commitmsg, repo.ui.username())
            newrev = concludenode(repo, rev, p1, external, commitmsg=commitmsg, extrafn=extrafn)
        if ('qtip' in repo.tags()):
            updatemq(repo, state, skipped, **opts)
        if (not keepf):
            rebased = [rev for rev in state if (state[rev] != nullmerge)]
            if rebased:
                if (set(repo.changelog.descendants(min(rebased))) - set(state)):
                    ui.warn(_('warning: new changesets detected on source branch, not stripping\n'))
                else:
                    repair.strip(ui, repo, repo[min(rebased)].node(), 'strip')
        clearstatus(repo)
        ui.status(_('rebase completed\n'))
        if os.path.exists(repo.sjoin('undo')):
            util.unlink(repo.sjoin('undo'))
        if skipped:
            ui.note((_('%d revisions have been skipped\n') % len(skipped)))
    finally:
        release(lock, wlock)
