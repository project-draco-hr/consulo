{
  PsiBuilder.Marker marker=builder.mark();
  final IElementType result=parseExpressionStatement(builder,parser);
  if (result != CALL_EXPRESSION && result != PATH_METHOD_CALL) {
    marker.drop();
    return result == WRONGWAY ? Result.WRONG_WAY : Result.EXPRESSION;
  }
  boolean isExprStatement=result == CALL_EXPRESSION;
  while (true) {
    boolean nameParsed=namePartParse(builder,parser) == REFERENCE_EXPRESSION;
    PsiBuilder.Marker exprStatement;
    if (nameParsed) {
      exprStatement=marker.precede();
      marker.done(REFERENCE_EXPRESSION);
    }
 else {
      exprStatement=marker;
    }
    if (builder.getTokenType() == mLPAREN) {
      PrimaryExpression.methodCallArgsParse(builder,parser);
      exprStatement.done(PATH_METHOD_CALL);
    }
 else     if (mLBRACK.equals(builder.getTokenType()) && !ParserUtils.lookAhead(builder,mLBRACK,mCOLON) && !ParserUtils.lookAhead(builder,mLBRACK,mNLS,mCOLON)) {
      PathExpression.indexPropertyArgsParse(builder,parser);
      exprStatement.done(PATH_INDEX_PROPERTY);
      if (mLPAREN.equals(builder.getTokenType())) {
        PrimaryExpression.methodCallArgsParse(builder,parser);
      }
 else       if (mLCURLY.equals(builder.getTokenType())) {
        PsiBuilder.Marker argsMarker=builder.mark();
        argsMarker.done(ARGUMENTS);
      }
      while (mLCURLY.equals(builder.getTokenType())) {
        OpenOrClosableBlock.parseClosableBlock(builder,parser);
      }
      exprStatement=exprStatement.precede();
      exprStatement.done(PATH_METHOD_CALL);
    }
 else     if (nameParsed && CommandArguments.parseCommandArguments(builder,parser)) {
      isExprStatement=true;
      exprStatement.done(CALL_EXPRESSION);
    }
 else {
      exprStatement.drop();
      break;
    }
    marker=exprStatement.precede();
  }
  return isExprStatement ? Result.EXPR_STATEMENT : Result.EXPRESSION;
}
