{
  PsiBuilder.Marker marker=builder.mark();
  final IElementType result=parseExpressionStatement(builder,parser);
  if (result != CALL_EXPRESSION) {
    marker.drop();
    return result != WRONGWAY;
  }
  while (true) {
    if (PathExpression.namePartParse(builder,parser) != REFERENCE_EXPRESSION) {
      marker.drop();
      break;
    }
    final PsiBuilder.Marker exprStatement=marker.precede();
    marker.done(REFERENCE_EXPRESSION);
    if (builder.getTokenType() == mLPAREN) {
      PrimaryExpression.methodCallArgsParse(builder,parser);
      exprStatement.done(PATH_METHOD_CALL);
    }
 else     if (CommandArguments.parse(builder,parser)) {
      exprStatement.done(CALL_EXPRESSION);
    }
 else {
      exprStatement.drop();
      builder.error(GroovyBundle.message("expression.expected"));
      break;
    }
    marker=exprStatement.precede();
  }
  return true;
}
