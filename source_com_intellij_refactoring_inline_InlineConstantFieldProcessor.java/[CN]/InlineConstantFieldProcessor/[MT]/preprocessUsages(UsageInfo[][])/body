{
  ArrayList<String> conflicts=new ArrayList<String>();
  ReferencedElementsCollector collector=new ReferencedElementsCollector();
  PsiExpression initializer=myField.getInitializer();
  LOG.assertTrue(initializer != null);
  initializer.accept(collector);
  HashSet<PsiMember> referencedWithVisibility=collector.myReferencedMembers;
  UsageInfo[] plainUsages=usages[0];
  PsiResolveHelper resolveHelper=myField.getManager().getResolveHelper();
  for (int i=0; i < plainUsages.length; i++) {
    UsageInfo info=plainUsages[i];
    PsiElement element=info.getElement();
    LOG.assertTrue(element instanceof PsiReferenceExpression);
    if (isAccessedForWriting((PsiExpression)element)) {
      String message=ConflictsUtil.getDescription(myField,true) + " is used for writing in " + ConflictsUtil.getDescription(ConflictsUtil.getContainer(element),true);
      conflicts.add(message);
    }
    for (Iterator<PsiMember> iterator=referencedWithVisibility.iterator(); iterator.hasNext(); ) {
      PsiMember member=iterator.next();
      if (!resolveHelper.isAccessible(member,element,null)) {
        String message=ConflictsUtil.getDescription(member,true) + " will not be accessible from " + ConflictsUtil.getDescription(ConflictsUtil.getContainer(element),true)+ " after inlining";
        conflicts.add(message);
      }
    }
  }
  if (myDialog != null && conflicts.size() > 0) {
    ConflictsDialog dialog=new ConflictsDialog(conflicts.toArray(new String[conflicts.size()]),myProject);
    dialog.show();
    if (!dialog.isOK())     return false;
  }
  ToolWindowManager.getInstance(myProject).invokeLater(new Runnable(){
    public void run(){
      myDialog.close(DialogWrapper.CANCEL_EXIT_CODE);
    }
  }
);
  return true;
}
