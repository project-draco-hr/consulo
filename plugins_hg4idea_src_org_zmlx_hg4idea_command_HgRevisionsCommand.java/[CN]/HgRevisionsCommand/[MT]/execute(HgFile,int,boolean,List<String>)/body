{
  if ((limit <= 0 && limit != -1) || hgFile == null || hgFile.getRepo() == null) {
    return Collections.emptyList();
  }
  HgCommandExecutor hgCommandExecutor=new HgCommandExecutor(project);
  String template=HgChangesetUtil.makeTemplate(includeFiles ? LONG_TEMPLATE_ITEMS : SHORT_TEMPLATE_ITEMS);
  int expectedItemCount=includeFiles ? LONG_TEMPLATE_ITEMS.length : SHORT_TEMPLATE_ITEMS.length;
  FilePath originalFileName=HgUtil.getOriginalFileName(hgFile.toFilePath(),ChangeListManager.getInstance(project));
  HgFile originalHgFile=new HgFile(hgFile.getRepo(),originalFileName);
  HgCommandResult result=execute(hgCommandExecutor,hgFile.getRepo(),template,limit,originalHgFile,argsForCmd);
  final List<HgFileRevision> revisions=new LinkedList<HgFileRevision>();
  if (result == null) {
    return revisions;
  }
  List<String> errors=result.getErrorLines();
  if (errors != null && !errors.isEmpty()) {
    throw new HgCommandException(errors.toString());
  }
  String output=result.getRawOutput();
  String[] changeSets=output.split(HgChangesetUtil.CHANGESET_SEPARATOR);
  for (  String line : changeSets) {
    try {
      String[] attributes=line.split(HgChangesetUtil.ITEM_SEPARATOR);
      int numAttributes=attributes.length;
      if (!includeFiles && (numAttributes != expectedItemCount)) {
        LOG.debug("Wrong format. Skipping line " + line);
        continue;
      }
 else       if (includeFiles && (numAttributes < FILES_ADDED_INDEX)) {
        LOG.debug("Wrong format for long template. Skipping line " + line);
        continue;
      }
      String revisionString=attributes[REVISION_INDEX];
      String changeset=attributes[CHANGESET_INDEX];
      String parentsString=attributes[PARENTS_INDEX];
      List<HgRevisionNumber> parents=new ArrayList<HgRevisionNumber>(2);
      if (StringUtil.isEmpty(parentsString)) {
        Long revision=Long.valueOf(revisionString);
        HgRevisionNumber parentRevision=HgRevisionNumber.getLocalInstance(String.valueOf(revision - 1));
        parents.add(parentRevision);
      }
 else {
        String[] parentStrings=parentsString.trim().split(" ");
        for (        String parentString : parentStrings) {
          String[] parentParts=parentString.split(":");
          if (Integer.valueOf(parentParts[0]) >= 0) {
            parents.add(HgRevisionNumber.getInstance(parentParts[0],parentParts[1]));
          }
        }
      }
      final HgRevisionNumber vcsRevisionNumber=HgRevisionNumber.getInstance(revisionString,changeset,parents);
      Date revisionDate=DATE_FORMAT.parse(attributes[DATE_INDEX]);
      String author=attributes[AUTHOR_INDEX];
      String branchName=attributes[BRANCH_INDEX];
      String commitMessage=attributes[MESSAGE_INDEX];
      Set<String> filesAdded=Collections.emptySet();
      Set<String> filesModified=Collections.emptySet();
      Set<String> filesDeleted=Collections.emptySet();
      Map<String,String> copies=Collections.emptyMap();
      if (numAttributes > FILES_ADDED_INDEX) {
        filesAdded=parseFileList(attributes[FILES_ADDED_INDEX]);
        if (numAttributes > FILES_MODIFIED_INDEX) {
          filesModified=parseFileList(attributes[FILES_MODIFIED_INDEX]);
          if (numAttributes > FILES_DELETED_INDEX) {
            filesDeleted=parseFileList(attributes[FILES_DELETED_INDEX]);
            if (numAttributes > FILES_COPIED_INDEX) {
              copies=parseCopiesFileList(attributes[FILES_COPIED_INDEX]);
              Iterator<String> keys=copies.keySet().iterator();
              while (keys.hasNext()) {
                String s=keys.next();
                if (filesAdded.contains(copies.get(s)) && filesDeleted.contains(s)) {
                  filesAdded.remove(copies.get(s));
                  filesDeleted.remove(s);
                }
 else                 if (!filesDeleted.contains(s)) {
                  keys.remove();
                }
              }
            }
          }
        }
      }
      revisions.add(new HgFileRevision(project,hgFile,vcsRevisionNumber,branchName,revisionDate,author,commitMessage,filesModified,filesAdded,filesDeleted,copies));
    }
 catch (    NumberFormatException e) {
      LOG.warn("Error parsing rev in line " + line);
    }
catch (    ParseException e) {
      LOG.warn("Error parsing date in line " + line);
    }
  }
  return revisions;
}
