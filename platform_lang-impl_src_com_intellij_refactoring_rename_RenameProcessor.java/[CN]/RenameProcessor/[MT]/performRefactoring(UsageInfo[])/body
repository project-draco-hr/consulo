{
  final int[] choice=myAllRenames.size() > 1 ? new int[]{-1} : null;
  String message=null;
  try {
    for (Iterator<Map.Entry<PsiElement,String>> iterator=myAllRenames.entrySet().iterator(); iterator.hasNext(); ) {
      Map.Entry<PsiElement,String> entry=iterator.next();
      if (entry.getKey() instanceof PsiFile) {
        final PsiFile file=(PsiFile)entry.getKey();
        final PsiDirectory containingDirectory=file.getContainingDirectory();
        if (CopyFilesOrDirectoriesHandler.checkFileExist(containingDirectory,choice,file,entry.getValue(),"Rename")) {
          iterator.remove();
          continue;
        }
      }
      RenameUtil.checkRename(entry.getKey(),entry.getValue());
    }
  }
 catch (  IncorrectOperationException e) {
    message=e.getMessage();
  }
  if (message != null) {
    CommonRefactoringUtil.showErrorMessage(RefactoringBundle.message("rename.title"),message,getHelpID(),myProject);
    return;
  }
  List<Runnable> postRenameCallbacks=new ArrayList<Runnable>();
  final MultiMap<PsiElement,UsageInfo> classified=classifyUsages(myAllRenames.keySet(),usages);
  for (  final PsiElement element : myAllRenames.keySet()) {
    String newName=myAllRenames.get(element);
    final RefactoringElementListener elementListener=getTransaction().getElementListener(element);
    final RenamePsiElementProcessor renamePsiElementProcessor=RenamePsiElementProcessor.forElement(element);
    Runnable postRenameCallback=renamePsiElementProcessor.getPostRenameCallback(element,newName,elementListener);
    final Collection<UsageInfo> infos=classified.get(element);
    try {
      RenameUtil.doRename(element,newName,infos.toArray(new UsageInfo[infos.size()]),myProject,elementListener);
    }
 catch (    final IncorrectOperationException e) {
      RenameUtil.showErrorMessage(e,element,myProject);
      return;
    }
    if (postRenameCallback != null) {
      postRenameCallbacks.add(postRenameCallback);
    }
  }
  for (  Runnable runnable : postRenameCallbacks) {
    runnable.run();
  }
  List<NonCodeUsageInfo> nonCodeUsages=new ArrayList<NonCodeUsageInfo>();
  for (  UsageInfo usage : usages) {
    if (usage instanceof NonCodeUsageInfo) {
      nonCodeUsages.add((NonCodeUsageInfo)usage);
    }
  }
  myNonCodeUsages=nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);
  if (!mySkippedUsages.isEmpty()) {
    if (!ApplicationManager.getApplication().isUnitTestMode() && !ApplicationManager.getApplication().isHeadlessEnvironment()) {
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        public void run(){
          final IdeFrame ideFrame=WindowManager.getInstance().getIdeFrame(myProject);
          if (ideFrame != null) {
            StatusBarEx statusBar=(StatusBarEx)ideFrame.getStatusBar();
            HyperlinkListener listener=new HyperlinkListener(){
              public void hyperlinkUpdate(              HyperlinkEvent e){
                if (e.getEventType() != HyperlinkEvent.EventType.ACTIVATED)                 return;
                Messages.showMessageDialog("<html>Following usages were safely skipped:<br>" + StringUtil.join(mySkippedUsages,new Function<UnresolvableCollisionUsageInfo,String>(){
                  public String fun(                  UnresolvableCollisionUsageInfo unresolvableCollisionUsageInfo){
                    return unresolvableCollisionUsageInfo.getDescription();
                  }
                }
,"<br>") + "</html>","Not All Usages Were Renamed",null);
              }
            }
;
            statusBar.notifyProgressByBalloon(MessageType.WARNING,"<html><body>Unable to rename certain usages. <a href=\"\">Browse</a></body></html>",null,listener);
          }
        }
      }
,ModalityState.NON_MODAL);
    }
  }
}
