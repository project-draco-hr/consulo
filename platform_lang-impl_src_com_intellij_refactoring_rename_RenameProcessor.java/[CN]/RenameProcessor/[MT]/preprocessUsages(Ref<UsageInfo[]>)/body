{
  UsageInfo[] usagesIn=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  RenameUtil.addConflictDescriptions(usagesIn,conflicts);
  RenamePsiElementProcessor.forElement(myPrimaryElement).findExistingNameConflicts(myPrimaryElement,myNewName,conflicts,myAllRenames);
  if (!conflicts.isEmpty()) {
    final RefactoringEventData conflictData=new RefactoringEventData();
    conflictData.putUserData(RefactoringEventData.CONFLICTS_KEY,conflicts.values());
    myProject.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).conflictsDetected("refactoring.rename",conflictData);
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      throw new ConflictsInTestsException(conflicts.values());
    }
    ConflictsDialog conflictsDialog=prepareConflictsDialog(conflicts,refUsages.get());
    if (!conflictsDialog.showAndGet()) {
      if (conflictsDialog.isShowConflicts())       prepareSuccessful();
      return false;
    }
  }
  final List<UsageInfo> variableUsages=new ArrayList<UsageInfo>();
  if (!myRenamers.isEmpty()) {
    if (!findRenamedVariables(variableUsages))     return false;
    final LinkedHashMap<PsiElement,String> renames=new LinkedHashMap<PsiElement,String>();
    for (    final AutomaticRenamer renamer : myRenamers) {
      final List<? extends PsiNamedElement> variables=renamer.getElements();
      for (      final PsiNamedElement variable : variables) {
        final String newName=renamer.getNewName(variable);
        if (newName != null) {
          addElement(variable,newName);
          prepareRenaming(variable,newName,renames);
        }
      }
    }
    if (!renames.isEmpty()) {
      for (      PsiElement element : renames.keySet()) {
        assertNonCompileElement(element);
      }
      myAllRenames.putAll(renames);
      final Runnable runnable=new Runnable(){
        @Override public void run(){
          for (          final Map.Entry<PsiElement,String> entry : renames.entrySet()) {
            final UsageInfo[] usages=ApplicationManager.getApplication().runReadAction(new Computable<UsageInfo[]>(){
              @Override public UsageInfo[] compute(){
                return RenameUtil.findUsages(entry.getKey(),entry.getValue(),mySearchInComments,mySearchTextOccurrences,myAllRenames);
              }
            }
);
            Collections.addAll(variableUsages,usages);
          }
        }
      }
;
      if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable,RefactoringBundle.message("searching.for.variables"),true,myProject)) {
        return false;
      }
    }
  }
  final Set<UsageInfo> usagesSet=ContainerUtil.newLinkedHashSet(usagesIn);
  usagesSet.addAll(variableUsages);
  final List<UnresolvableCollisionUsageInfo> conflictUsages=RenameUtil.removeConflictUsages(usagesSet);
  if (conflictUsages != null) {
    mySkippedUsages.addAll(conflictUsages);
  }
  refUsages.set(usagesSet.toArray(new UsageInfo[usagesSet.size()]));
  prepareSuccessful();
  return PsiElementRenameHandler.canRename(myProject,null,myPrimaryElement);
}
