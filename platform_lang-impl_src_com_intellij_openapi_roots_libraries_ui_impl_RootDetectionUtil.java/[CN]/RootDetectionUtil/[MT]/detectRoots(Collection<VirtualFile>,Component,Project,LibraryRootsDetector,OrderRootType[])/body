{
  final List<OrderRoot> result=new ArrayList<OrderRoot>();
  final List<SuggestedChildRootInfo> suggestedRoots=new ArrayList<SuggestedChildRootInfo>();
  new Task.Modal(project,"Scanning for Roots",true){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      try {
        for (        VirtualFile rootCandidate : rootCandidates) {
          final Collection<DetectedLibraryRoot> roots=detector.detectRoots(rootCandidate,indicator);
          if (!roots.isEmpty() && allRootsHaveOneTypeAndEqualTo(roots,rootCandidate)) {
            for (            DetectedLibraryRoot root : roots) {
              final LibraryRootType libraryRootType=root.getTypes().get(0);
              result.add(new OrderRoot(root.getFile(),libraryRootType.getType(),libraryRootType.isJarDirectory()));
            }
          }
 else {
            for (            DetectedLibraryRoot root : roots) {
              final HashMap<LibraryRootType,String> names=new HashMap<LibraryRootType,String>();
              for (              LibraryRootType type : root.getTypes()) {
                final String typeName=detector.getRootTypeName(type);
                LOG.assertTrue(typeName != null,"Unexpected root type " + type.getType().name() + (type.isJarDirectory() ? " (jar directory)" : "")+ ", detectors: "+ detector);
                names.put(type,typeName);
              }
              suggestedRoots.add(new SuggestedChildRootInfo(rootCandidate,root,names));
            }
          }
        }
      }
 catch (      ProcessCanceledException ignored) {
      }
    }
  }
.queue();
  if (!suggestedRoots.isEmpty()) {
    final DetectedRootsChooserDialog dialog=parentComponent != null ? new DetectedRootsChooserDialog(parentComponent,suggestedRoots) : new DetectedRootsChooserDialog(project,suggestedRoots);
    dialog.show();
    if (!dialog.isOK()) {
      return Collections.emptyList();
    }
    for (    SuggestedChildRootInfo rootInfo : dialog.getChosenRoots()) {
      final LibraryRootType selectedRootType=rootInfo.getSelectedRootType();
      result.add(new OrderRoot(rootInfo.getDetectedRoot().getFile(),selectedRootType.getType(),selectedRootType.isJarDirectory()));
    }
  }
  if (result.isEmpty() && rootTypesAllowedToBeSelectedByUserIfNothingIsDetected.length > 0) {
    Map<String,Pair<OrderRootType,Boolean>> types=new HashMap<String,Pair<OrderRootType,Boolean>>();
    for (    OrderRootType type : rootTypesAllowedToBeSelectedByUserIfNothingIsDetected) {
      for (      boolean isJarDirectory : new boolean[]{false,true}) {
        final String typeName=detector.getRootTypeName(new LibraryRootType(type,isJarDirectory));
        if (typeName != null) {
          types.put(typeName,Pair.create(type,isJarDirectory));
        }
      }
    }
    LOG.assertTrue(!types.isEmpty(),"No allowed root types found for " + detector);
    List<String> sortedNames=new ArrayList<String>(types.keySet());
    Collections.sort(sortedNames,String.CASE_INSENSITIVE_ORDER);
    final int i=Messages.showChooseDialog("Choose category for selected files:","Attach Files",ArrayUtil.toStringArray(sortedNames),sortedNames.get(0),null);
    if (i != -1) {
      final Pair<OrderRootType,Boolean> pair=types.get(sortedNames.get(i));
      for (      VirtualFile candidate : rootCandidates) {
        result.add(new OrderRoot(candidate,pair.getFirst(),pair.getSecond()));
      }
    }
  }
  return result;
}
