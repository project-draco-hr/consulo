{
  final List<OrderRoot> result=new ArrayList<OrderRoot>();
  final List<SuggestedChildRootInfo> suggestedRoots=new ArrayList<SuggestedChildRootInfo>();
  new Task.Modal(project,"Scanning for Roots",true){
    @Override public void run(    @NotNull ProgressIndicator indicator){
      try {
        for (        VirtualFile rootCandidate : rootCandidates) {
          final Collection<DetectedLibraryRoot> roots=detector.detectRoots(rootCandidate,indicator);
          if (!roots.isEmpty() && allRootsHaveOneTypeAndEqualTo(roots,rootCandidate)) {
            for (            DetectedLibraryRoot root : roots) {
              final LibraryRootType libraryRootType=root.getTypes().get(0);
              result.add(new OrderRoot(root.getFile(),libraryRootType.getType(),libraryRootType.isJarDirectory()));
            }
          }
 else {
            for (            DetectedLibraryRoot root : roots) {
              final HashMap<LibraryRootType,String> names=new HashMap<LibraryRootType,String>();
              for (              LibraryRootType type : root.getTypes()) {
                final String typeName=detector.getRootTypeName(type);
                LOG.assertTrue(typeName != null,"Unexpected root type " + type.getType().getName() + (type.isJarDirectory() ? " (jar directory)" : "")+ ", "+ ""+ "detectors: "+ detector);
                names.put(type,typeName);
              }
              suggestedRoots.add(new SuggestedChildRootInfo(rootCandidate,root,names));
            }
          }
        }
      }
 catch (      ProcessCanceledException ignored) {
      }
    }
  }
.queue();
  if (!suggestedRoots.isEmpty()) {
    final DetectedRootsChooserDialog dialog=parentComponent != null ? new DetectedRootsChooserDialog(parentComponent,suggestedRoots) : new DetectedRootsChooserDialog(project,suggestedRoots);
    dialog.show();
    if (!dialog.isOK()) {
      return Collections.emptyList();
    }
    for (    SuggestedChildRootInfo rootInfo : dialog.getChosenRoots()) {
      final LibraryRootType selectedRootType=rootInfo.getSelectedRootType();
      result.add(new OrderRoot(rootInfo.getDetectedRoot().getFile(),selectedRootType.getType(),selectedRootType.isJarDirectory()));
    }
  }
  if (result.isEmpty() && rootTypesAllowedToBeSelectedByUserIfNothingIsDetected.length > 0) {
    Map<String,Pair<OrderRootType,Boolean>> types=new HashMap<String,Pair<OrderRootType,Boolean>>();
    for (    OrderRootType type : rootTypesAllowedToBeSelectedByUserIfNothingIsDetected) {
      for (      boolean isJarDirectory : new boolean[]{false,true}) {
        final String typeName=detector.getRootTypeName(new LibraryRootType(type,isJarDirectory));
        if (typeName != null) {
          types.put(typeName,Pair.create(type,isJarDirectory));
        }
      }
    }
    if (types.isEmpty()) {
      return Collections.emptyList();
    }
    List<String> names=new ArrayList<String>(types.keySet());
    String title="Choose Categories of Selected Files";
    String description=XmlStringUtil.wrapInHtml(ApplicationNamesInfo.getInstance().getProductName() + " cannot determine what kind of files the chosen items contain.<br>" + "Choose the appropriate categories from the list.");
    ChooseElementsDialog<String> dialog;
    if (parentComponent != null) {
      dialog=new ChooseRootTypeElementsDialog(parentComponent,names,title,description);
    }
 else {
      dialog=new ChooseRootTypeElementsDialog(project,names,title,description);
    }
    for (    String rootType : dialog.showAndGetResult()) {
      final Pair<OrderRootType,Boolean> pair=types.get(rootType);
      for (      VirtualFile candidate : rootCandidates) {
        result.add(new OrderRoot(candidate,pair.getFirst(),pair.getSecond()));
      }
    }
  }
  return result;
}
