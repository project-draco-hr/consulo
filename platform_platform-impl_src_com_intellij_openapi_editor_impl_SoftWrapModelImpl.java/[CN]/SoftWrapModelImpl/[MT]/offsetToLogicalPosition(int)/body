{
  DocumentImpl document=(DocumentImpl)myEditor.getDocument();
  CharSequence chars=document.getCharsNoThreadCheck();
  int targetLine=document.getLineNumber(offset);
  int targetLineStartOffset=document.getLineStartOffset(targetLine);
  updateVisibleAreaIfNecessary();
  LogicalPosition cached=myLogicalPositionsByOffsets.get(offset);
  if (cached != null) {
    return cached;
  }
  int softWrapIntroducedLines=0;
  int linesFromCurrentSoftWrap=0;
  int symbolsOnCurrentLogicalLine=0;
  int symbolsOnCurrentVisibleLine=0;
  int rawColumn=toVisualColumnSymbolsNumber(chars,targetLineStartOffset,offset);
  LogicalPosition rawLineStartLogicalPosition=new LogicalPosition(targetLine,rawColumn);
  int index=myWrapOffsets.binarySearch(targetLineStartOffset);
  if (index < 0) {
    index=-index - 1;
  }
  int max=Math.min(index,myWrapOffsets.size());
  for (int j=0; j < max; j++) {
    softWrapIntroducedLines+=StringUtil.countNewLines(myWraps.get(myWrapOffsets.get(j)).getText());
  }
  if (max >= myWrapOffsets.size() || myWrapOffsets.get(max) > offset) {
    return new LogicalPosition(rawLineStartLogicalPosition.line,rawLineStartLogicalPosition.column,softWrapIntroducedLines,0,0);
  }
  FoldingModel foldingModel=myEditor.getFoldingModel();
  max=Math.min(chars.length(),offset);
  for (int i=targetLineStartOffset; i < max; i++) {
    FoldRegion region=foldingModel.getCollapsedRegionAtOffset(i);
    if (region != null && !region.isExpanded()) {
      i=region.getEndOffset();
      symbolsOnCurrentLogicalLine+=region.getEndOffset() - region.getStartOffset();
      symbolsOnCurrentVisibleLine+=region.getPlaceholderText().length();
      continue;
    }
    TextChange softWrap=myWraps.get(i);
    if (softWrap != null) {
      CharSequence softWrapText=softWrap.getText();
      for (int j=0; j < softWrapText.length(); j++) {
        if (softWrapText.charAt(j) == '\n') {
          softWrapIntroducedLines++;
          linesFromCurrentSoftWrap++;
          symbolsOnCurrentVisibleLine=0;
        }
 else {
          symbolsOnCurrentVisibleLine++;
        }
      }
    }
    symbolsOnCurrentLogicalLine++;
    symbolsOnCurrentVisibleLine++;
  }
  LogicalPosition result=new LogicalPosition(rawLineStartLogicalPosition.line,symbolsOnCurrentLogicalLine,softWrapIntroducedLines,linesFromCurrentSoftWrap,symbolsOnCurrentVisibleLine - symbolsOnCurrentLogicalLine);
  myLogicalPositionsByOffsets.put(offset,result);
  return result;
}
