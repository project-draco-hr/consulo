{
  Document document=myEditor.getDocument();
  int maxOffset=document.getLineEndOffset(Math.min(defaultLogical.line,document.getLineCount() - 1));
  int endIndex=myStorage.getSoftWrapIndex(maxOffset + 1);
  if (endIndex < 0) {
    endIndex=-endIndex - 1;
  }
  int softWrapLinesBeforeCurrentLogicalLine=0;
  int softWrapLinesOnCurrentLogicalLine=0;
  int lastSoftWrapLogicalLine=-1;
  FoldingModel foldingModel=myEditor.getFoldingModel();
  int i=0;
  List<TextChange> softWraps=myStorage.getSoftWraps();
  int max=Math.min(softWraps.size(),endIndex);
  for (; i < max; i++) {
    TextChange softWrap=softWraps.get(i);
    if (foldingModel.isOffsetCollapsed(softWrap.getStart())) {
      continue;
    }
    int currentSoftWrapLineFeeds=StringUtil.countNewLines(softWrap.getText());
    int softWrapLine=document.getLineNumber(softWrap.getStart());
    int visualLineBeforeSoftWrapAppliance=myEditor.logicalToVisualPosition(new LogicalPosition(softWrapLine,0)).line + softWrapLinesBeforeCurrentLogicalLine + softWrapLinesOnCurrentLogicalLine;
    if (visualLineBeforeSoftWrapAppliance > visual.line) {
      softWrapLinesBeforeCurrentLogicalLine+=softWrapLinesOnCurrentLogicalLine;
      int logicalLine=defaultLogical.line - softWrapLinesBeforeCurrentLogicalLine;
      LogicalPosition foldingUnawarePosition=new LogicalPosition(logicalLine,defaultLogical.column,softWrapLinesBeforeCurrentLogicalLine,0,0,0,0);
      return adjustFoldingData(foldingModel,foldingUnawarePosition);
    }
    if (lastSoftWrapLogicalLine >= 0 && lastSoftWrapLogicalLine != softWrapLine) {
      softWrapLinesBeforeCurrentLogicalLine+=softWrapLinesOnCurrentLogicalLine;
      softWrapLinesOnCurrentLogicalLine=0;
    }
    lastSoftWrapLogicalLine=softWrapLine;
    int visualLineAfterSoftWrapAppliance=visualLineBeforeSoftWrapAppliance + currentSoftWrapLineFeeds;
    if (visualLineAfterSoftWrapAppliance < visual.line) {
      softWrapLinesOnCurrentLogicalLine+=currentSoftWrapLineFeeds;
      continue;
    }
    Context context=new Context(defaultLogical,visual,softWrapLinesBeforeCurrentLogicalLine,softWrapLinesOnCurrentLogicalLine,visualLineBeforeSoftWrapAppliance,foldingModel);
    int startLineOffset=document.getLineStartOffset(softWrapLine);
    int endLineOffset=document.getLineEndOffset(softWrapLine);
    CharSequence documentText=document.getCharsSequence();
    for (int j=startLineOffset; j < endLineOffset; j++) {
      TextChange softWrapToProcess=myStorage.getSoftWrap(j);
      if (softWrapToProcess != null && j >= softWrap.getStart()) {
        CharSequence softWrapText=softWrapToProcess.getText();
        for (int k=0; k < softWrapText.length(); k++) {
          LogicalPosition result=context.onSoftWrapSymbol(softWrapText.charAt(k));
          if (result != null) {
            return result;
          }
        }
      }
      LogicalPosition result=context.onNonSoftWrapSymbol(documentText.charAt(j));
      if (result != null) {
        return result;
      }
    }
    int logicalLine=defaultLogical.line - softWrapLinesBeforeCurrentLogicalLine - context.softWrapLinesOnCurrentLineBeforeTargetSoftWrap- context.targetSoftWrapLines;
    int logicalColumn=context.symbolsOnCurrentLogicalLine + visual.column - context.symbolsOnCurrentVisualLine;
    int softWrapColumnDiff=visual.column - logicalColumn;
    LogicalPosition foldingUnawarePosition=new LogicalPosition(logicalLine,logicalColumn,softWrapLinesBeforeCurrentLogicalLine,context.softWrapLinesOnCurrentLineBeforeTargetSoftWrap + context.targetSoftWrapLines,softWrapColumnDiff,0,0);
    return adjustFoldingData(foldingModel,foldingUnawarePosition);
  }
  softWrapLinesBeforeCurrentLogicalLine+=softWrapLinesOnCurrentLogicalLine;
  int logicalLine=defaultLogical.line - softWrapLinesBeforeCurrentLogicalLine;
  LogicalPosition foldingUnaware=new LogicalPosition(logicalLine,defaultLogical.column,softWrapLinesBeforeCurrentLogicalLine,0,0,0,0);
  return adjustFoldingData(foldingModel,foldingUnaware);
}
