{
  super.visitAssignmentExpression(expression);
  final PsiExpression lExpression=expression.getLExpression();
  final TypeView left=new TypeView(lExpression);
  final PsiExpression rExpression=expression.getRExpression();
  if (rExpression == null)   return;
  final TypeView right=new TypeView(rExpression);
  final IElementType sign=expression.getOperationTokenType();
  if (sign != JavaTokenType.EQ) {
    final IElementType binaryOperator=TypeConversionUtil.convertEQtoOperation(sign);
    if (!TypeConversionUtil.isBinaryOperatorApplicable(binaryOperator,left.getType(),right.getType(),false)) {
      if (left.isChanged()) {
        findConversionOrFail(expression,lExpression,left.getTypePair());
      }
      if (right.isChanged()) {
        findConversionOrFail(expression,rExpression,right.getTypePair());
      }
      return;
    }
  }
switch (TypeInfection.getInfection(left,right)) {
case TypeInfection.NONE_INFECTED:
    break;
case TypeInfection.LEFT_INFECTED:
  myLabeler.migrateExpressionType(rExpression,left.getType(),myStatement,TypeConversionUtil.isAssignable(left.getType(),right.getType()),true);
break;
case TypeInfection.RIGHT_INFECTED:
myLabeler.migrateExpressionType(lExpression,right.getType(),myStatement,TypeConversionUtil.isAssignable(left.getType(),right.getType()),false);
break;
case TypeInfection.BOTH_INFECTED:
addTypeUsage(lExpression);
addTypeUsage(rExpression);
break;
default :
LOG.error("Must not happen.");
}
}
