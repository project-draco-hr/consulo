{
  super.visitAssignmentExpression(expression);
  final PsiExpression lExpression=expression.getLExpression();
  final TypeView left=new TypeView(lExpression);
  final PsiExpression rExpression=expression.getRExpression();
  if (rExpression == null)   return;
  final TypeView right=new TypeView(rExpression);
  final IElementType sign=expression.getOperationTokenType();
  final PsiType ltype=left.getType();
  final PsiType rtype=right.getType();
  if (ltype == null || rtype == null)   return;
  if (sign != JavaTokenType.EQ) {
    final IElementType binaryOperator=TypeConversionUtil.convertEQtoOperation(sign);
    if (!TypeConversionUtil.isBinaryOperatorApplicable(binaryOperator,ltype,rtype,false)) {
      if (left.isChanged()) {
        findConversionOrFail(expression,lExpression,left.getTypePair());
      }
      if (right.isChanged()) {
        findConversionOrFail(expression,rExpression,right.getTypePair());
      }
      return;
    }
  }
switch (TypeInfection.getInfection(left,right)) {
case TypeInfection.NONE_INFECTED:
    break;
case TypeInfection.LEFT_INFECTED:
  myLabeler.migrateExpressionType(rExpression,ltype,myStatement,TypeConversionUtil.isAssignable(ltype,rtype),true);
break;
case TypeInfection.RIGHT_INFECTED:
myLabeler.migrateExpressionType(lExpression,rtype,myStatement,TypeConversionUtil.isAssignable(ltype,rtype),false);
break;
case TypeInfection.BOTH_INFECTED:
addTypeUsage(lExpression);
addTypeUsage(rExpression);
break;
default :
LOG.error("Must not happen.");
}
}
