{
  super.visitMethod(method);
  if (method.hasModifierProperty(PsiModifier.STATIC) || method.hasModifierProperty(PsiModifier.ABSTRACT) || method.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
    return;
  }
  if (method.isConstructor() || method.getNameIdentifier() == null) {
    return;
  }
  if (m_ignoreEmptyMethods && MethodUtils.isEmpty(method)) {
    return;
  }
  final PsiClass containingClass=ClassUtils.getContainingClass(method);
  if (containingClass == null) {
    return;
  }
  final ExtensionsArea rootArea=Extensions.getRootArea();
  final ExtensionPoint<Condition<PsiMember>> extensionPoint=rootArea.getExtensionPoint("com.intellij.cantBeStatic");
  final Condition<PsiMember>[] addins=extensionPoint.getExtensions();
  for (  Condition<PsiMember> addin : addins) {
    if (addin.value(method)) {
      return;
    }
  }
  final PsiElement scope=containingClass.getScope();
  if (!(scope instanceof PsiJavaFile) && !containingClass.hasModifierProperty(PsiModifier.STATIC)) {
    return;
  }
  if (m_onlyPrivateOrFinal && !method.hasModifierProperty(PsiModifier.FINAL) && !method.hasModifierProperty(PsiModifier.PRIVATE)) {
    return;
  }
  final Query<MethodSignatureBackedByPsiMethod> superMethodQuery=SuperMethodsSearch.search(method,null,true,false);
  if (superMethodQuery.findFirst() != null) {
    return;
  }
  if (MethodUtils.isOverridden(method)) {
    return;
  }
  final MethodReferenceVisitor visitor=new MethodReferenceVisitor(method);
  method.accept(visitor);
  if (!visitor.areReferencesStaticallyAccessible()) {
    return;
  }
  registerMethodError(method);
}
