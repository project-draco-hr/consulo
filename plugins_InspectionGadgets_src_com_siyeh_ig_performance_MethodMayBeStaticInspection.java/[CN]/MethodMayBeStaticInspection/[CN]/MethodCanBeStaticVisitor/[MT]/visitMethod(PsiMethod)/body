{
  super.visitMethod(method);
  if (method.hasModifierProperty(PsiModifier.STATIC) || method.hasModifierProperty(PsiModifier.ABSTRACT) || method.hasModifierProperty(PsiModifier.SYNCHRONIZED)) {
    return;
  }
  if (method.isConstructor() || method.getNameIdentifier() == null) {
    return;
  }
  if (m_ignoreEmptyMethods && MethodUtils.isEmpty(method)) {
    return;
  }
  final PsiClass containingClass=ClassUtils.getContainingClass(method);
  if (containingClass == null) {
    return;
  }
  final Object[] addins=Extensions.getRootArea().getExtensionPoint("com.intellij.cantBeStatic").getExtensions();
  for (  Object addin : addins) {
    if (((Condition<PsiMember>)addin).value(method))     return;
  }
  final PsiElement scope=containingClass.getScope();
  if (!(scope instanceof PsiJavaFile) && !containingClass.hasModifierProperty(PsiModifier.STATIC)) {
    return;
  }
  if (m_onlyPrivateOrFinal && !method.hasModifierProperty(PsiModifier.FINAL) && !method.hasModifierProperty(PsiModifier.PRIVATE)) {
    return;
  }
  if (TestUtils.isJUnitTestMethod(method)) {
    return;
  }
  final Query<MethodSignatureBackedByPsiMethod> superMethodQuery=SuperMethodsSearch.search(method,null,true,false);
  if (superMethodQuery.findFirst() != null) {
    return;
  }
  if (MethodUtils.isOverridden(method)) {
    return;
  }
  final MethodReferenceVisitor visitor=new MethodReferenceVisitor(method);
  method.accept(visitor);
  if (!visitor.areReferencesStaticallyAccessible()) {
    return;
  }
  registerMethodError(method);
}
