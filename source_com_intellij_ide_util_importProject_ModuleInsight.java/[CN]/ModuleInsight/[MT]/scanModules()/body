{
  myProgress.setIndeterminate(true);
  final Map<File,ModuleDescriptor> contentRootToModules=new HashMap<File,ModuleDescriptor>();
  try {
    myProgress.pushState();
    for (    Pair<File,String> pair : mySourceRoots) {
      final File sourceRoot=pair.getFirst();
      if (myIgnoredNames.contains(sourceRoot.getName())) {
        continue;
      }
      myProgress.setText("Scanning " + sourceRoot.getPath());
      final HashSet<String> usedPackages=new HashSet<String>();
      mySourceRootToReferencedPackagesMap.put(sourceRoot,usedPackages);
      final HashSet<String> selfPackages=new HashSet<String>();
      mySourceRootToPackagesMap.put(sourceRoot,selfPackages);
      scanSources(sourceRoot,pair.getSecond(),usedPackages,selfPackages);
      usedPackages.removeAll(selfPackages);
    }
    myProgress.popState();
    myProgress.pushState();
    myProgress.setText("Building modules layout...");
    for (    File srcRoot : mySourceRootToPackagesMap.keySet()) {
      final File moduleContentRoot=myEntryPointRoots.contains(srcRoot) ? srcRoot : srcRoot.getParentFile();
      ModuleDescriptor moduleDescriptor=contentRootToModules.get(moduleContentRoot);
      if (moduleDescriptor != null) {
        moduleDescriptor.addSourceRoot(moduleContentRoot,srcRoot);
      }
 else {
        moduleDescriptor=new ModuleDescriptor(moduleContentRoot,new HashSet<File>(Collections.singleton(srcRoot)));
        contentRootToModules.put(moduleContentRoot,moduleDescriptor);
      }
    }
    buildModuleDependencies(contentRootToModules);
    myProgress.popState();
  }
 catch (  ProcessCanceledException ignored) {
  }
  myModules=new ArrayList<ModuleDescriptor>(contentRootToModules.values());
  final Set<String> moduleNames=new HashSet<String>();
  for (  ModuleDescriptor module : myModules) {
    final String suggested=suggestUniqueName(moduleNames,module.getName());
    module.setName(suggested);
    moduleNames.add(suggested);
  }
}
