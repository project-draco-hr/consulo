{
  if (elements.length != 1) {
    return;
  }
  final PsiMethod method=PsiTreeUtil.getParentOfType(elements[0],PsiMethod.class,false);
  if (method == null) {
    return;
  }
  if (method.isConstructor()) {
    showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("constructor.returns.can.not.be.wrapped"),project);
    return;
  }
  final PsiType returnType=method.getReturnType();
  if (PsiType.VOID.equals(returnType)) {
    showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("method.selected.returns.void"),project);
    return;
  }
  final Set<PsiMethod> siblingMethods=MethodInheritanceUtils.calculateSiblingMethods(method);
  boolean hasLibrarySibling=false;
  for (  PsiMethod siblingMethod : siblingMethods) {
    if (siblingMethod instanceof PsiCompiledElement) {
      hasLibrarySibling=true;
      break;
    }
  }
  if (hasLibrarySibling) {
    showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class"),project);
    return;
  }
  invoke(method);
}
