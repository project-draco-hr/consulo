{
  final WrapReturnValueDialog dialog=new WrapReturnValueDialog(method);
  dialog.show();
  if (!dialog.isOK()) {
    return;
  }
  final Project project=method.getProject();
  final PsiManager manager=method.getManager();
  final GlobalSearchScope scope=GlobalSearchScope.allScope(project);
  final boolean useExistingClass=dialog.useExistingClass();
  final String existingClassName=dialog.getExistingClassName();
  final boolean previewUsages=dialog.isPreviewUsages();
  if (useExistingClass) {
    final PsiClass existingClass=JavaPsiFacade.getInstance(manager.getProject()).findClass(existingClassName,scope);
    if (existingClass == null) {
      showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("could.not.find.selected.wrapping.class"),project);
      return;
    }
    if (!classMayWrapType(existingClass,method.getReturnType())) {
      showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("there.already.exists.an.incompatible.class.with.the.chosen.name"),project);
      return;
    }
    final String className=existingClass.getName();
    final String qualifiedName=existingClass.getQualifiedName();
    final String packageName=qualifiedName.substring(0,qualifiedName.length() - (className.length() + 1));
    perform(project,new Runnable(){
      public void run(){
        final WrapReturnValueProcessor processor=new WrapReturnValueProcessor(className,packageName,method,previewUsages,existingClass);
        processor.run();
      }
    }
);
  }
 else {
    final String className=dialog.getClassName();
    final String packageName=dialog.getPackageName();
    final String qualifiedName=ClassUtil.createQualifiedName(packageName,className);
    final PsiClass existingClass=JavaPsiFacade.getInstance(manager.getProject()).findClass(qualifiedName,scope);
    if (existingClass != null) {
      showErrorMessage(RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"),project);
      return;
    }
    perform(project,new Runnable(){
      public void run(){
        final WrapReturnValueProcessor processor=new WrapReturnValueProcessor(className,packageName,method,previewUsages,existingClass);
        processor.run();
      }
    }
);
  }
}
