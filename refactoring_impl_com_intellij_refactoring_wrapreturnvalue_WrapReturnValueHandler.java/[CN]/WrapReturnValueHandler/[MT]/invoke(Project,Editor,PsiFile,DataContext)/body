{
  final ScrollingModel scrollingModel=editor.getScrollingModel();
  scrollingModel.scrollToCaret(ScrollType.MAKE_VISIBLE);
  final PsiElement element=(PsiElement)dataContext.getData(DataConstants.PSI_ELEMENT);
  PsiMethod selectedMethod=null;
  if (element instanceof PsiMethod) {
    selectedMethod=(PsiMethod)element;
  }
 else {
    final CaretModel caretModel=editor.getCaretModel();
    final int position=caretModel.getOffset();
    PsiElement selectedElement=file.findElementAt(position);
    while (selectedElement != null) {
      if (selectedElement instanceof PsiMethod) {
        selectedMethod=(PsiMethod)selectedElement;
        break;
      }
      selectedElement=selectedElement.getParent();
    }
  }
  if (selectedMethod == null) {
    CommonRefactoringUtil.showErrorMessage(null,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("the.caret.should.be.positioned.at.the.name.of.the.method.to.be.refactored"),this.getHelpID(),project);
    return;
  }
  if (selectedMethod.isConstructor()) {
    CommonRefactoringUtil.showErrorMessage(null,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("constructor.returns.can.not.be.wrapped"),this.getHelpID(),project);
    return;
  }
  final PsiType returnType=selectedMethod.getReturnType();
  if (PsiType.VOID.equals(returnType)) {
    CommonRefactoringUtil.showErrorMessage(null,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("method.selected.returns.void"),this.getHelpID(),project);
    return;
  }
  final Set<PsiMethod> siblingMethods=MethodInheritanceUtils.calculateSiblingMethods(selectedMethod);
  boolean hasLibrarySibling=false;
  for (  PsiMethod siblingMethod : siblingMethods) {
    if (siblingMethod instanceof PsiCompiledElement) {
      hasLibrarySibling=true;
      break;
    }
  }
  if (hasLibrarySibling) {
    CommonRefactoringUtil.showErrorMessage(null,RefactorJBundle.message("cannot.perform.the.refactoring") + RefactorJBundle.message("the.selected.method.cannot.be.wrapped.because.it.is.defined.in.a.non.project.class"),this.getHelpID(),project);
    return;
  }
  invoke(selectedMethod);
}
