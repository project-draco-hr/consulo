{
  return new Callbacks.Backend(){
    public Collection<String> getClassFiles(){
      final HashSet<String> result=new HashSet<String>();
      for (      DependencyContext.S s : myClassToSourceFile.keyCollection()) {
        result.add(myContext.getValue(s));
      }
      return result;
    }
    public void associate(    final String classFileName,    final Callbacks.SourceFileNameLookup sourceFileName,    final ClassReader cr){
      final DependencyContext.S classFileNameS=myContext.get(classFileName);
      final Pair<ClassRepr,Pair<UsageRepr.Cluster,Set<UsageRepr.Usage>>> result=new ClassfileAnalyzer(myContext).analyze(classFileNameS,cr);
      final ClassRepr repr=result.first;
      final UsageRepr.Cluster localUsages=result.second.first;
      final Set<UsageRepr.Usage> localAnnotationUsages=result.second.second;
      final String srcFileName=sourceFileName.get(repr == null ? null : myContext.getValue(repr.getSourceFileName()));
      final DependencyContext.S sourceFileNameS=myContext.get(srcFileName);
      if (repr != null) {
        final DependencyContext.S className=repr.name;
        for (        UsageRepr.Usage u : localUsages.getUsages()) {
          myClassToClassDependency.put(u.getOwner(),className);
        }
      }
      if (repr != null) {
        myClassToSourceFile.put(repr.name,sourceFileNameS);
        mySourceFileToClasses.put(sourceFileNameS,repr);
        for (        DependencyContext.S s : repr.getSupers()) {
          myClassToSubclasses.put(s,repr.name);
        }
      }
      if (!localUsages.isEmpty()) {
        updateSourceToUsages(sourceFileNameS,localUsages);
      }
      if (!localAnnotationUsages.isEmpty()) {
        updateSourceToAnnotationUsages(sourceFileNameS,localAnnotationUsages);
      }
    }
  }
;
}
