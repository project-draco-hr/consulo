{
  return new Callbacks.Backend(){
    public Collection<String> getClassFiles(){
      final HashSet<String> result=new HashSet<String>();
synchronized (myLock) {
        for (        DependencyContext.S s : myClassToSourceFile.keyCollection()) {
          result.add(myContext.getValue(s));
        }
      }
      return result;
    }
    public void associate(    final String classFileName,    final Callbacks.SourceFileNameLookup sourceFileName,    final ClassReader cr){
synchronized (myLock) {
        final DependencyContext.S classFileNameS=myContext.get(classFileName);
        final Pair<ClassRepr,Pair<UsageRepr.Cluster,Set<UsageRepr.Usage>>> result=new ClassfileAnalyzer(myContext).analyze(classFileNameS,cr);
        final ClassRepr repr=result.first;
        final UsageRepr.Cluster localUsages=result.second.first;
        final Set<UsageRepr.Usage> localAnnotationUsages=result.second.second;
        final String srcFileName=sourceFileName.get(repr == null ? null : myContext.getValue(repr.getSourceFileName()));
        final DependencyContext.S sourceFileNameS=myContext.get(srcFileName);
        if (repr != null) {
          final DependencyContext.S className=repr.name;
          myClassToSourceFile.put(repr.name,sourceFileNameS);
          mySourceFileToClasses.put(sourceFileNameS,repr);
          for (          DependencyContext.S s : repr.getSupers()) {
            myClassToSubclasses.put(s,repr.name);
          }
          for (          UsageRepr.Usage u : localUsages.getUsages()) {
            final DependencyContext.S owner=u.getOwner();
            if (!owner.equals(className)) {
              final DependencyContext.S sourceFile=repr.getSourceFileName();
              final DependencyContext.S ownerSourceFile=myClassToSourceFile.get(owner);
              if (ownerSourceFile != null) {
                if (!ownerSourceFile.equals(sourceFile)) {
                  myClassToClassDependency.put(owner,className);
                }
              }
 else {
                myClassToClassDependency.put(owner,className);
              }
            }
          }
        }
        if (!localUsages.isEmpty()) {
          mySourceFileToUsages.put(sourceFileNameS,localUsages);
        }
        if (!localAnnotationUsages.isEmpty()) {
          mySourceFileToAnnotationUsages.put(sourceFileNameS,localAnnotationUsages);
        }
      }
    }
    @Override public void registerConstantUsage(    final String className,    final String fieldName,    final String fieldOwner){
    }
    @Override public void registerImports(    final String className,    final Collection<String> imports,    Collection<String> staticImports){
      for (      String s : staticImports) {
        int i=s.length() - 1;
        for (; s.charAt(i) != '.'; i--)         ;
        imports.add(s.substring(0,i));
      }
      addPostPass(new PostPass(){
        public void perform(){
          final DependencyContext.S rootClassName=myContext.get(className.replace(".","/"));
          final DependencyContext.S fileName=myClassToSourceFile.get(rootClassName);
          for (          final String i : imports) {
            if (i.endsWith("*")) {
              continue;
            }
            final DependencyContext.S iname=myContext.get(i.replace(".","/"));
            myClassToClassDependency.put(iname,rootClassName);
            if (fileName != null) {
              final UsageRepr.Cluster cluster=new UsageRepr.Cluster();
              cluster.addUsage(rootClassName,UsageRepr.createClassUsage(myContext,iname));
              mySourceFileToUsages.put(fileName,cluster);
            }
          }
        }
      }
);
    }
  }
;
}
