{
  return new Callbacks.Backend(){
    public Collection<String> getClassFiles(){
      final Set<String> result=new HashSet<String>();
synchronized (myLock) {
        myClassToSourceFile.forEachEntry(new TIntIntProcedure(){
          @Override public boolean execute(          int s,          int b){
            result.add(myContext.getValue(s));
            return true;
          }
        }
);
      }
      return result;
    }
    public void associate(    final String classFileName,    final Callbacks.SourceFileNameLookup sourceFileName,    final ClassReader cr){
synchronized (myLock) {
        final int classFileNameS=myContext.get(classFileName);
        final Pair<ClassRepr,Pair<UsageRepr.Cluster,Set<UsageRepr.Usage>>> result=new ClassfileAnalyzer(myContext).analyze(classFileNameS,cr);
        final ClassRepr repr=result.first;
        final UsageRepr.Cluster localUsages=result.second.first;
        final Set<UsageRepr.Usage> localAnnotationUsages=result.second.second;
        final String srcFileName=sourceFileName.get(repr == null ? null : myContext.getValue(repr.getSourceFileName()));
        final int sourceFileNameS=myContext.get(srcFileName);
        if (repr != null) {
          final int className=repr.name;
          myClassToSourceFile.put(repr.name,sourceFileNameS);
          mySourceFileToClasses.put(sourceFileNameS,repr);
          for (          final int s : repr.getSupers()) {
            myClassToSubclasses.put(s,repr.name);
          }
          for (          final UsageRepr.Usage u : localUsages.getUsages()) {
            final int owner=u.getOwner();
            if (owner != className) {
              final int sourceFile=repr.getSourceFileName();
              final int ownerSourceFile=myClassToSourceFile.get(owner);
              if (ownerSourceFile > 0) {
                if (ownerSourceFile != sourceFile) {
                  myClassToClassDependency.put(owner,className);
                }
              }
 else {
                myClassToClassDependency.put(owner,className);
              }
            }
          }
        }
        if (!localUsages.isEmpty()) {
          mySourceFileToUsages.put(sourceFileNameS,localUsages);
        }
        if (!localAnnotationUsages.isEmpty()) {
          mySourceFileToAnnotationUsages.put(sourceFileNameS,localAnnotationUsages);
        }
      }
    }
    @Override public void registerConstantUsage(    final String className,    final String fieldName,    final String fieldOwner){
    }
    @Override public void registerImports(    final String className,    final Collection<String> imports,    Collection<String> staticImports){
      for (      final String s : staticImports) {
        int i=s.length() - 1;
        for (; s.charAt(i) != '.'; i--)         ;
        imports.add(s.substring(0,i));
      }
      addPostPass(new PostPass(){
        public void perform(){
          final int rootClassName=myContext.get(className.replace(".","/"));
          final int fileName=myClassToSourceFile.get(rootClassName);
          for (          final String i : imports) {
            if (i.endsWith("*")) {
              continue;
            }
            final int iname=myContext.get(i.replace(".","/"));
            myClassToClassDependency.put(iname,rootClassName);
            if (fileName > 0) {
              final UsageRepr.Cluster cluster=new UsageRepr.Cluster();
              cluster.addUsage(rootClassName,UsageRepr.createClassUsage(myContext,iname));
              mySourceFileToUsages.put(fileName,cluster);
            }
          }
        }
      }
);
    }
  }
;
}
