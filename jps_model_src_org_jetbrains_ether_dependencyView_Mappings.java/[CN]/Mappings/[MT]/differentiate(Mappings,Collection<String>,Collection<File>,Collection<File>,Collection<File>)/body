{
  debug("Begin of Differentiate:");
  delta.compensateRemovedContent(filesToCompile);
  final Util u=new Util(delta);
  final Util self=new Util(this);
  final Util o=new Util();
  if (removed != null) {
    for (    String file : removed) {
      final Collection<ClassRepr> classes=mySourceFileToClasses.get(myContext.get(file));
      if (classes != null) {
        for (        ClassRepr c : classes) {
          u.affectAll(c.name,affectedFiles);
        }
      }
    }
  }
  for (  DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {
    final Set<ClassRepr> classes=(Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);
    final Set<ClassRepr> pastClasses=(Set<ClassRepr>)mySourceFileToClasses.get(fileName);
    final Set<DependencyContext.S> dependants=new HashSet<DependencyContext.S>();
    final Set<UsageRepr.Usage> affectedUsages=new HashSet<UsageRepr.Usage>();
    final Set<UsageRepr.AnnotationUsage> annotationQuery=new HashSet<UsageRepr.AnnotationUsage>();
    final Map<UsageRepr.Usage,Util.UsageConstraint> usageConstraints=new HashMap<UsageRepr.Usage,Util.UsageConstraint>();
    final Difference.Specifier<ClassRepr> classDiff=Difference.make(pastClasses,classes);
    debug("Processing changed classes:");
    for (    Pair<ClassRepr,Difference> changed : classDiff.changed()) {
      final ClassRepr it=changed.first;
      final ClassRepr.Diff diff=(ClassRepr.Diff)changed.second;
      self.appendDependents(it,dependants);
      delta.addChangedClass(it.name);
      debug("Changed: ",it.name);
      final int addedModifiers=diff.addedModifiers();
      final int removedModifiers=diff.removedModifiers();
      final boolean superClassChanged=(diff.base() & Difference.SUPERCLASS) > 0;
      final boolean interfacesChanged=!diff.interfaces().unchanged();
      final boolean signatureChanged=(diff.base() & Difference.SIGNATURE) > 0;
      if (superClassChanged || interfacesChanged || signatureChanged) {
        debug("Superclass changed: ",superClassChanged);
        debug("Interfaces changed: ",interfacesChanged);
        debug("Signature changed ",signatureChanged);
        final boolean extendsChanged=superClassChanged && !diff.extendsAdded();
        final boolean interfacesRemoved=interfacesChanged && !diff.interfaces().removed().isEmpty();
        debug("Extends changed: ",extendsChanged);
        debug("Interfaces removed: ",interfacesRemoved);
        u.affectSubclasses(it.name,affectedFiles,affectedUsages,dependants,extendsChanged || interfacesRemoved || signatureChanged);
      }
      if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {
        debug("Class-to-interface or interface-to-class conversion detected, added class usage to affected usages");
        affectedUsages.add(it.createUsage());
      }
      if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {
        debug("Annotation, retention policy = SOURCE => a switch to non-incremental mode requested");
        if (!incrementalDecision(it.outerClassName,it,affectedFiles)) {
          debug("End of Differentiate, returning false");
          return false;
        }
      }
      if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {
        debug("Introduction of 'protected' modifier detected, adding class usage + inheritance constraint to affected usages");
        final UsageRepr.Usage usage=it.createUsage();
        affectedUsages.add(usage);
        usageConstraints.put(usage,u.new InheritanceConstraint(it.name));
      }
      if (diff.packageLocalOn()) {
        debug("Introduction of 'package local' access detected, adding class usage + package constraint to affected usages");
        final UsageRepr.Usage usage=it.createUsage();
        affectedUsages.add(usage);
        usageConstraints.put(usage,u.new PackageConstraint(it.getPackageName()));
      }
      if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {
        debug("Introduction of 'private' or 'final' modifier(s) detected, adding class usage to affected usages");
        affectedUsages.add(it.createUsage());
      }
      if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0 || (addedModifiers & Opcodes.ACC_STATIC) > 0) {
        debug("Introduction of 'abstract' or 'static' modifier(s) detected, adding class new usage to affected usages");
        affectedUsages.add(UsageRepr.createClassNewUsage(myContext,it.name));
      }
      if (it.isAnnotation()) {
        debug("Class is annotation, performing annotation-specific analysis");
        if (diff.retentionChanged()) {
          debug("Retention policy change detected, adding class usage to affected usages");
          affectedUsages.add(it.createUsage());
        }
 else {
          final Collection<ElementType> removedtargets=diff.targets().removed();
          if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {
            debug("Removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested");
            if (!incrementalDecision(it.outerClassName,it,affectedFiles)) {
              debug("End of Differentiate, returning false");
              return false;
            }
          }
          if (!removedtargets.isEmpty()) {
            debug("Removed some annotation targets, adding annotation query");
            annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr.createAnnotationUsage(myContext,TypeRepr.createClassType(myContext,it.name),null,removedtargets));
          }
          for (          MethodRepr m : diff.methods().added()) {
            if (!m.hasValue()) {
              debug("Added method with no default value: ",m.name);
              debug("Adding class usage to affected usages");
              affectedUsages.add(it.createUsage());
            }
          }
        }
        debug("End of annotation-specific analysis");
      }
      debug("Processing added methods: ");
      for (      MethodRepr m : diff.methods().added()) {
        debug("Method: ",m.name);
        if (it.isAnnotation()) {
          debug("Class is annotation, skipping method analysis");
          continue;
        }
        if ((it.access & Opcodes.ACC_INTERFACE) > 0 || (it.access & Opcodes.ACC_ABSTRACT) > 0 || (m.access & Opcodes.ACC_ABSTRACT) > 0) {
          debug("Class is abstract, or is interface, or added method in abstract => affecting all subclasses");
          u.affectSubclasses(it.name,affectedFiles,affectedUsages,dependants,false);
        }
        Collection<DependencyContext.S> propagated=null;
        if ((m.access & Opcodes.ACC_PRIVATE) == 0 && !myContext.getValue(m.name).equals("<init>")) {
          final ClassRepr oldIt=getReprByName(it.name);
          if (oldIt != null && self.findOverridenMethods(m,oldIt).size() > 0) {
          }
 else {
            propagated=u.propagateMethodAccess(m.name,it.name);
            debug("Conservative case on overriding methods, affecting method usages");
            u.affectMethodUsages(m,propagated,m.createMetaUsage(myContext,it.name),affectedUsages,dependants);
          }
        }
        if ((m.access & Opcodes.ACC_PRIVATE) == 0) {
          final Collection<Pair<MethodRepr,ClassRepr>> affectedMethods=u.findAllMethodsBySpecificity(m,it);
          final MethodRepr.Predicate overrides=MethodRepr.equalByJavaRules(m);
          if (propagated == null) {
            propagated=u.propagateMethodAccess(m.name,it.name);
          }
          final Collection<MethodRepr> lessSpecific=it.findMethods(u.lessSpecific(m));
          for (          MethodRepr mm : lessSpecific) {
            if (!mm.equals(m)) {
              debug("Found less specific method, affecting method usages");
              u.affectMethodUsages(mm,propagated,mm.createUsage(myContext,it.name),affectedUsages,dependants);
            }
          }
          debug("Processing affected by specificity methods");
          for (          Pair<MethodRepr,ClassRepr> p : affectedMethods) {
            final MethodRepr mm=p.first;
            final ClassRepr cc=p.second;
            if (cc == myMockClass) {
            }
 else {
              debug("Method: ",mm.name);
              debug("Class : ",cc.name);
              if (overrides.satisfy(mm)) {
                debug("Current method overrides that found");
                final Option<Boolean> subtypeOf=u.isSubtypeOf(mm.type,m.type);
                if (weakerAccess(mm.access,m.access) || ((m.access & Opcodes.ACC_STATIC) > 0 && (mm.access & Opcodes.ACC_STATIC) == 0) || ((m.access & Opcodes.ACC_STATIC) == 0 && (mm.access & Opcodes.ACC_STATIC) > 0)|| ((m.access & Opcodes.ACC_FINAL) > 0)|| !m.exceptions.equals(mm.exceptions)|| (subtypeOf.isNone() || !subtypeOf.value())|| !empty(mm.signature)|| !empty(m.signature)) {
                  final DependencyContext.S file=myClassToSourceFile.get(cc.name);
                  if (file != null) {
                    final String f=myContext.getValue(file);
                    debug("Complex condition is satisfied, affecting file ",f);
                    affectedFiles.add(new File(f));
                  }
                }
              }
 else {
                debug("Current method does not override that found");
                final Collection<DependencyContext.S> yetPropagated=self.propagateMethodAccess(mm.name,cc.name);
                final Collection<DependencyContext.S> deps=myClassToClassDependency.get(cc.name);
                if (deps != null) {
                  dependants.addAll(deps);
                }
                debug("Affecting method usages for that found");
                u.affectMethodUsages(mm,yetPropagated,mm.createUsage(myContext,cc.name),affectedUsages,dependants);
              }
            }
          }
          final Collection<DependencyContext.S> subClasses=getAllSubclasses(it.name);
          if (subClasses != null) {
            for (            final DependencyContext.S subClass : subClasses) {
              final ClassRepr r=u.reprByName(subClass);
              final DependencyContext.S sourceFileName=myClassToSourceFile.get(subClass);
              if (r != null && sourceFileName != null) {
                final DependencyContext.S outerClass=r.outerClassName;
                if (u.methodVisible(outerClass,m)) {
                  final String f=myContext.getValue(sourceFileName);
                  debug("Affecting file due to local overriding: ",f);
                  affectedFiles.add(new File(f));
                }
              }
            }
          }
        }
      }
      debug("End of added methods processing");
      debug("Processing removed methods:");
      for (      MethodRepr m : diff.methods().removed()) {
        debug("Method ",m.name);
        final Collection<Pair<MethodRepr,ClassRepr>> overridenMethods=u.findOverridenMethods(m,it);
        final Collection<DependencyContext.S> propagated=u.propagateMethodAccess(m.name,it.name);
        if (overridenMethods.size() == 0) {
          debug("No overridden methods found, affecting method usages");
          u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),affectedUsages,dependants);
        }
 else {
          boolean clear=true;
          loop:           for (          Pair<MethodRepr,ClassRepr> overriden : overridenMethods) {
            final MethodRepr mm=overriden.first;
            if (mm == myMockMethod || !mm.type.equals(m.type) || !empty(mm.signature) || !empty(m.signature)) {
              clear=false;
              break loop;
            }
          }
          if (!clear) {
            debug("No clearly overridden methods found, affecting method usages");
            u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),affectedUsages,dependants);
          }
        }
        if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {
          for (          DependencyContext.S p : propagated) {
            final ClassRepr s=u.reprByName(p);
            if (s != null) {
              final Collection<Pair<MethodRepr,ClassRepr>> overridenInS=u.findOverridenMethods(m,s);
              overridenInS.addAll(overridenMethods);
              boolean allAbstract=true;
              boolean visited=false;
              for (              Pair<MethodRepr,ClassRepr> pp : overridenInS) {
                final ClassRepr cc=pp.second;
                if (cc == myMockClass) {
                  visited=true;
                  continue;
                }
                if (cc.name.equals(it.name)) {
                  continue;
                }
                visited=true;
                allAbstract=((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);
                if (!allAbstract) {
                  break;
                }
              }
              if (allAbstract && visited) {
                final DependencyContext.S source=myClassToSourceFile.get(p);
                if (source != null) {
                  final String f=myContext.getValue(source);
                  debug("Removed method is not abstract & is overrides some abstract method which is not then over-overriden in subclass ",p);
                  debug("Affecting subclass source file ",f);
                  affectedFiles.add(new File(f));
                }
              }
            }
          }
        }
      }
      debug("End of removed methods processing");
      debug("Processing changed methods:");
      for (      Pair<MethodRepr,Difference> mr : diff.methods().changed()) {
        final MethodRepr m=mr.first;
        final MethodRepr.Diff d=(MethodRepr.Diff)mr.second;
        final boolean throwsChanged=(d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);
        debug("Method: ",m.name);
        if (it.isAnnotation()) {
          if (d.defaultRemoved()) {
            debug("Class is annotation, default value is removed => adding annotation query");
            final List<DependencyContext.S> l=new LinkedList<DependencyContext.S>();
            l.add(m.name);
            annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr.createAnnotationUsage(myContext,TypeRepr.createClassType(myContext,it.name),l,null));
          }
        }
 else         if (d.base() != Difference.NONE || throwsChanged) {
          final Collection<DependencyContext.S> propagated=u.propagateMethodAccess(m.name,it.name);
          boolean affected=false;
          boolean constrained=false;
          final Set<UsageRepr.Usage> usages=new HashSet<UsageRepr.Usage>();
          if (d.packageLocalOn()) {
            debug("Method became package-local, affecting method usages outside the package");
            u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,dependants);
            for (            UsageRepr.Usage usage : usages) {
              usageConstraints.put(usage,u.new InheritanceConstraint(it.name));
            }
            affectedUsages.addAll(usages);
            affected=true;
            constrained=true;
          }
          if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {
            if (!affected) {
              debug("Return type, throws list or signature changed --- affecting method usages");
              u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,dependants);
              affectedUsages.addAll(usages);
            }
          }
 else           if ((d.base() & Difference.ACCESS) > 0) {
            if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {
              if (!affected) {
                debug("Added static or private specifier or removed static specifier --- affecting method usages");
                u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,dependants);
                affectedUsages.addAll(usages);
              }
              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {
                debug("Added static specifier --- affecting subclasses");
                u.affectSubclasses(it.name,affectedFiles,affectedUsages,dependants,false);
              }
            }
 else {
              if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {
                debug("Added final, public or abstract specifier --- affecting subclasses");
                u.affectSubclasses(it.name,affectedFiles,affectedUsages,dependants,false);
              }
              if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {
                if (!constrained) {
                  debug("Added public or package-local method became protected --- affect method usages with protected constraint");
                  if (!affected) {
                    u.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,dependants);
                    affectedUsages.addAll(usages);
                  }
                  for (                  UsageRepr.Usage usage : usages) {
                    usageConstraints.put(usage,u.new InheritanceConstraint(it.name));
                  }
                }
              }
            }
          }
        }
      }
      debug("End of changed methods processing");
      final int mask=Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;
      debug("Processing added fields");
      for (      FieldRepr f : diff.fields().added()) {
        debug("Field: ",f.name);
        final boolean fPrivate=(f.access & Opcodes.ACC_PRIVATE) > 0;
        final boolean fProtected=(f.access & Opcodes.ACC_PROTECTED) > 0;
        final boolean fPublic=(f.access & Opcodes.ACC_PUBLIC) > 0;
        final boolean fPLocal=!fPrivate && !fProtected && !fPublic;
        if (!fPrivate) {
          final Collection<DependencyContext.S> subClasses=getAllSubclasses(it.name);
          for (          final DependencyContext.S subClass : subClasses) {
            final ClassRepr r=u.reprByName(subClass);
            final DependencyContext.S sourceFileName=myClassToSourceFile.get(subClass);
            if (r != null && sourceFileName != null) {
              if (r.isLocal) {
                debug("Affecting local subclass (introduced field can potentially hide surrounding method parameters/local variables): ",sourceFileName);
                affectedFiles.add(new File(myContext.getValue(sourceFileName)));
              }
 else {
                final DependencyContext.S outerClass=r.outerClassName;
                if (!empty(outerClass) && u.fieldVisible(outerClass,f)) {
                  debug("Affecting inner subclass (introduced field can potentially hide surrounding class fields): ",sourceFileName);
                  affectedFiles.add(new File(myContext.getValue(sourceFileName)));
                }
              }
            }
            debug("Affecting field usages referenced from subclass ",subClass);
            final Collection<DependencyContext.S> propagated=u.propagateFieldAccess(f.name,subClass);
            u.affectFieldUsages(f,propagated,f.createUsage(myContext,subClass),affectedUsages,dependants);
            final Collection<DependencyContext.S> deps=myClassToClassDependency.get(subClass);
            if (deps != null) {
              dependants.addAll(deps);
            }
          }
        }
        final Collection<Pair<FieldRepr,ClassRepr>> overridden=u.findOverridenFields(f,it);
        for (        Pair<FieldRepr,ClassRepr> p : overridden) {
          final FieldRepr ff=p.first;
          final ClassRepr cc=p.second;
          final boolean ffPrivate=(ff.access & Opcodes.ACC_PRIVATE) > 0;
          final boolean ffProtected=(ff.access & Opcodes.ACC_PROTECTED) > 0;
          final boolean ffPublic=(ff.access & Opcodes.ACC_PUBLIC) > 0;
          final boolean ffPLocal=isPackageLocal(ff.access);
          if (!ffPrivate) {
            final Collection<DependencyContext.S> propagated=o.propagateFieldAccess(ff.name,cc.name);
            final Set<UsageRepr.Usage> localUsages=new HashSet<UsageRepr.Usage>();
            debug("Affecting usages of overridden field in class ",cc.name);
            u.affectFieldUsages(ff,propagated,ff.createUsage(myContext,cc.name),localUsages,dependants);
            if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected)|| (fPLocal && ffPLocal)) {
            }
 else {
              Util.UsageConstraint constaint;
              if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {
                constaint=u.new NegationConstraint(u.new InheritanceConstraint(cc.name));
              }
 else               if (ffPublic && ffPLocal) {
                constaint=u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));
              }
 else {
                constaint=u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));
              }
              for (              UsageRepr.Usage usage : localUsages) {
                usageConstraints.put(usage,constaint);
              }
            }
            affectedUsages.addAll(localUsages);
          }
        }
      }
      debug("End of added fields processing");
      debug("Processing removed fields:");
      for (      FieldRepr f : diff.fields().removed()) {
        debug("Field: ",it.name);
        if ((f.access & Opcodes.ACC_PRIVATE) == 0 && (f.access & mask) == mask && f.hasValue()) {
          debug("Field had value and was (non-private) final static => a switch to non-incremental mode requested");
          if (!incrementalDecision(it.name,f,affectedFiles)) {
            debug("End of Differentiate, returning false");
            return false;
          }
        }
        final Collection<DependencyContext.S> propagated=u.propagateFieldAccess(f.name,it.name);
        u.affectFieldUsages(f,propagated,f.createUsage(myContext,it.name),affectedUsages,dependants);
      }
      debug("End of removed fields processing");
      debug("Processing changed fields:");
      for (      Pair<FieldRepr,Difference> f : diff.fields().changed()) {
        final Difference d=f.second;
        final FieldRepr field=f.first;
        debug("Field: ",it.name);
        if ((field.access & Opcodes.ACC_PRIVATE) == 0 && (field.access & mask) == mask) {
          if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {
            debug("Inline field changed it's access or value => a switch to non-incremental mode requested");
            if (!incrementalDecision(it.name,field,affectedFiles)) {
              debug("End of Differentiate, returning false");
              return false;
            }
          }
        }
        if (d.base() != Difference.NONE) {
          final Collection<DependencyContext.S> propagated=u.propagateFieldAccess(field.name,it.name);
          if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {
            debug("Type or signature changed --- affecting field usages");
            u.affectFieldUsages(field,propagated,field.createUsage(myContext,it.name),affectedUsages,dependants);
          }
 else           if ((d.base() & Difference.ACCESS) > 0) {
            if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 || (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {
              debug("Added/removed static modifier or added private/volatile modifier --- affecting field usages");
              u.affectFieldUsages(field,propagated,field.createUsage(myContext,it.name),affectedUsages,dependants);
            }
 else {
              boolean affected=false;
              final Set<UsageRepr.Usage> usages=new HashSet<UsageRepr.Usage>();
              if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {
                debug("Added final modifier --- affecting field assign usages");
                u.affectFieldUsages(field,propagated,field.createAssignUsage(myContext,it.name),usages,dependants);
                affectedUsages.addAll(usages);
                affected=true;
              }
              if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {
                debug("Removed public modifier, affecting field usages with appropriate constraint");
                if (!affected) {
                  u.affectFieldUsages(field,propagated,field.createUsage(myContext,it.name),usages,dependants);
                  affectedUsages.addAll(usages);
                }
                for (                UsageRepr.Usage usage : usages) {
                  if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {
                    usageConstraints.put(usage,u.new InheritanceConstraint(it.name));
                  }
 else {
                    usageConstraints.put(usage,u.new PackageConstraint(it.getPackageName()));
                  }
                }
              }
            }
          }
        }
      }
      debug("End of changed fields processing");
    }
    debug("End of changed classes processing");
    debug("Processing removed classes:");
    for (    ClassRepr c : classDiff.removed()) {
      delta.addChangedClass(c.name);
      self.appendDependents(c,dependants);
      debug("Adding usages of class ",c.name);
      affectedUsages.add(c.createUsage());
    }
    debug("End of removed classes processing.");
    debug("Processing added classes:");
    for (    ClassRepr c : classDiff.added()) {
      delta.addChangedClass(c.name);
      final Collection<DependencyContext.S> depClasses=myClassToClassDependency.get(c.name);
      if (depClasses != null) {
        for (        DependencyContext.S depClass : depClasses) {
          final DependencyContext.S fName=myClassToSourceFile.get(depClass);
          if (fName != null) {
            final String f=myContext.getValue(fName);
            debug("Adding dependent file ",f);
            affectedFiles.add(new File(f));
          }
        }
      }
    }
    debug("End of added classes processing.");
    debug("Checking dependent files:");
    final Set<DependencyContext.S> dependentFiles=new HashSet<DependencyContext.S>();
    for (    DependencyContext.S depClass : dependants) {
      final DependencyContext.S file=myClassToSourceFile.get(depClass);
      if (file != null) {
        dependentFiles.add(file);
      }
    }
    filewise:     for (    DependencyContext.S depFile : dependentFiles) {
      final File theFile=new File(myContext.getValue(depFile));
      if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {
        continue filewise;
      }
      debug("Dependent file: ",depFile);
      final Collection<UsageRepr.Cluster> depClusters=mySourceFileToUsages.get(depFile);
      if (depClusters != null) {
        for (        UsageRepr.Cluster depCluster : depClusters) {
          final Set<UsageRepr.Usage> depUsages=depCluster.getUsages();
          if (depUsages == null) {
            continue;
          }
          final Set<UsageRepr.Usage> usages=new HashSet<UsageRepr.Usage>(depUsages);
          usages.retainAll(affectedUsages);
          if (!usages.isEmpty()) {
            for (            UsageRepr.Usage usage : usages) {
              final Util.UsageConstraint constraint=usageConstraints.get(usage);
              if (constraint == null) {
                debug("Added file with no constraints");
                affectedFiles.add(theFile);
                continue filewise;
              }
 else {
                final Set<DependencyContext.S> residenceClasses=depCluster.getResidence(usage);
                for (                DependencyContext.S residentName : residenceClasses) {
                  if (constraint.checkResidence(residentName)) {
                    debug("Added file with satisfied constraint");
                    affectedFiles.add(theFile);
                    continue filewise;
                  }
                }
              }
            }
          }
          if (annotationQuery.size() > 0) {
            final Collection<UsageRepr.Usage> annotationUsages=mySourceFileToAnnotationUsages.get(depFile);
            for (            UsageRepr.Usage usage : annotationUsages) {
              for (              UsageRepr.AnnotationUsage query : annotationQuery) {
                if (query.satisfies(usage)) {
                  debug("Added file due to annotation query");
                  affectedFiles.add(theFile);
                  continue filewise;
                }
              }
            }
          }
        }
      }
    }
  }
  if (removed != null) {
    for (    String r : removed) {
      affectedFiles.remove(new File(r));
    }
  }
  debug("End of Differentiate, returning true");
  return true;
}
