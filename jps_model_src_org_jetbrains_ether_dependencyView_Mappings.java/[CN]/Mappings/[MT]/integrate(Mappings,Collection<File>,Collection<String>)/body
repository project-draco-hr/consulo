{
synchronized (myLock) {
    try {
      delta.runPostPasses();
      if (removed != null) {
        for (        String file : removed) {
          final DependencyContext.S key=myContext.get(file);
          final Set<ClassRepr> classes=(Set<ClassRepr>)mySourceFileToClasses.get(key);
          final Collection<UsageRepr.Cluster> clusters=mySourceFileToUsages.get(key);
          if (classes != null) {
            for (            ClassRepr cr : classes) {
              myClassToSubclasses.remove(cr.name);
              myClassToSourceFile.remove(cr.name);
              myClassToClassDependency.remove(cr.name);
              for (              DependencyContext.S superSomething : cr.getSupers()) {
                myClassToSubclasses.removeFrom(superSomething,cr.name);
              }
              if (clusters != null) {
                for (                UsageRepr.Cluster cluster : clusters) {
                  final Set<UsageRepr.Usage> usages=cluster.getUsages();
                  if (usages != null) {
                    for (                    UsageRepr.Usage u : usages) {
                      if (u instanceof UsageRepr.ClassUsage) {
                        final Set<DependencyContext.S> residents=cluster.getResidence(u);
                        if (residents != null && residents.contains(cr.name)) {
                          myClassToClassDependency.removeFrom(((UsageRepr.ClassUsage)u).className,cr.name);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          mySourceFileToClasses.remove(key);
          mySourceFileToUsages.remove(key);
          mySourceFileToAnnotationUsages.remove(key);
        }
      }
      if (delta.isDifferentiated()) {
        for (        DependencyContext.S c : delta.getChangedClasses()) {
          final Collection<DependencyContext.S> subClasses=delta.myClassToSubclasses.get(c);
          if (subClasses != null) {
            myClassToSubclasses.replace(c,subClasses);
          }
 else {
            myClassToSubclasses.remove(c);
          }
          final DependencyContext.S sourceFile=delta.myClassToSourceFile.get(c);
          if (sourceFile != null) {
            myClassToSourceFile.put(c,sourceFile);
          }
 else {
            myClassToSourceFile.remove(c);
          }
        }
        for (        DependencyContext.S f : delta.getChangedFiles()) {
          final Collection<ClassRepr> classes=delta.mySourceFileToClasses.get(f);
          if (classes != null) {
            mySourceFileToClasses.replace(f,classes);
          }
 else {
            mySourceFileToClasses.remove(f);
          }
          final Collection<UsageRepr.Cluster> clusters=delta.mySourceFileToUsages.get(f);
          if (clusters != null) {
            mySourceFileToUsages.replace(f,clusters);
          }
 else {
            mySourceFileToUsages.remove(f);
          }
          final Collection<UsageRepr.Usage> usages=delta.mySourceFileToAnnotationUsages.get(f);
          if (usages != null) {
            mySourceFileToAnnotationUsages.replace(f,usages);
          }
 else {
            mySourceFileToAnnotationUsages.remove(f);
          }
        }
      }
 else {
        myClassToSubclasses.putAll(delta.myClassToSubclasses);
        myClassToSourceFile.putAll(delta.myClassToSourceFile);
        mySourceFileToClasses.replaceAll(delta.mySourceFileToClasses);
        mySourceFileToUsages.replaceAll(delta.mySourceFileToUsages);
        mySourceFileToAnnotationUsages.replaceAll(delta.mySourceFileToAnnotationUsages);
      }
      final Collection<DependencyContext.S> compiledSet=new HashSet<DependencyContext.S>(compiled.size());
      for (      File c : compiled) {
        compiledSet.add(myContext.get(FileUtil.toSystemIndependentName(c.getAbsolutePath())));
      }
      final Collection<DependencyContext.S> changedClasses=delta.getChangedClasses();
      for (      DependencyContext.S aClass : delta.myClassToClassDependency.keyCollection()) {
        final Collection<DependencyContext.S> now=delta.myClassToClassDependency.get(aClass);
        if (delta.isDifferentiated()) {
          final boolean classChanged=changedClasses.contains(aClass);
          final HashSet<DependencyContext.S> depClasses=new HashSet<DependencyContext.S>(now);
          depClasses.retainAll(changedClasses);
          if (!classChanged && depClasses.isEmpty()) {
            continue;
          }
        }
        final Collection<DependencyContext.S> past=myClassToClassDependency.get(aClass);
        if (past == null) {
          myClassToClassDependency.put(aClass,now);
        }
 else {
          boolean changed=past.removeAll(compiledSet);
          changed|=past.addAll(now);
          if (changed) {
            myClassToClassDependency.replace(aClass,past);
          }
        }
      }
    }
  finally {
      delta.close();
    }
  }
}
