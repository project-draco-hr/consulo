{
synchronized (myLock) {
    try {
      delta.runPostPasses();
      if (removed != null) {
        for (        String file : removed) {
          final int key=myContext.get(file);
          final Set<ClassRepr> classes=(Set<ClassRepr>)mySourceFileToClasses.get(key);
          final Collection<UsageRepr.Cluster> clusters=mySourceFileToUsages.get(key);
          if (classes != null) {
            for (            ClassRepr cr : classes) {
              myClassToSubclasses.remove(cr.name);
              myClassToSourceFile.remove(cr.name);
              myClassToClassDependency.remove(cr.name);
              for (              int superSomething : cr.getSupers()) {
                myClassToSubclasses.removeFrom(superSomething,cr.name);
              }
              if (clusters != null) {
                for (                UsageRepr.Cluster cluster : clusters) {
                  final Set<UsageRepr.Usage> usages=cluster.getUsages();
                  if (usages != null) {
                    for (                    UsageRepr.Usage u : usages) {
                      if (u instanceof UsageRepr.ClassUsage) {
                        final TIntHashSet residents=cluster.getResidence(u);
                        if (residents != null && residents.contains(cr.name)) {
                          myClassToClassDependency.removeFrom(((UsageRepr.ClassUsage)u).className,cr.name);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          mySourceFileToClasses.remove(key);
          mySourceFileToUsages.remove(key);
          mySourceFileToAnnotationUsages.remove(key);
        }
      }
      if (delta.isDifferentiated()) {
        delta.getChangedClasses().forEach(new TIntProcedure(){
          @Override public boolean execute(          int c){
            final TIntHashSet subClasses=delta.myClassToSubclasses.get(c);
            if (subClasses != null) {
              myClassToSubclasses.replace(c,subClasses);
            }
 else {
              myClassToSubclasses.remove(c);
            }
            final int sourceFile=delta.myClassToSourceFile.get(c);
            if (sourceFile > 0) {
              myClassToSourceFile.put(c,sourceFile);
            }
 else {
              myClassToSourceFile.remove(c);
            }
            return true;
          }
        }
);
        delta.getChangedFiles().forEach(new TIntProcedure(){
          @Override public boolean execute(          int f){
            final Collection<ClassRepr> classes=delta.mySourceFileToClasses.get(f);
            if (classes != null) {
              mySourceFileToClasses.replace(f,classes);
            }
 else {
              mySourceFileToClasses.remove(f);
            }
            final Collection<UsageRepr.Cluster> clusters=delta.mySourceFileToUsages.get(f);
            if (clusters != null) {
              mySourceFileToUsages.replace(f,clusters);
            }
 else {
              mySourceFileToUsages.remove(f);
            }
            final Collection<UsageRepr.Usage> usages=delta.mySourceFileToAnnotationUsages.get(f);
            if (usages != null) {
              mySourceFileToAnnotationUsages.replace(f,usages);
            }
 else {
              mySourceFileToAnnotationUsages.remove(f);
            }
            return true;
          }
        }
);
      }
 else {
        myClassToSubclasses.putAll(delta.myClassToSubclasses);
        myClassToSourceFile.putAll(delta.myClassToSourceFile);
        mySourceFileToClasses.replaceAll(delta.mySourceFileToClasses);
        mySourceFileToUsages.replaceAll(delta.mySourceFileToUsages);
        mySourceFileToAnnotationUsages.replaceAll(delta.mySourceFileToAnnotationUsages);
      }
      final int[] compiledClasses=getClassNames(compiled);
      final int[] changedClassesArray=delta.getChangedClasses().toArray();
      delta.myClassToClassDependency.forEachEntry(new TIntObjectProcedure<TIntHashSet>(){
        @Override public boolean execute(        int aClass,        TIntHashSet now){
          if (delta.isDifferentiated()) {
            final boolean classChanged=delta.getChangedClasses().contains(aClass);
            final TIntHashSet depClasses=new TIntHashSet(DEFAULT_SET_CAPACITY,DEFAULT_SET_LOAD_FACTOR);
            addAll(depClasses,now);
            depClasses.retainAll(changedClassesArray);
            if (!classChanged && depClasses.isEmpty()) {
              return true;
            }
          }
          final TIntHashSet past=myClassToClassDependency.get(aClass);
          if (past == null) {
            myClassToClassDependency.put(aClass,now);
          }
 else {
            boolean changed=past.removeAll(compiledClasses);
            changed|=addAll(past,now);
            if (changed) {
              myClassToClassDependency.replace(aClass,past);
            }
          }
          return true;
        }
      }
);
    }
  finally {
      delta.close();
    }
  }
}
