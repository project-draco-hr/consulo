{
synchronized (myLock) {
    try {
      assert(delta.isDifferentiated());
      final Collection<String> removed=delta.getRemovedFiles();
      delta.runPostPasses();
      final IntIntMultiMaplet dependenciesTrashBin=new IntIntTransientMultiMaplet();
      if (removed != null) {
        for (        final String file : removed) {
          final int fileName=myContext.get(file);
          final Set<ClassRepr> fileClasses=(Set<ClassRepr>)mySourceFileToClasses.get(fileName);
          if (fileClasses != null) {
            for (            final ClassRepr aClass : fileClasses) {
              cleanupRemovedClass(delta,aClass,mySourceFileToUsages.get(fileName),mySourceFileToAnnotationUsages.get(fileName),dependenciesTrashBin);
            }
          }
          mySourceFileToClasses.remove(fileName);
          mySourceFileToUsages.remove(fileName);
          mySourceFileToAnnotationUsages.remove(fileName);
        }
      }
      final TIntHashSet compiledClasses=new TIntHashSet();
      addAllKeys(compiledClasses,delta.myClassToSourceFile);
      if (!delta.isRebuild()) {
        for (        ClassRepr repr : delta.getDeletedClasses()) {
          cleanupRemovedClass(delta,repr,null,null,dependenciesTrashBin);
        }
        delta.getRemovedSuperClasses().forEachEntry(new TIntObjectProcedure<TIntHashSet>(){
          @Override public boolean execute(          final int a,          final TIntHashSet b){
            if (!compiledClasses.contains(a)) {
              final TIntHashSet old=myClassToSubclasses.get(a);
              if (old != null) {
                old.removeAll(b.toArray());
                myClassToSubclasses.replace(a,old);
              }
            }
            return true;
          }
        }
);
        delta.myClassToSubclasses.forEachEntry(new TIntObjectProcedure<TIntHashSet>(){
          @Override public boolean execute(          final int className,          final TIntHashSet newSubClasses){
            final TIntHashSet oldSubClasses=myClassToSubclasses.get(className);
            if (oldSubClasses != null) {
              oldSubClasses.forEach(new TIntProcedure(){
                @Override public boolean execute(                final int value){
                  if (!compiledClasses.contains(value)) {
                    newSubClasses.add(value);
                  }
                  return true;
                }
              }
);
            }
            if (newSubClasses.size() == 0) {
              myClassToSubclasses.remove(className);
            }
 else {
              myClassToSubclasses.replace(className,newSubClasses);
            }
            return true;
          }
        }
);
        compiledClasses.forEach(new TIntProcedure(){
          @Override public boolean execute(          final int className){
            final TIntHashSet s=delta.myClassToSubclasses.get(className);
            final int sourceFile=delta.myClassToSourceFile.get(className);
            if (sourceFile > 0) {
              myClassToSourceFile.put(className,sourceFile);
            }
 else {
              myClassToSourceFile.remove(className);
            }
            cleanupBackDependency(className,null,null,dependenciesTrashBin);
            return true;
          }
        }
);
        delta.getChangedFiles().forEach(new TIntProcedure(){
          @Override public boolean execute(          final int fileName){
            final Collection<ClassRepr> classes=delta.mySourceFileToClasses.get(fileName);
            if (classes != null) {
              mySourceFileToClasses.replace(fileName,classes);
            }
 else {
              mySourceFileToClasses.remove(fileName);
            }
            final Collection<UsageRepr.Cluster> clusters=delta.mySourceFileToUsages.get(fileName);
            if (clusters != null) {
              mySourceFileToUsages.replace(fileName,clusters);
            }
 else {
              mySourceFileToUsages.remove(fileName);
            }
            final Collection<UsageRepr.Usage> usages=delta.mySourceFileToAnnotationUsages.get(fileName);
            if (usages != null) {
              mySourceFileToAnnotationUsages.replace(fileName,usages);
            }
 else {
              mySourceFileToAnnotationUsages.remove(fileName);
            }
            return true;
          }
        }
);
      }
 else {
        myClassToSubclasses.putAll(delta.myClassToSubclasses);
        myClassToSourceFile.putAll(delta.myClassToSourceFile);
        mySourceFileToClasses.replaceAll(delta.mySourceFileToClasses);
        mySourceFileToUsages.replaceAll(delta.mySourceFileToUsages);
        mySourceFileToAnnotationUsages.replaceAll(delta.mySourceFileToAnnotationUsages);
      }
      final TIntHashSet affectedClasses=new TIntHashSet();
      addAllKeys(affectedClasses,dependenciesTrashBin);
      addAllKeys(affectedClasses,delta.myClassToClassDependency);
      affectedClasses.forEach(new TIntProcedure(){
        @Override public boolean execute(        int aClass){
          final TIntHashSet now=delta.myClassToClassDependency.get(aClass);
          final TIntHashSet toRemove=dependenciesTrashBin.get(aClass);
          final boolean hasDataToAdd=now != null && !now.isEmpty();
          if (toRemove != null && !toRemove.isEmpty()) {
            final TIntHashSet current=myClassToClassDependency.get(aClass);
            if (current != null && !current.isEmpty()) {
              final TIntHashSet before=new TIntHashSet();
              addAll(before,current);
              final boolean removed=current.removeAll(toRemove.toArray());
              final boolean added=hasDataToAdd && current.addAll(now.toArray());
              if ((removed && !added) || (!removed && added) || !before.equals(current)) {
                myClassToClassDependency.replace(aClass,current);
              }
            }
 else {
              if (hasDataToAdd) {
                myClassToClassDependency.put(aClass,now);
              }
            }
          }
 else {
            if (hasDataToAdd) {
              myClassToClassDependency.put(aClass,now);
            }
          }
          return true;
        }
      }
);
    }
  finally {
      delta.close();
    }
  }
}
