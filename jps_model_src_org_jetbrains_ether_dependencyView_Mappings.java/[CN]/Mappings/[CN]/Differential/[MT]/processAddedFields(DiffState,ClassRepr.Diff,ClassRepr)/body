{
  debug("Processing added fields");
  for (  final FieldRepr f : diff.fields().added()) {
    debug("Field: ",f.name);
    final boolean fPrivate=(f.access & Opcodes.ACC_PRIVATE) > 0;
    final boolean fProtected=(f.access & Opcodes.ACC_PROTECTED) > 0;
    final boolean fPublic=(f.access & Opcodes.ACC_PUBLIC) > 0;
    final boolean fPLocal=!fPrivate && !fProtected && !fPublic;
    if (!fPrivate) {
      final TIntHashSet subClasses=getAllSubclasses(classRepr.name);
      subClasses.forEach(new TIntProcedure(){
        @Override public boolean execute(        int subClass){
          final ClassRepr r=myFuture.reprByName(subClass);
          if (r != null) {
            final int sourceFileName=myClassToSourceFile.get(subClass);
            if (sourceFileName > 0) {
              if (r.isLocal()) {
                debug("Affecting local subclass (introduced field can potentially hide surrounding method parameters/local variables): ",sourceFileName);
                myAffectedFiles.add(new File(myContext.getValue(sourceFileName)));
              }
 else {
                final int outerClass=r.getOuterClassName();
                if (!isEmpty(outerClass) && myFuture.isFieldVisible(outerClass,f)) {
                  debug("Affecting inner subclass (introduced field can potentially hide surrounding class fields): ",sourceFileName);
                  myAffectedFiles.add(new File(myContext.getValue(sourceFileName)));
                }
              }
            }
          }
          debug("Affecting field usages referenced from subclass ",subClass);
          final TIntHashSet propagated=myFuture.propagateFieldAccess(f.name,subClass);
          myFuture.affectFieldUsages(f,propagated,f.createUsage(myContext,subClass),state.myAffectedUsages,state.myDependants);
          final TIntHashSet deps=myClassToClassDependency.get(subClass);
          if (deps != null) {
            addAll(state.myDependants,deps);
          }
          return true;
        }
      }
);
    }
    final Collection<Pair<FieldRepr,ClassRepr>> overriddenFields=new HashSet<Pair<FieldRepr,ClassRepr>>();
    myFuture.addOverriddenFields(f,classRepr,overriddenFields);
    for (    final Pair<FieldRepr,ClassRepr> p : overriddenFields) {
      final FieldRepr ff=p.first;
      final ClassRepr cc=p.second;
      final boolean ffPrivate=(ff.access & Opcodes.ACC_PRIVATE) > 0;
      final boolean ffProtected=(ff.access & Opcodes.ACC_PROTECTED) > 0;
      final boolean ffPublic=(ff.access & Opcodes.ACC_PUBLIC) > 0;
      final boolean ffPLocal=Difference.isPackageLocal(ff.access);
      if (!ffPrivate) {
        final TIntHashSet propagated=myPresent.propagateFieldAccess(ff.name,cc.name);
        final Set<UsageRepr.Usage> localUsages=new HashSet<UsageRepr.Usage>();
        debug("Affecting usages of overridden field in class ",cc.name);
        myFuture.affectFieldUsages(ff,propagated,ff.createUsage(myContext,cc.name),localUsages,state.myDependants);
        if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected)|| (fPLocal && ffPLocal)) {
        }
 else {
          Util.UsageConstraint constaint;
          if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {
            constaint=myFuture.new NegationConstraint(myFuture.new InheritanceConstraint(cc.name));
          }
 else           if (ffPublic && ffPLocal) {
            constaint=myFuture.new NegationConstraint(myFuture.new PackageConstraint(cc.getPackageName()));
          }
 else {
            constaint=myFuture.new IntersectionConstraint(myFuture.new NegationConstraint(myFuture.new InheritanceConstraint(cc.name)),myFuture.new NegationConstraint(myFuture.new PackageConstraint(cc.getPackageName())));
          }
          for (          final UsageRepr.Usage usage : localUsages) {
            state.myUsageConstraints.put(usage,constaint);
          }
        }
        state.myAffectedUsages.addAll(localUsages);
      }
    }
  }
  debug("End of added fields processing");
  return true;
}
