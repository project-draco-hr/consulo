{
  debug("Processing changed methods:");
  for (  final Pair<MethodRepr,Difference> mr : diff.methods().changed()) {
    final MethodRepr m=mr.first;
    final MethodRepr.Diff d=(MethodRepr.Diff)mr.second;
    final boolean throwsChanged=(d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);
    debug("Method: ",m.name);
    if (it.isAnnotation()) {
      if (d.defaultRemoved()) {
        debug("Class is annotation, default value is removed => adding annotation query");
        final TIntHashSet l=new TIntHashSet(DEFAULT_SET_CAPACITY,DEFAULT_SET_LOAD_FACTOR);
        l.add(m.name);
        state.myAnnotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr.createAnnotationUsage(myContext,TypeRepr.createClassType(myContext,it.name),l,null));
      }
    }
 else     if (d.base() != Difference.NONE || throwsChanged) {
      final TIntHashSet propagated=myUpdated.propagateMethodAccess(m.name,it.name);
      boolean affected=false;
      boolean constrained=false;
      final Set<UsageRepr.Usage> usages=new HashSet<UsageRepr.Usage>();
      if (d.packageLocalOn()) {
        debug("Method became package-local, affecting method usages outside the package");
        myUpdated.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,state.myDependants);
        for (        final UsageRepr.Usage usage : usages) {
          state.myUsageConstraints.put(usage,myUpdated.new InheritanceConstraint(it.name));
        }
        state.myAffectedUsages.addAll(usages);
        affected=true;
        constrained=true;
      }
      if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {
        if (!affected) {
          debug("Return type, throws list or signature changed --- affecting method usages");
          myUpdated.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,state.myDependants);
          state.myAffectedUsages.addAll(usages);
        }
      }
 else       if ((d.base() & Difference.ACCESS) > 0) {
        if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 || (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {
          if (!affected) {
            debug("Added static or private specifier or removed static specifier --- affecting method usages");
            myUpdated.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,state.myDependants);
            state.myAffectedUsages.addAll(usages);
          }
          if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {
            debug("Added static specifier --- affecting subclasses");
            myUpdated.affectSubclasses(it.name,myAffectedFiles,state.myAffectedUsages,state.myDependants,false);
          }
        }
 else {
          if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 || (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 || (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {
            debug("Added final, public or abstract specifier --- affecting subclasses");
            myUpdated.affectSubclasses(it.name,myAffectedFiles,state.myAffectedUsages,state.myDependants,false);
          }
          if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {
            if (!constrained) {
              debug("Added public or package-local method became protected --- affect method usages with protected constraint");
              if (!affected) {
                myUpdated.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),usages,state.myDependants);
                state.myAffectedUsages.addAll(usages);
              }
              for (              final UsageRepr.Usage usage : usages) {
                state.myUsageConstraints.put(usage,myUpdated.new InheritanceConstraint(it.name));
              }
            }
          }
        }
      }
    }
  }
  debug("End of changed methods processing");
}
