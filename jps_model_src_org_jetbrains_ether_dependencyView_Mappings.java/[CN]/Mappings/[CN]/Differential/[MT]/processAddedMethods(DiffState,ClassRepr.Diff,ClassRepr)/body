{
  debug("Processing added methods: ");
  if (it.isAnnotation()) {
    debug("Class is annotation, skipping method analysis");
    return;
  }
  final TIntHashSet affectedFiles=new TIntHashSet(DEFAULT_SET_CAPACITY,DEFAULT_SET_LOAD_FACTOR);
  Ref<ClassRepr> oldItRef=null;
  for (  final MethodRepr m : diff.methods().added()) {
    debug("Method: ",m.name);
    if ((it.access & Opcodes.ACC_INTERFACE) > 0 || (it.access & Opcodes.ACC_ABSTRACT) > 0 || (m.access & Opcodes.ACC_ABSTRACT) > 0) {
      debug("Class is abstract, or is interface, or added method in abstract => affecting all subclasses");
      myUpdated.affectSubclasses(it.name,myAffectedFiles,state.myAffectedUsages,state.myDependants,false);
    }
    TIntHashSet propagated=null;
    if ((m.access & Opcodes.ACC_PRIVATE) == 0 && m.name != myInitName) {
      if (oldItRef == null) {
        oldItRef=new Ref<ClassRepr>(getReprByName(it.name));
      }
      final ClassRepr oldIt=oldItRef.get();
      if (oldIt != null && myOriginal.hasOverriddenMethods(oldIt,MethodRepr.equalByJavaRules(m))) {
      }
 else {
        if (m.myArgumentTypes.length > 0) {
          propagated=myUpdated.propagateMethodAccess(m.name,it.name);
          debug("Conservative case on overriding methods, affecting method usages");
          myUpdated.affectMethodUsages(m,propagated,m.createMetaUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
    }
    if ((m.access & Opcodes.ACC_PRIVATE) == 0) {
      final Collection<Pair<MethodRepr,ClassRepr>> affectedMethods=myUpdated.findAllMethodsBySpecificity(m,it);
      final MethodRepr.Predicate overrides=MethodRepr.equalByJavaRules(m);
      if (propagated == null) {
        propagated=myUpdated.propagateMethodAccess(m.name,it.name);
      }
      final Collection<MethodRepr> lessSpecific=it.findMethods(myUpdated.lessSpecific(m));
      for (      final MethodRepr mm : lessSpecific) {
        if (!mm.equals(m)) {
          debug("Found less specific method, affecting method usages");
          myUpdated.affectMethodUsages(mm,propagated,mm.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
      debug("Processing affected by specificity methods");
      for (      final Pair<MethodRepr,ClassRepr> pair : affectedMethods) {
        final MethodRepr method=pair.first;
        final ClassRepr methodClass=pair.second;
        if (methodClass == MOCK_CLASS) {
          continue;
        }
        final Boolean inheritorOf=myOriginal.isInheritorOf(methodClass.name,it.name);
        final boolean isInheritor=inheritorOf != null && inheritorOf;
        debug("Method: ",method.name);
        debug("Class : ",methodClass.name);
        if (overrides.satisfy(method) && isInheritor) {
          debug("Current method overrides that found");
          final int file=myClassToSourceFile.get(methodClass.name);
          if (file > 0) {
            affectedFiles.add(file);
            debug("Affecting file ",file);
          }
        }
 else {
          debug("Current method does not override that found");
          final TIntHashSet yetPropagated=myOriginal.propagateMethodAccess(method.name,it.name);
          if (isInheritor) {
            final TIntHashSet deps=myClassToClassDependency.get(methodClass.name);
            if (deps != null) {
              addAll(state.myDependants,deps);
            }
            myUpdated.affectMethodUsages(method,yetPropagated,method.createUsage(myContext,methodClass.name),state.myAffectedUsages,state.myDependants);
          }
          debug("Affecting method usages for that found");
          myUpdated.affectMethodUsages(method,yetPropagated,method.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
        }
      }
      final TIntHashSet subClasses=getAllSubclasses(it.name);
      if (subClasses != null) {
        subClasses.forEach(new TIntProcedure(){
          @Override public boolean execute(          int subClass){
            final ClassRepr r=myUpdated.reprByName(subClass);
            if (r != null) {
              final int sourceFileName=myClassToSourceFile.get(subClass);
              if (sourceFileName > 0) {
                final int outerClass=r.getOuterClassName();
                if (myUpdated.isMethodVisible(outerClass,m)) {
                  affectedFiles.add(sourceFileName);
                  debug("Affecting file due to local overriding: ",sourceFileName);
                }
              }
            }
            return true;
          }
        }
);
      }
    }
  }
  affectedFiles.forEach(new TIntProcedure(){
    @Override public boolean execute(    int file){
      myAffectedFiles.add(new File(myContext.getValue(file)));
      return true;
    }
  }
);
  debug("End of added methods processing");
}
