{
  debug("Processing removed methods:");
  final TIntHashSet affectedFiles=new TIntHashSet(DEFAULT_SET_CAPACITY,DEFAULT_SET_LOAD_FACTOR);
  for (  final MethodRepr m : diff.methods().removed()) {
    debug("Method ",m.name);
    final Collection<Pair<MethodRepr,ClassRepr>> overridenMethods=myFuture.findOverriddenMethods(m,it);
    final TIntHashSet propagated=myFuture.propagateMethodAccess(m.name,it.name);
    if (overridenMethods.size() == 0) {
      debug("No overridden methods found, affecting method usages");
      myFuture.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
    }
 else {
      boolean clear=true;
      loop:       for (      final Pair<MethodRepr,ClassRepr> overriden : overridenMethods) {
        final MethodRepr mm=overriden.first;
        if (mm == MOCK_METHOD || !mm.myType.equals(m.myType) || !isEmpty(mm.signature) || !isEmpty(m.signature)) {
          clear=false;
          break loop;
        }
      }
      if (!clear) {
        debug("No clearly overridden methods found, affecting method usages");
        myFuture.affectMethodUsages(m,propagated,m.createUsage(myContext,it.name),state.myAffectedUsages,state.myDependants);
      }
    }
    final Collection<Pair<MethodRepr,ClassRepr>> overridingMethods=new HashSet<Pair<MethodRepr,ClassRepr>>();
    myFuture.addOverridingMethods(m,it,MethodRepr.equalByJavaRules(m),overridingMethods);
    for (    final Pair<MethodRepr,ClassRepr> p : overridingMethods) {
      final int fName=myClassToSourceFile.get(p.second.name);
      affectedFiles.add(fName);
      debug("Affecting file by overriding: ",fName);
    }
    if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {
      propagated.forEach(new TIntProcedure(){
        @Override public boolean execute(        int p){
          if (p != it.name) {
            final ClassRepr s=myFuture.reprByName(p);
            if (s != null) {
              final Collection<Pair<MethodRepr,ClassRepr>> overridenInS=myFuture.findOverriddenMethods(m,s);
              overridenInS.addAll(overridenMethods);
              boolean allAbstract=true;
              boolean visited=false;
              for (              final Pair<MethodRepr,ClassRepr> pp : overridenInS) {
                final ClassRepr cc=pp.second;
                if (cc == MOCK_CLASS) {
                  visited=true;
                  continue;
                }
                if (cc.name == it.name) {
                  continue;
                }
                visited=true;
                allAbstract=((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);
                if (!allAbstract) {
                  break;
                }
              }
              if (allAbstract && visited) {
                final int source=myClassToSourceFile.get(p);
                if (source > 0) {
                  affectedFiles.add(source);
                  debug("Removed method is not abstract & overrides some abstract method which is not then over-overriden in subclass ",p);
                  debug("Affecting subclass source file ",source);
                }
              }
            }
          }
          return true;
        }
      }
);
    }
  }
  affectedFiles.forEach(new TIntProcedure(){
    @Override public boolean execute(    int file){
      final String f=myContext.getValue(file);
      myAffectedFiles.add(new File(f));
      return true;
    }
  }
);
  debug("End of removed methods processing");
}
