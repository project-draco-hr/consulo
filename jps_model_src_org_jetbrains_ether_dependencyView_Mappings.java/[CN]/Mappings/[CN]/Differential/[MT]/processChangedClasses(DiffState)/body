{
  debug("Processing changed classes:");
  for (  final Pair<ClassRepr,Difference> changed : state.myClassDiff.changed()) {
    final ClassRepr it=changed.first;
    final ClassRepr.Diff diff=(ClassRepr.Diff)changed.second;
    myDelta.addChangedClass(it.name);
    debug("Changed: ",it.name);
    final int addedModifiers=diff.addedModifiers();
    final boolean superClassChanged=(diff.base() & Difference.SUPERCLASS) > 0;
    final boolean interfacesChanged=!diff.interfaces().unchanged();
    final boolean signatureChanged=(diff.base() & Difference.SIGNATURE) > 0;
    if (superClassChanged) {
      myDelta.registerRemovedSuperClass(it.name,((TypeRepr.ClassType)it.getSuperClass()).myClassName);
      final ClassRepr newClass=myDelta.getReprByName(it.name);
      assert(newClass != null);
      myDelta.registerAddedSuperClass(it.name,((TypeRepr.ClassType)newClass.getSuperClass()).myClassName);
    }
    if (interfacesChanged) {
      for (      final TypeRepr.AbstractType typ : diff.interfaces().removed()) {
        myDelta.registerRemovedSuperClass(it.name,((TypeRepr.ClassType)typ).myClassName);
      }
      for (      final TypeRepr.AbstractType typ : diff.interfaces().added()) {
        myDelta.registerAddedSuperClass(it.name,((TypeRepr.ClassType)typ).myClassName);
      }
    }
    if (myEasyMode) {
      continue;
    }
    myPresent.appendDependents(it,state.myDependants);
    if (superClassChanged || interfacesChanged || signatureChanged) {
      debug("Superclass changed: ",superClassChanged);
      debug("Interfaces changed: ",interfacesChanged);
      debug("Signature changed ",signatureChanged);
      final boolean extendsChanged=superClassChanged && !diff.extendsAdded();
      final boolean interfacesRemoved=interfacesChanged && !diff.interfaces().removed().isEmpty();
      debug("Extends changed: ",extendsChanged);
      debug("Interfaces removed: ",interfacesRemoved);
      myFuture.affectSubclasses(it.name,myAffectedFiles,state.myAffectedUsages,state.myDependants,extendsChanged || interfacesRemoved || signatureChanged);
    }
    if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {
      debug("Class-to-interface or interface-to-class conversion detected, added class usage to affected usages");
      state.myAffectedUsages.add(it.createUsage());
    }
    if (it.isAnnotation() && it.getRetentionPolicy() == RetentionPolicy.SOURCE) {
      debug("Annotation, retention policy = SOURCE => a switch to non-incremental mode requested");
      if (!incrementalDecision(it.getOuterClassName(),it,myAffectedFiles,myFilter)) {
        debug("End of Differentiate, returning false");
        return false;
      }
    }
    if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {
      debug("Introduction of 'protected' modifier detected, adding class usage + inheritance constraint to affected usages");
      final UsageRepr.Usage usage=it.createUsage();
      state.myAffectedUsages.add(usage);
      state.myUsageConstraints.put(usage,myFuture.new InheritanceConstraint(it.name));
    }
    if (diff.packageLocalOn()) {
      debug("Introduction of 'package local' access detected, adding class usage + package constraint to affected usages");
      final UsageRepr.Usage usage=it.createUsage();
      state.myAffectedUsages.add(usage);
      state.myUsageConstraints.put(usage,myFuture.new PackageConstraint(it.getPackageName()));
    }
    if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {
      debug("Introduction of 'private' or 'final' modifier(s) detected, adding class usage to affected usages");
      state.myAffectedUsages.add(it.createUsage());
    }
    if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0 || (addedModifiers & Opcodes.ACC_STATIC) > 0) {
      debug("Introduction of 'abstract' or 'static' modifier(s) detected, adding class new usage to affected usages");
      state.myAffectedUsages.add(UsageRepr.createClassNewUsage(myContext,it.name));
    }
    if (it.isAnnotation()) {
      debug("Class is annotation, performing annotation-specific analysis");
      if (diff.retentionChanged()) {
        debug("Retention policy change detected, adding class usage to affected usages");
        state.myAffectedUsages.add(it.createUsage());
      }
 else {
        final Collection<ElemType> removedtargets=diff.targets().removed();
        if (removedtargets.contains(ElemType.LOCAL_VARIABLE)) {
          debug("Removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested");
          if (!incrementalDecision(it.getOuterClassName(),it,myAffectedFiles,myFilter)) {
            debug("End of Differentiate, returning false");
            return false;
          }
        }
        if (!removedtargets.isEmpty()) {
          debug("Removed some annotation targets, adding annotation query");
          final UsageRepr.AnnotationUsage annotationUsage=(UsageRepr.AnnotationUsage)UsageRepr.createAnnotationUsage(myContext,TypeRepr.createClassType(myContext,it.name),null,EnumSet.copyOf(removedtargets));
          state.myAnnotationQuery.add(annotationUsage);
        }
        for (        final MethodRepr m : diff.methods().added()) {
          if (!m.hasValue()) {
            debug("Added method with no default value: ",m.name);
            debug("Adding class usage to affected usages");
            state.myAffectedUsages.add(it.createUsage());
          }
        }
      }
      debug("End of annotation-specific analysis");
    }
    processAddedMethods(state,diff,it);
    processRemovedMethods(state,diff,it);
    processChangedMethods(state,diff,it);
    if (!processAddedFields(state,diff,it)) {
      return false;
    }
    if (!processRemovedFields(state,diff,it)) {
      return false;
    }
    if (!processChangedFields(state,diff,it)) {
      return false;
    }
  }
  debug("End of changed classes processing");
  return !myEasyMode;
}
