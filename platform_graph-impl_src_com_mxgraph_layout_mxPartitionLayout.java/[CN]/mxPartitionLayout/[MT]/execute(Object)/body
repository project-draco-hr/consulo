{
  mxIGraphModel model=graph.getModel();
  mxGeometry pgeo=model.getGeometry(parent);
  if (pgeo == null && model.getParent(parent) == model.getRoot() || parent == graph.getView().getCurrentRoot()) {
    mxRectangle tmp=getContainerSize();
    pgeo=new mxGeometry(0,0,tmp.getWidth(),tmp.getHeight());
  }
  if (pgeo != null) {
    int childCount=model.getChildCount(parent);
    List<Object> children=new ArrayList<Object>(childCount);
    for (int i=0; i < childCount; i++) {
      Object child=model.getChildAt(parent,i);
      if (!isVertexIgnored(child) && isVertexMovable(child)) {
        children.add(child);
      }
    }
    int n=children.size();
    if (n > 0) {
      double x0=border;
      double y0=border;
      double other=(horizontal) ? pgeo.getHeight() : pgeo.getWidth();
      other-=2 * border;
      mxRectangle size=graph.getStartSize(parent);
      other-=(horizontal) ? size.getHeight() : size.getWidth();
      x0=x0 + size.getWidth();
      y0=y0 + size.getHeight();
      double tmp=border + (n - 1) * spacing;
      double value=(horizontal) ? ((pgeo.getWidth() - x0 - tmp) / n) : ((pgeo.getHeight() - y0 - tmp) / n);
      if (value > 0) {
        model.beginUpdate();
        try {
          for (int i=0; i < n; i++) {
            Object child=children.get(i);
            mxGeometry geo=model.getGeometry(child);
            if (geo != null) {
              geo=(mxGeometry)geo.clone();
              geo.setX(x0);
              geo.setY(y0);
              if (horizontal) {
                if (resizeVertices) {
                  geo.setWidth(value);
                  geo.setHeight(other);
                }
                x0+=value + spacing;
              }
 else {
                if (resizeVertices) {
                  geo.setHeight(value);
                  geo.setWidth(other);
                }
                y0+=value + spacing;
              }
              model.setGeometry(child,geo);
            }
          }
        }
  finally {
          model.endUpdate();
        }
      }
    }
  }
}
