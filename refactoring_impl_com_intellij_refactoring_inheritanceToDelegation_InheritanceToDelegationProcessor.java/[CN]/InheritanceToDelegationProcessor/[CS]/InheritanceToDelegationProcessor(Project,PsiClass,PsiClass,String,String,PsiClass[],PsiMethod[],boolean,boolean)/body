{
  super(project);
  myClass=aClass;
  myInnerClassName=innerClassName;
  myIsDelegateOtherMembers=delegateOtherMembers;
  myManager=myClass.getManager();
  myFactory=myManager.getElementFactory();
  myBaseClass=targetBaseClass;
  LOG.assertTrue(myBaseClass != null && (myBaseClass.getQualifiedName() == null || !myBaseClass.getQualifiedName().equals("java.lang.Object")));
  myBaseClassMembers=getAllBaseClassMembers();
  myBaseClassBases=getAllBases();
  myBaseClassType=myFactory.createType(myBaseClass,getSuperSubstitutor(myBaseClass));
  myIsInnerClassNeeded=InheritanceToDelegationUtil.isInnerClassNeeded(myClass,myBaseClass);
  myFieldName=fieldName;
  final String propertyName=CodeStyleManager.getInstance(myProject).variableNameToPropertyName(myFieldName,VariableKind.FIELD);
  myGetterName=PropertyUtil.suggestGetterName(propertyName,myBaseClassType);
  myGenerateGetter=generateGetter;
  myDelegatedInterfaces=new LinkedHashSet<PsiClass>();
  addAll(myDelegatedInterfaces,delegatedInterfaces);
  myDelegatedMethods=new LinkedHashSet<PsiMethod>();
  addAll(myDelegatedMethods,delegatedMethods);
  myDelegatedMethodsVisibility=new HashMap<PsiMethod,String>();
  for (  PsiMethod method : myDelegatedMethods) {
    MethodSignature signature=method.getSignature(getSuperSubstitutor(method.getContainingClass()));
    PsiMethod overridingMethod=MethodSignatureUtil.findMethodBySignature(myClass,signature,false);
    if (overridingMethod != null) {
      myDelegatedMethodsVisibility.put(method,VisibilityUtil.getVisibilityModifier(overridingMethod.getModifierList()));
    }
  }
  myOverriddenMethods=getOverriddenMethods();
}
