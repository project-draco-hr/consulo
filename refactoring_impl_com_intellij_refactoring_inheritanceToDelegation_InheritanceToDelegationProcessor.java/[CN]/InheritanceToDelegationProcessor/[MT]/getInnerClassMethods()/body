{
  ArrayList<InnerClassMethod> result=new ArrayList<InnerClassMethod>();
  if (!myBaseClass.isInterface()) {
    PsiMethod[] constructors=myClass.getConstructors();
    for (    PsiMethod constructor : constructors) {
      final PsiStatement[] statements=constructor.getBody().getStatements();
      if (statements.length > 0 && RefactoringUtil.isSuperOrThisCall(statements[0],true,false)) {
        final PsiMethodCallExpression superConstructorCall=(PsiMethodCallExpression)((PsiExpressionStatement)statements[0]).getExpression();
        PsiElement superConstructor=superConstructorCall.getMethodExpression().resolve();
        if (superConstructor instanceof PsiMethod && ((PsiMethod)superConstructor).isConstructor()) {
          result.add(new InnerClassConstructor((PsiMethod)superConstructor));
        }
      }
    }
  }
{
class InnerClassOverridingMethod extends InnerClassMethod {
      public InnerClassOverridingMethod(      PsiMethod method){
        super(method);
      }
      public void createMethod(      PsiClass innerClass) throws IncorrectOperationException {
        OverridenMethodClassMemberReferencesVisitor visitor=new OverridenMethodClassMemberReferencesVisitor();
        myMethod.accept(visitor);
        final List<PsiAction> actions=visitor.getPsiActions();
        for (        PsiAction action : actions) {
          action.run();
        }
        innerClass.add(myMethod);
        myMethod.delete();
      }
    }
    for (    PsiMethod method : myOverridenMethods) {
      result.add(new InnerClassOverridingMethod(method));
    }
  }
{
class InnerClassAbstractMethod extends InnerClassMethod {
      public InnerClassAbstractMethod(      PsiMethod method){
        super(method);
        LOG.assertTrue(method.hasModifierProperty(PsiModifier.ABSTRACT));
      }
      public void createMethod(      PsiClass innerClass) throws IncorrectOperationException {
        PsiSubstitutor substitutor=getSuperSubstitutor(myMethod.getContainingClass());
        PsiMethod method=delegateMethod(myClass.getName() + ".this",myMethod,substitutor);
        final PsiClass containingClass=myMethod.getContainingClass();
        if (myBaseClass.isInterface() || containingClass.isInterface()) {
          method.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true);
        }
        innerClass.add(method);
        final MethodSignature signature=myMethod.getSignature(substitutor);
        PsiMethod outerMethod=MethodSignatureUtil.findMethodBySignature(myClass,signature,false);
        if (outerMethod == null) {
          final String visibility=checkOuterClassAbstractMethod(signature);
          PsiMethod newOuterMethod=(PsiMethod)myClass.add(myMethod);
          newOuterMethod.getModifierList().setModifierProperty(visibility,true);
          if (newOuterMethod.getDocComment() != null) {
            newOuterMethod.getDocComment().delete();
          }
        }
      }
    }
    PsiMethod[] methods=myBaseClass.getAllMethods();
    for (    PsiMethod method : methods) {
      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {
        final MethodSignature signature=method.getSignature(getSuperSubstitutor(method.getContainingClass()));
        PsiMethod classMethod=MethodSignatureUtil.findMethodBySignature(myClass,signature,true);
        if (classMethod == null || classMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
          result.add(new InnerClassAbstractMethod(method));
        }
      }
    }
  }
  return result;
}
