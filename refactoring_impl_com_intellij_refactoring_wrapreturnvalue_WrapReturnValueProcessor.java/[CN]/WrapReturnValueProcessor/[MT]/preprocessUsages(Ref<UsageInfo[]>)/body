{
  List<String> conflicts=new ArrayList<String>();
  final PsiClass existingClass=JavaPsiFacade.getInstance(myProject).findClass(myQualifiedName);
  if (myUseExistingClass) {
    if (existingClass == null) {
      conflicts.add(RefactorJBundle.message("could.not.find.selected.wrapping.class"));
    }
 else {
      boolean foundConstructor=false;
      final PsiMethod[] constructors=existingClass.getConstructors();
      for (      PsiMethod constructor : constructors) {
        final PsiParameter[] parameters=constructor.getParameterList().getParameters();
        if (parameters.length == 1) {
          final PsiParameter parameter=parameters[0];
          final PsiType parameterType=parameter.getType();
          if (TypeConversionUtil.isAssignable(method.getReturnType(),parameterType)) {
            foundConstructor=true;
            break;
          }
        }
      }
      if (!foundConstructor) {
        conflicts.add("Existing class does not have appropriate constructor");
      }
    }
    if (unwrapMethodName.length() == 0) {
      conflicts.add("Existing class does not have getter for selected field");
    }
  }
 else {
    if (existingClass != null) {
      conflicts.add(RefactorJBundle.message("there.already.exists.a.class.with.the.selected.name"));
    }
  }
  return showConflicts(conflicts);
}
