{
  final List<VirtualFile> basicVfRoots=ObjectsConvertor.convert(myTopRoots,new Convertor<RootUrlInfo,VirtualFile>(){
    public VirtualFile convert(    final RootUrlInfo real){
      return real.getVirtualFile();
    }
  }
);
  final ChangeListManager clManager=ChangeListManager.getInstance(myVcs.getProject());
  if (clearState) {
    myGate.get();
  }
  clManager.invokeAfterUpdate(new Runnable(){
    public void run(){
      final List<RootUrlInfo> nestedRoots=new ArrayList<RootUrlInfo>();
      final NestedCopiesData data=myGate.get();
      for (      NestedCopiesBuilder.MyPointInfo info : data.getSet()) {
        if (NestedCopyType.external.equals(info.getType()) || NestedCopyType.switched.equals(info.getType())) {
          final File infoFile=new File(info.getFile().getPath());
          boolean copyFound=false;
          for (          RootUrlInfo topRoot : myTopRoots) {
            if (topRoot.getIoFile().equals(infoFile)) {
              topRoot.setType(info.getType());
              copyFound=true;
              break;
            }
          }
          if (copyFound) {
            continue;
          }
          try {
            final SVNStatus svnStatus=SvnUtil.getStatus(myVcs,infoFile);
            if (svnStatus.getURL() == null)             continue;
            info.setUrl(svnStatus.getURL());
            info.setFormat(WorkingCopyFormat.getInstance(svnStatus.getWorkingCopyFormat()));
          }
 catch (          Exception e) {
            continue;
          }
        }
        for (        RootUrlInfo topRoot : myTopRoots) {
          if (VfsUtil.isAncestor(topRoot.getVirtualFile(),info.getFile(),true)) {
            final RepoInfo repoRoot=myRepositoryRoots.ask(info.getUrl());
            if (repoRoot != null) {
              final RootUrlInfo rootInfo=new RootUrlInfo(repoRoot.getUrl(),info.getUrl(),info.getFormat(),info.getFile(),topRoot.getRoot(),repoRoot.isRepoSupportsMergeinfo());
              rootInfo.setType(info.getType());
              nestedRoots.add(rootInfo);
            }
            break;
          }
        }
      }
      myTopRoots.addAll(nestedRoots);
      myApplier.apply(myVcs,myAtomicSectionsAware,myTopRoots,myLonelyRoots);
    }
  }
,InvokeAfterUpdateMode.SILENT_CALLBACK_POOLED,null,new Consumer<VcsDirtyScopeManager>(){
    public void consume(    VcsDirtyScopeManager vcsDirtyScopeManager){
      if (clearState) {
        vcsDirtyScopeManager.filesDirty(null,basicVfRoots);
      }
    }
  }
,null);
}
