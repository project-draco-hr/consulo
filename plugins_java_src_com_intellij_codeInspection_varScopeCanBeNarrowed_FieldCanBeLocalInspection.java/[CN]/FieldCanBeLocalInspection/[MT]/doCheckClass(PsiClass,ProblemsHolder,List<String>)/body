{
  if (aClass.isInterface())   return;
  final PsiField[] fields=aClass.getFields();
  final Set<PsiField> candidates=new LinkedHashSet<PsiField>();
  for (  PsiField field : fields) {
    if (AnnotationUtil.isAnnotated(field,excludeAnnos)) {
      continue;
    }
    if (field.hasModifierProperty(PsiModifier.PRIVATE) && !(field.hasModifierProperty(PsiModifier.STATIC) && field.hasModifierProperty(PsiModifier.FINAL))) {
      candidates.add(field);
    }
  }
  removeFieldsReferencedFromInitializers(aClass,candidates);
  if (candidates.isEmpty())   return;
  final Set<PsiField> usedFields=new THashSet<PsiField>();
  removeReadFields(aClass,candidates,usedFields);
  if (candidates.isEmpty())   return;
  final ImplicitUsageProvider[] implicitUsageProviders=Extensions.getExtensions(ImplicitUsageProvider.EP_NAME);
  for (  PsiField field : candidates) {
    if (usedFields.contains(field) && !hasImplicitReadOrWriteUsage(field,implicitUsageProviders)) {
      final String message=InspectionsBundle.message("inspection.field.can.be.local.problem.descriptor");
      holder.registerProblem(field.getNameIdentifier(),message,new ConvertFieldToLocalQuickFix());
    }
  }
}
