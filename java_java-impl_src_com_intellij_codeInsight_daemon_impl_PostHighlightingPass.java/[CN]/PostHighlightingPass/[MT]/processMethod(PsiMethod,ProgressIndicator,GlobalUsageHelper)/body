{
  boolean isPrivate=method.hasModifierProperty(PsiModifier.PRIVATE);
  PsiClass containingClass=method.getContainingClass();
  if (isMethodReferenced(method,progress,isPrivate,containingClass,helper))   return null;
  HighlightInfoType highlightInfoType;
  HighlightDisplayKey highlightDisplayKey;
  String key;
  if (isPrivate) {
    highlightInfoType=HighlightInfoType.UNUSED_SYMBOL;
    highlightDisplayKey=myUnusedSymbolKey;
    key=method.isConstructor() ? "private.constructor.is.not.used" : "private.method.is.not.used";
  }
 else {
    highlightInfoType=myDeadCodeInfoType;
    highlightDisplayKey=myDeadCodeKey;
    key=method.isConstructor() ? "constructor.is.not.used" : "method.is.not.used";
  }
  String symbolName=HighlightMessageUtil.getSymbolName(method,PsiSubstitutor.EMPTY);
  String message=JavaErrorMessages.message(key,symbolName);
  PsiIdentifier identifier=method.getNameIdentifier();
  final HighlightInfo highlightInfo=createUnusedSymbolInfo(identifier,message,highlightInfoType);
  QuickFixAction.registerQuickFixAction(highlightInfo,new SafeDeleteFix(method),highlightDisplayKey);
  SpecialAnnotationsUtil.createAddToSpecialAnnotationFixes(method,new Processor<String>(){
    @Override public boolean process(    final String annoName){
      QuickFixAction.registerQuickFixAction(highlightInfo,UnusedSymbolLocalInspection.createQuickFix(annoName,"methods",method.getProject()));
      return true;
    }
  }
);
  if (method.getReturnType() != null || containingClass != null && Comparing.strEqual(containingClass.getName(),method.getName())) {
    ChangeSignatureGestureDetector.getInstance(myProject).dismissForElement(method);
  }
  return highlightInfo;
}
