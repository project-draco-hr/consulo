{
  if (myRefCountHolder.isReferenced(method))   return null;
  boolean isPrivate=method.hasModifierProperty(PsiModifier.PRIVATE);
  PsiClass containingClass=method.getContainingClass();
  HighlightInfoType highlightInfoType=HighlightInfoType.UNUSED_SYMBOL;
  HighlightDisplayKey highlightDisplayKey=myUnusedSymbolKey;
  if (isPrivate) {
    if (HighlightMethodUtil.isSerializationRelatedMethod(method,containingClass) || isIntentionalPrivateConstructor(method,containingClass)) {
      return null;
    }
    if (isImplicitUsage(method,progress)) {
      return null;
    }
  }
 else {
    if (containingClass != null && method.isConstructor() && containingClass.getConstructors().length == 1 && isClassUnused(containingClass,progress) == USED) {
      return null;
    }
    if (isImplicitUsage(method,progress))     return null;
    if (method.findSuperMethods().length != 0) {
      return null;
    }
    if (!weAreSureThereAreNoUsages(method,progress)) {
      return null;
    }
    highlightInfoType=myDeadCodeInfoType;
    highlightDisplayKey=myDeadCodeKey;
  }
  String key=isPrivate ? method.isConstructor() ? "private.constructor.is.not.used" : "private.method.is.not.used" : method.isConstructor() ? "constructor.is.not.used" : "method.is.not.used";
  String symbolName=HighlightMessageUtil.getSymbolName(method,PsiSubstitutor.EMPTY);
  String message=JavaErrorMessages.message(key,symbolName);
  PsiIdentifier identifier=method.getNameIdentifier();
  final HighlightInfo highlightInfo=createUnusedSymbolInfo(identifier,message,highlightInfoType);
  QuickFixAction.registerQuickFixAction(highlightInfo,new SafeDeleteFix(method),highlightDisplayKey);
  SpecialAnnotationsUtil.createAddToSpecialAnnotationFixes(method,new Processor<String>(){
    public boolean process(    final String annoName){
      QuickFixAction.registerQuickFixAction(highlightInfo,myUnusedSymbolInspection.createQuickFix(annoName,"methods"));
      return true;
    }
  }
);
  return highlightInfo;
}
