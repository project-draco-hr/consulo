{
  Set<PsiMethod> alreadyImplemented=new THashSet<PsiMethod>();
  for (  HierarchicalMethodSignature signatureHierarchical : aClass.getVisibleSignatures()) {
    for (    PsiMethod superS : signatureHierarchical.getMethod().findSuperMethods()) {
      add(superS,alreadyImplemented);
    }
  }
  PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(aClass.getProject()).getResolveHelper();
  for (  HierarchicalMethodSignature signatureHierarchical : aClass.getVisibleSignatures()) {
    PsiMethod method=signatureHierarchical.getMethod();
    PsiClass containingClass=method.getContainingClass();
    if (containingClass == null) {
      continue;
    }
    if (!aClass.equals(containingClass) && method.hasModifierProperty(PsiModifier.ABSTRACT) && !method.hasModifierProperty(PsiModifier.STATIC)&& !method.hasModifierProperty(PsiModifier.PRIVATE)&& !alreadyImplemented.contains(method)) {
      return method;
    }
    final List<HierarchicalMethodSignature> superSignatures=signatureHierarchical.getSuperSignatures();
    for (    HierarchicalMethodSignature superSignatureHierarchical : superSignatures) {
      final PsiMethod superMethod=superSignatureHierarchical.getMethod();
      if (superMethod.hasModifierProperty(PsiModifier.ABSTRACT) && !resolveHelper.isAccessible(superMethod,method,null)) {
        return superMethod;
      }
    }
  }
  return checkPackageLocalInSuperClass(aClass);
}
