{
  int conflictsCount=conflicts.size();
  if (conflictsCount <= 0)   return null;
  if (conflictsCount == 1)   return conflicts.get(0);
  int maxCheckLevel=-1;
  int[] checkLevels=new int[conflictsCount];
  int index=0;
  for (  final CandidateInfo conflict : conflicts) {
    final MethodCandidateInfo method=(MethodCandidateInfo)conflict;
    final int level=getCheckLevel(method);
    checkLevels[index++]=level;
    maxCheckLevel=Math.max(maxCheckLevel,level);
  }
  for (int i=conflictsCount - 1; i >= 0; i--) {
    if (checkLevels[i] < maxCheckLevel) {
      conflicts.remove(i);
    }
  }
  conflictsCount=conflicts.size();
  if (conflictsCount == 1)   return conflicts.get(0);
  checkParametersNumber(conflicts,myArgumentsList.getExpressions().length);
  conflictsCount=conflicts.size();
  if (conflictsCount == 1)   return conflicts.get(0);
  final int applicabilityLevel=checkApplicability(conflicts);
  final boolean applicable=applicabilityLevel > MethodCandidateInfo.ApplicabilityLevel.NOT_APPLICABLE;
  conflictsCount=conflicts.size();
  if (conflictsCount == 1)   return conflicts.get(0);
  CandidateInfo[] conflictsArray=conflicts.toArray(new CandidateInfo[conflictsCount]);
  outer:   for (int i=0; i < conflictsCount; i++) {
    final CandidateInfo method=conflictsArray[i];
    for (    final CandidateInfo info : conflicts) {
      if (info == method)       break;
      if (checkOverriding(method,info)) {
        conflicts.remove(method);
        continue outer;
      }
    }
  }
  conflictsCount=conflicts.size();
  if (conflictsCount == 1)   return conflicts.get(0);
  if (applicable) {
    final CandidateInfo[] newConflictsArray=conflicts.toArray(new CandidateInfo[conflicts.size()]);
    for (int i=0; i < conflictsCount; i++) {
      final CandidateInfo method=newConflictsArray[i];
      for (int j=0; j < i; j++) {
        final CandidateInfo conflict=newConflictsArray[j];
        if (conflict == method)         break;
switch (isMoreSpecific(method,conflict,applicabilityLevel)) {
case TRUE:
          conflicts.remove(conflict);
        break;
case FALSE:
      conflicts.remove(method);
    continue;
case CONFLICT:
  break;
}
}
}
}
if (conflicts.size() == 1) {
return conflicts.get(0);
}
return null;
}
