{
  if (!checkBases) {
    CachedValue<Map<String,List<PsiMethod>>> cache=myMethodsMapCache;
    if (cache == null) {
      final CachedValuesManager manager=CachedValuesManager.getManager(myClass.getProject());
      final Object[] dependencies={PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT,myTreeChangeTracker};
      myMethodsMapCache=cache=manager.createCachedValue(new CachedValueProvider<Map<String,List<PsiMethod>>>(){
        @Override public Result<Map<String,List<PsiMethod>>> compute(){
          return Result.create(getMethodsMap(),dependencies);
        }
      }
,false);
    }
    final Map<String,List<PsiMethod>> cachedMethods=cache.getValue();
    if (cachedMethods != null) {
      final List<PsiMethod> methods=cachedMethods.get(name);
      if (methods != null && !methods.isEmpty()) {
        return methods.toArray(new PsiMethod[methods.size()]);
      }
    }
    return PsiMethod.EMPTY_ARRAY;
  }
  return PsiClassImplUtil.findMethodsByName(myClass,name,checkBases);
}
