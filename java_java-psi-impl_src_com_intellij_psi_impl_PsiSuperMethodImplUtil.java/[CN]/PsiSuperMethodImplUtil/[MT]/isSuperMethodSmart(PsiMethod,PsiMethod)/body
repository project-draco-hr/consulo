{
  if (method == superMethod)   return false;
  PsiClass aClass=method.getContainingClass();
  PsiClass superClass=superMethod.getContainingClass();
  if (aClass == null || superClass == null || superClass == aClass)   return false;
  if (!canHaveSuperMethod(method,true,false))   return false;
  PsiMethod[] superMethods=null;
  Map<MethodSignature,HierarchicalMethodSignature> cachedMap=SIGNATURES_KEY.getCachedValueOrNull(aClass);
  if (cachedMap != null) {
    HierarchicalMethodSignature signature=cachedMap.get(method.getSignature(PsiSubstitutor.EMPTY));
    if (signature != null) {
      superMethods=MethodSignatureUtil.convertMethodSignaturesToMethods(signature.getSuperSignatures());
    }
  }
  if (superMethods == null) {
    PsiClassType[] directSupers=aClass.getSuperTypes();
    List<PsiMethod> found=null;
    boolean canceled=false;
    for (    PsiClassType directSuper : directSupers) {
      PsiClassType.ClassResolveResult resolveResult=directSuper.resolveGenerics();
      if (resolveResult.getSubstitutor() != PsiSubstitutor.EMPTY) {
        canceled=true;
        break;
      }
      PsiClass directSuperClass=resolveResult.getElement();
      if (directSuperClass == null)       continue;
      PsiMethod[] candidates=directSuperClass.findMethodsBySignature(method,false);
      if (candidates.length != 0) {
        if (found == null)         found=new ArrayList<PsiMethod>();
        for (        PsiMethod candidate : candidates) {
          if (PsiUtil.canBeOverriden(candidate))           found.add(candidate);
        }
      }
    }
    superMethods=canceled ? null : found == null ? PsiMethod.EMPTY_ARRAY : found.toArray(new PsiMethod[found.size()]);
  }
  if (superMethods == null) {
    superMethods=MethodSignatureUtil.convertMethodSignaturesToMethods(method.getHierarchicalMethodSignature().getSuperSignatures());
  }
  for (  PsiMethod superCandidate : superMethods) {
    if (superMethod.equals(superCandidate) || isSuperMethodSmart(superCandidate,superMethod))     return true;
  }
  return false;
}
