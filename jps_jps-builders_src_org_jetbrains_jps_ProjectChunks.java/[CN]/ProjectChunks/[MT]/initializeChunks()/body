{
  if (chunks != null) {
    return;
  }
  myAllTargets=new ArrayList<ModuleBuildTarget>(myProject.getModules().size() * 2);
  for (  JpsModule module : myProject.getModules()) {
    myAllTargets.add(new ModuleBuildTarget(module,JavaModuleBuildTargetType.PRODUCTION));
    myAllTargets.add(new ModuleBuildTarget(module,JavaModuleBuildTargetType.TEST));
  }
  myTargetDependencies=new HashMap<ModuleBuildTarget,Collection<ModuleBuildTarget>>();
  for (  ModuleBuildTarget target : myAllTargets) {
    myTargetDependencies.put(target,target.computeDependencies());
  }
  GraphGenerator<ModuleBuildTarget> graph=GraphGenerator.create(CachingSemiGraph.create(new GraphGenerator.SemiGraph<ModuleBuildTarget>(){
    @Override public Collection<ModuleBuildTarget> getNodes(){
      return myAllTargets;
    }
    @Override public Iterator<ModuleBuildTarget> getIn(    ModuleBuildTarget n){
      return myTargetDependencies.get(n).iterator();
    }
  }
));
  final DFSTBuilder<ModuleBuildTarget> builder=new DFSTBuilder<ModuleBuildTarget>(graph);
  final TIntArrayList sccs=builder.getSCCs();
  chunks=new ArrayList<ModuleChunk>(sccs.size());
  sccs.forEach(new TIntProcedure(){
    int myTNumber=0;
    public boolean execute(    int size){
      final Set<ModuleBuildTarget> chunkNodes=new LinkedHashSet<ModuleBuildTarget>();
      boolean test=false;
      for (int j=0; j < size; j++) {
        final ModuleBuildTarget node=builder.getNodeByTNumber(myTNumber + j);
        test=node.isTests();
        chunkNodes.add(node);
      }
      chunks.add(new ModuleChunk(chunkNodes,test));
      myTNumber+=size;
      return true;
    }
  }
);
}
