def walk(self, match, subrepos, unknown, ignored):
    '\n        Walk recursively through the directory tree, finding all files\n        matched by match.\n\n        Return a dict mapping filename to stat-like object (either\n        mercurial.osutil.stat instance or return value of os.stat()).\n        '

    def fwarn(f, msg):
        self._ui.warn(('%s: %s\n' % (self.pathto(f), msg)))
        return False

    def badtype(mode):
        kind = _('unknown')
        if stat.S_ISCHR(mode):
            kind = _('character device')
        elif stat.S_ISBLK(mode):
            kind = _('block device')
        elif stat.S_ISFIFO(mode):
            kind = _('fifo')
        elif stat.S_ISSOCK(mode):
            kind = _('socket')
        elif stat.S_ISDIR(mode):
            kind = _('directory')
        return (_('unsupported file type (type is %s)') % kind)
    ignore = self._ignore
    dirignore = self._dirignore
    if ignored:
        ignore = util.never
        dirignore = util.never
    elif (not unknown):
        ignore = util.always
        dirignore = util.always
    matchfn = match.matchfn
    badfn = match.bad
    dmap = self._map
    normpath = util.normpath
    listdir = osutil.listdir
    lstat = os.lstat
    getkind = stat.S_IFMT
    dirkind = stat.S_IFDIR
    regkind = stat.S_IFREG
    lnkkind = stat.S_IFLNK
    join = self._join
    work = []
    wadd = work.append
    if self._checkcase:
        normalize = self._normalize
    else:
        normalize = (lambda x, y: x)
    exact = skipstep3 = False
    if (matchfn == match.exact):
        exact = True
        dirignore = util.always
    elif (match.files() and (not match.anypats())):
        skipstep3 = True
    files = set(match.files())
    if ((not files) or ('.' in files)):
        files = ['']
    results = dict.fromkeys(subrepos)
    results['.hg'] = None
    for ff in sorted(files):
        nf = normalize(normpath(ff), False)
        if (nf in results):
            continue
        try:
            st = lstat(join(nf))
            kind = getkind(st.st_mode)
            if (kind == dirkind):
                skipstep3 = False
                if (nf in dmap):
                    results[nf] = None
                match.dir(nf)
                if (not dirignore(nf)):
                    wadd(nf)
            elif ((kind == regkind) or (kind == lnkkind)):
                results[nf] = st
            else:
                badfn(ff, badtype(kind))
                if (nf in dmap):
                    results[nf] = None
        except OSError as inst:
            if (nf in dmap):
                results[nf] = None
            else:
                prefix = (nf + '/')
                for fn in dmap:
                    if fn.startswith(prefix):
                        match.dir(nf)
                        skipstep3 = False
                        break
                else:
                    badfn(ff, inst.strerror)
    while work:
        nd = work.pop()
        skip = None
        if (nd == '.'):
            nd = ''
        else:
            skip = '.hg'
        try:
            entries = listdir(join(nd), stat=True, skip=skip)
        except OSError as inst:
            if (inst.errno == errno.EACCES):
                fwarn(nd, inst.strerror)
                continue
            raise
        for (f, kind, st) in entries:
            nf = normalize(((nd and ((nd + '/') + f)) or f), True)
            if (nf not in results):
                if (kind == dirkind):
                    if (not ignore(nf)):
                        match.dir(nf)
                        wadd(nf)
                    if ((nf in dmap) and matchfn(nf)):
                        results[nf] = None
                elif ((kind == regkind) or (kind == lnkkind)):
                    if (nf in dmap):
                        if matchfn(nf):
                            results[nf] = st
                    elif (matchfn(nf) and (not ignore(nf))):
                        results[nf] = st
                elif ((nf in dmap) and matchfn(nf)):
                    results[nf] = None
    if ((not skipstep3) and (not exact)):
        visit = sorted([f for f in dmap if ((f not in results) and matchfn(f))])
        for (nf, st) in zip(visit, util.statfiles([join(i) for i in visit])):
            if ((not (st is None)) and (not (getkind(st.st_mode) in (regkind, lnkkind)))):
                st = None
            results[nf] = st
    for s in subrepos:
        del results[s]
    del results['.hg']
    return results
