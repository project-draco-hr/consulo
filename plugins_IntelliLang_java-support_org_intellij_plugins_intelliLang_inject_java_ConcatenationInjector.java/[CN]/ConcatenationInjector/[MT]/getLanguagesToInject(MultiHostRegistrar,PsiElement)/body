{
  if (operands.length == 0)   return;
  boolean hasLiteral=false;
  InjectedLanguage tempInjectedLanguage=null;
  for (  PsiElement operand : operands) {
    if (PsiUtilEx.isStringOrCharacterLiteral(operand)) {
      tempInjectedLanguage=myTemporaryPlacesRegistry.getLanguageFor((PsiLanguageInjectionHost)operand);
      hasLiteral=true;
      if (tempInjectedLanguage != null)       break;
    }
  }
  if (!hasLiteral)   return;
  final Language tempLanguage=tempInjectedLanguage == null ? null : tempInjectedLanguage.getLanguage();
  final PsiFile containingFile=operands[0].getContainingFile();
  InjectionProcessor injectionProcessor=new InjectionProcessor(myConfiguration,operands){
    @Override protected void processInjection(    Language language,    List<Trinity<PsiLanguageInjectionHost,InjectedLanguage,TextRange>> list,    boolean xmlInjection,    boolean unparsable){
      InjectorUtils.registerInjection(language,list,containingFile,registrar);
      InjectorUtils.registerSupport(mySupport,xmlInjection,registrar);
      if (unparsable)       InjectorUtils.putInjectedFileUserData(registrar,InjectedLanguageUtil.FRANKENSTEIN_INJECTION,Boolean.TRUE);
    }
    @Override protected boolean areThereInjectionsWithName(    String methodName,    boolean annoOnly){
      if (getAnnotatedElementsValue().contains(methodName)) {
        return true;
      }
      if (!annoOnly && getXmlAnnotatedElementsValue().contains(methodName)) {
        return true;
      }
      return false;
    }
  }
;
  if (tempLanguage != null) {
    injectionProcessor.processCommentInjectionInner(null,null,tempLanguage);
    InjectorUtils.putInjectedFileUserData(registrar,LanguageInjectionSupport.TEMPORARY_INJECTED_LANGUAGE,tempInjectedLanguage);
  }
 else {
    injectionProcessor.processInjections();
  }
}
