{
  final String module=CvsUtil.getModuleName(myFile);
  if (module != null) {
    CvsHistoryCache cache=CvsHistoryCache.create();
    try {
      final CvsConnectionSettings settings=CvsEntriesManager.getInstance().getCvsConnectionSettingsFor(myFile);
      final CvsHistoryCacheElement cacheElement=cache.getCache(settings,module);
      final CvsChangeListsBuilder builder=new CvsChangeListsBuilder(module,settings,myProject);
      final ChangeBrowserSettings browserSettings=ChangeBrowserSettings.getSettings(myProject);
      Date date=browserSettings.getDateBeforeFilter();
      if (date == null) {
        date=new Date();
      }
      final CvsResult executionResult=runRLogOperation(settings,module,cacheElement,date);
      if (!executionResult.hasNoErrors()) {
        throw executionResult.composeError();
      }
 else       if (executionResult.isCanceled()) {
        throw new ProcessCanceledException();
      }
 else {
        cacheElement.flush(date);
        final List<LogInformationWrapper> logs=cacheElement.getLogInformationList();
        builder.addLogs(logs);
        final List<CvsChangeList> versions=builder.getVersions();
        browserSettings.filterChanges(versions);
        if (browserSettings.USE_USER_FILTER) {
          for (Iterator<CvsChangeList> iterator=versions.iterator(); iterator.hasNext(); ) {
            CvsChangeList repositoryVersion=iterator.next();
            if (!Comparing.equal(browserSettings.USER,repositoryVersion.getCommitterName())) {
              iterator.remove();
            }
          }
        }
        return versions;
      }
    }
  finally {
      cache.dispose();
    }
  }
 else {
    throw new VcsException(CvsBundle.message("cannot.find.repository.location.error.message",myFile.getPath()));
  }
}
