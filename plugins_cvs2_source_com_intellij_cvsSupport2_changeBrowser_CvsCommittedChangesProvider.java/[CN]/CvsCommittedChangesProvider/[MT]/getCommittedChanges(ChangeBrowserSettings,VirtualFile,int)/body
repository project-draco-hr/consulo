{
  final VirtualFile rootDir=root.isDirectory() ? root : root.getParent();
  final String module=CvsUtil.getModuleName(root);
  if (module != null) {
    CvsHistoryCache cache=CvsHistoryCache.create();
    try {
      final CvsConnectionSettings connectionSettings=CvsEntriesManager.getInstance().getCvsConnectionSettingsFor(rootDir);
      final CvsHistoryCacheElement cacheElement=cache.getCache(connectionSettings,module);
      final CvsChangeListsBuilder builder=new CvsChangeListsBuilder(module,connectionSettings,myProject);
      Date date=settings.getDateBeforeFilter();
      if (date == null) {
        date=new Date();
      }
      final CvsResult executionResult=runRLogOperation(connectionSettings,module,cacheElement,date);
      if (!executionResult.hasNoErrors()) {
        throw executionResult.composeError();
      }
 else       if (executionResult.isCanceled()) {
        throw new ProcessCanceledException();
      }
 else {
        cacheElement.flush(date);
        final List<LogInformationWrapper> logs=cacheElement.getLogInformationList();
        builder.addLogs(logs);
        final List<CvsChangeList> versions=builder.getVersions();
        settings.filterChanges(versions);
        if (settings.USE_USER_FILTER) {
          for (Iterator<CvsChangeList> iterator=versions.iterator(); iterator.hasNext(); ) {
            CvsChangeList repositoryVersion=iterator.next();
            if (!Comparing.equal(settings.USER,repositoryVersion.getCommitterName())) {
              iterator.remove();
            }
          }
        }
        return versions;
      }
    }
  finally {
      cache.dispose();
    }
  }
 else {
    throw new VcsException(CvsBundle.message("cannot.find.repository.location.error.message",root.getPath()));
  }
}
