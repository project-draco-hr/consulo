{
  if (asynchronous) {
    ApplicationManager.getApplication().assertReadAccessAllowed();
  }
 else {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
  }
  final ModalityState modalityState=EventQueue.isDispatchThread() ? ModalityState.current() : ModalityState.NON_MMODAL;
  final WorkerThread worker;
  if (asynchronous) {
    worker=new WorkerThread("Synchronize worker");
  }
 else {
    worker=null;
  }
  final Runnable endTask=new Runnable(){
    public void run(){
      ProgressIndicator indicator=getManager().getRefreshIndicator();
      if (indicator != null) {
        indicator.stop();
      }
      getManager().afterRefreshFinish(asynchronous,modalityState);
    }
  }
;
  final Runnable runnable=new Runnable(){
    public void run(){
      getManager().beforeRefreshStart(asynchronous,modalityState,null);
      final ProgressIndicator indicator=getManager().getRefreshIndicator();
      if (indicator != null) {
        indicator.start();
        indicator.setText(VfsBundle.message("file.synchronize.progress"));
      }
      storeRefreshStatusToFiles();
      refreshRoots();
      WatchRequest[] requests;
synchronized (LOCK) {
        requests=normalizeRootsForRefresh();
      }
      for (      final WatchRequest request : requests) {
        final String rootPath=request.getRootPath();
        String runPath=rootPath;
        final VirtualFileImpl rootFile=(VirtualFileImpl)findFileByPath(runPath);
        if (rootFile != null) {
          final PhysicalFile file=rootFile.getPhysicalFile();
          final boolean recursively=request.isToWatchRecursively();
          if (!file.exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!rootFile.isValid())                 return;
                boolean isDirectory=rootFile.isDirectory();
                fireBeforeFileDeletion(null,rootFile);
synchronized (LOCK) {
                  final VirtualFileImpl parent=(VirtualFileImpl)rootFile.getParent();
                  if (parent != null)                   parent.removeChild(rootFile);
                  myRootsToWatch.remove(request);
                  updateFileWatcher();
                }
                fireFileDeleted(null,rootFile,rootFile.getName(),isDirectory,null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(rootFile,recursively,false,worker,modalityState,asynchronous,true);
          }
        }
 else {
          final boolean physicalExists=new File(request.getFileSystemRootPath()).exists();
          if (physicalExists) {
            final int index=runPath.lastIndexOf('/');
            while (index >= 0) {
              String parentPath=runPath.substring(0,index);
              final VirtualFileImpl vParent=(VirtualFileImpl)findFileByPath(parentPath);
              if (vParent != null) {
                final String path=runPath;
                getManager().addEventToFireByRefresh(new Runnable(){
                  public void run(){
                    final VirtualFileImpl newVFile=new VirtualFileImpl(path);
                    vParent.addChild(newVFile);
                    newVFile.setParent(vParent);
                    fireFileCreated(null,newVFile);
                  }
                }
,asynchronous,modalityState);
                break;
              }
              runPath=parentPath;
            }
          }
        }
      }
      FileWatcher.resyncedManually();
    }
  }
;
  if (asynchronous) {
    Runnable runnable1=new Runnable(){
      public void run(){
        LOG.info("Executing request:" + this);
        worker.start();
        ApplicationManager.getApplication().runReadAction(runnable);
        worker.dispose(false);
        try {
          worker.join();
        }
 catch (        InterruptedException e) {
        }
        endTask.run();
      }
    }
;
    getSynchronizeQueueAlarm().addRequest(runnable1,0);
  }
 else {
    runnable.run();
    endTask.run();
  }
}
