{
  if (!asynchronous) {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
  }
  final ModalityState modalityState=VirtualFileManagerImpl.calcModalityStateForRefreshEventsPosting(asynchronous);
  final Runnable runnable=new Runnable(){
    public void run(){
      getManager().beforeRefreshStart(asynchronous,modalityState,null);
      storeRefreshStatusToFiles();
      refreshFSRoots();
      WatchRequest[] requests;
      WRITE_LOCK.lock();
      try {
        requests=normalizeRootsForRefresh();
      }
  finally {
        WRITE_LOCK.unlock();
      }
      for (      final WatchRequest request : requests) {
        String runPath=request.getRootPath();
        final VirtualFileImpl rootFile=(VirtualFileImpl)findFileByPath(runPath,true,false);
        if (rootFile != null) {
          final File file=rootFile.getPhysicalFile();
          final boolean recursively=request.isToWatchRecursively();
          if (!file.exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!rootFile.isValid())                 return;
                fireBeforeFileDeletion(null,rootFile);
                WRITE_LOCK.lock();
                try {
                  final VirtualFileImpl parent=rootFile.getParent();
                  if (parent != null)                   parent.removeChild(rootFile);
                }
  finally {
                  WRITE_LOCK.unlock();
                }
                fireFileDeleted(null,rootFile,rootFile.getName(),null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(rootFile,recursively,false,modalityState,asynchronous,false);
            if (!recursively && rootFile.areChildrenCached()) {
              for (              VirtualFileImpl child : rootFile.getChildren()) {
                refreshInner(child,false,modalityState,asynchronous,false);
              }
            }
          }
        }
 else {
          final String fileSystemPath=request.getFileSystemRootPath();
          checkFileCreated(fileSystemPath,runPath,asynchronous,modalityState);
        }
      }
      final Set<Map.Entry<String,VirtualFileImpl>> entries=new HashSet<Map.Entry<String,VirtualFileImpl>>(myUnaccountedFiles.entrySet());
      for (      final Map.Entry<String,VirtualFileImpl> entry : entries) {
        final VirtualFileImpl file=entry.getValue();
        if (file != null && file.isValid()) {
          if (!file.getPhysicalFile().exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!file.isValid())                 return;
                fireBeforeFileDeletion(null,file);
                WRITE_LOCK.lock();
                try {
                  myUnaccountedFiles.put(entry.getKey(),null);
                  file.setParent(null);
                }
  finally {
                  WRITE_LOCK.unlock();
                }
                fireFileDeleted(null,file,file.getName(),null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(file,true,false,modalityState,asynchronous,false);
          }
        }
 else {
          final String vfsPath=entry.getKey();
          final String fsPath=vfsPath.replace('/',File.separatorChar);
          checkFileCreated(fsPath,vfsPath,asynchronous,modalityState);
        }
      }
      FileWatcher.resyncedManually();
      getManager().afterRefreshFinish(asynchronous,modalityState);
    }
  }
;
  if (asynchronous) {
    submitAsynchronousTask(new Runnable(){
      public void run(){
        if (LOG.isDebugEnabled()) {
          LOG.debug("Executing request:" + this);
        }
        runnable.run();
      }
    }
);
  }
 else {
    runnable.run();
  }
}
