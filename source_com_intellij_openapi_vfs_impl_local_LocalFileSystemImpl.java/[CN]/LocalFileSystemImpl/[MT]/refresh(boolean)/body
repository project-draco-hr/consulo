{
  if (!asynchronous) {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
  }
  final ModalityState modalityState=VirtualFileManagerImpl.calcModalityStateForRefreshEventsPosting(asynchronous);
  final Runnable endTask=new Runnable(){
    public void run(){
      getManager().afterRefreshFinish(asynchronous,modalityState);
    }
  }
;
  final Runnable runnable=new Runnable(){
    public void run(){
      getManager().beforeRefreshStart(asynchronous,modalityState,null);
      storeRefreshStatusToFiles();
      refreshFSRoots();
      WatchRequest[] requests;
synchronized (LOCK) {
        requests=normalizeRootsForRefresh();
      }
      for (      final WatchRequest request : requests) {
        String runPath=request.getRootPath();
        final VirtualFileImpl rootFile=(VirtualFileImpl)_findFileByPath(runPath,false);
        if (rootFile != null) {
          final PhysicalFile file=rootFile.getPhysicalFile();
          final boolean recursively=request.isToWatchRecursively();
          if (!file.exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!rootFile.isValid())                 return;
                boolean isDirectory=rootFile.isDirectory();
                fireBeforeFileDeletion(null,rootFile);
synchronized (LOCK) {
                  final VirtualFileImpl parent=rootFile.getParent();
                  if (parent != null)                   parent.removeChild(rootFile);
                }
                fireFileDeleted(null,rootFile,rootFile.getName(),isDirectory,null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(rootFile,recursively,false,modalityState,asynchronous,true,false);
          }
        }
 else {
          final String fileSystemPath=request.getFileSystemRootPath();
          checkFileCreated(fileSystemPath,runPath,asynchronous,modalityState);
        }
      }
      final Set<Map.Entry<String,VirtualFileImpl>> entries=new HashSet<Map.Entry<String,VirtualFileImpl>>(myUnaccountedFiles.entrySet());
      for (      final Map.Entry<String,VirtualFileImpl> entry : entries) {
        final VirtualFileImpl file=entry.getValue();
        if (file != null && file.isValid()) {
          if (!file.getPhysicalFile().exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!file.isValid())                 return;
                boolean isDirectory=file.isDirectory();
                fireBeforeFileDeletion(null,file);
synchronized (LOCK) {
                  myUnaccountedFiles.put(entry.getKey(),null);
                  file.setParent(null);
                }
                fireFileDeleted(null,file,file.getName(),isDirectory,null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(file,true,false,modalityState,asynchronous,false,false);
          }
        }
 else {
          final String vfsPath=entry.getKey();
          final String fsPath=vfsPath.replace('/',File.separatorChar);
          checkFileCreated(fsPath,vfsPath,asynchronous,modalityState);
        }
      }
      FileWatcher.resyncedManually();
    }
  }
;
  if (asynchronous) {
    getSynchronizeExecutor().submit(new Runnable(){
      public void run(){
        if (LOG.isDebugEnabled()) {
          LOG.debug("Executing request:" + this);
        }
        runnable.run();
        endTask.run();
      }
    }
);
  }
 else {
    runnable.run();
    endTask.run();
  }
}
