{
  if (!asynchronous) {
    ApplicationManager.getApplication().assertWriteAccessAllowed();
  }
  final ModalityState modalityState=EventQueue.isDispatchThread() ? ModalityState.current() : ModalityState.NON_MMODAL;
  final Runnable endTask=new Runnable(){
    public void run(){
      getManager().getRefreshIndicator().stop();
      getManager().afterRefreshFinish(asynchronous,modalityState);
    }
  }
;
  final Runnable runnable=new Runnable(){
    public void run(){
      getManager().beforeRefreshStart(asynchronous,modalityState,null);
      final ProgressIndicator indicator=getManager().getRefreshIndicator();
      indicator.start();
      indicator.setText(VfsBundle.message("file.synchronize.progress"));
      storeRefreshStatusToFiles();
      refreshFSRoots();
      WatchRequest[] requests;
synchronized (LOCK) {
        requests=normalizeRootsForRefresh();
      }
      for (      final WatchRequest request : requests) {
        String runPath=request.getRootPath();
        final VirtualFileImpl rootFile=(VirtualFileImpl)_findFileByPath(runPath,false);
        if (rootFile != null) {
          final PhysicalFile file=rootFile.getPhysicalFile();
          final boolean recursively=request.isToWatchRecursively();
          if (!file.exists()) {
            final Runnable action=new Runnable(){
              public void run(){
                if (!rootFile.isValid())                 return;
                boolean isDirectory=rootFile.isDirectory();
                fireBeforeFileDeletion(null,rootFile);
synchronized (LOCK) {
                  final VirtualFileImpl parent=rootFile.getParent();
                  if (parent != null)                   parent.removeChild(rootFile);
                }
                fireFileDeleted(null,rootFile,rootFile.getName(),isDirectory,null);
              }
            }
;
            getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
          }
 else {
            refresh(rootFile,recursively,false,modalityState,asynchronous,true);
          }
        }
 else {
          final boolean physicalExists=new File(request.getFileSystemRootPath()).exists();
          if (physicalExists) {
            int index=runPath.lastIndexOf('/');
            while (index >= 0) {
              String parentPath=runPath.substring(0,index);
              final VirtualFileImpl vParent=(VirtualFileImpl)_findFileByPath(parentPath,false);
              if (vParent != null) {
                final String path=runPath;
                getManager().addEventToFireByRefresh(new Runnable(){
                  public void run(){
                    final VirtualFileImpl newVFile=new VirtualFileImpl(path);
                    vParent.addChild(newVFile);
                    fireFileCreated(null,newVFile);
                  }
                }
,asynchronous,modalityState);
                break;
              }
              runPath=parentPath;
              index=runPath.lastIndexOf('/');
            }
          }
        }
      }
      for (      final Map.Entry<String,VirtualFileImpl> entry : myUnaccountedFiles.entrySet()) {
        final VirtualFileImpl file=entry.getValue();
        if (!file.getPhysicalFile().exists()) {
          final Runnable action=new Runnable(){
            public void run(){
              if (!file.isValid())               return;
              boolean isDirectory=file.isDirectory();
              fireBeforeFileDeletion(null,file);
synchronized (LOCK) {
                myUnaccountedFiles.remove(entry.getKey());
              }
              fireFileDeleted(null,file,file.getName(),isDirectory,null);
            }
          }
;
          getManager().addEventToFireByRefresh(action,asynchronous,modalityState);
        }
 else {
          file.refreshInternal(false,modalityState,false,asynchronous);
        }
      }
      FileWatcher.resyncedManually();
    }
  }
;
  if (asynchronous) {
    getSynchronizeExecutor().submit(new Runnable(){
      public void run(){
        LOG.info("Executing request:" + this);
        runnable.run();
        endTask.run();
      }
    }
);
  }
 else {
    runnable.run();
    endTask.run();
  }
}
