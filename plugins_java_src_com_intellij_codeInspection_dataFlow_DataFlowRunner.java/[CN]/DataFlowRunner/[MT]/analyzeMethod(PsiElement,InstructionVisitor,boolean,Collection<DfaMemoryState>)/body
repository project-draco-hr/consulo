{
  try {
    prepareAnalysis(psiBlock,initialStates);
    final ControlFlow flow=createControlFlowAnalyzer().buildControlFlow(psiBlock,ignoreAssertions);
    if (flow == null)     return RunnerResult.NOT_APPLICABLE;
    int endOffset=flow.getInstructionCount();
    myInstructions=flow.getInstructions();
    myFields=flow.getFields();
    myNestedClosures.clear();
    Set<Instruction> joinInstructions=ContainerUtil.newHashSet();
    for (    Instruction instruction : myInstructions) {
      if (instruction instanceof GotoInstruction) {
        joinInstructions.add(myInstructions[((GotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof ConditionalGotoInstruction) {
        joinInstructions.add(myInstructions[((ConditionalGotoInstruction)instruction).getOffset()]);
      }
 else       if (instruction instanceof GosubInstruction) {
        joinInstructions.add(myInstructions[((GosubInstruction)instruction).getSubprogramOffset()]);
      }
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Analyzing code block: " + psiBlock.getText());
      for (int i=0; i < myInstructions.length; i++) {
        Instruction instruction=myInstructions[i];
        LOG.debug(i + ": " + instruction.toString());
      }
    }
    Integer tooExpensiveHash=psiBlock.getUserData(TOO_EXPENSIVE_HASH);
    if (tooExpensiveHash != null && tooExpensiveHash == psiBlock.getText().hashCode()) {
      LOG.debug("Too complex because hasn't changed since being too complex already");
      return RunnerResult.TOO_COMPLEX;
    }
    final StateQueue queue=new StateQueue();
    for (    final DfaMemoryState initialState : initialStates) {
      queue.offer(new DfaInstructionState(myInstructions[0],initialState));
    }
    MultiMapBasedOnSet<BranchingInstruction,DfaMemoryState> processedStates=new MultiMapBasedOnSet<BranchingInstruction,DfaMemoryState>();
    MultiMapBasedOnSet<BranchingInstruction,DfaMemoryState> incomingStates=new MultiMapBasedOnSet<BranchingInstruction,DfaMemoryState>();
    WorkingTimeMeasurer measurer=new WorkingTimeMeasurer(shouldCheckTimeLimit() ? ourTimeLimit : ourTimeLimit * 42);
    int count=0;
    while (!queue.isEmpty()) {
      for (      DfaInstructionState instructionState : queue.getNextInstructionStates(joinInstructions)) {
        if (count++ % 1024 == 0 && measurer.isTimeOver()) {
          LOG.debug("Too complex because the analysis took too long");
          psiBlock.putUserData(TOO_EXPENSIVE_HASH,psiBlock.getText().hashCode());
          return RunnerResult.TOO_COMPLEX;
        }
        ProgressManager.checkCanceled();
        if (LOG.isDebugEnabled()) {
          LOG.debug(instructionState.toString());
        }
        Instruction instruction=instructionState.getInstruction();
        if (instruction instanceof BranchingInstruction) {
          BranchingInstruction branching=(BranchingInstruction)instruction;
          Collection<DfaMemoryState> processed=processedStates.get(branching);
          if (processed.contains(instructionState.getMemoryState())) {
            continue;
          }
          if (processed.size() > MAX_STATES_PER_BRANCH) {
            LOG.debug("Too complex because too many different possible states");
            return RunnerResult.TOO_COMPLEX;
          }
          processedStates.putValue(branching,instructionState.getMemoryState().createCopy());
        }
        DfaInstructionState[] after=acceptInstruction(visitor,instructionState);
        for (        DfaInstructionState state : after) {
          Instruction nextInstruction=state.getInstruction();
          if (nextInstruction.getIndex() >= endOffset) {
            continue;
          }
          if (nextInstruction instanceof BranchingInstruction) {
            BranchingInstruction branching=(BranchingInstruction)nextInstruction;
            if (processedStates.get(branching).contains(state.getMemoryState()) || incomingStates.get(branching).contains(state.getMemoryState())) {
              continue;
            }
            incomingStates.putValue(branching,state.getMemoryState().createCopy());
          }
          queue.offer(state);
        }
      }
    }
    psiBlock.putUserData(TOO_EXPENSIVE_HASH,null);
    LOG.debug("Analysis ok");
    return RunnerResult.OK;
  }
 catch (  ArrayIndexOutOfBoundsException e) {
    LOG.error(psiBlock.getText(),e);
    return RunnerResult.ABORTED;
  }
catch (  EmptyStackException e) {
    if (LOG.isDebugEnabled()) {
      LOG.error(e);
    }
    return RunnerResult.ABORTED;
  }
}
