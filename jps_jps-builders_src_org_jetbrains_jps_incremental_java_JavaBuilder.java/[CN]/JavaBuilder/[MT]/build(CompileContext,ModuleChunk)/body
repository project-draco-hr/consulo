{
  try {
    final TimestampStorage tsStorage=context.getBuildDataManager().getTimestampStorage(BUILDER_NAME);
    final Set<File> filesToCompile=new LinkedHashSet<File>();
    final List<File> formsToCompile=new ArrayList<File>();
    final List<File> upToDateForms=new ArrayList<File>();
    final Set<String> srcRoots=new HashSet<String>();
    final boolean wholeModuleRebuildRequired=context.isDirty(chunk);
    context.processFiles(chunk,new FileProcessor(){
      public boolean apply(      Module module,      File file,      String sourceRoot) throws Exception {
        if (JAVA_SOURCES_FILTER.accept(file)) {
          srcRoots.add(sourceRoot);
          if (wholeModuleRebuildRequired || isFileDirty(file,context,tsStorage)) {
            filesToCompile.add(file);
          }
        }
 else         if (FORM_SOURCES_FILTER.accept(file)) {
          if (wholeModuleRebuildRequired || isFileDirty(file,context,tsStorage)) {
            formsToCompile.add(file);
          }
 else {
            upToDateForms.add(file);
          }
        }
        return true;
      }
    }
);
    for (    File form : formsToCompile) {
      for (      String root : srcRoots) {
        final File boundSource=getBoundSource(root,form);
        if (boundSource != null) {
          filesToCompile.add(boundSource);
          break;
        }
      }
    }
    for (    File form : upToDateForms) {
      for (      String root : srcRoots) {
        final File boundSource=getBoundSource(root,form);
        if (boundSource != null && filesToCompile.contains(boundSource)) {
          formsToCompile.add(form);
          break;
        }
      }
    }
    upToDateForms.clear();
    final Set<File> removed=Paths.CHUNK_REMOVED_SOURCES_KEY.get(context);
    final Set<String> removedPaths;
    if (removed == null || removed.isEmpty()) {
      removedPaths=Collections.emptySet();
    }
 else {
      removedPaths=new HashSet<String>();
      for (      File file : removed) {
        removedPaths.add(file.getPath());
      }
    }
    return compile(context,chunk,filesToCompile,formsToCompile,removedPaths);
  }
 catch (  Exception e) {
    String message=e.getMessage();
    if (message == null) {
      final ByteArrayOutputStream out=new ByteArrayOutputStream();
      e.printStackTrace(new PrintStream(out));
      message="Internal error: \n" + out.toString();
    }
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,message));
    throw new ProjectBuildException(message,e);
  }
}
