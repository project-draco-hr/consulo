{
  final TasksCounter counter=new TasksCounter();
  COUNTER_KEY.set(context,counter);
  final Set<JpsModule> modules=chunk.getModules();
  ProcessorConfigProfile profile=null;
  if (modules.size() == 1) {
    profile=context.getAnnotationProcessingProfile(modules.iterator().next());
  }
 else {
    final JpsJavaExtensionService javaExt=JpsJavaExtensionService.getInstance();
    Pair<String,LanguageLevel> pair=null;
    for (    JpsModule module : modules) {
      final LanguageLevel moduleLevel=javaExt.getLanguageLevel(module);
      if (pair == null) {
        pair=Pair.create(module.getName(),moduleLevel);
      }
 else {
        if (!Comparing.equal(pair.getSecond(),moduleLevel)) {
          final String message="Modules " + pair.getFirst() + " and "+ module.getName()+ " must have the same language level because of cyclic dependencies between them";
          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR,message));
          return true;
        }
      }
    }
    for (    JpsModule module : modules) {
      final ProcessorConfigProfile prof=context.getAnnotationProcessingProfile(module);
      if (prof.isEnabled()) {
        final String message="Annotation processing is not supported for module cycles. Please ensure that all modules from cycle [" + chunk.getName() + "] are excluded from annotation processing";
        diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR,message));
        return true;
      }
    }
  }
  final Map<File,Set<File>> outs=buildOutputDirectoriesMap(context,chunk);
  final List<String> options=getCompilationOptions(context,chunk,profile);
  final ClassProcessingConsumer classesConsumer=new ClassProcessingConsumer(context,outputSink);
  try {
    final boolean rc;
    if (USE_EMBEDDED_JAVAC) {
      final boolean useEclipse=useEclipseCompiler(context);
      rc=JavacMain.compile(options,files,classpath,platformCp,sourcePath,outs,diagnosticSink,classesConsumer,context.getCancelStatus(),useEclipse);
    }
 else {
      final JavacServerClient client=ensureJavacServerLaunched(context);
      final RequestFuture<JavacServerResponseHandler> future=client.sendCompileRequest(options,files,classpath,platformCp,sourcePath,outs,diagnosticSink,classesConsumer);
      while (!future.waitFor(100L,TimeUnit.MILLISECONDS)) {
        if (context.getCancelStatus().isCanceled()) {
          future.cancel(false);
        }
      }
      rc=future.getMessageHandler().isTerminatedSuccessfully();
    }
    return rc;
  }
  finally {
    counter.await();
  }
}
