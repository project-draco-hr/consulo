{
  final Set<File> problematic=new THashSet<File>(FileUtil.FILE_HASHING_STRATEGY);
  for (  final CompiledClass compiledClass : outputConsumer.getCompiledClasses().values()) {
    final BinaryContent originalContent=compiledClass.getContent();
    final ClassReader reader=new ClassReader(originalContent.getBuffer(),originalContent.getOffset(),originalContent.getLength());
    final int version=getClassFileVersion(reader);
    if (version >= Opcodes.V1_5) {
      boolean success=false;
      final ClassWriter writer=new InstrumenterClassWriter(getAsmClassWriterFlags(version),finder);
      try {
        final NotNullVerifyingInstrumenter instrumenter=new NotNullVerifyingInstrumenter(writer);
        reader.accept(instrumenter,0);
        if (instrumenter.isModification()) {
          compiledClass.setContent(new BinaryContent(writer.toByteArray()));
        }
        success=true;
      }
 catch (      Throwable e) {
        final StringBuilder msg=new StringBuilder();
        msg.append("@NotNull instrumentation failed ");
        final File sourceFile=compiledClass.getSourceFile();
        if (sourceFile != null) {
          msg.append(" for ").append(sourceFile.getName());
        }
        msg.append(": ").append(e.getMessage());
        context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,msg.toString(),sourceFile != null ? sourceFile.getPath() : null));
      }
 finally {
        if (!success) {
          problematic.add(compiledClass.getSourceFile());
        }
      }
    }
  }
  return problematic;
}
