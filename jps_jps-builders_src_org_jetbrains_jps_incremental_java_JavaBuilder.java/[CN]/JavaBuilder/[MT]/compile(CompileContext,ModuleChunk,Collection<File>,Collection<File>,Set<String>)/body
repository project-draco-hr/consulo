{
  ExitCode exitCode=ExitCode.OK;
  if (files.isEmpty() && forms.isEmpty()) {
    return exitCode;
  }
  final ProjectPaths paths=context.getProjectPaths();
  final Mappings delta=new Mappings();
  DELTA_MAPPINGS_CALLBACK_KEY.set(context,delta.getCallback());
  final boolean addNotNullAssertions=true;
  final Collection<File> classpath=paths.getCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Collection<File> platformCp=paths.getPlatformCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Map<File,Set<File>> outs=buildOutputDirectoriesMap(context,chunk);
  final List<String> options=getCompilationOptions(context,chunk);
  final TimestampStorage tsStorage=context.getBuildDataManager().getTimestampStorage(BUILDER_NAME);
  Set<File> allCompiledFiles=ALL_COMPILED_FILES_KEY.get(context);
  if (allCompiledFiles == null) {
    allCompiledFiles=new HashSet<File>();
    ALL_COMPILED_FILES_KEY.set(context,allCompiledFiles);
  }
  Set<File> allAffectedFiles=ALL_AFFECTED_FILES_KEY.get(context);
  if (allAffectedFiles == null) {
    allAffectedFiles=new HashSet<File>();
    ALL_AFFECTED_FILES_KEY.set(context,allAffectedFiles);
  }
  final DiagnosticSink diagnosticSink=new DiagnosticSink(context);
  final OutputFilesSink outputSink=new OutputFilesSink(context);
  Collection<File> successfulForms=Collections.emptyList();
  try {
    boolean compiledOk=myJavacCompiler.compile(options,files,classpath,platformCp,outs,context,diagnosticSink,outputSink);
    final Collection<File> chunkSourcePath=ProjectPaths.getSourcePathsWithDependents(chunk,context.isCompilingTests());
    final ClassLoader compiledClassesLoader=createInstrumentationClassLoader(classpath,platformCp,chunkSourcePath,outputSink);
    if (!forms.isEmpty()) {
      try {
        context.processMessage(new ProgressMessage("Instrumenting forms [" + chunk.getName() + "]"));
        successfulForms=instrumentForms(context,chunk,chunkSourcePath,compiledClassesLoader,forms,outputSink);
      }
  finally {
        context.processMessage(new ProgressMessage("Finished instrumenting forms [" + chunk.getName() + "]"));
      }
    }
    if (addNotNullAssertions) {
      try {
        context.processMessage(new ProgressMessage("Adding NotNull assertions [" + chunk.getName() + "]"));
        instrumentNotNull(context,outputSink,compiledClassesLoader);
      }
  finally {
        context.processMessage(new ProgressMessage("Finished adding NotNull assertions [" + chunk.getName() + "]"));
      }
    }
    if (!compiledOk || diagnosticSink.getErrorCount() > 0) {
      throw new ProjectBuildException("Compilation failed: errors: " + diagnosticSink.getErrorCount() + "; warnings: "+ diagnosticSink.getWarningCount());
    }
  }
  finally {
    context.setDirty(chunk,false);
    outputSink.writePendingData();
    final Set<File> successfullyCompiled=outputSink.getSuccessfullyCompiled();
    final Mappings globalMappings=context.getMappings();
    if (context.isMake()) {
      DELTA_MAPPINGS_CALLBACK_KEY.set(context,null);
      allAffectedFiles.addAll(files);
      allCompiledFiles.addAll(successfullyCompiled);
      allAffectedFiles.removeAll(successfullyCompiled);
      final boolean incremental=globalMappings.differentiate(delta,removedSources,successfullyCompiled,allCompiledFiles,allAffectedFiles);
      if (incremental) {
        final Set<File> newlyAffectedFiles=new HashSet<File>(allAffectedFiles);
        newlyAffectedFiles.removeAll(allCompiledFiles);
        for (        File file : newlyAffectedFiles) {
          tsStorage.markDirty(file);
        }
        if (chunkContainsAffectedFiles(context,chunk,newlyAffectedFiles)) {
          exitCode=ExitCode.ADDITIONAL_PASS_REQUIRED;
        }
      }
 else {
        exitCode=ExitCode.ADDITIONAL_PASS_REQUIRED;
        context.setDirty(chunk,true);
      }
    }
    globalMappings.integrate(delta,successfullyCompiled,removedSources);
    for (    File file : successfullyCompiled) {
      tsStorage.saveStamp(file);
    }
    for (    File file : successfulForms) {
      tsStorage.saveStamp(file);
    }
  }
  return exitCode;
}
