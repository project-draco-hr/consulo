{
  if (!IS_ENABLED.get(context,Boolean.TRUE)) {
    return ExitCode.NOTHING_DONE;
  }
  final JpsProject project=context.getProjectDescriptor().getProject();
  final JpsJavaCompilerConfiguration configuration=JpsJavaExtensionService.getInstance().getOrCreateCompilerConfiguration(project);
  try {
    final Map<File,ModuleBuildTarget> filesToCompile=new THashMap<File,ModuleBuildTarget>(FileUtil.FILE_HASHING_STRATEGY);
    final Map<File,ModuleBuildTarget> formsToCompile=new THashMap<File,ModuleBuildTarget>(FileUtil.FILE_HASHING_STRATEGY);
    dirtyFilesHolder.processDirtyFiles(new FileProcessor<JavaSourceRootDescriptor,ModuleBuildTarget>(){
      public boolean apply(      ModuleBuildTarget target,      File file,      JavaSourceRootDescriptor descriptor) throws IOException {
        if (JAVA_SOURCES_FILTER.accept(file)) {
          filesToCompile.put(file,target);
        }
 else         if (FORM_SOURCES_FILTER.accept(file)) {
          formsToCompile.put(file,target);
        }
        return true;
      }
    }
);
    if (OPTION_ENABLE_FORMS_INSTRUMENTATION) {
      final JpsCompilerExcludes excludes=configuration.getCompilerExcludes();
      if (!context.isProjectRebuild()) {
        for (Iterator<Map.Entry<File,ModuleBuildTarget>> formsIterator=formsToCompile.entrySet().iterator(); formsIterator.hasNext(); ) {
          final Map.Entry<File,ModuleBuildTarget> entry=formsIterator.next();
          final File form=entry.getKey();
          final ModuleBuildTarget target=entry.getValue();
          final File boundSource=findBoundSource(context,target,form);
          if (boundSource != null) {
            if (!excludes.isExcluded(boundSource)) {
              filesToCompile.put(boundSource,target);
            }
 else {
              formsIterator.remove();
            }
          }
        }
        final OneToManyPathsMapping sourceToFormMap=context.getProjectDescriptor().dataManager.getSourceToFormMap();
        for (        Map.Entry<File,ModuleBuildTarget> entry : filesToCompile.entrySet()) {
          final File srcFile=entry.getKey();
          final ModuleBuildTarget target=entry.getValue();
          final String srcPath=srcFile.getPath();
          final Collection<String> boundForms=sourceToFormMap.getState(srcPath);
          if (boundForms != null) {
            for (            String formPath : boundForms) {
              final File formFile=new File(formPath);
              if (!excludes.isExcluded(formFile)) {
                if (formFile.exists()) {
                  FSOperations.markDirty(context,formFile);
                  formsToCompile.put(formFile,target);
                }
              }
            }
            sourceToFormMap.remove(srcPath);
          }
        }
      }
    }
    if (context.isMake()) {
      final ProjectBuilderLogger logger=context.getLoggingManager().getProjectBuilderLogger();
      if (logger.isEnabled()) {
        if (filesToCompile.size() > 0) {
          logger.logCompiledFiles(filesToCompile.keySet(),BUILDER_NAME,"Compiling files:");
        }
        if (!formsToCompile.isEmpty()) {
          logger.logCompiledFiles(formsToCompile.keySet(),FORMS_BUILDER_NAME,"Compiling forms:");
        }
      }
    }
    return compile(context,chunk,dirtyFilesHolder,filesToCompile.keySet(),formsToCompile.keySet(),outputConsumer);
  }
 catch (  ProjectBuildException e) {
    throw e;
  }
catch (  Exception e) {
    String message=e.getMessage();
    if (message == null) {
      final ByteArrayOutputStream out=new ByteArrayOutputStream();
      final PrintStream stream=new PrintStream(out);
      try {
        e.printStackTrace(stream);
      }
  finally {
        stream.close();
      }
      message="Internal error: \n" + out.toString();
    }
    context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.ERROR,message));
    throw new ProjectBuildException(message,e);
  }
}
