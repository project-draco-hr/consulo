{
  ExitCode exitCode=ExitCode.NOTHING_DONE;
  final boolean hasSourcesToCompile=!files.isEmpty() || !forms.isEmpty();
  if (!hasSourcesToCompile && !Utils.hasRemovedSources(context)) {
    return exitCode;
  }
  final ProjectPaths paths=context.getProjectPaths();
  final ProjectDescriptor pd=context.getProjectDescriptor();
  final boolean addNotNullAssertions=pd.project.getCompilerConfiguration().isAddNotNullAssertions();
  final Collection<File> classpath=paths.getCompilationClasspath(chunk,context.isCompilingTests(),false);
  final Collection<File> platformCp=paths.getPlatformCompilationClasspath(chunk,context.isCompilingTests(),false);
  final DiagnosticSink diagnosticSink=new DiagnosticSink(context);
  final OutputFilesSink outputSink=new OutputFilesSink(context);
  final Mappings delta=pd.dataManager.getMappings().createDelta();
  DELTA_MAPPINGS_CALLBACK_KEY.set(context,delta.getCallback());
  try {
    if (hasSourcesToCompile) {
      exitCode=ExitCode.OK;
      final Set<File> tempRootsSourcePath=new HashSet<File>();
      final ModuleRootsIndex index=pd.rootsIndex;
      for (      Module module : chunk.getModules()) {
        for (        RootDescriptor rd : index.getModuleRoots(context,module)) {
          if (rd.isTemp) {
            tempRootsSourcePath.add(rd.root);
          }
        }
      }
      final String chunkName=getChunkPresentableName(chunk);
      context.processMessage(new ProgressMessage("Compiling java [" + chunkName + "]"));
      final int filesCount=files.size();
      boolean compiledOk=true;
      if (filesCount > 0) {
        LOG.info("Compiling " + filesCount + " java files; module: "+ chunkName);
        compiledOk=compileJava(context,chunk,files,classpath,platformCp,tempRootsSourcePath,diagnosticSink,outputSink);
      }
      context.checkCanceled();
      if (!forms.isEmpty() || addNotNullAssertions) {
        final Map<File,String> chunkSourcePath=ProjectPaths.getSourceRootsWithDependents(chunk,context.isCompilingTests());
        final InstrumentationClassFinder finder=createInstrumentationClassFinder(platformCp,classpath,chunkSourcePath,outputSink);
        try {
          if (!forms.isEmpty()) {
            try {
              context.processMessage(new ProgressMessage("Instrumenting forms [" + chunkName + "]"));
              instrumentForms(context,chunk,chunkSourcePath,finder,forms,outputSink);
              if (pd.project.getUiDesignerConfiguration().isCopyFormsRuntimeToOutput() && !context.isCompilingTests()) {
                for (                Module module : chunk.getModules()) {
                  final File outputDir=paths.getModuleOutputDir(module,false);
                  if (outputDir != null) {
                    CopyResourcesUtil.copyFormsRuntime(outputDir.getAbsolutePath(),false);
                  }
                }
              }
            }
  finally {
              context.processMessage(new ProgressMessage("Finished instrumenting forms [" + chunkName + "]"));
            }
          }
          context.checkCanceled();
          if (addNotNullAssertions) {
            try {
              context.processMessage(new ProgressMessage("Adding NotNull assertions [" + chunkName + "]"));
              instrumentNotNull(context,outputSink,finder);
            }
  finally {
              context.processMessage(new ProgressMessage("Finished adding NotNull assertions [" + chunkName + "]"));
            }
          }
        }
  finally {
          finder.releaseResources();
        }
      }
      context.checkCanceled();
      if (!compiledOk && diagnosticSink.getErrorCount() == 0) {
        diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.ERROR,"Compilation failed: internal java compiler error"));
      }
      if (!Utils.PROCEED_ON_ERROR_KEY.get(context,Boolean.FALSE) && diagnosticSink.getErrorCount() > 0) {
        if (!compiledOk) {
          diagnosticSink.report(new PlainMessageDiagnostic(Diagnostic.Kind.OTHER,"Errors occurred while compiling module '" + chunkName + "'"));
        }
        throw new ProjectBuildException("Compilation failed: errors: " + diagnosticSink.getErrorCount() + "; warnings: "+ diagnosticSink.getWarningCount());
      }
    }
  }
  finally {
    outputSink.writePendingData();
    final Set<File> successfullyCompiled=outputSink.getSuccessfullyCompiled();
    DELTA_MAPPINGS_CALLBACK_KEY.set(context,null);
    if (updateMappings(context,delta,chunk,files,successfullyCompiled)) {
      exitCode=ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
  }
  return exitCode;
}
