{
  ExitCode exitCode=ExitCode.OK;
  final boolean hasSourcesToCompile=!files.isEmpty() || !forms.isEmpty();
  if (!hasSourcesToCompile && !context.hasRemovedSources()) {
    return exitCode;
  }
  final ProjectPaths paths=context.getProjectPaths();
  final Mappings delta=context.createDelta();
  DELTA_MAPPINGS_CALLBACK_KEY.set(context,delta.getCallback());
  final boolean addNotNullAssertions=true;
  final Collection<File> classpath=paths.getCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Collection<File> platformCp=paths.getPlatformCompilationClasspath(chunk,context.isCompilingTests(),!context.isMake());
  final Map<File,Set<File>> outs=buildOutputDirectoriesMap(context,chunk);
  final List<String> options=getCompilationOptions(context,chunk);
  final DiagnosticSink diagnosticSink=new DiagnosticSink(context);
  final OutputFilesSink outputSink=new OutputFilesSink(context);
  Collection<File> successfulForms=Collections.emptyList();
  try {
    if (hasSourcesToCompile) {
      final Set<File> sourcePath=TEMPORARY_SOURCE_ROOTS_KEY.get(context,Collections.<File>emptySet());
      final boolean compiledOk=myJavacCompiler.compile(options,files,classpath,platformCp,sourcePath,outs,context,diagnosticSink,outputSink);
      final Map<File,String> chunkSourcePath=ProjectPaths.getSourceRootsWithDependents(chunk,context.isCompilingTests());
      final ClassLoader compiledClassesLoader=createInstrumentationClassLoader(classpath,platformCp,chunkSourcePath,outputSink);
      if (!forms.isEmpty()) {
        try {
          context.processMessage(new ProgressMessage("Instrumenting forms [" + chunk.getName() + "]"));
          successfulForms=instrumentForms(context,chunk,chunkSourcePath,compiledClassesLoader,forms,outputSink);
        }
  finally {
          context.processMessage(new ProgressMessage("Finished instrumenting forms [" + chunk.getName() + "]"));
        }
      }
      if (addNotNullAssertions) {
        try {
          context.processMessage(new ProgressMessage("Adding NotNull assertions [" + chunk.getName() + "]"));
          instrumentNotNull(context,outputSink,compiledClassesLoader);
        }
  finally {
          context.processMessage(new ProgressMessage("Finished adding NotNull assertions [" + chunk.getName() + "]"));
        }
      }
      if (!compiledOk && diagnosticSink.getErrorCount() == 0) {
        throw new ProjectBuildException("Compilation failed: internal java compiler error");
      }
      if (diagnosticSink.getErrorCount() > 0) {
        throw new ProjectBuildException("Compilation failed: errors: " + diagnosticSink.getErrorCount() + "; warnings: "+ diagnosticSink.getWarningCount());
      }
    }
  }
  finally {
    context.setDirty(chunk,false);
    outputSink.writePendingData();
    final Set<File> successfullyCompiled=outputSink.getSuccessfullyCompiled();
    DELTA_MAPPINGS_CALLBACK_KEY.set(context,null);
    if (updateMappings(context,delta,chunk,files,successfullyCompiled)) {
      exitCode=ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
    final TimestampStorage tsStorage=context.getBuildDataManager().getTimestampStorage(BUILDER_NAME);
    for (    File file : successfulForms) {
      tsStorage.saveStamp(file);
    }
  }
  if (exitCode != ExitCode.ADDITIONAL_PASS_REQUIRED) {
    final Set<File> tempRoots=TEMPORARY_SOURCE_ROOTS_KEY.get(context);
    TEMPORARY_SOURCE_ROOTS_KEY.set(context,null);
    if (tempRoots != null) {
      for (      File root : tempRoots) {
        FileUtil.delete(root);
      }
    }
  }
  return exitCode;
}
