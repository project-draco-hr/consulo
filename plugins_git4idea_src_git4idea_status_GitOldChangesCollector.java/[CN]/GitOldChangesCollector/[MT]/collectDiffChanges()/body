{
  Collection<FilePath> dirtyPaths=dirtyPaths(true);
  if (dirtyPaths.isEmpty()) {
    return;
  }
  GitSimpleHandler handler=new GitSimpleHandler(myProject,myVcsRoot,GitCommand.DIFF);
  handler.addParameters("--name-status","--diff-filter=ADCMRUXT","-M","HEAD");
  handler.setNoSSH(true);
  handler.setSilent(true);
  handler.setStdoutSuppressed(true);
  handler.endOptions();
  handler.addRelativePaths(dirtyPaths);
  if (handler.isLargeCommandLine()) {
    handler=new GitSimpleHandler(myProject,myVcsRoot,GitCommand.DIFF);
    handler.addParameters("--name-status","--diff-filter=ADCMRUXT","-M","HEAD");
    handler.setNoSSH(true);
    handler.setSilent(true);
    handler.setStdoutSuppressed(true);
    handler.endOptions();
  }
  try {
    String output=handler.run();
    GitChangeUtils.parseChanges(myProject,myVcsRoot,null,GitChangeUtils.loadRevision(myProject,myVcsRoot,"HEAD"),output,myChanges,myUnmergedNames);
  }
 catch (  VcsException ex) {
    if (!GitChangeUtils.isHeadMissing(ex)) {
      throw ex;
    }
    handler=new GitSimpleHandler(myProject,myVcsRoot,GitCommand.LS_FILES);
    handler.addParameters("--cached");
    handler.setNoSSH(true);
    handler.setSilent(true);
    handler.setStdoutSuppressed(true);
    String output=handler.run();
    if (output.length() > 0) {
      StringTokenizer tokenizer=new StringTokenizer(output,"\n\r");
      while (tokenizer.hasMoreTokens()) {
        final String s=tokenizer.nextToken();
        Change ch=new Change(null,GitContentRevision.createRevision(myVcsRoot,s,null,myProject,false,false,true),FileStatus.ADDED);
        myChanges.add(ch);
      }
    }
  }
}
