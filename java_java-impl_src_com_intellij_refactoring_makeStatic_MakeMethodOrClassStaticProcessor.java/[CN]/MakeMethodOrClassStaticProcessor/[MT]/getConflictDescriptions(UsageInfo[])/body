{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  HashSet<PsiElement> processed=new HashSet<PsiElement>();
  String typeString=StringUtil.capitalize(UsageViewUtil.getType(myMember));
  for (  UsageInfo usageInfo : usages) {
    if (usageInfo instanceof InternalUsageInfo && !(usageInfo instanceof SelfUsageInfo)) {
      PsiElement referencedElement=((InternalUsageInfo)usageInfo).getReferencedElement();
      if (!mySettings.isMakeClassParameter()) {
        if (referencedElement instanceof PsiModifierListOwner) {
          if (((PsiModifierListOwner)referencedElement).hasModifierProperty(PsiModifier.STATIC)) {
            continue;
          }
        }
        if (processed.contains(referencedElement))         continue;
        processed.add(referencedElement);
        if (referencedElement instanceof PsiField) {
          PsiField field=(PsiField)referencedElement;
          if (mySettings.getNameForField(field) == null) {
            String message=RefactoringBundle.message("0.uses.non.static.1.which.is.not.passed.as.a.parameter",typeString,RefactoringUIUtil.getDescription(field,true));
            conflicts.putValue(field,message);
          }
        }
 else {
          String message=RefactoringBundle.message("0.uses.1.which.needs.class.instance",typeString,RefactoringUIUtil.getDescription(referencedElement,true));
          conflicts.putValue(referencedElement,message);
        }
      }
    }
    if (usageInfo instanceof OverridingMethodUsageInfo) {
      LOG.assertTrue(myMember instanceof PsiMethod);
      final PsiMethod overridingMethod=((PsiMethod)usageInfo.getElement());
      String message=RefactoringBundle.message("method.0.is.overridden.by.1",RefactoringUIUtil.getDescription(myMember,false),RefactoringUIUtil.getDescription(overridingMethod,true));
      conflicts.putValue(overridingMethod,message);
    }
 else {
      PsiElement element=usageInfo.getElement();
      PsiElement container=ConflictsUtil.getContainer(element);
      if (processed.contains(container))       continue;
      processed.add(container);
      List<Settings.FieldParameter> fieldParameters=mySettings.getParameterOrderList();
      ArrayList<PsiField> inaccessible=new ArrayList<PsiField>();
      for (      final Settings.FieldParameter fieldParameter : fieldParameters) {
        if (!PsiUtil.isAccessible(fieldParameter.field,element,null)) {
          inaccessible.add(fieldParameter.field);
        }
      }
      if (inaccessible.isEmpty())       continue;
      createInaccessibleFieldsConflictDescription(inaccessible,container,conflicts);
    }
  }
  return conflicts;
}
