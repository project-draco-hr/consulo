{
  final PsiMethod method=p.getMethod();
  final SearchScope scope=p.getScope();
  final PsiClass parentClass=method.getContainingClass();
  Processor<PsiClass> inheritorsProcessor=new Processor<PsiClass>(){
    public boolean process(    PsiClass inheritor){
      PsiSubstitutor substitutor=TypeConversionUtil.getSuperClassSubstitutor(parentClass,inheritor,PsiSubstitutor.EMPTY);
      MethodSignature signature=method.getSignature(substitutor);
      PsiMethod found=MethodSignatureUtil.findMethodBySuperSignature(inheritor,signature,false);
      if (found == null || !isAcceptable(found,method)) {
        if (parentClass.isInterface() && !inheritor.isInterface()) {
          final PsiClass superClass=inheritor.getSuperClass();
          if (superClass != null && !superClass.isInheritor(parentClass,true)) {
            found=MethodSignatureUtil.findMethodInSuperClassBySignatureInDerived(inheritor,superClass,signature,true);
            if (found != null && isAcceptable(found,method)) {
              return consumer.process(found) && p.isCheckDeep();
            }
          }
        }
        return true;
      }
      return consumer.process(found) && p.isCheckDeep();
    }
  }
;
  return ClassInheritorsSearch.search(parentClass,scope,true).forEach(inheritorsProcessor);
}
