{
  ParserUtils.getToken(builder,kNEW);
  ParserUtils.getToken(builder,mNLS);
  PsiBuilder.Marker rb=builder.mark();
  TypeArguments.parseTypeArguments(builder,false);
  if (!TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType()) && mIDENT != builder.getTokenType()) {
    rb.rollbackTo();
  }
 else {
    rb.drop();
  }
  PsiBuilder.Marker anonymousMarker=builder.mark();
  String name=null;
  if (TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,BUILT_IN_TYPE);
  }
 else   if (mIDENT == builder.getTokenType()) {
    name=builder.getTokenText();
    ReferenceElement.parse(builder,false,true,false,true,true);
  }
 else {
    builder.error(GroovyBundle.message("type.specification.expected"));
    anonymousMarker.drop();
    return NEW_EXPRESSION;
  }
  if (builder.getTokenType() == mLPAREN || ParserUtils.lookAhead(builder,mNLS,mLPAREN)) {
    ParserUtils.getToken(builder,mNLS);
    methodCallArgsParse(builder,parser);
    if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder,mNLS,mLCURLY)) {
      ParserUtils.getToken(builder,mNLS);
      TypeDefinition.parseClassBody(builder,name,parser);
      anonymousMarker.done(ANONYMOUS_CLASS_DEFINITION);
      return NEW_EXPRESSION;
    }
  }
 else   if (builder.getTokenType() == mLBRACK) {
    PsiBuilder.Marker forArray=builder.mark();
    while (ParserUtils.getToken(builder,mLBRACK)) {
      ParserUtils.getToken(builder,mNLS);
      if (!AssignmentExpression.parse(builder,parser)) {
        builder.error(GroovyBundle.message("expression.expected"));
      }
      ParserUtils.getToken(builder,mNLS);
      ParserUtils.getToken(builder,mRBRACK,GroovyBundle.message("rbrack.expected"));
    }
    forArray.done(ARRAY_DECLARATOR);
  }
 else {
    builder.error(GroovyBundle.message("lparen.expected"));
  }
  anonymousMarker.drop();
  return NEW_EXPRESSION;
}
