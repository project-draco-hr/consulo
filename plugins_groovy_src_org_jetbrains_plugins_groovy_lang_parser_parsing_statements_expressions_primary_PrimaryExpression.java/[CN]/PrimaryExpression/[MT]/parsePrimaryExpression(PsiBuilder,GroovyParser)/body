{
  if (TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,BUILT_IN_TYPE_EXPRESSION);
    return BUILT_IN_TYPE_EXPRESSION;
  }
  if (kTHIS == builder.getTokenType()) {
    ParserUtils.eatElement(builder,THIS_REFERENCE_EXPRESSION);
    return THIS_REFERENCE_EXPRESSION;
  }
  if (kSUPER == builder.getTokenType()) {
    ParserUtils.eatElement(builder,SUPER_REFERENCE_EXPRESSION);
    return SUPER_REFERENCE_EXPRESSION;
  }
  if (kNEW == builder.getTokenType()) {
    return newExprParse(builder,parser);
  }
  if (mIDENT == builder.getTokenType()) {
    ParserUtils.eatElement(builder,REFERENCE_EXPRESSION);
    return REFERENCE_EXPRESSION;
  }
  if (mGSTRING_BEGIN == builder.getTokenType()) {
    return StringConstructorExpression.parse(builder,parser);
  }
  if (mREGEX_BEGIN == builder.getTokenType()) {
    return RegexConstructorExpression.parse(builder,parser);
  }
  if (mLBRACK == builder.getTokenType()) {
    return ListOrMapConstructorExpression.parse(builder,parser);
  }
  if (mLPAREN == builder.getTokenType()) {
    return parenthesizedExprParse(builder,parser);
  }
  if (mLCURLY == builder.getTokenType()) {
    return OpenOrClosableBlock.parseClosableBlock(builder,parser);
  }
  if (TokenSets.CONSTANTS.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,LITERAL);
    return LITERAL;
  }
  if (mWRONG_REGEX_LITERAL == builder.getTokenType()) {
    PsiBuilder.Marker marker=builder.mark();
    builder.advanceLexer();
    builder.error(GroovyBundle.message("wrong.string"));
    marker.done(LITERAL);
    return LITERAL;
  }
  return WRONGWAY;
}
