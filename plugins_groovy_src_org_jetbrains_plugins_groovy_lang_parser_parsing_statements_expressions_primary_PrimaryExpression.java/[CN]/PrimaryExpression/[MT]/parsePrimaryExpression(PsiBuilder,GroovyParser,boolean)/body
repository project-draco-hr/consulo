{
  final IElementType tokenType=builder.getTokenType();
  if (TokenSets.BUILT_IN_TYPES.contains(tokenType)) {
    ParserUtils.eatElement(builder,BUILT_IN_TYPE_EXPRESSION);
    return BUILT_IN_TYPE_EXPRESSION;
  }
  if (kNEW == tokenType) {
    PsiBuilder.Marker marker=builder.mark();
    final GroovyElementType type=newExprParse(builder,parser);
    marker.done(type);
    return type;
  }
  if (mIDENT == tokenType || kSUPER == tokenType || kTHIS == tokenType) {
    ParserUtils.eatElement(builder,REFERENCE_EXPRESSION);
    return REFERENCE_EXPRESSION;
  }
  if (mGSTRING_BEGIN == tokenType) {
    final boolean result=CompoundStringExpression.parse(builder,parser,false,mGSTRING_BEGIN,mGSTRING_CONTENT,mGSTRING_END,null,GSTRING,GroovyBundle.message("string.end.expected"));
    return result ? GSTRING : LITERAL;
  }
  if (mREGEX_BEGIN == tokenType) {
    CompoundStringExpression.parse(builder,parser,false,mREGEX_BEGIN,mREGEX_CONTENT,mREGEX_END,mREGEX_LITERAL,REGEX,GroovyBundle.message("regex.end.expected"));
    return REGEX;
  }
  if (mDOLLAR_SLASH_REGEX_BEGIN == tokenType) {
    CompoundStringExpression.parse(builder,parser,false,mDOLLAR_SLASH_REGEX_BEGIN,mDOLLAR_SLASH_REGEX_CONTENT,mDOLLAR_SLASH_REGEX_END,mDOLLAR_SLASH_REGEX_LITERAL,REGEX,GroovyBundle.message("dollar.slash.end.expected"));
    return REGEX;
  }
  if (mLBRACK == tokenType) {
    return ListOrMapConstructorExpression.parse(builder,parser);
  }
  if (mLPAREN == tokenType) {
    return parenthesizedExprParse(builder,parser);
  }
  if (mLCURLY == tokenType) {
    return OpenOrClosableBlock.parseClosableBlock(builder,parser);
  }
  if (tokenType == mSTRING_LITERAL || tokenType == mGSTRING_LITERAL) {
    return ParserUtils.eatElement(builder,literalsAsRefExprs ? REFERENCE_EXPRESSION : LITERAL);
  }
  if (TokenSets.CONSTANTS.contains(tokenType)) {
    return ParserUtils.eatElement(builder,LITERAL);
  }
  return WRONGWAY;
}
