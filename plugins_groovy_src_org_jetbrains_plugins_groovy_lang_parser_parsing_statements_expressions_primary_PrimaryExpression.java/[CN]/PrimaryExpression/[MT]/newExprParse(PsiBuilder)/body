{
  PsiBuilder.Marker marker=builder.mark();
  ParserUtils.getToken(builder,kNEW);
  ParserUtils.getToken(builder,mNLS);
  PsiBuilder.Marker rb=builder.mark();
  TypeArguments.parse(builder);
  if (!TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType()) && !mIDENT.equals(builder.getTokenType())) {
    rb.rollbackTo();
  }
 else {
    rb.drop();
  }
  if (TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,BUILT_IN_TYPE);
  }
 else   if (mIDENT.equals(builder.getTokenType())) {
    ReferenceElement.parseReferenceElement(builder);
  }
 else {
    builder.error(GroovyBundle.message("type.specification.expected"));
    marker.done(NEW_EXPRESSION);
    return NEW_EXPRESSION;
  }
  if (builder.getTokenType() == mLPAREN || ParserUtils.lookAhead(builder,mNLS,mLPAREN)) {
    ParserUtils.getToken(builder,mNLS);
    methodCallArgsParse(builder);
    if (builder.getTokenType() == mLCURLY || ParserUtils.lookAhead(builder,mNLS,mLCURLY)) {
      ParserUtils.getToken(builder,mNLS);
      OpenOrClosableBlock.parseClosableBlock(builder);
    }
  }
 else   if (builder.getTokenType() == mLBRACK) {
    PsiBuilder.Marker forArray=builder.mark();
    while (ParserUtils.getToken(builder,mLBRACK)) {
      ParserUtils.getToken(builder,mNLS);
      AssignmentExpression.parse(builder);
      ParserUtils.getToken(builder,mNLS);
      ParserUtils.getToken(builder,mRBRACK,GroovyBundle.message("rbrack.expected"));
    }
    forArray.done(ARRAY_DECLARATOR);
  }
 else {
    builder.error(GroovyBundle.message("lparen.expected"));
  }
  marker.done(NEW_EXPRESSION);
  return NEW_EXPRESSION;
}
