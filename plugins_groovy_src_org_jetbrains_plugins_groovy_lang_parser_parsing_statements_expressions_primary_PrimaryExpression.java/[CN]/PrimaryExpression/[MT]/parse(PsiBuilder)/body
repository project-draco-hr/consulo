{
  if (TokenSets.BUILT_IN_TYPE.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,BUILT_IN_TYPE_EXPRESSION);
    return true;
  }
  if (kTHIS.equals(builder.getTokenType())) {
    ParserUtils.eatElement(builder,THIS_REFERENCE_EXPRESSION);
    return true;
  }
  if (kSUPER.equals(builder.getTokenType())) {
    ParserUtils.eatElement(builder,SUPER_REFERENCE_EXPRESSION);
    return true;
  }
  if (kNEW.equals(builder.getTokenType())) {
    newExprParse(builder);
    return true;
  }
  if (mIDENT.equals(builder.getTokenType())) {
    ParserUtils.eatElement(builder,REFERENCE_EXPRESSION);
    return true;
  }
  if (mGSTRING_SINGLE_BEGIN.equals(builder.getTokenType())) {
    StringConstructorExpression.parse(builder);
    return true;
  }
  if (mREGEX_BEGIN.equals(builder.getTokenType())) {
    RegexConstructorExpression.parse(builder);
    return true;
  }
  if (mLBRACK.equals(builder.getTokenType())) {
    ListOrMapConstructorExpression.parse(builder);
    return true;
  }
  if (mLPAREN.equals(builder.getTokenType())) {
    return parenthesizedExprParse(builder);
  }
  if (mLCURLY.equals(builder.getTokenType())) {
    OpenOrClosableBlock.parseClosableBlock(builder);
    return true;
  }
  if (TokenSets.CONSTANTS.contains(builder.getTokenType())) {
    ParserUtils.eatElement(builder,LITERAL);
    return true;
  }
  if (TokenSets.WRONG_CONSTANTS.contains(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    builder.advanceLexer();
    builder.error(GroovyBundle.message("wrong.string"));
    marker.done(LITERAL);
    return true;
  }
  return false;
}
