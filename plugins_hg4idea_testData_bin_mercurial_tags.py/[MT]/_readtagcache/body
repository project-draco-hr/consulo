def _readtagcache(ui, repo):
    'Read the tag cache and return a tuple (heads, fnodes, cachetags,\n    shouldwrite).  If the cache is completely up-to-date, cachetags is a\n    dict of the form returned by _readtags(); otherwise, it is None and\n    heads and fnodes are set.  In that case, heads is the list of all\n    heads currently in the repository (ordered from tip to oldest) and\n    fnodes is a mapping from head to .hgtags filenode.  If those two are\n    set, caller is responsible for reading tag info from each head.'
    try:
        cachefile = repo.opener('tags.cache', 'r')
        cachelines = iter(cachefile)
        _debug(ui, ('reading tag cache from %s\n' % cachefile.name))
    except IOError:
        cachefile = None
    cacherevs = []
    cacheheads = []
    cachefnode = {}
    if cachefile:
        for line in cachelines:
            if (line == '\n'):
                break
            line = line.rstrip().split()
            cacherevs.append(int(line[0]))
            headnode = bin(line[1])
            cacheheads.append(headnode)
            if (len(line) == 3):
                fnode = bin(line[2])
                cachefnode[headnode] = fnode
    tipnode = repo.changelog.tip()
    tiprev = (len(repo.changelog) - 1)
    if (cacheheads and (cacheheads[0] == tipnode) and (cacherevs[0] == tiprev)):
        _debug(ui, 'tag cache: tip unchanged\n')
        tags = _readtags(ui, repo, cachelines, cachefile.name)
        cachefile.close()
        return (None, None, tags, False)
    if cachefile:
        cachefile.close()
    repoheads = repo.heads()
    if (repoheads == [nullid]):
        return ([], {}, {}, False)
    if (not cacheheads):
        _debug(ui, 'tag cache: cache file missing or empty\n')
    elif (cacheheads and (tiprev < cacherevs[0])):
        _debug(ui, ('tag cache: tip rev decremented (from %d to %d), so we must be destroying nodes\n' % (cacherevs[0], tiprev)))
    else:
        _debug(ui, ('tag cache: tip has changed (%d:%s); must find new heads\n' % (tiprev, short(tipnode))))
    newheads = [head for head in repoheads if (head not in set(cacheheads))]
    _debug(ui, ('tag cache: found %d head(s) not in cache: %s\n' % (len(newheads), map(short, newheads))))
    for head in newheads:
        cctx = repo[head]
        try:
            fnode = cctx.filenode('.hgtags')
            cachefnode[head] = fnode
        except error.LookupError:
            pass
    return (repoheads, cachefnode, None, True)
