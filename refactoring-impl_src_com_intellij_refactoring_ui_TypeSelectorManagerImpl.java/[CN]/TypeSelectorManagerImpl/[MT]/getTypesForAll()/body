{
  final ArrayList<ExpectedTypeInfo[]> expectedTypesFromAll=new ArrayList<ExpectedTypeInfo[]>();
  for (  PsiExpression occurence : myOccurences) {
    final ExpectedTypeInfo[] expectedTypes=myExpectedTypesProvider.getExpectedTypes(occurence,false,myOccurrenceClassProvider);
    if (expectedTypes.length > 0) {
      expectedTypesFromAll.add(expectedTypes);
    }
  }
  final ArrayList<PsiType> allowedTypes=new ArrayList<PsiType>();
  RefactoringHierarchyUtil.processSuperTypes(myDefaultType,new RefactoringHierarchyUtil.SuperTypeVisitor(){
    public void visitType(    PsiType aType){
      checkIfAllowed(aType);
    }
    public void visitClass(    PsiClass aClass){
      checkIfAllowed(myFactory.createType(aClass));
    }
    private void checkIfAllowed(    PsiType type){
      final ExpectedTypeInfo typeInfo=myExpectedTypesProvider.createInfo(type,ExpectedTypeInfo.TYPE_STRICTLY,type,TailType.NONE);
      for (      ExpectedTypeInfo[] expectedTypes : expectedTypesFromAll) {
        boolean validFound=false;
        for (        ExpectedTypeInfo expectedType : expectedTypes) {
          if (expectedType.intersect(typeInfo).length != 0) {
            validFound=true;
            break;
          }
        }
        if (!validFound)         return;
      }
      allowedTypes.add(type);
    }
  }
);
  final ArrayList<PsiType> result=normalizeTypeList(allowedTypes);
  return result.toArray(new PsiType[result.size()]);
}
