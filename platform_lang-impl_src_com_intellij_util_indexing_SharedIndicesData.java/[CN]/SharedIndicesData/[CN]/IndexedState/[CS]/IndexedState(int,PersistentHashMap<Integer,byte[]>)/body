{
  this.fileOrContentId=fileOrContentId;
  this.storage=storage;
  byte[] bytes=storage.get(fileOrContentId);
  if (bytes == null) {
    return;
  }
  DataInputStream stream=new DataInputStream(new UnsyncByteArrayInputStream(bytes));
  boolean compactNecessary=false;
  TIntLongHashMap stateMap=null;
  while (stream.available() > 0) {
    int chunkSize=DataInputOutputUtil.readINT(stream);
    int chunkIndexId=DataInputOutputUtil.readINT(stream);
    long chunkIndexTimeStamp=DataInputOutputUtil.readTIME(stream);
    int currentOffset=bytes.length - stream.available();
    ID<?,?> chunkIndexID;
    if (((chunkIndexID=ID.findById(chunkIndexId)) != null && chunkIndexTimeStamp == IndexingStamp.getIndexCreationStamp(chunkIndexID))) {
      if (chunkSize != 0) {
        if (stateMap == null)         stateMap=new TIntLongHashMap();
        stateMap.put(chunkIndexId,(((long)currentOffset) << 32) | chunkSize);
      }
 else       if (stateMap != null) {
        stateMap.remove(chunkIndexId);
        compactNecessary=true;
      }
    }
 else {
      compactNecessary=true;
    }
    stream.skipBytes(chunkSize);
  }
  values=bytes;
  this.compactNecessary=compactNecessary;
  indexId2Offset=stateMap;
}
