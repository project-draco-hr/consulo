{
  LOG.assertTrue(!PsiDocumentManager.getInstance(project).hasUncommitedDocuments());
  PsiMethod method;
  if (expr != null) {
    method=Util.getContainingMethod(expr);
  }
 else {
    method=Util.getContainingMethod(localVar);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + expr);
  }
  myProject=project;
  if (expr == null && localVar == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.block.should.represent.an.expression"));
    CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.INTRODUCE_PARAMETER,myProject);
    return false;
  }
  if (method == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("is.not.supported.in.the.current.context",REFACTORING_NAME));
    CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.INTRODUCE_PARAMETER,myProject);
    return false;
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,method))   return false;
  final PsiType typeByExpression=!invokedOnDeclaration ? RefactoringUtil.getTypeByExpressionWithExpectedType(expr) : null;
  if (!invokedOnDeclaration && typeByExpression == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("type.of.the.selected.expression.cannot.be.determined"));
    CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.INTRODUCE_PARAMETER,myProject);
    return false;
  }
  if (!invokedOnDeclaration && typeByExpression == PsiType.VOID) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.INTRODUCE_PARAMETER,project);
    return false;
  }
  final List<PsiMethod> validEnclosingMethods=getEnclosingMethods(method);
  if (validEnclosingMethods.size() > 1 && !ApplicationManager.getApplication().isUnitTestMode()) {
    final EnclosingMethodSelectionDialog dialog=new EnclosingMethodSelectionDialog(project,validEnclosingMethods);
    dialog.show();
    if (!dialog.isOK())     return false;
    method=dialog.getSelectedMethod();
  }
 else   if (validEnclosingMethods.size() == 1) {
    method=validEnclosingMethods.get(0);
  }
  final PsiMethod methodToSearchFor=SuperMethodWarningUtil.checkSuperMethod(method,RefactoringBundle.message("to.refactor"));
  if (methodToSearchFor == null)   return false;
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,methodToSearchFor))   return false;
  TIntArrayList parametersToRemove=expr == null ? new TIntArrayList() : Util.findParametersToRemove(method,expr);
  PsiExpression[] occurences;
  if (expr != null) {
    occurences=CodeInsightUtil.findExpressionOccurrences(method,expr);
  }
 else {
    occurences=CodeInsightUtil.findReferenceExpressions(method,localVar);
  }
  if (editor != null) {
    RefactoringUtil.highlightAllOccurences(myProject,occurences,editor);
  }
  boolean mustBeFinal=false;
  if (localVar != null) {
    for (    PsiExpression occurrence : occurences) {
      if (PsiTreeUtil.getParentOfType(occurrence,PsiClass.class,PsiMethod.class) != method) {
        mustBeFinal=true;
        break;
      }
    }
  }
  List<UsageInfo> localVars=new ArrayList<UsageInfo>();
  List<UsageInfo> classMemberRefs=new ArrayList<UsageInfo>();
  List<UsageInfo> params=new ArrayList<UsageInfo>();
  if (expr != null) {
    Util.analyzeExpression(expr,localVars,classMemberRefs,params);
  }
  if (expr instanceof PsiReferenceExpression) {
    PsiElement resolved=((PsiReferenceExpression)expr).resolve();
    if (resolved instanceof PsiLocalVariable) {
      localVar=(PsiLocalVariable)resolved;
    }
  }
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    @NonNls String parameterName="anObject";
    boolean replaceAllOccurences=true;
    boolean isDeleteLocalVariable=true;
    PsiExpression initializer=localVar != null && expr == null ? localVar.getInitializer() : expr;
    new IntroduceParameterProcessor(myProject,method,methodToSearchFor,initializer,expr,localVar,isDeleteLocalVariable,parameterName,replaceAllOccurences,IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE,mustBeFinal,false,null,parametersToRemove).run();
  }
 else {
    final String propName=localVar != null ? JavaCodeStyleManager.getInstance(myProject).variableNameToPropertyName(localVar.getName(),VariableKind.LOCAL_VARIABLE) : null;
    final PsiType initializerType=IntroduceParameterProcessor.getInitializerType(null,expr,localVar);
    TypeSelectorManager typeSelectorManager=expr != null ? new TypeSelectorManagerImpl(project,initializerType,expr,occurences) : new TypeSelectorManagerImpl(project,initializerType,occurences);
    NameSuggestionsGenerator nameSuggestionsGenerator=new NameSuggestionsGenerator(){
      public SuggestedNameInfo getSuggestedNameInfo(      PsiType type){
        return JavaCodeStyleManager.getInstance(myProject).suggestVariableName(VariableKind.PARAMETER,propName,expr,type);
      }
      public Pair<LookupItemPreferencePolicy,Set<LookupItem>> completeVariableName(      String prefix,      PsiType type){
        LinkedHashSet<LookupItem> set=new LinkedHashSet<LookupItem>();
        LookupItemPreferencePolicy policy=CompletionUtil.completeVariableNameForRefactoring(myProject,set,prefix,type,VariableKind.PARAMETER);
        return new Pair<LookupItemPreferencePolicy,Set<LookupItem>>(policy,set);
      }
    }
;
    new IntroduceParameterDialog(myProject,classMemberRefs,occurences.length,localVar,expr,nameSuggestionsGenerator,typeSelectorManager,methodToSearchFor,method,parametersToRemove,mustBeFinal).show();
  }
  return true;
}
