{
  if (!myRecentlyUpdatedFiles.isEmpty()) {
    myResolveWorker.execute(myRecentlyUpdatedFiles);
  }
  final boolean haveConflicts=ResolveWorker.haveUnresolvedConflicts(myRecentlyUpdatedFiles);
  accomulate();
  if ((!myMerger.hasNext()) || haveConflicts || (!myExceptions.isEmpty())|| myAccomulatedFiles.containErrors()|| wasCanceled) {
    initMergeTarget();
    if (myAccomulatedFiles.isEmpty() && myExceptions.isEmpty() && (myMergeTarget == null)&& (!wasCanceled)) {
      Messages.showMessageDialog(SvnBundle.message("action.Subversion.integrate.changes.message.files.up.to.date.text"),myTitle,Messages.getInformationIcon());
    }
 else {
      if (haveConflicts) {
        final VcsException exception=new VcsException(SvnBundle.message("svn.integrate.changelist.warning.unresolved.conflicts.text"));
        exception.setIsWarning(true);
        myExceptions.add(exception);
      }
      if (wasCanceled) {
        final List<String> details=new LinkedList<String>();
        details.add("Integration was canceled");
        myMerger.getSkipped(new Consumer<String>(){
          public void consume(          String s){
            if (!StringUtil.isEmptyOrSpaces(s)) {
              details.add(s);
            }
          }
        }
);
        final VcsException exception=new VcsException(details);
        exception.setIsWarning(true);
        myExceptions.add(exception);
      }
      finishActions(wasCanceled);
    }
    myMerger.afterProcessing();
  }
 else {
    stepToNextChangeList();
  }
}
