{
  int x=0;
  if (lineStartOffset == 0 && myPrefixText != null) {
    for (    char c : myPrefixText) {
      x+=EditorUtil.charWidth(c,myPrefixAttributes.getFontType(),this);
    }
  }
  if (pos.column == 0)   return x;
  int offset=lineStartOffset;
  CharSequence text=myDocument.getCharsNoThreadCheck();
  int textLength=myDocument.getTextLength();
  IterationState state=new IterationState(this,offset,false);
  int fontType=state.getMergedAttributes().getFontType();
  int spaceSize=EditorUtil.getSpaceWidth(fontType,this);
  int column=0;
  outer:   while (column < pos.column) {
    if (offset >= textLength)     break;
    if (offset >= state.getEndOffset()) {
      state.advance();
      fontType=state.getMergedAttributes().getFontType();
    }
    FoldRegion region=state.getCurrentFold();
    if (region != null) {
      char[] placeholder=region.getPlaceholderText().toCharArray();
      for (      char aPlaceholder : placeholder) {
        x+=EditorUtil.charWidth(aPlaceholder,fontType,this);
        column++;
        if (column >= pos.column)         break outer;
      }
      offset=region.getEndOffset();
    }
 else {
      char c=text.charAt(offset);
      if (c == '\n') {
        break;
      }
      if (c == '\t') {
        int prevX=x;
        x=EditorUtil.nextTabStop(x,this);
        column+=(x - prevX) / spaceSize;
      }
 else {
        x+=EditorUtil.charWidth(c,fontType,this);
        column++;
      }
      offset++;
    }
  }
  if (column != pos.column) {
    x+=EditorUtil.getSpaceWidth(fontType,this) * (pos.column - column);
  }
  return x;
}
