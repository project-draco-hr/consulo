{
  int endX=x;
  if (start < end) {
    FontInfo font=EditorUtil.fontForChar(text[start],fontType,this);
    for (int j=start; j < end; j++) {
      final char c=text[j];
      FontInfo newFont=EditorUtil.fontForChar(c,fontType,this);
      if (font != newFont || endX > clip.x + clip.width) {
        if (!(x < clip.x && endX < clip.x || x > clip.x + clip.width && endX > clip.x + clip.width)) {
          drawCharsCached(g,text,start,j,x,y,fontType,fontColor);
        }
        start=j;
        x=endX;
        font=newFont;
      }
      if (x < clip.x && endX < clip.x) {
        start=j;
        x=endX;
        font=newFont;
      }
 else       if (x > clip.x + clip.width) {
        return endX;
      }
      final int charWidth=font.charWidth(c,myEditorComponent);
      if (c == ' ' && myCommonSpaceWidth > 0 && myLastCache != null && (charWidth != myCommonSpaceWidth || charWidth != myLastCache.spaceWidth)) {
        myForceRefreshFont=true;
      }
      endX+=charWidth;
      if (newFont.hasGlyphsToBreakDrawingIteration() && newFont.getSymbolsToBreakDrawingIteration().contains(c)) {
        drawCharsCached(g,text,start,j + 1,x,y,fontType,fontColor);
        x=endX;
        start=j + 1;
      }
    }
    if (!(x < clip.x && endX < clip.x || x > clip.x + clip.width && endX > clip.x + clip.width)) {
      drawCharsCached(g,text,start,end,x,y,fontType,fontColor);
    }
  }
  return endX;
}
