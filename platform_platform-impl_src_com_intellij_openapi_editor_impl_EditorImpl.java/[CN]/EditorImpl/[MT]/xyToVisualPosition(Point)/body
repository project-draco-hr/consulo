{
  int line=yPositionToVisibleLineNumber(p.y);
  int px=p.x;
  if (line == 0 && myPrefixText != null) {
    for (    char c : myPrefixText) {
      px-=EditorUtil.charWidth(c,myPrefixAttributes.getFontType(),this);
    }
  }
  LogicalPosition logicalPosition=visualToLogicalPosition(new VisualPosition(line,0));
  int offset=logicalPositionToOffset(logicalPosition);
  int textLength=myDocument.getTextLength();
  if (offset >= textLength)   return new VisualPosition(line,0);
  boolean activeSoftWrapProcessed=true;
  if (logicalPosition.softWrapLinesOnCurrentLogicalLine > 0) {
    activeSoftWrapProcessed=false;
  }
  int column=0;
  int prevX=0;
  CharSequence text=myDocument.getCharsNoThreadCheck();
  char c=' ';
  IterationState state=new IterationState(this,offset,false);
  int fontType=state.getMergedAttributes().getFontType();
  int spaceSize=EditorUtil.getSpaceWidth(fontType,this);
  int x=0;
  int charWidth;
  outer:   while (true) {
    charWidth=-1;
    if (offset >= textLength) {
      break;
    }
    if (offset >= state.getEndOffset()) {
      state.advance();
      fontType=state.getMergedAttributes().getFontType();
    }
    FoldRegion region=state.getCurrentFold();
    if (region != null) {
      char[] placeholder=region.getPlaceholderText().toCharArray();
      for (      char aPlaceholder : placeholder) {
        c=aPlaceholder;
        x+=EditorUtil.charWidth(c,fontType,this);
        if (x >= px) {
          break outer;
        }
        column++;
      }
      offset=region.getEndOffset();
    }
 else {
      TextChange softWrap=mySoftWrapModel.getSoftWrap(offset);
      if (softWrap != null) {
        int softWrapLinesToSkip=activeSoftWrapProcessed ? 0 : logicalPosition.softWrapLinesOnCurrentLogicalLine;
        if (softWrapLinesToSkip <= 0) {
          prevX=x;
          charWidth=getSoftWrapModel().getMinDrawingWidthInPixels(SoftWrapDrawingType.BEFORE_SOFT_WRAP_LINE_FEED);
          x+=charWidth;
          if (x >= px) {
            break outer;
          }
          column++;
        }
        CharSequence softWrapText=softWrap.getText();
        for (int i=0; i < softWrapText.length(); i++) {
          c=softWrapText.charAt(i);
          if (softWrapLinesToSkip > 0) {
            if (c == '\n') {
              softWrapLinesToSkip--;
            }
            continue;
          }
          prevX=x;
          charWidth=charToVisibleWidth(c,fontType,x);
          if (charWidth == 0) {
            charWidth=spaceSize;
            break outer;
          }
          x+=charWidth;
          if (x >= px) {
            break outer;
          }
          column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
        }
        activeSoftWrapProcessed=true;
        prevX=x;
        charWidth=mySoftWrapModel.getMinDrawingWidthInPixels(SoftWrapDrawingType.AFTER_SOFT_WRAP);
        x+=charWidth;
        if (x >= px) {
          break outer;
        }
        column++;
      }
      prevX=x;
      c=text.charAt(offset);
      charWidth=charToVisibleWidth(c,fontType,x);
      if (charWidth == 0) {
        break;
      }
      x+=charWidth;
      if (x >= px) {
        break;
      }
      column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
      offset++;
    }
  }
  if (charWidth < 0) {
    charWidth=EditorUtil.charWidth(c,fontType,this);
  }
  if (x >= px && c == '\t') {
    if (mySettings.isCaretInsideTabs()) {
      column+=(px - prevX) / spaceSize;
      if ((px - prevX) % spaceSize > spaceSize / 2)       column++;
    }
 else     if ((x - px) * 2 < x - prevX) {
      column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
    }
  }
 else {
    if (x >= px) {
      if ((x - px) * 2 < charWidth)       column++;
    }
 else {
      column+=(px - x) / spaceSize;
      if ((px - x) * 2 >= spaceSize) {
        column++;
      }
    }
  }
  return new VisualPosition(line,column);
}
