{
  int line=yPositionToVisibleLine(p.y);
  int px=p.x;
  if (line == 0 && myPrefixText != null) {
    px-=myPrefixWidthInPixels;
  }
  int textLength=myDocument.getTextLength();
  LogicalPosition logicalPosition=visualToLogicalPosition(new VisualPosition(line,0));
  int offset=logicalPositionToOffset(logicalPosition);
  if (offset >= textLength)   return new VisualPosition(line,EditorUtil.columnsNumber(p.x,EditorUtil.getSpaceWidth(Font.PLAIN,this)));
  boolean activeSoftWrapProcessed=logicalPosition.softWrapLinesOnCurrentLogicalLine <= 0;
  CharSequence text=myDocument.getCharsNoThreadCheck();
  LogicalPosition endLogicalPosition=visualToLogicalPosition(new VisualPosition(line + 1,0));
  int endOffset=logicalPositionToOffset(endLogicalPosition);
  if (offset > endOffset) {
    LogMessageEx.error(LOG,"Detected invalid (x; y)->VisualPosition processing",String.format("Given point: %s, mapped to visual line %d. Visual(%d; %d) is mapped to " + "logical position '%s' which is mapped to offset %d (start offset). Visual(%d; %d) is mapped to logical '%s' which is mapped " + "to offset %d (end offset). State: %s",p,line,line,0,logicalPosition,offset,line + 1,0,endLogicalPosition,endOffset,dumpState()));
    return new VisualPosition(line,EditorUtil.columnsNumber(p.x,EditorUtil.getSpaceWidth(Font.PLAIN,this)));
  }
  IterationState state=new IterationState(this,offset,endOffset,false);
  try {
    int fontType=state.getMergedAttributes().getFontType();
    int spaceSize=EditorUtil.getSpaceWidth(fontType,this);
    int x=0;
    int charWidth;
    boolean onSoftWrapDrawing=false;
    char c=' ';
    int prevX=0;
    int column=0;
    outer:     while (true) {
      charWidth=-1;
      if (offset >= textLength) {
        break;
      }
      if (offset >= state.getEndOffset()) {
        state.advance();
        fontType=state.getMergedAttributes().getFontType();
      }
      SoftWrap softWrap=mySoftWrapModel.getSoftWrap(offset);
      if (softWrap != null) {
        if (activeSoftWrapProcessed) {
          prevX=x;
          charWidth=getSoftWrapModel().getMinDrawingWidthInPixels(SoftWrapDrawingType.BEFORE_SOFT_WRAP_LINE_FEED);
          x+=charWidth;
          if (x >= px) {
            onSoftWrapDrawing=true;
          }
 else {
            column++;
          }
          break outer;
        }
 else {
          CharSequence softWrapText=softWrap.getText();
          for (int i=1; i < softWrapText.length(); i++) {
            c=softWrapText.charAt(i);
            prevX=x;
            charWidth=charToVisibleWidth(c,fontType,x);
            x+=charWidth;
            if (x >= px) {
              break outer;
            }
            column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
          }
          prevX=x;
          charWidth=mySoftWrapModel.getMinDrawingWidthInPixels(SoftWrapDrawingType.AFTER_SOFT_WRAP);
          x+=charWidth;
          if (x >= px) {
            onSoftWrapDrawing=true;
            break outer;
          }
          column++;
          activeSoftWrapProcessed=true;
        }
      }
      FoldRegion region=state.getCurrentFold();
      if (region != null) {
        char[] placeholder=region.getPlaceholderText().toCharArray();
        for (        char aPlaceholder : placeholder) {
          c=aPlaceholder;
          x+=EditorUtil.charWidth(c,fontType,this);
          if (x >= px) {
            break outer;
          }
          column++;
        }
        offset=region.getEndOffset();
      }
 else {
        prevX=x;
        c=text.charAt(offset);
        charWidth=charToVisibleWidth(c,fontType,x);
        if (charWidth == 0) {
          break;
        }
        x+=charWidth;
        if (x >= px) {
          break;
        }
        column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
        offset++;
      }
    }
    if (charWidth < 0) {
      charWidth=EditorUtil.charWidth(c,fontType,this);
    }
    if (charWidth < 0) {
      charWidth=spaceSize;
    }
    if (x >= px && c == '\t' && !onSoftWrapDrawing) {
      if (mySettings.isCaretInsideTabs()) {
        column+=(px - prevX) / spaceSize;
        if ((px - prevX) % spaceSize > spaceSize / 2)         column++;
      }
 else       if ((x - px) * 2 < x - prevX) {
        column+=EditorUtil.columnsNumber(c,x,prevX,spaceSize);
      }
    }
 else {
      if (x >= px) {
        if ((x - px) * 2 < charWidth)         column++;
      }
 else {
        int diff=px - x;
        column+=diff / spaceSize;
        if (diff % spaceSize * 2 >= spaceSize) {
          column++;
        }
      }
    }
    return new VisualPosition(line,column);
  }
  finally {
    state.dispose();
  }
}
