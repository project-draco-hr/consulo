{
  myCurrentFontType=null;
  myLastCache=null;
  final int plainSpaceWidth=EditorUtil.getSpaceWidth(Font.PLAIN,this);
  final int boldSpaceWidth=EditorUtil.getSpaceWidth(Font.BOLD,this);
  final int italicSpaceWidth=EditorUtil.getSpaceWidth(Font.ITALIC,this);
  final int boldItalicSpaceWidth=EditorUtil.getSpaceWidth(Font.BOLD | Font.ITALIC,this);
  mySpacesHaveSameWidth=plainSpaceWidth == boldSpaceWidth && plainSpaceWidth == italicSpaceWidth && plainSpaceWidth == boldItalicSpaceWidth;
  int lineHeight=getLineHeight();
  int visibleLineNumber=clip.y / lineHeight;
  LogicalPosition logicalPosition=xyToLogicalPosition(new Point(0,clip.y));
  int startLineNumber=logicalPosition.line;
  Point position=new Point(0,visibleLineNumber * lineHeight);
  if (startLineNumber == 0 && myPrefixText != null) {
    position.x=drawString(g,myPrefixText,0,myPrefixText.length,position,clip,myPrefixAttributes.getEffectColor(),myPrefixAttributes.getEffectType(),myPrefixAttributes.getFontType(),myPrefixAttributes.getForegroundColor());
  }
  if (startLineNumber >= myDocument.getLineCount() || startLineNumber < 0) {
    if (position.x > 0)     flushCachedChars(g);
    return;
  }
  boolean activeSoftWrapProcessed=true;
  int start=myDocument.getLineStartOffset(startLineNumber);
  if (logicalPosition.isOnSoftWrappedLine()) {
    start=logicalPositionToOffset(logicalPosition);
    activeSoftWrapProcessed=false;
  }
  IterationState iterationState=new IterationState(this,start,paintSelection());
  LineIterator lIterator=createLineIterator();
  lIterator.start(start);
  if (lIterator.atEnd()) {
    return;
  }
  TextAttributes attributes=iterationState.getMergedAttributes();
  Color currentColor=attributes.getForegroundColor();
  if (currentColor == null) {
    currentColor=getForegroundColor();
  }
  Color effectColor=attributes.getEffectColor();
  EffectType effectType=attributes.getEffectType();
  int fontType=attributes.getFontType();
  g.setColor(currentColor);
  final char[] chars=myDocument.getRawChars();
  while (!iterationState.atEnd() && !lIterator.atEnd()) {
    int hEnd=iterationState.getEndOffset();
    int lEnd=lIterator.getEnd();
    if (hEnd >= lEnd) {
      FoldRegion collapsedFolderAt=myFoldingModel.getCollapsedRegionAtOffset(start);
      if (collapsedFolderAt == null) {
        drawString(g,chars,start,lEnd - lIterator.getSeparatorLength(),position,clip,effectColor,effectType,fontType,currentColor);
        position.x=0;
        if (position.y > clip.y + clip.height) {
          break;
        }
        position.y+=lineHeight;
        start=lEnd;
      }
      lIterator.advance();
    }
 else {
      FoldRegion collapsedFolderAt=iterationState.getCurrentFold();
      if (collapsedFolderAt != null) {
        int foldingXStart=position.x;
        position.x=drawString(g,collapsedFolderAt.getPlaceholderText(),position,clip,effectColor,effectType,fontType,currentColor);
        BorderEffect.paintFoldedEffect(g,foldingXStart,position.y,position.x,getLineHeight(),effectColor,effectType);
      }
 else {
        if (hEnd > lEnd - lIterator.getSeparatorLength()) {
          position.x=drawString(g,chars,start,lEnd - lIterator.getSeparatorLength(),position,clip,effectColor,effectType,fontType,currentColor);
        }
 else {
          boolean breakWholeIteration=false;
          if (mySoftWrapModel.shouldWrap(chars,start,hEnd,position)) {
            TextChange softWrap=mySoftWrapModel.wrap(start);
            int softWrapLinesToSkip=activeSoftWrapProcessed ? 0 : logicalPosition.linesFromActiveSoftWrap;
            char[] softWrapChars=softWrap.getChars();
            int softWrapSegmentStartIndex=0;
            for (int i=0; i < softWrapChars.length; i++) {
              if (softWrapChars[i] != '\n') {
                continue;
              }
              if (softWrapLinesToSkip-- > 0) {
                position.x=0;
                softWrapSegmentStartIndex=i + 1;
                continue;
              }
              if (i - softWrapSegmentStartIndex > 0) {
                drawString(g,softWrapChars,softWrapSegmentStartIndex,i,position,clip,currentColor,effectType,fontType,currentColor);
              }
              position.x=0;
              if (position.y > clip.y + clip.height) {
                breakWholeIteration=true;
                break;
              }
              position.y+=lineHeight;
              softWrapSegmentStartIndex=i + 1;
            }
            if (softWrapSegmentStartIndex < softWrapChars.length - 1) {
              position.x+=drawString(g,softWrapChars,softWrapSegmentStartIndex,softWrapChars.length,position,clip,effectColor,effectType,fontType,currentColor);
            }
            activeSoftWrapProcessed=true;
          }
          if (breakWholeIteration) {
            break;
          }
          position.x=drawString(g,chars,start,hEnd,position,clip,effectColor,effectType,fontType,currentColor);
        }
      }
      iterationState.advance();
      attributes=iterationState.getMergedAttributes();
      currentColor=attributes.getForegroundColor();
      if (currentColor == null) {
        currentColor=getForegroundColor();
      }
      effectColor=attributes.getEffectColor();
      effectType=attributes.getEffectType();
      fontType=attributes.getFontType();
      start=iterationState.getStartOffset();
    }
  }
  FoldRegion collapsedFolderAt=iterationState.getCurrentFold();
  if (collapsedFolderAt != null) {
    int foldingXStart=position.x;
    int foldingXEnd=drawString(g,collapsedFolderAt.getPlaceholderText(),position,clip,effectColor,effectType,fontType,currentColor);
    BorderEffect.paintFoldedEffect(g,foldingXStart,position.y,foldingXEnd,getLineHeight(),effectColor,effectType);
  }
  flushCachedChars(g);
}
