{
  int x=xOffset;
  if (startOffset == 0 && myPrefixText != null) {
    x+=myPrefixWidthInPixels;
  }
  if (targetColumn <= 0)   return x;
  ++totals;
  for (int i=0; i < myLastStartOffsets.length; ++i) {
    if (startOffset == myLastStartOffsets[i] && targetColumn == myLastTargetColumns[i]) {
      ++hits;
      if ((hits & 0xFF) == 0) {
        PsiFile file=PsiDocumentManager.getInstance(myProject).getCachedPsiFile(myDocument);
        LOG.info("Hits:" + hits + ","+ totals+ ","+ (file != null ? file.getViewProvider().getVirtualFile() : null));
      }
      return myLastXs[i] + xOffset;
    }
  }
  int offset=startOffset;
  CharSequence text=myDocument.getCharsNoThreadCheck();
  int textLength=myDocument.getTextLength();
  IterationState state=new IterationState(this,startOffset,calcEndOffset(startOffset,targetColumn),false);
  try {
    int fontType=state.getMergedAttributes().getFontType();
    int spaceSize=EditorUtil.getSpaceWidth(fontType,this);
    int column=0;
    outer:     while (column < targetColumn) {
      if (offset >= textLength)       break;
      if (offset >= state.getEndOffset()) {
        state.advance();
        fontType=state.getMergedAttributes().getFontType();
      }
      SoftWrap softWrap=getSoftWrapModel().getSoftWrap(offset);
      if (softWrap != null && offset > startOffset) {
        column++;
        x+=getSoftWrapModel().getMinDrawingWidthInPixels(SoftWrapDrawingType.BEFORE_SOFT_WRAP_LINE_FEED);
        break;
      }
      FoldRegion region=state.getCurrentFold();
      if (region != null) {
        char[] placeholder=region.getPlaceholderText().toCharArray();
        for (        char aPlaceholder : placeholder) {
          x+=EditorUtil.charWidth(aPlaceholder,fontType,this);
          column++;
          if (column >= targetColumn)           break outer;
        }
        offset=region.getEndOffset();
      }
 else {
        char c=text.charAt(offset);
        if (c == '\n') {
          break;
        }
        if (c == '\t') {
          int prevX=x;
          x=EditorUtil.nextTabStop(x,this);
          int columnDiff=(x - prevX) / spaceSize;
          if ((x - prevX) % spaceSize > 0) {
            columnDiff++;
          }
          column+=columnDiff;
        }
 else {
          x+=EditorUtil.charWidth(c,fontType,this);
          column++;
        }
        offset++;
      }
    }
    if (column != targetColumn) {
      x+=EditorUtil.getSpaceWidth(fontType,this) * (targetColumn - column);
    }
    myLastTargetColumns[myLastPosition]=targetColumn;
    myLastStartOffsets[myLastPosition]=startOffset;
    myLastXs[myLastPosition]=x - xOffset;
    myLastPosition=(myLastPosition + 1) % myLastStartOffsets.length;
    return x;
  }
  finally {
    state.dispose();
  }
}
