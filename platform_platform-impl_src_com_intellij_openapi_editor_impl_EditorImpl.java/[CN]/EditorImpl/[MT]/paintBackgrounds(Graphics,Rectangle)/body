{
  Color defaultBackground=getBackgroundColor();
  g.setColor(defaultBackground);
  g.fillRect(clip.x,clip.y,clip.width,clip.height);
  int lineHeight=getLineHeight();
  int visibleLineNumber=clip.y / lineHeight;
  int startLineNumber=xyToLogicalPosition(new Point(0,clip.y)).line;
  Point position=new Point(0,visibleLineNumber * lineHeight);
  if (startLineNumber == 0 && myPrefixText != null) {
    position.x=drawBackground(g,myPrefixAttributes.getBackgroundColor(),new String(myPrefixText),position,myPrefixAttributes.getFontType(),defaultBackground,clip);
  }
  if (startLineNumber >= myDocument.getLineCount() || startLineNumber < 0) {
    if (position.x > 0)     flushBackground(g,clip);
    return;
  }
  int start=myDocument.getLineStartOffset(startLineNumber);
  IterationState iterationState=new IterationState(this,start,paintSelection());
  LineIterator lIterator=createLineIterator();
  lIterator.start(start);
  if (lIterator.atEnd()) {
    return;
  }
  myLastBackgroundPosition=null;
  myLastBackgroundColor=null;
  TextAttributes attributes=iterationState.getMergedAttributes();
  Color backColor=getBackgroundColor(attributes);
  int fontType=attributes.getFontType();
  CharSequence text=myDocument.getCharsNoThreadCheck();
  int lastLineIndex=Math.max(0,myDocument.getLineCount() - 1);
  outer:   while (!iterationState.atEnd() && !lIterator.atEnd()) {
    int hEnd=iterationState.getEndOffset();
    int lEnd=lIterator.getEnd();
    getSoftWrapModel().registerSoftWrapIfNecessary(myDocument.getRawChars(),start,hEnd,position.x,fontType);
    if (hEnd >= lEnd) {
      FoldRegion collapsedFolderAt=myFoldingModel.getCollapsedRegionAtOffset(start);
      if (collapsedFolderAt == null) {
        position.x=drawBackground(g,backColor,text.subSequence(start,lEnd - lIterator.getSeparatorLength()),position,fontType,defaultBackground,clip);
        if (lIterator.getLineNumber() < lastLineIndex) {
          if (backColor != null && !backColor.equals(defaultBackground)) {
            g.setColor(backColor);
            g.fillRect(position.x,position.y,clip.x + clip.width - position.x,lineHeight);
          }
        }
 else {
          paintAfterFileEndBackground(iterationState,g,position,clip,lineHeight,defaultBackground);
          break;
        }
        position.x=0;
        if (position.y > clip.y + clip.height)         break;
        position.y+=lineHeight;
        start=lEnd;
      }
      lIterator.advance();
    }
 else {
      FoldRegion collapsedFolderAt=iterationState.getCurrentFold();
      if (collapsedFolderAt != null) {
        position.x=drawBackground(g,backColor,collapsedFolderAt.getPlaceholderText(),position,fontType,defaultBackground,clip);
      }
 else {
        List<? extends TextChange> softWraps=getSoftWrapModel().getSoftWrapsForRange(start,hEnd);
        int startToUse=start;
        for (        TextChange softWrap : softWraps) {
          if (softWrap.getStart() > startToUse) {
            position.x=drawBackground(g,backColor,text.subSequence(startToUse,softWrap.getStart()),position,fontType,defaultBackground,clip);
          }
          startToUse=softWrap.getStart();
          CharSequence softWrapText=softWrap.getText();
          int softWrapStart=0;
          int softWrapEnd=0;
          while (softWrapEnd < softWrapText.length()) {
            for (; softWrapEnd < softWrapText.length() && softWrapText.charAt(softWrapEnd) != '\n'; softWrapEnd++)             ;
            if (softWrapEnd >= softWrapText.length()) {
              position.x=drawBackground(g,backColor,softWrapText.subSequence(softWrapStart,softWrapText.length()),position,fontType,defaultBackground,clip);
            }
 else {
              if (softWrapEnd > softWrapStart) {
                drawBackground(g,backColor,softWrapText.subSequence(softWrapStart,softWrapEnd - 1),position,fontType,defaultBackground,clip);
                if (backColor != null && !backColor.equals(defaultBackground)) {
                  g.setColor(backColor);
                  g.fillRect(position.x,position.y,clip.x + clip.width - position.x,lineHeight);
                }
              }
              if (position.y > clip.y + clip.height)               break outer;
              position.x=0;
              position.y+=lineHeight;
              softWrapStart=softWrapEnd + 1;
              softWrapEnd=softWrapStart;
            }
          }
        }
        if (startToUse < hEnd) {
          if (hEnd > lEnd - lIterator.getSeparatorLength()) {
            position.x=drawBackground(g,backColor,text.subSequence(startToUse,lEnd - lIterator.getSeparatorLength()),position,fontType,defaultBackground,clip);
          }
 else {
            position.x=drawBackground(g,backColor,text.subSequence(startToUse,hEnd),position,fontType,defaultBackground,clip);
          }
        }
      }
      iterationState.advance();
      attributes=iterationState.getMergedAttributes();
      backColor=getBackgroundColor(attributes);
      fontType=attributes.getFontType();
      start=iterationState.getStartOffset();
    }
  }
  flushBackground(g,clip);
  if (lIterator.getLineNumber() >= lastLineIndex && position.y <= clip.y + clip.height) {
    paintAfterFileEndBackground(iterationState,g,position,clip,lineHeight,defaultBackground);
  }
  if (mySoftWrapsChanged) {
    mySoftWrapsChanged=false;
    validateSize();
    repaintToScreenBottom(xyToLogicalPosition(position).line);
    myGutterComponent.repaint(0,clip.y,myGutterComponent.getWidth(),myGutterComponent.getHeight() - clip.y);
  }
}
