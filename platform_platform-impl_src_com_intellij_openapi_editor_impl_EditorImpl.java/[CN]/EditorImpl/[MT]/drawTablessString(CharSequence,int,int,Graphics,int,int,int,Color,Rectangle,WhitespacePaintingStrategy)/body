{
  int endX=x;
  if (start < end) {
    FontInfo font=null;
    boolean drawWhitespace=false;
    for (int j=start; j < end; j++) {
      if (x > clip.x + clip.width) {
        return endX;
      }
      final char c=text.charAt(j);
      FontInfo newFont=EditorUtil.fontForChar(c,fontType,this);
      boolean newDrawWhitespace=context.showWhitespaceAtOffset(j);
      boolean isRtlChar=myDisableRtl && isRtlCharacter(c);
      if (j > start && (endX < clip.x || endX > clip.x + clip.width || newFont != font || newDrawWhitespace != drawWhitespace || isRtlChar)) {
        if (isOverlappingRange(clip,x,endX)) {
          drawCharsCached(g,text,start,j,x,y,fontType,fontColor,drawWhitespace);
        }
        start=j;
        x=endX;
      }
      font=newFont;
      drawWhitespace=newDrawWhitespace;
      endX+=font.charWidth(c);
      if (font.hasGlyphsToBreakDrawingIteration() && font.getSymbolsToBreakDrawingIteration().contains(c) || isRtlChar) {
        drawCharsCached(g,text,start,j + 1,x,y,fontType,fontColor,drawWhitespace);
        start=j + 1;
        x=endX;
      }
    }
    if (isOverlappingRange(clip,x,endX)) {
      drawCharsCached(g,text,start,end,x,y,fontType,fontColor,drawWhitespace);
    }
  }
  return endX;
}
