{
  myInitialMouseEvent=e;
  if (myMouseSelectionState != MOUSE_SELECTION_STATE_NONE && System.currentTimeMillis() - myMouseSelectionChangeTimestamp > 1000) {
    setMouseSelectionState(MOUSE_SELECTION_STATE_NONE);
  }
  int x=e.getX();
  int y=e.getY();
  if (x < 0)   x=0;
  if (y < 0)   y=0;
  final EditorMouseEventArea eventArea=getMouseEventArea(e);
  if (eventArea == EditorMouseEventArea.FOLDING_OUTLINE_AREA) {
    final FoldRegion range=myGutterComponent.findFoldingAnchorAt(x,y);
    if (range != null) {
      final boolean expansion=!range.isExpanded();
      int scrollShift=y - getScrollingModel().getVerticalScrollOffset();
      Runnable processor=new Runnable(){
        public void run(){
          myFoldingModel.flushCaretShift();
          range.setExpanded(expansion);
        }
      }
;
      getFoldingModel().runBatchFoldingOperation(processor);
      y=myGutterComponent.getHeadCenterY(range);
      getScrollingModel().scrollVertically(y - scrollShift);
      return;
    }
  }
  if (e.getSource() == myGutterComponent) {
    if (eventArea == EditorMouseEventArea.LINE_MARKERS_AREA || eventArea == EditorMouseEventArea.ANNOTATIONS_AREA || eventArea == EditorMouseEventArea.LINE_NUMBERS_AREA) {
      myGutterComponent.mousePressed(e);
      if (e.isConsumed())       return;
    }
    x=0;
  }
  int oldSelectionStart=mySelectionModel.getLeadSelectionOffset();
  moveCaretToScreenPos(x,y);
  if (e.isPopupTrigger())   return;
  requestFocus();
  int caretOffset=getCaretModel().getOffset();
  myMouseSelectedRegion=myFoldingModel.getFoldingPlaceholderAt(new Point(x,y));
  myMousePressedInsideSelection=mySelectionModel.hasSelection() && caretOffset >= mySelectionModel.getSelectionStart() && caretOffset <= mySelectionModel.getSelectionEnd();
  if (!myMousePressedInsideSelection && mySelectionModel.hasBlockSelection()) {
    int[] starts=mySelectionModel.getBlockSelectionStarts();
    int[] ends=mySelectionModel.getBlockSelectionEnds();
    for (int i=0; i < starts.length; i++) {
      if (caretOffset >= starts[i] && caretOffset < ends[i]) {
        myMousePressedInsideSelection=true;
        break;
      }
    }
  }
  if (getMouseEventArea(e) == EditorMouseEventArea.LINE_NUMBERS_AREA && e.getClickCount() == 1) {
    mySelectionModel.selectLineAtCaret();
    setMouseSelectionState(MOUSE_SELECTION_STATE_LINE_SELECTED);
    mySavedSelectionStart=mySelectionModel.getSelectionStart();
    mySavedSelectionEnd=mySelectionModel.getSelectionEnd();
    return;
  }
  if (e.isShiftDown() && !e.isControlDown() && !e.isAltDown()) {
    if (getMouseSelectionState() != MOUSE_SELECTION_STATE_NONE) {
      if (caretOffset < mySavedSelectionStart) {
        mySelectionModel.setSelection(mySavedSelectionEnd,caretOffset);
      }
 else {
        mySelectionModel.setSelection(mySavedSelectionStart,caretOffset);
      }
    }
 else {
      mySelectionModel.setSelection(oldSelectionStart,caretOffset);
    }
  }
 else {
    if (!myMousePressedInsideSelection && (getSelectionModel().hasSelection() || getSelectionModel().hasBlockSelection())) {
      setMouseSelectionState(MOUSE_SELECTION_STATE_NONE);
      mySelectionModel.setSelection(caretOffset,caretOffset);
    }
 else {
      if (!e.isPopupTrigger()) {
switch (e.getClickCount()) {
case 2:
          mySelectionModel.selectWordAtCaret(mySettings.isMouseClickSelectionHonorsCamelWords());
        setMouseSelectionState(MOUSE_SELECTION_STATE_WORD_SELECTED);
      mySavedSelectionStart=mySelectionModel.getSelectionStart();
    mySavedSelectionEnd=mySelectionModel.getSelectionEnd();
  getCaretModel().moveToOffset(mySavedSelectionEnd);
break;
case 3:
mySelectionModel.selectLineAtCaret();
setMouseSelectionState(MOUSE_SELECTION_STATE_LINE_SELECTED);
mySavedSelectionStart=mySelectionModel.getSelectionStart();
mySavedSelectionEnd=mySelectionModel.getSelectionEnd();
break;
}
}
}
}
}
