{
  if (!myIsDirty)   return;
synchronized (this) {
    if (!myIsDirty)     return;
    int lineCount=Math.min(myLineWidths.size(),myDocument.getLineCount());
    if (myMaxWidth != -1 && myDocument.isInBulkUpdate()) {
      mySize=new Dimension(myMaxWidth,getLineHeight() * lineCount);
      myIsDirty=false;
      return;
    }
    final CharSequence text=myDocument.getCharsNoThreadCheck();
    int end=myDocument.getTextLength();
    int x=0;
    boolean lastLineLengthCalculated=false;
    final int fontSize=myScheme.getEditorFontSize();
    final String fontName=myScheme.getEditorFontName();
    List<? extends SoftWrap> softWraps=getSoftWrapModel().getRegisteredSoftWraps();
    int softWrapsIndex=-1;
    for (int line=0; line < lineCount; line++) {
      if (myLineWidths.getQuick(line) != -1)       continue;
      if (line == lineCount - 1) {
        lastLineLengthCalculated=true;
      }
      x=0;
      int offset=myDocument.getLineStartOffset(line);
      if (offset >= myDocument.getTextLength()) {
        myLineWidths.set(line,0);
        break;
      }
      if (softWrapsIndex < 0) {
        softWrapsIndex=getSoftWrapModel().getSoftWrapIndex(offset);
        if (softWrapsIndex < 0) {
          softWrapsIndex=-softWrapsIndex - 1;
        }
      }
      IterationState state=new IterationState(EditorImpl.this,offset,false);
      int fontType=state.getMergedAttributes().getFontType();
      int maxPreviousSoftWrappedWidth=-1;
      while (offset < end && line < lineCount) {
        char c=text.charAt(offset);
        if (offset >= state.getEndOffset()) {
          state.advance();
          fontType=state.getMergedAttributes().getFontType();
        }
        while (softWrapsIndex < softWraps.size() && line < lineCount) {
          SoftWrap softWrap=softWraps.get(softWrapsIndex);
          if (softWrap.getStart() > offset) {
            break;
          }
          softWrapsIndex++;
          if (softWrap.getStart() == offset) {
            maxPreviousSoftWrappedWidth=Math.max(maxPreviousSoftWrappedWidth,x);
            x=softWrap.getIndentInPixels();
          }
        }
        FoldRegion collapsed=state.getCurrentFold();
        if (collapsed != null) {
          String placeholder=collapsed.getPlaceholderText();
          for (int i=0; i < placeholder.length(); i++) {
            x+=EditorUtil.charWidth(placeholder.charAt(i),fontType,EditorImpl.this);
          }
          offset=collapsed.getEndOffset();
          line=myDocument.getLineNumber(offset);
        }
 else {
          if (c == '\t') {
            x=EditorUtil.nextTabStop(x,EditorImpl.this);
            offset++;
          }
 else {
            if (c == '\n') {
              myLineWidths.set(line,Math.max(x,maxPreviousSoftWrappedWidth));
              if (line + 1 >= lineCount || myLineWidths.getQuick(line + 1) != -1)               break;
              offset++;
              x=0;
              line++;
            }
 else {
              x+=ComplementaryFontsRegistry.getFontAbleToDisplay(c,fontSize,fontType,fontName).charWidth(c,myEditorComponent);
              offset++;
            }
          }
        }
      }
    }
    if (lineCount > 0 && lastLineLengthCalculated) {
      myLineWidths.set(lineCount - 1,x);
    }
    int startToUse=0;
    int endToUse=Math.min(lineCount,myLineWidths.size());
    if (endToUse > 0 && getSoftWrapModel().isSoftWrappingEnabled()) {
      Rectangle visibleArea=getScrollingModel().getVisibleArea();
      startToUse=xyToLogicalPosition(visibleArea.getLocation()).line;
      endToUse=Math.min(endToUse,xyToLogicalPosition(new Point(0,visibleArea.y + visibleArea.height)).line);
    }
    int maxWidth=0;
    for (int i=startToUse; i < endToUse; i++) {
      maxWidth=Math.max(maxWidth,myLineWidths.getQuick(i));
    }
    mySize=new Dimension(maxWidth,getLineHeight() * Math.max(getVisibleLineCount(),1));
    myIsDirty=false;
  }
}
