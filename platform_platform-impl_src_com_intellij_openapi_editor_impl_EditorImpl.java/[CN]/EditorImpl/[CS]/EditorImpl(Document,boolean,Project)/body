{
  myProject=project;
  myDocument=(DocumentImpl)document;
  myScheme=createBoundColorSchemeDelegate(null);
  initTabPainter();
  myIsViewer=viewer;
  mySettings=new SettingsImpl(this);
  mySelectionModel=new SelectionModelImpl(this);
  myMarkupModel=new EditorMarkupModelImpl(this);
  myFoldingModel=new FoldingModelImpl(this);
  myCaretModel=new CaretModelImpl(this);
  mySoftWrapModel=new SoftWrapModelImpl(this);
  mySizeContainer.reset();
  myCommandProcessor=CommandProcessor.getInstance();
  if (project != null) {
    myConnection=project.getMessageBus().connect();
    myConnection.subscribe(DocumentBulkUpdateListener.TOPIC,new EditorDocumentBulkUpdateAdapter());
  }
  myMouseMotionListeners=ContainerUtil.createEmptyCOWList();
  myMarkupModelListener=new MarkupModelListener(){
    @Override public void afterAdded(    @NotNull RangeHighlighterEx highlighter){
      attributesChanged(highlighter);
    }
    @Override public void beforeRemoved(    @NotNull RangeHighlighterEx highlighter){
      attributesChanged(highlighter);
    }
    @Override public void attributesChanged(    @NotNull RangeHighlighterEx highlighter){
      int textLength=myDocument.getTextLength();
      int start=Math.min(Math.max(highlighter.getAffectedAreaStartOffset(),0),textLength);
      int end=Math.min(Math.max(highlighter.getAffectedAreaEndOffset(),0),textLength);
      int startLine=start == -1 ? 0 : myDocument.getLineNumber(start);
      int endLine=end == -1 ? myDocument.getLineCount() : myDocument.getLineNumber(end);
      repaintLines(Math.max(0,startLine - 1),Math.min(endLine + 1,getDocument().getLineCount()));
      GutterIconRenderer renderer=highlighter.getGutterIconRenderer();
      if (renderer != null || highlighter.getErrorStripeMarkColor() != null) {
        ((EditorMarkupModelImpl)getMarkupModel()).repaint(start,end);
      }
      if (renderer != null) {
        updateGutterSize();
      }
      updateCaretCursor();
    }
  }
;
  ((MarkupModelEx)DocumentMarkupModel.forDocument(myDocument,myProject,true)).addMarkupModelListener(myCaretModel,myMarkupModelListener);
  ((MarkupModelEx)getMarkupModel()).addMarkupModelListener(myCaretModel,myMarkupModelListener);
  myDocument.addDocumentListener(myFoldingModel,myCaretModel);
  myDocument.addDocumentListener(myCaretModel,myCaretModel);
  myDocument.addDocumentListener(mySelectionModel,myCaretModel);
  myDocument.addDocumentListener(new EditorDocumentAdapter(),myCaretModel);
  myDocument.addDocumentListener(mySoftWrapModel,myCaretModel);
  myFoldingModel.addListener(mySoftWrapModel);
  myIndentsModel=new IndentsModelImpl(this);
  myCaretModel.addCaretListener(new CaretListener(){
    private LightweightHint myCurrentHint=null;
    private IndentGuideDescriptor myCurrentCaretGuide=null;
    @Override public void caretPositionChanged(    CaretEvent e){
      if (myStickySelection) {
        int selectionStart=Math.min(myStickySelectionStart,getDocument().getTextLength() - 1);
        mySelectionModel.setSelection(selectionStart,myCaretModel.getVisualPosition(),myCaretModel.getOffset());
      }
      final IndentGuideDescriptor newGuide=myIndentsModel.getCaretIndentGuide();
      if (!Comparing.equal(myCurrentCaretGuide,newGuide)) {
        repaintGuide(newGuide);
        repaintGuide(myCurrentCaretGuide);
        myCurrentCaretGuide=newGuide;
        if (myCurrentHint != null) {
          myCurrentHint.hide();
          myCurrentHint=null;
        }
        if (newGuide != null) {
          final Rectangle visibleArea=getScrollingModel().getVisibleArea();
          final int line=newGuide.startLine;
          if (logicalLineToY(line) < visibleArea.y) {
            TextRange textRange=new TextRange(myDocument.getLineStartOffset(line),myDocument.getLineEndOffset(line));
            myCurrentHint=EditorFragmentComponent.showEditorFragmentHint(EditorImpl.this,textRange,false,false);
          }
        }
      }
    }
  }
);
  myCaretCursor=new CaretCursor();
  myFoldingModel.flushCaretShift();
  myScrollBarOrientation=VERTICAL_SCROLLBAR_RIGHT;
  mySoftWrapModel.addSoftWrapChangeListener(new SoftWrapChangeListenerAdapter(){
    @Override public void softWrapAdded(    @NotNull SoftWrap softWrap){
      mySoftWrapsChanged=true;
    }
    @Override public void softWrapsRemoved(){
      mySoftWrapsChanged=true;
    }
  }
);
  mySoftWrapModel.addVisualSizeChangeListener(new VisualSizeChangeListener(){
    @Override public void onLineWidthsChange(    int startLine,    int oldEndLine,    int newEndLine,    @NotNull TIntIntHashMap lineWidths){
      mySizeContainer.update(startLine,newEndLine,oldEndLine);
      for (int i=startLine; i <= newEndLine; i++) {
        if (lineWidths.contains(i)) {
          int width=lineWidths.get(i);
          if (width >= 0) {
            mySizeContainer.updateLineWidthIfNecessary(i,width);
          }
        }
      }
    }
  }
);
  EditorHighlighter highlighter=new EmptyEditorHighlighter(myScheme.getAttributes(HighlighterColors.TEXT));
  setHighlighter(highlighter);
  myEditorComponent=new EditorComponentImpl(this);
  myScrollPane=new MyScrollPane();
  myPanel=new JPanel();
  myHeaderPanel=new MyHeaderPanel();
  myVerticalScrollBar=new MyScrollBar(Adjustable.VERTICAL);
  myGutterComponent=new EditorGutterComponentImpl(this);
  initComponent();
  myScrollingModel=new ScrollingModelImpl(this);
  myGutterComponent.updateSize();
  Dimension preferredSize=getPreferredSize();
  myEditorComponent.setSize(preferredSize);
  if (Patches.APPLE_BUG_ID_3716835) {
    myScrollingModel.addVisibleAreaListener(new VisibleAreaListener(){
      @Override public void visibleAreaChanged(      VisibleAreaEvent e){
        if (myAppleRepaintAlarm == null) {
          myAppleRepaintAlarm=new Alarm(Alarm.ThreadToUse.SWING_THREAD);
        }
        myAppleRepaintAlarm.cancelAllRequests();
        myAppleRepaintAlarm.addRequest(new Runnable(){
          @Override public void run(){
            repaint(0,myDocument.getTextLength());
          }
        }
,50,ModalityState.stateForComponent(myEditorComponent));
      }
    }
);
  }
  updateCaretCursor();
  if (!ourIsUnitTestMode) {
    UiNotifyConnector.doWhenFirstShown(myEditorComponent,new Runnable(){
      @Override public void run(){
        if (!isDisposed() && !myScrollingModel.isScrollingNow()) {
          myScrollingModel.disableAnimation();
          myScrollingModel.scrollHorizontally(0);
          myScrollingModel.enableAnimation();
        }
      }
    }
);
  }
}
