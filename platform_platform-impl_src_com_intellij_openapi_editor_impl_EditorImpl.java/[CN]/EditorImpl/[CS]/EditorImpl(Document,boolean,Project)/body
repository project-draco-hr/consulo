{
  assertIsDispatchThread();
  myProject=project;
  myDocument=(DocumentEx)document;
  if (myDocument instanceof DocumentImpl && !myUseNewRendering) {
    ((DocumentImpl)myDocument).requestTabTracking();
  }
  myScheme=createBoundColorSchemeDelegate(null);
  initTabPainter();
  myIsViewer=viewer;
  mySettings=new SettingsImpl(this,project);
  if (!mySettings.isUseSoftWraps() && shouldSoftWrapsBeForced()) {
    mySettings.setUseSoftWrapsQuiet();
    putUserData(FORCED_SOFT_WRAPS,Boolean.TRUE);
  }
  MarkupModelEx documentMarkup=(MarkupModelEx)DocumentMarkupModel.forDocument(myDocument,myProject,true);
  mySelectionModel=new SelectionModelImpl(this);
  myMarkupModel=new EditorMarkupModelImpl(this);
  myDocumentMarkupModel=new EditorFilteringMarkupModelEx(this,documentMarkup);
  myFoldingModel=new FoldingModelImpl(this);
  myCaretModel=new CaretModelImpl(this);
  myScrollingModel=new ScrollingModelImpl(this);
  mySoftWrapModel=new SoftWrapModelImpl(this);
  if (!myUseNewRendering)   mySizeContainer.reset();
  myCommandProcessor=CommandProcessor.getInstance();
  myImmediatePainter=new ImmediatePainter(this);
  if (myDocument instanceof DocumentImpl) {
    myBulkUpdateListener=new EditorDocumentBulkUpdateAdapter();
    ((DocumentImpl)myDocument).addInternalBulkModeListener(myBulkUpdateListener);
  }
  myMarkupModelListener=new MarkupModelListener(){
    private boolean areRenderersInvolved(    @NotNull RangeHighlighterEx highlighter){
      return highlighter.getCustomRenderer() != null || highlighter.getGutterIconRenderer() != null || highlighter.getLineMarkerRenderer() != null || highlighter.getLineSeparatorRenderer() != null;
    }
    @Override public void afterAdded(    @NotNull RangeHighlighterEx highlighter){
      attributesChanged(highlighter,areRenderersInvolved(highlighter),EditorUtil.attributesImpactFontStyleOrColor(highlighter.getTextAttributes()));
    }
    @Override public void beforeRemoved(    @NotNull RangeHighlighterEx highlighter){
      attributesChanged(highlighter,areRenderersInvolved(highlighter),EditorUtil.attributesImpactFontStyleOrColor(highlighter.getTextAttributes()));
    }
    @Override public void attributesChanged(    @NotNull RangeHighlighterEx highlighter,    boolean renderersChanged,    boolean fontStyleOrColorChanged){
      if (myDocument.isInBulkUpdate())       return;
      if (myUseNewRendering && renderersChanged) {
        updateGutterSize();
      }
      boolean errorStripeNeedsRepaint=renderersChanged || highlighter.getErrorStripeMarkColor() != null;
      if (myUseNewRendering && myDocumentChangeInProgress) {
        myErrorStripeNeedsRepaint|=errorStripeNeedsRepaint;
        return;
      }
      int textLength=myDocument.getTextLength();
      clearTextWidthCache();
      int start=Math.min(Math.max(highlighter.getAffectedAreaStartOffset(),0),textLength);
      int end=Math.min(Math.max(highlighter.getAffectedAreaEndOffset(),0),textLength);
      int startLine=start == -1 ? 0 : myDocument.getLineNumber(start);
      int endLine=end == -1 ? myDocument.getLineCount() : myDocument.getLineNumber(end);
      if (myUseNewRendering && start != end && fontStyleOrColorChanged) {
        myView.invalidateRange(start,end);
      }
      if (!myFoldingModel.isInBatchFoldingOperation()) {
        repaintLines(Math.max(0,startLine - 1),Math.min(endLine + 1,getDocument().getLineCount()));
      }
      if (errorStripeNeedsRepaint) {
        if (myFoldingModel.isInBatchFoldingOperation()) {
          myErrorStripeNeedsRepaint=true;
        }
 else {
          myMarkupModel.repaint(start,end);
        }
      }
      if (!myUseNewRendering && renderersChanged) {
        updateGutterSize();
      }
      updateCaretCursor();
    }
  }
;
  getFilteredDocumentMarkupModel().addMarkupModelListener(myCaretModel,myMarkupModelListener);
  getMarkupModel().addMarkupModelListener(myCaretModel,myMarkupModelListener);
  myDocument.addDocumentListener(myFoldingModel,myCaretModel);
  myDocument.addDocumentListener(myCaretModel,myCaretModel);
  myDocument.addDocumentListener(mySelectionModel,myCaretModel);
  myDocument.addDocumentListener(new EditorDocumentAdapter(),myCaretModel);
  myDocument.addDocumentListener(mySoftWrapModel,myCaretModel);
  myFoldingModel.addListener(mySoftWrapModel,myCaretModel);
  myIndentsModel=new IndentsModelImpl(this);
  myCaretModel.addCaretListener(new CaretListener(){
    @Nullable private LightweightHint myCurrentHint;
    @Nullable private IndentGuideDescriptor myCurrentCaretGuide;
    @Override public void caretPositionChanged(    CaretEvent e){
      if (myStickySelection) {
        int selectionStart=Math.min(myStickySelectionStart,getDocument().getTextLength() - 1);
        mySelectionModel.setSelection(selectionStart,myCaretModel.getVisualPosition(),myCaretModel.getOffset());
      }
      final IndentGuideDescriptor newGuide=myIndentsModel.getCaretIndentGuide();
      if (!Comparing.equal(myCurrentCaretGuide,newGuide)) {
        repaintGuide(newGuide);
        repaintGuide(myCurrentCaretGuide);
        myCurrentCaretGuide=newGuide;
        if (myCurrentHint != null) {
          myCurrentHint.hide();
          myCurrentHint=null;
        }
        if (newGuide != null) {
          final Rectangle visibleArea=getScrollingModel().getVisibleArea();
          final int line=newGuide.startLine;
          if (logicalLineToY(line) < visibleArea.y) {
            TextRange textRange=new TextRange(myDocument.getLineStartOffset(line),myDocument.getLineEndOffset(line));
            myCurrentHint=EditorFragmentComponent.showEditorFragmentHint(EditorImpl.this,textRange,false,false);
          }
        }
      }
    }
    @Override public void caretAdded(    CaretEvent e){
      if (myPrimaryCaret != null) {
        myPrimaryCaret.updateVisualPosition();
      }
      repaintCaretRegion(e);
      myPrimaryCaret=myCaretModel.getPrimaryCaret();
    }
    @Override public void caretRemoved(    CaretEvent e){
      repaintCaretRegion(e);
      myPrimaryCaret=myCaretModel.getPrimaryCaret();
      myPrimaryCaret.updateVisualPosition();
    }
  }
);
  myCaretCursor=new CaretCursor();
  myFoldingModel.flushCaretShift();
  myScrollBarOrientation=VERTICAL_SCROLLBAR_RIGHT;
  mySoftWrapModel.addSoftWrapChangeListener(new SoftWrapChangeListenerAdapter(){
    @Override public void recalculationEnds(){
      if (myCaretModel.isUpToDate()) {
        myCaretModel.updateVisualPosition();
      }
    }
    @Override public void softWrapsChanged(){
      mySoftWrapsChanged=true;
    }
  }
);
  if (!myUseNewRendering) {
    mySoftWrapModel.addVisualSizeChangeListener(new VisualSizeChangeListener(){
      @Override public void onLineWidthsChange(      int startLine,      int oldEndLine,      int newEndLine,      @NotNull TIntIntHashMap lineWidths){
        mySizeContainer.update(startLine,newEndLine,oldEndLine);
        for (int i=startLine; i <= newEndLine; i++) {
          if (lineWidths.contains(i)) {
            int width=lineWidths.get(i);
            if (width >= 0) {
              mySizeContainer.updateLineWidthIfNecessary(i,width);
            }
          }
        }
      }
    }
);
  }
  EditorHighlighter highlighter=new EmptyEditorHighlighter(myScheme.getAttributes(HighlighterColors.TEXT));
  setHighlighter(highlighter);
  myEditorComponent=new EditorComponentImpl(this);
  myVerticalScrollBar=(MyScrollBar)myScrollPane.getVerticalScrollBar();
  myVerticalScrollBar.setOpaque(false);
  myPanel=new JPanel();
  UIUtil.putClientProperty(myPanel,UIUtil.NOT_IN_HIERARCHY_COMPONENTS,new Iterable<JComponent>(){
    @NotNull @Override public Iterator<JComponent> iterator(){
      JComponent component=getPermanentHeaderComponent();
      if (component != null && !component.isValid()) {
        return Collections.singleton(component).iterator();
      }
      return ContainerUtil.emptyIterator();
    }
  }
);
  myHeaderPanel=new MyHeaderPanel();
  myGutterComponent=new EditorGutterComponentImpl(this);
  initComponent();
  if (myUseNewRendering) {
    myView=new EditorView(this);
    myView.reinitSettings();
  }
 else {
    myView=null;
  }
  if (UISettings.getInstance().PRESENTATION_MODE) {
    setFontSize(UISettings.getInstance().PRESENTATION_MODE_FONT_SIZE);
  }
  myGutterComponent.updateSize();
  Dimension preferredSize=getPreferredSize();
  myEditorComponent.setSize(preferredSize);
  updateCaretCursor();
  if (SystemInfo.isJavaVersionAtLeast("1.8") && SystemInfo.isMacIntel64 && SystemInfo.isJetbrainsJvm&& Registry.is("ide.mac.forceTouch")) {
    new MacGestureSupportForEditor(getComponent());
  }
}
