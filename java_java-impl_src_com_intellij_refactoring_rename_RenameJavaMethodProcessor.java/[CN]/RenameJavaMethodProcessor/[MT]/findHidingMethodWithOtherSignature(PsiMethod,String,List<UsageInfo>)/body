{
  final PsiClass containingClass=methodToRename.getContainingClass();
  if (containingClass != null) {
    final PsiMethod prototype=getPrototypeWithNewName(methodToRename,newName);
    if (prototype == null || containingClass.findMethodBySignature(prototype,true) != null)     return;
    final PsiMethod[] methodsByName=containingClass.findMethodsByName(newName,true);
    if (methodsByName.length > 0) {
      for (      UsageInfo info : result) {
        final PsiElement element=info.getElement();
        if (element instanceof PsiReferenceExpression) {
          if (((PsiReferenceExpression)element).resolve() == methodToRename) {
            final PsiMethodCallExpression copy=(PsiMethodCallExpression)JavaPsiFacade.getElementFactory(element.getProject()).createExpressionFromText(element.getParent().getText(),element);
            final PsiReferenceExpression expression=(PsiReferenceExpression)copy.getMethodExpression().handleElementRename(newName);
            final JavaResolveResult resolveResult=expression.advancedResolve(true);
            final PsiMember resolveResultElement=(PsiMember)resolveResult.getElement();
            if (resolveResult.isValidResult() && resolveResultElement != null) {
              result.add(new UnresolvableCollisionUsageInfo(element,methodToRename){
                @Override public String getDescription(){
                  return "Method call would be linked to \"" + RefactoringUIUtil.getDescription(resolveResultElement,true) + "\" after rename";
                }
              }
);
              break;
            }
          }
        }
      }
    }
  }
}
