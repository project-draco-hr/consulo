{
  final PsiClass containingClass=method.getContainingClass();
  if (containingClass == null)   return;
  if (method.hasModifierProperty(PsiModifier.PRIVATE))   return;
  Collection<PsiClass> inheritors=ClassInheritorsSearch.search(containingClass,containingClass.getUseScope(),true).findAll();
  MethodSignature oldSignature=method.getSignature(PsiSubstitutor.EMPTY);
  MethodSignature newSignature=MethodSignatureUtil.createMethodSignature(newName,oldSignature.getParameterTypes(),oldSignature.getTypeParameters(),oldSignature.getSubstitutor());
  for (  PsiClass inheritor : inheritors) {
    PsiSubstitutor superSubstitutor=TypeConversionUtil.getSuperClassSubstitutor(containingClass,inheritor,PsiSubstitutor.EMPTY);
    final PsiMethod[] methodsByName=inheritor.findMethodsByName(newName,false);
    for (    PsiMethod conflictingMethod : methodsByName) {
      if (newSignature.equals(conflictingMethod.getSignature(superSubstitutor))) {
        result.add(new SubmemberHidesMemberUsageInfo(conflictingMethod,method));
        break;
      }
    }
  }
}
