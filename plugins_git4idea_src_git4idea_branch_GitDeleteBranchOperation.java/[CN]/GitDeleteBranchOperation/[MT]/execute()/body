{
  boolean fatalErrorHappened=false;
  while (hasMoreRepositories() && !fatalErrorHappened) {
    final GitRepository repository=next();
    GitSimpleEventDetector notFullyMergedDetector=new GitSimpleEventDetector(GitSimpleEventDetector.Event.BRANCH_NOT_FULLY_MERGED);
    GitBranchNotMergedToUpstreamDetector notMergedToUpstreamDetector=new GitBranchNotMergedToUpstreamDetector();
    GitCommandResult result=myGit.branchDelete(repository,myBranchName,false,notFullyMergedDetector,notMergedToUpstreamDetector);
    if (result.success()) {
      refresh(repository);
      markSuccessful(repository);
    }
 else     if (notFullyMergedDetector.hasHappened()) {
      String baseBranch=notMergedToUpstreamDetector.getBaseBranch();
      if (baseBranch == null) {
        baseBranch=myCurrentBranch;
      }
      Collection<GitRepository> remainingRepositories=getRemainingRepositories();
      boolean forceDelete=showNotFullyMergedDialog(myBranchName,baseBranch,remainingRepositories);
      if (forceDelete) {
        GitCompoundResult compoundResult=forceDelete(myBranchName,remainingRepositories);
        if (compoundResult.totalSuccess()) {
          GitRepository[] remainingRepositoriesArray=ArrayUtil.toObjectArray(remainingRepositories,GitRepository.class);
          markSuccessful(remainingRepositoriesArray);
          refresh(remainingRepositoriesArray);
        }
 else {
          fatalError(getErrorTitle(),compoundResult.getErrorOutputWithReposIndication());
          return;
        }
      }
 else {
        fatalError(getErrorTitle(),"This branch is not fully merged to " + baseBranch + ".");
        fatalErrorHappened=true;
      }
    }
 else {
      fatalError(getErrorTitle(),result.getErrorOutputAsJoinedString());
      fatalErrorHappened=true;
    }
  }
  if (!fatalErrorHappened) {
    notifySuccess();
  }
}
