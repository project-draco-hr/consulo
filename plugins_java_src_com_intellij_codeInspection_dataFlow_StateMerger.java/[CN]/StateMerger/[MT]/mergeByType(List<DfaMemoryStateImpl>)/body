{
  MultiMap<Pair<DfaVariableValue,DfaPsiType>,DfaMemoryStateImpl> byInstanceof=new MultiMap<Pair<DfaVariableValue,DfaPsiType>,DfaMemoryStateImpl>();
  for (  final DfaMemoryStateImpl state : states) {
    ProgressManager.checkCanceled();
    for (    DfaVariableValue value : state.getChangedVariables()) {
      for (      DfaPsiType instanceofValue : state.getVariableState(value).myInstanceofValues) {
        byInstanceof.putValue(Pair.create(value,instanceofValue),state);
      }
    }
  }
  for (  final DfaMemoryStateImpl state : states) {
    ProgressManager.checkCanceled();
    for (    final DfaVariableValue var : state.getChangedVariables()) {
      for (      final DfaPsiType notInstanceof : state.getVariableState(var).myNotInstanceofValues) {
        final DfaVariableState varStateWithoutType=getVarStateWithoutType(state,var,notInstanceof);
        List<DfaMemoryStateImpl> complementaryStates=ContainerUtil.filter(byInstanceof.get(Pair.create(var,notInstanceof)),new Condition<DfaMemoryStateImpl>(){
          @Override public boolean value(          DfaMemoryStateImpl another){
            return seemCompatible(state,another,var) && another.getVariableState(var).myInstanceofValues.contains(notInstanceof) && varStateWithoutType.equals(getVarStateWithoutType(another,var,notInstanceof))&& areEquivalentModuloVar(another,state,var)&& !(state.isNull(var) && another.isNotNull(var));
          }
        }
);
        if (complementaryStates.isEmpty()) {
          continue;
        }
        DfaMemoryStateImpl copy=state.createCopy();
        copy.setVariableState(var,varStateWithoutType);
        complementaryStates.add(state);
        mergeNullableState(var,copy,complementaryStates);
        mergeUnknowns(copy,complementaryStates);
        return getMergeResult(states,ContainerUtil.newIdentityTroveSet(complementaryStates),copy);
      }
    }
  }
  return null;
}
