{
  ClassReferenceScanner scanner=new ClassReferenceSearchingScanner(inheritor);
  final MyClassInstanceReferenceVisitor instanceVisitor=new MyClassInstanceReferenceVisitor(inheritor,usages);
  scanner.processReferences(new ClassInstanceScanner(inheritor,instanceVisitor));
  MyClassInheritorMemberReferencesVisitor classMemberVisitor=new MyClassInheritorMemberReferencesVisitor(inheritor,usages,instanceVisitor);
  inheritor.accept(classMemberVisitor);
  PsiMethod[] methods=inheritor.getMethods();
  for (int i=0; i < methods.length; i++) {
    PsiMethod method=methods[i];
    if (method.isConstructor() || method.hasModifierProperty(PsiModifier.PRIVATE))     return;
    final PsiMethod baseMethod=myBaseClass.findMethodBySignature(method,true);
    if (baseMethod != null) {
      final PsiMethod classMethod=myClass.findMethodBySignature(method,false);
      if (!baseMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
        usages.add(new NoLongerOverridingSubClassMethodUsageInfo(method,baseMethod));
      }
 else {
        if (classMethod != null && !classMethod.hasModifierProperty(PsiModifier.ABSTRACT)) {
          usages.add(new NoLongerOverridingSubClassMethodUsageInfo(method,baseMethod));
        }
      }
    }
  }
}
