{
  super(project);
  myClass=aClass;
  myInnerClassName=innerClassName;
  myIsDelegateOtherMembers=delegateOtherMembers;
  myManager=myClass.getManager();
  myFactory=myManager.getElementFactory();
  myBaseClass=targetBaseClass;
  LOG.assertTrue(myBaseClass != null && (myBaseClass.getQualifiedName() == null || !myBaseClass.getQualifiedName().equals("java.lang.Object")));
  myBaseClassMembers=getAllBaseClassMembers();
  myBaseClassBases=getAllBases();
  myBaseClassType=myFactory.createType(myBaseClass);
  myIsInnerClassNeeded=InheritanceToDelegationUtil.isInnerClassNeeded(myClass,myBaseClass);
  myFieldName=fieldName;
  final String propertyName=CodeStyleManager.getInstance(myProject).variableNameToPropertyName(myFieldName,VariableKind.FIELD);
  myGetterName=PropertyUtil.suggestGetterName(propertyName,myBaseClassType);
  myGenerateGetter=generateGetter;
  myDelegatedInterfaces=new LinkedHashSet<Object>();
  addAll(myDelegatedInterfaces,delegatedInterfaces);
  myDelegatedMethods=new LinkedHashSet<Object>();
  addAll(myDelegatedMethods,delegatedMethods);
  myDelegatedMethodsVisibility=new com.intellij.util.containers.HashMap<PsiMethod,String>();
  for (Iterator<Object> iterator=myDelegatedMethods.iterator(); iterator.hasNext(); ) {
    PsiMethod method=(PsiMethod)iterator.next();
    PsiMethod overridingMethod=myClass.findMethodBySignature(method,false);
    if (overridingMethod != null) {
      myDelegatedMethodsVisibility.put(method,VisibilityUtil.getVisibilityModifier(overridingMethod.getModifierList()));
    }
  }
  myOverridenMethods=getOverriddenMethods();
}
