{
  final Cache oldCache=myDependencyCache.getCache();
  final Cache newCache=myDependencyCache.getNewClassesCache();
  final boolean becameFinal=!CacheUtils.isFinal(oldCache,myQName) && CacheUtils.isFinal(newCache,myQName);
  final SymbolTable symbolTable=myDependencyCache.getSymbolTable();
  final Set<MemberInfo> removedConcreteMethods=fetchNonAbstractMethods(myRemovedMembers);
  final Set<MethodInfo> removedOverridableMethods;
  if (!removedMethods.isEmpty()) {
    removedOverridableMethods=new HashSet<MethodInfo>(removedMethods);
    for (Iterator<MethodInfo> it=removedOverridableMethods.iterator(); it.hasNext(); ) {
      final MethodInfo method=it.next();
      if (method.isFinal() || method.isStatic() || method.isPrivate()|| method.isConstructor()) {
        it.remove();
      }
    }
  }
 else {
    removedOverridableMethods=Collections.emptySet();
  }
  myDependencyCache.getCacheNavigator().walkSubClasses(myQName,new ClassInfoProcessor(){
    public boolean process(    final int subclassQName) throws CacheCorruptedException {
      if (myDependencyCache.isClassInfoMarked(subclassQName)) {
        return true;
      }
      if (!oldCache.containsClass(subclassQName)) {
        return true;
      }
      if (!removedMethods.isEmpty() && myIsRemoteInterface && !CacheUtils.isInterface(oldCache,subclassQName)) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: methods were removed from remote interface: "+ myDependencyCache.resolve(myQName));
          }
        }
        return true;
      }
      if (mySuperClassAdded || mySuperInterfaceAdded) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the superlist of "+ myDependencyCache.resolve(myQName)+ " is changed");
          }
        }
        return true;
      }
      if (becameFinal) {
        if (myQName == oldCache.getSuperQualifiedName(subclassQName)) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class "+ myDependencyCache.resolve(myQName)+ " was made final");
            }
          }
          return true;
        }
      }
      final int subclassDeclarationId=subclassQName;
      for (      final MemberInfo member : myAddedMembers) {
        if (member instanceof MethodInfo) {
          final MethodInfo method=(MethodInfo)member;
          if (method.isAbstract()) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added abstract method to "+ myDependencyCache.resolve(myQName));
              }
            }
            return true;
          }
          if (!method.isPrivate()) {
            MethodInfo derivedMethod=oldCache.findMethodsBySignature(subclassDeclarationId,method.getDescriptor(symbolTable),symbolTable);
            if (derivedMethod != null) {
              if (!method.getReturnTypeDescriptor(symbolTable).equals(CacheUtils.getMethodReturnTypeDescriptor(oldCache,derivedMethod,symbolTable))) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: return types of method "+ method+ " in base and derived classes are different");
                  }
                }
                return true;
              }
              if (MakeUtil.isMoreAccessible(method.getFlags(),derivedMethod.getFlags())) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the method "+ method+ " in derived class is less accessible than in base class");
                  }
                }
                return true;
              }
              if (!CacheUtils.areArraysContentsEqual(method.getThrownExceptions(),derivedMethod.getThrownExceptions())) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: exception lists of "+ method+ " in base and derived classes are different");
                  }
                }
                return true;
              }
            }
            if (hasGenericsNameClashes(method,oldCache,subclassQName)) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: found method with the same name, different generic signature, but the same erasure as "+ method);
                }
              }
              return true;
            }
          }
        }
 else         if (member instanceof FieldInfo) {
          if (oldCache.findFieldByName(subclassDeclarationId,member.getName()) != null) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added field "+ member+ " to base class");
              }
            }
            return true;
          }
        }
      }
      for (      final MemberInfo changedMember : myChangedMembers) {
        if (changedMember instanceof MethodInfo) {
          final MethodInfo oldMethod=(MethodInfo)changedMember;
          MethodChangeDescription changeDescription=(MethodChangeDescription)myChangeDescriptions.get(oldMethod);
          if (changeDescription.becameAbstract) {
            if (!ClsUtil.isAbstract(oldCache.getFlags(subclassQName))) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
                }
              }
              return true;
            }
          }
          final String oldMethodDescriptor=oldMethod.getDescriptor(symbolTable);
          final MethodInfo derivedMethod=oldCache.findMethodsBySignature(subclassDeclarationId,oldMethodDescriptor,symbolTable);
          if (derivedMethod != null) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
              }
            }
            return true;
          }
          myDependencyCache.getCacheNavigator().walkSuperInterfaces(subclassQName,new ClassInfoProcessor(){
            boolean found=false;
            public boolean process(            final int ifaceQName) throws CacheCorruptedException {
              if (found) {
                return false;
              }
              final MethodInfo implementee=oldCache.findMethodsBySignature(ifaceQName,oldMethodDescriptor,symbolTable);
              if (implementee != null) {
                found=true;
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method, implementing corresponding method inherited from an interface"+ oldMethod);
                  }
                }
              }
              return !found;
            }
          }
);
          if (myDependencyCache.isClassInfoMarked(subclassQName)) {
            return true;
          }
        }
      }
      if (!ClsUtil.isAbstract(oldCache.getFlags(subclassQName))) {
        if (hasUnimplementedAbstractMethods(subclassQName,new HashSet<MemberInfo>(removedConcreteMethods))) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class should be declared abstract because abstract method implementation was removed from its superclass: "+ myDependencyCache.resolve(myQName));
            }
          }
          return true;
        }
      }
      if (!removedOverridableMethods.isEmpty() && !myDependencyCache.isClassInfoMarked(subclassQName) && !myDependencyCache.getNewClassesCache().containsClass(subclassQName)) {
        final Cache cache=myDependencyCache.getCache();
        for (        MethodInfo subclassMethod : cache.getMethodIds(subclassQName)) {
          if (!subclassMethod.isConstructor()) {
            for (            MethodInfo removedMethod : removedOverridableMethods) {
              if (removedMethod.getName() == subclassMethod.getName()) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent subclass " + myDependencyCache.resolve(subclassQName) + "; reason: the class has methods annotated with @Override and some methods were changed or removed in a base class"+ myDependencyCache.resolve(myQName));
                  }
                }
                return true;
              }
            }
          }
        }
      }
      return true;
    }
  }
);
}
