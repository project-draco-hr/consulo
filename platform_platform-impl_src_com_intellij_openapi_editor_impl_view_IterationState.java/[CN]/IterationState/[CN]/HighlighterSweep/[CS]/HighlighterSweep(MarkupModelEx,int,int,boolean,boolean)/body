{
  final List<RangeHighlighterEx> list=new ArrayList<RangeHighlighterEx>();
  markupModel.processRangeHighlightersOverlappingWith(myReverseIteration ? end : start,myReverseIteration ? start : end,new CommonProcessors.CollectProcessor<RangeHighlighterEx>(list){
    @Override protected boolean accept(    RangeHighlighterEx ex){
      return (!onlyFullLine || ex.getTargetArea() == HighlighterTargetArea.LINES_IN_RANGE) && (!onlyFontAffecting || ex.getTextAttributes() != null && ex.getTextAttributes().getFontType() != Font.PLAIN);
    }
  }
);
  highlighters=list.isEmpty() ? RangeHighlighterEx.EMPTY_ARRAY : list.toArray(new RangeHighlighterEx[list.size()]);
  Arrays.sort(highlighters,myReverseIteration ? BY_AFFECTED_END_OFFSET_REVERSED : RangeHighlighterEx.BY_AFFECTED_START_OFFSET);
  while (i < highlighters.length) {
    RangeHighlighterEx highlighter=highlighters[i++];
    if (!skipHighlighter(highlighter)) {
      myNextHighlighter=highlighter;
      break;
    }
  }
}
