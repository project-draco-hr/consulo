{
  Instruction[] instructions=flow.getInstructions();
  PsiVariable[] writtenVariables=getWrittenVariables(flow,from,to);
  ArrayList<PsiVariable> result=new ArrayList<PsiVariable>(1);
  variables:   for (int k=0; k < writtenVariables.length; k++) {
    PsiVariable psiVariable=writtenVariables[k];
    Set<SSAInstructionState> processedStates=new THashSet<SSAInstructionState>();
    final List<SSAInstructionState> queue=new ArrayList<SSAInstructionState>();
    queue.add(new SSAInstructionState(0,from));
    while (queue.size() > 0) {
      final SSAInstructionState state=queue.remove(0);
      if (state.getWriteCount() > 1)       continue variables;
      if (!processedStates.contains(state)) {
        processedStates.add(state);
        int i=state.getInstructionIdx();
        if (i < to) {
          Instruction instruction=instructions[i];
          if (instruction instanceof ReturnInstruction) {
            int[] offsets=((ReturnInstruction)instruction).getPossibleReturnOffsets();
            for (int j=0; j < offsets.length; j++) {
              queue.add(new SSAInstructionState(state.getWriteCount(),Math.min(offsets[j],to)));
            }
          }
 else           if (instruction instanceof GoToInstruction) {
            int nextOffset=((GoToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
          }
 else           if (instruction instanceof ThrowToInstruction) {
            int nextOffset=((ThrowToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
          }
 else           if (instruction instanceof ConditionalGoToInstruction) {
            int nextOffset=((ConditionalGoToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else           if (instruction instanceof ConditionalThrowToInstruction) {
            int nextOffset=((ConditionalThrowToInstruction)instruction).offset;
            nextOffset=Math.min(nextOffset,to);
            queue.add(new SSAInstructionState(state.getWriteCount(),nextOffset));
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else           if (instruction instanceof WriteVariableInstruction) {
            WriteVariableInstruction write=(WriteVariableInstruction)instruction;
            queue.add(new SSAInstructionState(state.getWriteCount() + (write.variable == psiVariable ? 1 : 0),i + 1));
          }
 else           if (instruction instanceof ReadVariableInstruction) {
            ReadVariableInstruction read=(ReadVariableInstruction)instruction;
            if (read.variable == psiVariable && state.getWriteCount() == 0)             continue variables;
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
 else {
            queue.add(new SSAInstructionState(state.getWriteCount(),i + 1));
          }
        }
 else         if (!reportVarsIfNonInitializingPathExists && state.getWriteCount() == 0)         continue variables;
      }
    }
    result.add(psiVariable);
  }
  return result.toArray(new PsiVariable[result.size()]);
}
