def makeindex(self, req, tmpl, subdir=''):

    def archivelist(ui, nodeid, url):
        allowed = ui.configlist('web', 'allow_archive', untrusted=True)
        for i in [('zip', '.zip'), ('gz', '.tar.gz'), ('bz2', '.tar.bz2')]:
            if ((i[0] in allowed) or ui.configbool('web', ('allow' + i[0]), untrusted=True)):
                yield {'type': i[0], 'extension': i[1], 'node': nodeid, 'url': url, }
    sortdefault = (None, False)

    def entries(sortcolumn='', descending=False, subdir='', **map):
        rows = []
        parity = paritygen(self.stripecount)
        descend = self.ui.configbool('web', 'descend', True)
        for (name, path) in self.repos:
            if (not name.startswith(subdir)):
                continue
            name = name[len(subdir):]
            if ((not descend) and ('/' in name)):
                continue
            u = self.ui.copy()
            try:
                u.readconfig(os.path.join(path, '.hg', 'hgrc'))
            except Exception as e:
                u.warn((_('error reading %s/.hg/hgrc: %s\n') % (path, e)))
                continue

            def get(section, name, default=None):
                return u.config(section, name, default, untrusted=True)
            if u.configbool('web', 'hidden', untrusted=True):
                continue
            if (not self.read_allowed(u, req)):
                continue
            parts = [name]
            if ('PATH_INFO' in req.env):
                parts.insert(0, req.env['PATH_INFO'].rstrip('/'))
            if req.env['SCRIPT_NAME']:
                parts.insert(0, req.env['SCRIPT_NAME'])
            url = re.sub('/+', '/', ('/'.join(parts) + '/'))
            try:
                r = hg.repository(self.ui, path)
                d = (get_mtime(r.spath), util.makedate()[1])
            except OSError:
                continue
            contact = get_contact(get)
            description = get('web', 'description', '')
            name = get('web', 'name', name)
            row = dict(contact=(contact or 'unknown'), contact_sort=(contact.upper() or 'unknown'), name=name, name_sort=name, url=url, description=(description or 'unknown'), description_sort=(description.upper() or 'unknown'), lastchange=d, lastchange_sort=(d[1] - d[0]), archives=archivelist(u, 'tip', url))
            if ((not sortcolumn) or ((sortcolumn, descending) == sortdefault)):
                row['parity'] = parity.next()
                yield row
            else:
                rows.append((row[('%s_sort' % sortcolumn)], row))
        if rows:
            rows.sort()
            if descending:
                rows.reverse()
            for (key, row) in rows:
                row['parity'] = parity.next()
                yield row
    self.refresh()
    sortable = ['name', 'description', 'contact', 'lastchange']
    (sortcolumn, descending) = sortdefault
    if ('sort' in req.form):
        sortcolumn = req.form['sort'][0]
        descending = sortcolumn.startswith('-')
        if descending:
            sortcolumn = sortcolumn[1:]
        if (sortcolumn not in sortable):
            sortcolumn = ''
    sort = [(('sort_%s' % column), ('%s%s' % (((((not descending) and (column == sortcolumn)) and '-') or ''), column))) for column in sortable]
    self.refresh()
    self.updatereqenv(req.env)
    return tmpl('index', entries=entries, subdir=subdir, sortcolumn=sortcolumn, descending=descending, **dict(sort))
