{
  final Instruction[] flow=owner.getControlFlow();
  final ReachingDefinitionsDfaInstance dfaInstance=new ReachingDefinitionsDfaInstance(flow);
  final ReachingDefinitionsSemilattice lattice=new ReachingDefinitionsSemilattice();
  final DFAEngine<TIntObjectHashMap<TIntHashSet>> engine=new DFAEngine<TIntObjectHashMap<TIntHashSet>>(flow,dfaInstance,lattice);
  final List<TIntObjectHashMap<TIntHashSet>> dfaResult=engine.performDFA();
  final TIntHashSet unusedDefs=new TIntHashSet();
  for (  Instruction instruction : flow) {
    if (instruction instanceof ReadWriteVariableInstruction && ((ReadWriteVariableInstruction)instruction).isWrite()) {
      unusedDefs.add(instruction.num());
    }
  }
  for (int i=0; i < dfaResult.size(); i++) {
    final Instruction instruction=flow[i];
    if (instruction instanceof ReadWriteVariableInstruction) {
      final ReadWriteVariableInstruction varInst=(ReadWriteVariableInstruction)instruction;
      if (!varInst.isWrite()) {
        final String varName=varInst.getVariableName();
        TIntObjectHashMap<TIntHashSet> e=dfaResult.get(i);
        e.forEachValue(new TObjectProcedure<TIntHashSet>(){
          public boolean execute(          TIntHashSet reaching){
            reaching.forEach(new TIntProcedure(){
              public boolean execute(              int defNum){
                final String defName=((ReadWriteVariableInstruction)flow[defNum]).getVariableName();
                if (varName.equals(defName)) {
                  unusedDefs.remove(defNum);
                }
                return true;
              }
            }
);
            return true;
          }
        }
);
      }
    }
  }
  unusedDefs.forEach(new TIntProcedure(){
    public boolean execute(    int num){
      final ReadWriteVariableInstruction instruction=(ReadWriteVariableInstruction)flow[num];
      final PsiElement element=instruction.getElement();
      if (element == null)       return true;
      if (isLocalAssignment(element) && isUsedInTopLevelFlowOnly(element) && !isIncOrDec(element)) {
        PsiElement toHighlight=getHighlightElement(element);
        problemsHolder.registerProblem(toHighlight,GroovyInspectionBundle.message("unused.assignment.tooltip"),ProblemHighlightType.LIKE_UNUSED_SYMBOL);
      }
      return true;
    }
  }
);
}
