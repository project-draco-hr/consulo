{
  final ID<K,V> name=extension.getName();
  final int version=extension.getVersion();
  if (!extension.dependsOnFileContent()) {
    myNotRequiringContentIndices.add(name);
  }
 else {
    myRequiringContentIndices.add(name);
  }
  myIndexIdToVersionMap.put(name,version);
  final File versionFile=IndexInfrastructure.getVersionFile(name);
  final boolean versionFileExisted=versionFile.exists();
  boolean versionChanged=false;
  if (isCurrentVersionCorrupted || IndexInfrastructure.versionDiffers(versionFile,version)) {
    if (!isCurrentVersionCorrupted && versionFileExisted) {
      versionChanged=true;
      LOG.info("Version has changed for index " + extension.getName() + ". The index will be rebuilt.");
    }
    FileUtil.delete(IndexInfrastructure.getIndexRootDir(name));
    IndexInfrastructure.rewriteVersion(versionFile,version);
  }
  for (int attempt=0; attempt < 2; attempt++) {
    try {
      final MapIndexStorage<K,V> storage=new MapIndexStorage<K,V>(IndexInfrastructure.getStorageFile(name),extension.getKeyDescriptor(),extension.getValueExternalizer(),extension.getCacheSize());
      final MemoryIndexStorage<K,V> memStorage=new MemoryIndexStorage<K,V>(storage);
      final UpdatableIndex<K,V,FileContent> index=createIndex(name,extension,memStorage);
      myIndices.put(name,new Pair<UpdatableIndex<?,?,FileContent>,InputFilter>(index,new IndexableFilesFilter(extension.getInputFilter())));
      myUnsavedDataIndexingSemaphores.put(name,new Semaphore());
      myNoLimitCheckTypes.addAll(extension.getFileTypesWithSizeLimitNotApplicable());
      break;
    }
 catch (    IOException e) {
      LOG.info(e);
      FileUtil.delete(IndexInfrastructure.getIndexRootDir(name));
      IndexInfrastructure.rewriteVersion(versionFile,version);
    }
  }
  return versionChanged;
}
