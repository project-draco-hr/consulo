{
  final File indexStorageFile=IndexInfrastructure.getInputIndexStorageFile(indexId);
  final Ref<Boolean> isBufferingMode=new Ref<Boolean>(false);
  final Map<Integer,Collection<K>> tempMap=new com.intellij.util.containers.HashMap<Integer,Collection<K>>();
  final DataExternalizer<Collection<K>> dataExternalizer=new DataExternalizer<Collection<K>>(){
    public void save(    DataOutput out,    Collection<K> value) throws IOException {
      DataInputOutputUtil.writeINT(out,value.size());
      for (      K key : value) {
        keyDescriptor.save(out,key);
      }
    }
    public Collection<K> read(    DataInput in) throws IOException {
      final int size=DataInputOutputUtil.readINT(in);
      final List<K> list=new ArrayList<K>();
      for (int idx=0; idx < size; idx++) {
        list.add(keyDescriptor.read(in));
      }
      return list;
    }
  }
;
  final PersistentHashMap<Integer,Collection<K>> map=new PersistentHashMap<Integer,Collection<K>>(indexStorageFile,new EnumeratorIntegerDescriptor(),dataExternalizer){
    @Override public synchronized Collection<K> get(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        final Collection<K> collection=tempMap.get(integer);
        if (collection != null) {
          return collection;
        }
      }
      return super.get(integer);
    }
    @Override public synchronized void put(    Integer integer,    Collection<K> ks) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,ks == null ? Collections.<K>emptySet() : ks);
      }
 else {
        super.put(integer,ks);
      }
    }
    @Override public synchronized void remove(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,Collections.<K>emptySet());
      }
 else {
        super.remove(integer);
      }
    }
  }
;
  storage.addBufferingStateListsner(new MemoryIndexStorage.BufferingStateListener(){
    public void bufferingStateChanged(    boolean newState){
synchronized (map) {
        isBufferingMode.set(newState);
      }
    }
    public void memoryStorageCleared(){
synchronized (map) {
        tempMap.clear();
      }
    }
  }
);
  return map;
}
