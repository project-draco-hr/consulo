{
  final File indexStorageFile=IndexInfrastructure.getInputIndexStorageFile(indexId);
  final Ref<Boolean> isBufferingMode=new Ref<Boolean>(false);
  final TIntObjectHashMap<Collection<K>> tempMap=new TIntObjectHashMap<Collection<K>>();
  final DataExternalizer<Collection<K>> dataExternalizer=new DataExternalizer<Collection<K>>(){
    @Override public void save(    DataOutput out,    @NotNull Collection<K> value) throws IOException {
      try {
        DataInputOutputUtil.writeINT(out,value.size());
        for (        K key : value) {
          keyDescriptor.save(out,key);
        }
      }
 catch (      IllegalArgumentException e) {
        throw new IOException("Error saving data for index " + indexId,e);
      }
    }
    @NotNull @Override public Collection<K> read(    DataInput in) throws IOException {
      try {
        final int size=DataInputOutputUtil.readINT(in);
        final List<K> list=new ArrayList<K>(size);
        for (int idx=0; idx < size; idx++) {
          list.add(keyDescriptor.read(in));
        }
        return list;
      }
 catch (      IllegalArgumentException e) {
        throw new IOException("Error reading data for index " + indexId,e);
      }
    }
  }
;
  final PersistentHashMap<Integer,Collection<K>> map=new PersistentHashMap<Integer,Collection<K>>(indexStorageFile,EnumeratorIntegerDescriptor.INSTANCE,dataExternalizer){
    @Override protected Collection<K> doGet(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        final Collection<K> collection=tempMap.get(integer);
        if (collection != null) {
          return collection;
        }
      }
      return super.doGet(integer);
    }
    @Override protected void doPut(    Integer integer,    @Nullable Collection<K> ks) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,ks == null ? Collections.<K>emptySet() : ks);
      }
 else {
        super.doPut(integer,ks);
      }
    }
    @Override protected void doRemove(    Integer integer) throws IOException {
      if (isBufferingMode.get()) {
        tempMap.put(integer,Collections.<K>emptySet());
      }
 else {
        super.doRemove(integer);
      }
    }
  }
;
  storage.addBufferingStateListsner(new MemoryIndexStorage.BufferingStateListener(){
    @Override public void bufferingStateChanged(    boolean newState){
synchronized (map) {
        isBufferingMode.set(newState);
      }
    }
    @Override public void memoryStorageCleared(){
synchronized (map) {
        tempMap.clear();
      }
    }
  }
);
  return map;
}
