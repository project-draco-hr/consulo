{
  if (isUnderConfigOrSystem(file)) {
    return;
  }
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      final Iterable<VirtualFile> children=file instanceof NewVirtualFile ? ((NewVirtualFile)file).iterInDbChildren() : Arrays.asList(file.getChildren());
      for (      VirtualFile child : children) {
        invalidateIndices(child,markForReindex);
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    IndexingStamp.flushCache();
    final List<ID<?,?>> affectedIndices=new ArrayList<ID<?,?>>(myIndices.size());
    for (    final ID<?,?> indexId : myIndices.keySet()) {
      try {
        if (!needsFileContentLoading(indexId)) {
          if (shouldUpdateIndex(file,indexId)) {
            updateSingleIndex(indexId,file,null);
          }
        }
 else {
          if (shouldUpdateIndex(file,indexId)) {
            affectedIndices.add(indexId);
          }
        }
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
    if (!affectedIndices.isEmpty()) {
      if (markForReindex && !isTooLarge(file)) {
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            for (            ID<?,?> indexId : affectedIndices) {
              IndexingStamp.update(file,indexId,-1L);
            }
          }
        }
);
        iterateIndexableFiles(file,new Processor<VirtualFile>(){
          public boolean process(          final VirtualFile file){
            scheduleForUpdate(file);
            return true;
          }
        }
);
      }
 else {
        final InvalidationTask invalidator=new InvalidationTask(file){
          public void run(){
            removeFileDataFromIndices(affectedIndices,file);
          }
        }
;
        myFutureInvalidations.offer(invalidator);
      }
    }
    if (!markForReindex) {
      myFilesToUpdate.remove(file);
    }
    IndexingStamp.flushCache();
  }
}
