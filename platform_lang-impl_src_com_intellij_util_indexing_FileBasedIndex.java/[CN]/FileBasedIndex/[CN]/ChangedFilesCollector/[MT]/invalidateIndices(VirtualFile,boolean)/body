{
  if (isUnderConfigOrSystem(file)) {
    return;
  }
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      final Iterable<VirtualFile> children=file instanceof NewVirtualFile ? ((NewVirtualFile)file).iterInDbChildren() : Arrays.asList(file.getChildren());
      for (      VirtualFile child : children) {
        invalidateIndices(child,markForReindex);
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    IndexingStamp.flushCache();
    final List<ID<?,?>> affectedIndices=new ArrayList<ID<?,?>>(myIndices.size());
    for (    final ID<?,?> indexId : myIndices.keySet()) {
      try {
        if (!needsFileContentLoading(indexId)) {
          if (shouldUpdateIndex(file,indexId)) {
            updateSingleIndex(indexId,file,null);
          }
        }
 else {
          if (shouldUpdateIndex(file,indexId)) {
            affectedIndices.add(indexId);
          }
        }
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
    if (!affectedIndices.isEmpty()) {
      if (markForReindex && !isTooLarge(file)) {
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            for (            ID<?,?> indexId : affectedIndices) {
              IndexingStamp.update(file,indexId,-2L);
            }
          }
        }
);
        scheduleForUpdate(file);
      }
 else {
        myFutureInvalidations.offer(new InvalidationTask(file){
          public void run(){
            removeFileDataFromIndices(affectedIndices,file);
          }
        }
);
      }
    }
    if (!markForReindex) {
      final boolean removedFromUpdateQueue=myFilesToUpdate.remove(file);
      if (removedFromUpdateQueue && affectedIndices.isEmpty()) {
        myFutureInvalidations.offer(new InvalidationTask(file){
          public void run(){
            removeFileDataFromIndices(myRequiringContentIndices,file);
          }
        }
);
      }
    }
    IndexingStamp.flushCache();
  }
}
