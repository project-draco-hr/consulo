{
  if (isUnderConfigOrSystem(file)) {
    return;
  }
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      final Collection<VirtualFile> children=(file instanceof NewVirtualFile) ? ((NewVirtualFile)file).getInDbChildren() : Arrays.asList(file.getChildren());
      for (      VirtualFile child : children) {
        if (NullVirtualFile.INSTANCE != child) {
          invalidateIndices(child,markForReindex);
        }
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    IndexingStamp.flushCache();
    boolean indicesAffected=false;
    final boolean isTooLarge=isTooLarge(file);
    for (    final ID<?,?> indexId : myIndices.keySet()) {
      try {
        if (myNotRequiringContentIndices.contains(indexId)) {
          if (shouldUpdateIndex(file,indexId)) {
            updateSingleIndex(indexId,file,null);
          }
        }
 else {
          if (!isTooLarge && shouldUpdateIndex(file,indexId)) {
            indicesAffected=true;
            if (markForReindex) {
              ApplicationManager.getApplication().runReadAction(new Runnable(){
                public void run(){
                  IndexingStamp.update(file,indexId,-1L);
                }
              }
);
            }
 else {
              updateSingleIndex(indexId,file,null);
            }
          }
        }
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
    IndexingStamp.flushCache();
    if (indicesAffected && markForReindex) {
      iterateIndexableFiles(file,new Processor<VirtualFile>(){
        public boolean process(        final VirtualFile file){
          scheduleForUpdate(file);
          return true;
        }
      }
);
    }
  }
}
