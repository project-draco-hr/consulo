{
  if (isUnderConfigOrSystem(file)) {
    return;
  }
  if (file.isDirectory()) {
    if (isMock(file) || myManagingFS.wereChildrenAccessed(file)) {
      final Collection<VirtualFile> children=(file instanceof NewVirtualFile) ? ((NewVirtualFile)file).getInDbChildren() : Arrays.asList(file.getChildren());
      for (      VirtualFile child : children) {
        if (NullVirtualFile.INSTANCE != child) {
          invalidateIndices(child,markForReindex);
        }
      }
    }
  }
 else {
    cleanProcessedFlag(file);
    IndexingStamp.flushCache();
    final List<ID<?,?>> affectedIndices=new ArrayList<ID<?,?>>(myIndices.size());
    final boolean isTooLarge=isTooLarge(file);
    for (    final ID<?,?> indexId : myIndices.keySet()) {
      try {
        if (myNotRequiringContentIndices.contains(indexId)) {
          if (shouldUpdateIndex(file,indexId)) {
            updateSingleIndex(indexId,file,null);
          }
        }
 else {
          if (!isTooLarge && shouldUpdateIndex(file,indexId)) {
            affectedIndices.add(indexId);
          }
        }
      }
 catch (      StorageException e) {
        LOG.info(e);
        requestRebuild(indexId);
      }
    }
    if (affectedIndices.size() > 0) {
      if (markForReindex) {
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            for (            ID<?,?> indexId : affectedIndices) {
              IndexingStamp.update(file,indexId,-1L);
            }
          }
        }
);
        iterateIndexableFiles(file,new Processor<VirtualFile>(){
          public boolean process(          final VirtualFile file){
            scheduleForUpdate(file);
            return true;
          }
        }
);
      }
 else {
        final InvalidationTask invalidator=new InvalidationTask(file){
          public void run(){
            Throwable unexpectedError=null;
            for (            ID<?,?> indexId : affectedIndices) {
              try {
                updateSingleIndex(indexId,file,null);
              }
 catch (              StorageException e) {
                LOG.info(e);
                requestRebuild(indexId);
              }
catch (              ProcessCanceledException ignored) {
              }
catch (              Throwable e) {
                LOG.info(e);
                if (unexpectedError == null) {
                  unexpectedError=e;
                }
              }
            }
            IndexingStamp.flushCache();
            if (unexpectedError != null) {
              LOG.error(unexpectedError);
            }
          }
        }
;
        w.lock();
        try {
          myFutureInvalidations.offer(invalidator);
        }
  finally {
          w.unlock();
        }
      }
    }
    IndexingStamp.flushCache();
  }
}
