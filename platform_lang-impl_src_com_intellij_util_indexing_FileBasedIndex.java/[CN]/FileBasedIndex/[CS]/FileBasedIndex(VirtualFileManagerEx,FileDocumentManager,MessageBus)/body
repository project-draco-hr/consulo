{
  myVfManager=vfManager;
  myFileDocumentManager=fdm;
  myIsUnitTestMode=ApplicationManager.getApplication().isUnitTestMode();
  myConfigPath=calcConfigPath(PathManager.getConfigPath());
  mySystemPath=calcConfigPath(PathManager.getSystemPath());
  final MessageBusConnection connection=bus.connect();
  connection.subscribe(PsiDocumentTransactionListener.TOPIC,new PsiDocumentTransactionListener(){
    public void transactionStarted(    final Document doc,    final PsiFile file){
      if (file != null) {
        myTransactionMap.put(doc,file);
        myUpToDateIndices.clear();
      }
    }
    public void transactionCompleted(    final Document doc,    final PsiFile file){
      myTransactionMap.remove(doc);
    }
  }
);
  connection.subscribe(AppTopics.FILE_TYPES,new FileTypeListener(){
    private Map<FileType,Set<String>> myTypeToExtensionMap;
    public void beforeFileTypesChanged(    final FileTypeEvent event){
      cleanupProcessedFlag();
      myTypeToExtensionMap=new HashMap<FileType,Set<String>>();
      final FileTypeManager manager=event.getManager();
      for (      FileType type : manager.getRegisteredFileTypes()) {
        myTypeToExtensionMap.put(type,getExtensions(manager,type));
      }
    }
    public void fileTypesChanged(    final FileTypeEvent event){
      final Map<FileType,Set<String>> oldExtensions=myTypeToExtensionMap;
      myTypeToExtensionMap=null;
      if (oldExtensions != null) {
        final FileTypeManager manager=event.getManager();
        final Map<FileType,Set<String>> newExtensions=new HashMap<FileType,Set<String>>();
        for (        FileType type : manager.getRegisteredFileTypes()) {
          newExtensions.put(type,getExtensions(manager,type));
        }
        if (!newExtensions.keySet().containsAll(oldExtensions.keySet())) {
          rebuildAllndices();
          return;
        }
        for (        FileType type : oldExtensions.keySet()) {
          if (!newExtensions.get(type).containsAll(oldExtensions.get(type))) {
            rebuildAllndices();
            return;
          }
        }
      }
    }
    private Set<String> getExtensions(    FileTypeManager manager,    FileType type){
      final Set<String> set=new HashSet<String>();
      for (      FileNameMatcher matcher : manager.getAssociations(type)) {
        set.add(matcher.getPresentableString());
      }
      return set;
    }
    private void rebuildAllndices(){
      for (      ID<?,?> indexId : myIndices.keySet()) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          LOG.info(e);
        }
      }
      scheduleIndexRebuild(true);
    }
  }
);
  connection.subscribe(VirtualFileManager.VFS_CHANGES,new BulkFileListener(){
    public void before(    List<? extends VFileEvent> events){
      for (      VFileEvent event : events) {
        final Object requestor=event.getRequestor();
        if (requestor instanceof FileDocumentManager || requestor instanceof PsiManager || requestor == LocalHistory.VFS_EVENT_REQUESTOR) {
          cleanupMemoryStorage();
          break;
        }
      }
    }
    public void after(    List<? extends VFileEvent> events){
    }
  }
);
  connection.subscribe(AppTopics.FILE_DOCUMENT_SYNC,new FileDocumentManagerAdapter(){
    public void fileContentReloaded(    VirtualFile file,    Document document){
      cleanupMemoryStorage();
    }
    public void unsavedDocumentsDropped(){
      cleanupMemoryStorage();
    }
  }
);
  ApplicationManager.getApplication().addApplicationListener(new ApplicationAdapter(){
    public void writeActionStarted(    Object action){
      myUpToDateIndices.clear();
    }
  }
);
  myChangedFilesCollector=new ChangedFilesCollector();
  try {
    final FileBasedIndexExtension[] extensions=Extensions.getExtensions(FileBasedIndexExtension.EXTENSION_POINT_NAME);
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      ourRebuildStatus.put(extension.getName(),new AtomicInteger(OK));
    }
    final File corruptionMarker=new File(PathManager.getIndexRoot(),CORRUPTION_MARKER_NAME);
    final boolean currentVersionCorrupted=corruptionMarker.exists();
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      registerIndexer(extension,currentVersionCorrupted);
    }
    FileUtil.delete(corruptionMarker);
    dropUnregisteredIndices();
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (ourRebuildStatus.get(indexId).compareAndSet(REQUIRES_REBUILD,OK)) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          requestRebuild(indexId);
          LOG.error(e);
        }
      }
    }
    myVfManager.addVirtualFileListener(myChangedFilesCollector);
    registerIndexableSet(new AdditionalIndexableFileSet());
  }
  finally {
    ShutDownTracker.getInstance().registerShutdownTask(new Runnable(){
      public void run(){
        performShutdown();
      }
    }
);
    saveRegisteredIndices(myIndices.keySet());
    myFlushingFuture=JobScheduler.getScheduler().scheduleAtFixedRate(new Runnable(){
      int lastModCount=0;
      public void run(){
        if (lastModCount == myLocalModCount && !HeavyProcessLatch.INSTANCE.isRunning()) {
          flushAllIndices();
        }
        lastModCount=myLocalModCount;
      }
    }
,5000,5000,TimeUnit.MILLISECONDS);
  }
}
