{
  myVfManager=vfManager;
  myFileDocumentManager=fdm;
  myFileTypeManager=fileTypeManager;
  myIsUnitTestMode=ApplicationManager.getApplication().isUnitTestMode();
  myConfigPath=calcConfigPath(PathManager.getConfigPath());
  mySystemPath=calcConfigPath(PathManager.getSystemPath());
  final MessageBusConnection connection=bus.connect();
  connection.subscribe(PsiDocumentTransactionListener.TOPIC,new PsiDocumentTransactionListener(){
    @Override public void transactionStarted(    final Document doc,    final PsiFile file){
      if (file != null) {
synchronized (myTransactionMap) {
          myTransactionMap.put(doc,file);
        }
        myUpToDateIndices.clear();
      }
    }
    @Override public void transactionCompleted(    final Document doc,    final PsiFile file){
synchronized (myTransactionMap) {
        myTransactionMap.remove(doc);
      }
    }
  }
);
  connection.subscribe(FileTypeManager.TOPIC,new FileTypeListener(){
    @Nullable private Map<FileType,Set<String>> myTypeToExtensionMap;
    @Override public void beforeFileTypesChanged(    final FileTypeEvent event){
      cleanupProcessedFlag();
      myTypeToExtensionMap=new THashMap<FileType,Set<String>>();
      for (      FileType type : myFileTypeManager.getRegisteredFileTypes()) {
        myTypeToExtensionMap.put(type,getExtensions(type));
      }
    }
    @Override public void fileTypesChanged(    final FileTypeEvent event){
      final Map<FileType,Set<String>> oldExtensions=myTypeToExtensionMap;
      myTypeToExtensionMap=null;
      if (oldExtensions != null) {
        final Map<FileType,Set<String>> newExtensions=new THashMap<FileType,Set<String>>();
        for (        FileType type : myFileTypeManager.getRegisteredFileTypes()) {
          newExtensions.put(type,getExtensions(type));
        }
        if (!newExtensions.keySet().containsAll(oldExtensions.keySet())) {
          rebuildAllIndices();
          return;
        }
        for (        Map.Entry<FileType,Set<String>> entry : oldExtensions.entrySet()) {
          FileType fileType=entry.getKey();
          Set<String> strings=entry.getValue();
          if (!newExtensions.get(fileType).containsAll(strings)) {
            rebuildAllIndices();
            return;
          }
        }
      }
    }
    @NotNull private Set<String> getExtensions(    @NotNull FileType type){
      final Set<String> set=new THashSet<String>();
      for (      FileNameMatcher matcher : myFileTypeManager.getAssociations(type)) {
        set.add(matcher.getPresentableString());
      }
      return set;
    }
    private void rebuildAllIndices(){
      for (      ID<?,?> indexId : myIndices.keySet()) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          LOG.info(e);
        }
      }
      scheduleIndexRebuild(true);
    }
  }
);
  connection.subscribe(VirtualFileManager.VFS_CHANGES,new BulkFileListener(){
    @Override public void before(    @NotNull List<? extends VFileEvent> events){
      for (      VFileEvent event : events) {
        final Object requestor=event.getRequestor();
        if (requestor instanceof FileDocumentManager || requestor instanceof PsiManager || requestor == LocalHistory.VFS_EVENT_REQUESTOR) {
          cleanupMemoryStorage();
          break;
        }
      }
    }
    @Override public void after(    @NotNull List<? extends VFileEvent> events){
    }
  }
);
  connection.subscribe(AppTopics.FILE_DOCUMENT_SYNC,new FileDocumentManagerAdapter(){
    @Override public void fileContentReloaded(    VirtualFile file,    @NotNull Document document){
      cleanupMemoryStorage();
    }
    @Override public void unsavedDocumentsDropped(){
      cleanupMemoryStorage();
    }
  }
);
  ApplicationManager.getApplication().addApplicationListener(new ApplicationAdapter(){
    @Override public void writeActionStarted(    Object action){
      myUpToDateIndices.clear();
    }
  }
);
  myChangedFilesCollector=new ChangedFilesCollector();
  try {
    final FileBasedIndexExtension[] extensions=Extensions.getExtensions(FileBasedIndexExtension.EXTENSION_POINT_NAME);
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      ourRebuildStatus.put(extension.getName(),new AtomicInteger(OK));
    }
    final File corruptionMarker=new File(PathManager.getIndexRoot(),CORRUPTION_MARKER_NAME);
    final boolean currentVersionCorrupted=corruptionMarker.exists();
    boolean versionChanged=false;
    for (    FileBasedIndexExtension<?,?> extension : extensions) {
      versionChanged|=registerIndexer(extension,currentVersionCorrupted);
    }
    FileUtil.delete(corruptionMarker);
    String rebuildNotification=null;
    if (currentVersionCorrupted) {
      rebuildNotification="Index files on disk are corrupted. Indices will be rebuilt.";
    }
 else     if (versionChanged) {
      rebuildNotification="Index file format has changed for some indices. These indices will be rebuilt.";
    }
    if (rebuildNotification != null && !ApplicationManager.getApplication().isHeadlessEnvironment() && Registry.is("ide.showIndexRebuildMessage")) {
      new NotificationGroup("Indexing",NotificationDisplayType.BALLOON,false).createNotification("Index Rebuild",rebuildNotification,NotificationType.INFORMATION,null).notify(null);
    }
    dropUnregisteredIndices();
    for (    ID<?,?> indexId : myIndices.keySet()) {
      if (ourRebuildStatus.get(indexId).compareAndSet(REQUIRES_REBUILD,OK)) {
        try {
          clearIndex(indexId);
        }
 catch (        StorageException e) {
          requestRebuild(indexId);
          LOG.error(e);
        }
      }
    }
    myVfManager.addVirtualFileListener(myChangedFilesCollector);
    registerIndexableSet(new AdditionalIndexableFileSet(),null);
  }
  finally {
    ShutDownTracker.getInstance().registerShutdownTask(new Runnable(){
      @Override public void run(){
        performShutdown();
      }
    }
);
    saveRegisteredIndices(myIndices.keySet());
    myFlushingFuture=FlushingDaemon.everyFiveSeconds(new Runnable(){
      int lastModCount=0;
      @Override public void run(){
        if (lastModCount == myLocalModCount) {
          flushAllIndices(lastModCount);
        }
        lastModCount=myLocalModCount;
      }
    }
);
  }
}
