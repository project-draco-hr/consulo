{
  if (scopes == null)   return conflicts;
  for (Iterator<PsiElement> iterator=scopes.iterator(); iterator.hasNext(); ) {
    final PsiElement scope=iterator.next();
    if (scope instanceof PsiPackage || scope instanceof PsiDirectory)     return conflicts;
  }
  final Module targetModule=ModuleUtil.getModuleForFile(project,vFile);
  if (targetModule == null)   return conflicts;
  final GlobalSearchScope resolveScope=GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(targetModule);
  final HashSet<PsiElement> reported=new HashSet<PsiElement>();
  for (Iterator<PsiElement> iterator=scopes.iterator(); iterator.hasNext(); ) {
    final PsiElement scope=iterator.next();
    scope.accept(new PsiRecursiveElementVisitor(){
      public void visitReferenceElement(      PsiJavaCodeReferenceElement reference){
        super.visitReferenceElement(reference);
        final PsiElement resolved=reference.resolve();
        if (resolved != null && !reported.contains(resolved) && !isAncestor(resolved,scopes) && !PsiSearchScopeUtil.isInScope(resolveScope,resolved)) {
          final String scopeDescription=ConflictsUtil.htmlEmphasize(ConflictsUtil.getDescription(ConflictsUtil.getContainer(reference),true));
          final String message=ConflictsUtil.capitalize(ConflictsUtil.htmlEmphasize(ConflictsUtil.getDescription(resolved,true))) + ", referenced in " + scopeDescription+ ", will not be accessible in module "+ ConflictsUtil.htmlEmphasize(targetModule.getName());
          conflicts.add(message);
          reported.add(resolved);
        }
      }
    }
);
  }
  return conflicts;
}
