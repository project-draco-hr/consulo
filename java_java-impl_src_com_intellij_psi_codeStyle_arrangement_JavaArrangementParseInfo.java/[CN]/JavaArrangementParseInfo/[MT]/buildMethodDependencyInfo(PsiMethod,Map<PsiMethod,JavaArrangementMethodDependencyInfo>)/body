{
  JavaElementArrangementEntry entry=myMethodEntriesMap.get(method);
  if (entry == null) {
    return null;
  }
  JavaArrangementMethodDependencyInfo result=new JavaArrangementMethodDependencyInfo(entry);
  Stack<Pair<PsiMethod,JavaArrangementMethodDependencyInfo>> toProcess=new Stack<Pair<PsiMethod,JavaArrangementMethodDependencyInfo>>();
  toProcess.push(Pair.create(method,result));
  Set<PsiMethod> usedMethods=ContainerUtilRt.newHashSet();
  while (!toProcess.isEmpty()) {
    Pair<PsiMethod,JavaArrangementMethodDependencyInfo> pair=toProcess.pop();
    Set<PsiMethod> dependentMethods=myMethodDependencies.get(pair.first);
    if (dependentMethods == null) {
      continue;
    }
    usedMethods.add(pair.first);
    for (    PsiMethod dependentMethod : dependentMethods) {
      if (usedMethods.contains(dependentMethod)) {
        return null;
      }
      JavaElementArrangementEntry dependentEntry=myMethodEntriesMap.get(dependentMethod);
      if (dependentEntry == null) {
        continue;
      }
      JavaArrangementMethodDependencyInfo dependentMethodInfo=cache.get(dependentMethod);
      if (dependentMethodInfo == null) {
        cache.put(dependentMethod,dependentMethodInfo=new JavaArrangementMethodDependencyInfo(dependentEntry));
      }
      Pair<PsiMethod,JavaArrangementMethodDependencyInfo> dependentPair=Pair.create(dependentMethod,dependentMethodInfo);
      pair.second.addDependentMethodInfo(dependentPair.second);
      toProcess.push(dependentPair);
    }
  }
  return result;
}
