{
  String text=textWithImports.getText();
  String imports=textWithImports.getImports();
  GroovyPsiElement toEval;
  GroovyElementFactory factory=GroovyElementFactory.getInstance(project);
  toEval=textWithImports.getKind() == CodeFragmentKind.EXPRESSION ? factory.createExpressionFromText(text,context) : factory.createStatementFromText(text);
  final Set<String> locals=new HashSet<String>();
  toEval.accept(new GroovyRecursiveElementVisitor(){
    public void visitReferenceExpression(    GrReferenceExpression referenceExpression){
      super.visitReferenceExpression(referenceExpression);
      PsiElement resolved=referenceExpression.resolve();
      if (resolved instanceof GrVariable && !(resolved instanceof GrField)) {
        locals.add(((GrVariable)resolved).getName());
      }
    }
  }
);
  StringBuffer javaText=new StringBuffer();
  javaText.append("java.util.Map m = new java.util.HashMap();\n");
  for (  String local : locals) {
    javaText.append("m.put(\"").append(local).append("\", ").append(local).append(");\n");
  }
  javaText.append("groovy.lang.Binding b = new groovy.lang.Binding(m);\n");
  String finalEvalText=imports + "\n" + text;
  javaText.append("new groovy.lang.GroovyShell(b).evaluate(\"").append(StringUtil.escapeStringCharacters(finalEvalText)).append("\");");
  return toEval.getManager().getElementFactory().createCodeBlockCodeFragment(javaText.toString(),null,true);
}
