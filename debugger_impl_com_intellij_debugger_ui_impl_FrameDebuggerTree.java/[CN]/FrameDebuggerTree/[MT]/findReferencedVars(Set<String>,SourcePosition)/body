{
  final int line=position.getLine();
  if (line < 0) {
    return new Pair<Set<String>,Set<TextWithImports>>(Collections.<String>emptySet(),Collections.<TextWithImports>emptySet());
  }
  final PsiFile positionFile=position.getFile();
  final VirtualFile vFile=positionFile.getVirtualFile();
  final Document doc=vFile != null ? FileDocumentManager.getInstance().getDocument(vFile) : null;
  if (doc == null || doc.getLineCount() == 0 || line > (doc.getLineCount() - 1)) {
    return new Pair<Set<String>,Set<TextWithImports>>(Collections.<String>emptySet(),Collections.<TextWithImports>emptySet());
  }
  final TextRange limit=calculateLimitRange(positionFile,doc,line);
  int startLine=Math.max(limit.getStartOffset(),line - 1);
  startLine=Math.min(startLine,limit.getEndOffset());
  while (startLine > limit.getStartOffset() && shouldSkipLine(positionFile,doc,startLine)) {
    startLine--;
  }
  final int startOffset=doc.getLineStartOffset(startLine);
  int endLine=Math.min(line + 2,limit.getEndOffset());
  while (endLine < limit.getEndOffset() && shouldSkipLine(positionFile,doc,endLine)) {
    endLine++;
  }
  final int endOffset=doc.getLineEndOffset(endLine);
  final TextRange lineRange=new TextRange(startOffset,endOffset);
  if (!lineRange.isEmpty()) {
    final int offset=CharArrayUtil.shiftForward(doc.getCharsSequence(),doc.getLineStartOffset(line)," \t");
    PsiElement element=positionFile.findElementAt(offset);
    if (element != null) {
      PsiMethod method=PsiTreeUtil.getNonStrictParentOfType(element,PsiMethod.class);
      if (method != null) {
        element=method;
      }
 else {
        PsiField field=PsiTreeUtil.getNonStrictParentOfType(element,PsiField.class);
        if (field != null) {
          element=field;
        }
 else {
          final PsiClassInitializer initializer=PsiTreeUtil.getNonStrictParentOfType(element,PsiClassInitializer.class);
          if (initializer != null) {
            element=initializer;
          }
        }
      }
      final Set<String> vars=new HashSet<String>();
      final Set<TextWithImports> expressions=new HashSet<TextWithImports>();
      final PsiRecursiveElementVisitor variablesCollector=new VariablesCollector(visibleVars,adjustRange(element,lineRange),expressions,vars);
      element.accept(variablesCollector);
      return new Pair<Set<String>,Set<TextWithImports>>(vars,expressions);
    }
  }
  return new Pair<Set<String>,Set<TextWithImports>>(Collections.<String>emptySet(),Collections.<TextWithImports>emptySet());
}
