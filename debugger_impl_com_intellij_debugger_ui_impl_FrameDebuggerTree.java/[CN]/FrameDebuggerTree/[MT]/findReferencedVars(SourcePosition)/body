{
  final PsiFile file=position.getFile();
  final Document doc=FileDocumentManager.getInstance().getDocument(file.getVirtualFile());
  final int line=position.getLine();
  int startLine=Math.max(0,line - 1);
  while (startLine > 0 && isLineEmpty(doc,startLine))   startLine--;
  final int startOffset=doc.getLineStartOffset(startLine);
  int endLine=Math.min(line + 2,doc.getLineCount() - 1);
  while (endLine < doc.getLineCount() - 1 && isLineEmpty(doc,endLine))   endLine++;
  final int endOffset=doc.getLineEndOffset(endLine);
  final TextRange lineRange=new TextRange(startOffset,endOffset);
  final int offset=CharArrayUtil.shiftForward(doc.getCharsSequence(),doc.getLineStartOffset(line)," \t");
  PsiElement element=file.findElementAt(offset);
  if (element != null) {
    PsiStatement statement=PsiTreeUtil.getNonStrictParentOfType(element,PsiStatement.class);
    if (statement != null) {
      element=statement;
    }
 else {
      PsiExpression expression=PsiTreeUtil.getNonStrictParentOfType(element,PsiExpression.class);
      if (expression != null) {
        element=expression;
      }
    }
    final Set<String> vars=new HashSet<String>();
    final Set<TextWithImports> expressions=new HashSet<TextWithImports>();
    final PsiRecursiveElementVisitor variablesCollector=new PsiRecursiveElementVisitor(){
      public void visitReferenceExpression(      final PsiReferenceExpression reference){
        if (lineRange.intersects(reference.getTextRange())) {
          final PsiElement psiElement=reference.resolve();
          if (psiElement instanceof PsiVariable) {
            final PsiVariable var=(PsiVariable)psiElement;
            if (var instanceof PsiField && !hasMethodCall(reference)) {
              expressions.add(new TextWithImportsImpl(reference));
            }
 else {
              vars.add(var.getName());
            }
          }
        }
        super.visitReferenceExpression(reference);
      }
      public void visitArrayAccessExpression(      final PsiArrayAccessExpression expression){
        if (!hasMethodCall(expression)) {
          expressions.add(new TextWithImportsImpl(expression));
        }
        super.visitArrayAccessExpression(expression);
      }
      public void visitLocalVariable(      final PsiLocalVariable variable){
        if (lineRange.intersects(variable.getTextRange())) {
          vars.add(variable.getName());
        }
        super.visitLocalVariable(variable);
      }
      public void visitClass(      final PsiClass aClass){
      }
    }
;
    element.accept(variablesCollector);
    for (PsiElement sibling=element.getNextSibling(); sibling != null; sibling=sibling.getNextSibling()) {
      if (!lineRange.intersects(sibling.getTextRange())) {
        break;
      }
      sibling.accept(variablesCollector);
    }
    return new Pair<Set<String>,Set<TextWithImports>>(vars,expressions);
  }
  return new Pair<Set<String>,Set<TextWithImports>>(Collections.<String>emptySet(),Collections.<TextWithImports>emptySet());
}
