{
  if (isBlockStatementNeeded && GroovyTokenTypes.mLCURLY.equals(builder.getTokenType())) {
    return OpenOrClosableBlock.parseBlockStatement(builder);
  }
  if (GroovyTokenTypes.kIMPORT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    ImportStatement.parse(builder);
    marker.error(GroovyBundle.message("import.not.allowed"));
    return true;
  }
  if (GroovyTokenTypes.kIF.equals(builder.getTokenType())) {
    return parseIfStatement(builder);
  }
  if (GroovyTokenTypes.kSWITCH.equals(builder.getTokenType())) {
    return SwitchStatement.parse(builder);
  }
  if (GroovyTokenTypes.kTRY.equals(builder.getTokenType())) {
    return TryCatchStatement.parse(builder);
  }
  if (GroovyTokenTypes.kWHILE.equals(builder.getTokenType())) {
    return parseWhileStatement(builder);
  }
  if (GroovyTokenTypes.kFOR.equals(builder.getTokenType())) {
    return parseForStatement(builder);
  }
  if (ParserUtils.lookAhead(builder,GroovyTokenTypes.kSYNCHRONIZED,GroovyTokenTypes.mLPAREN)) {
    PsiBuilder.Marker synMarker=builder.mark();
    if (SynchronizedStatement.parse(builder)) {
      synMarker.drop();
      return true;
    }
 else {
      synMarker.rollbackTo();
    }
  }
  if (GroovyTokenTypes.kELSE.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("else.without.if"));
    parseStatement(builder,true);
    return true;
  }
  if (GroovyTokenTypes.kCATCH.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("catch.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kFINALLY.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("finally.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kCASE.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder);
    marker.error(GroovyBundle.message("case.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kDEFAULT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder);
    marker.error(GroovyBundle.message("default.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (BranchStatement.BRANCH_KEYWORDS.contains(builder.getTokenType())) {
    return BranchStatement.parse(builder);
  }
  if (ParserUtils.lookAhead(builder,GroovyTokenTypes.mIDENT,GroovyTokenTypes.mCOLON)) {
    return parseLabeledStatement(builder);
  }
  PsiBuilder.Marker declMarker=builder.mark();
  if (!Declaration.parse(builder,false)) {
    declMarker.rollbackTo();
  }
 else {
    declMarker.drop();
    return true;
  }
  if (TypeDefinition.parse(builder))   return true;
  return ExpressionStatement.parse(builder);
}
