{
  if (isBlockStatementNeeded && GroovyTokenTypes.mLCURLY.equals(builder.getTokenType())) {
    final PsiBuilder.Marker marker=builder.mark();
    OpenOrClosableBlock.parseOpenBlockDeep(builder,this);
    marker.done(BLOCK_STATEMENT);
    return true;
  }
  if (GroovyTokenTypes.kIMPORT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    ImportStatement.parse(builder,this);
    marker.error(GroovyBundle.message("import.not.allowed"));
    return true;
  }
  if (GroovyTokenTypes.kIF.equals(builder.getTokenType())) {
    return parseIfStatement(builder);
  }
  if (GroovyTokenTypes.kSWITCH.equals(builder.getTokenType())) {
    SwitchStatement.parseSwitch(builder,this);
    return true;
  }
  if (GroovyTokenTypes.kTRY.equals(builder.getTokenType())) {
    return TryCatchStatement.parse(builder,this);
  }
  if (GroovyTokenTypes.kWHILE.equals(builder.getTokenType())) {
    return parseWhileStatement(builder);
  }
  if (GroovyTokenTypes.kFOR.equals(builder.getTokenType())) {
    return parseForStatement(builder);
  }
  if (ParserUtils.lookAhead(builder,GroovyTokenTypes.kSYNCHRONIZED,GroovyTokenTypes.mLPAREN)) {
    PsiBuilder.Marker synMarker=builder.mark();
    if (SynchronizedStatement.parse(builder,this)) {
      synMarker.drop();
      return true;
    }
 else {
      synMarker.rollbackTo();
    }
  }
  if (GroovyTokenTypes.kELSE.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("else.without.if"));
    parseStatement(builder,true);
    return true;
  }
  if (GroovyTokenTypes.kCATCH.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("catch.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kFINALLY.equals(builder.getTokenType())) {
    ParserUtils.wrapError(builder,GroovyBundle.message("finally.without.try"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kCASE.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder,this);
    marker.error(GroovyBundle.message("case.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (GroovyTokenTypes.kDEFAULT.equals(builder.getTokenType())) {
    PsiBuilder.Marker marker=builder.mark();
    SwitchStatement.parseCaseLabel(builder,this);
    marker.error(GroovyBundle.message("default.without.switch"));
    parseStatement(builder,false);
    return true;
  }
  if (BranchStatement.BRANCH_KEYWORDS.contains(builder.getTokenType())) {
    return BranchStatement.parse(builder,this);
  }
  if (ParserUtils.lookAhead(builder,GroovyTokenTypes.mIDENT,GroovyTokenTypes.mCOLON)) {
    return parseLabeledStatement(builder);
  }
  PsiBuilder.Marker declMarker=builder.mark();
  boolean modifiersParsed=Modifiers.parse(builder,this);
  if (kIMPORT == builder.getTokenType()) {
    final PsiBuilder.Marker impMarker=declMarker.precede();
    ImportStatement.parseAfterModifiers(builder);
    declMarker.done(IMPORT_STATEMENT);
    impMarker.error(GroovyBundle.message("import.not.allowed"));
    return true;
  }
  if (kCLASS == builder.getTokenType() || kINTERFACE == builder.getTokenType() || kENUM == builder.getTokenType() || mAT == builder.getTokenType()) {
    final IElementType tdType=TypeDefinition.parseAfterModifiers(builder,this);
    if (tdType != WRONGWAY) {
      declMarker.done(tdType);
      return true;
    }
  }
  final IElementType declType=Declaration.parseAfterModifiers(builder,false,false,this,modifiersParsed);
  if (declType != WRONGWAY) {
    if (declType != null) {
      declMarker.done(declType);
    }
 else {
      declMarker.drop();
    }
    return true;
  }
  if (modifiersParsed) {
    declMarker.done(VARIABLE_DEFINITION_ERROR);
    return true;
  }
  declMarker.rollbackTo();
  return AssignmentExpression.parse(builder,this,true);
}
