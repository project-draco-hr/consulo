{
  int line=pos.line;
  int column=pos.column;
  int visualLineCount=myView.getEditor().getVisibleLineCount();
  if (line >= visualLineCount) {
    return new LogicalPosition(line - visualLineCount + myDocument.getLineCount(),column,pos.leansRight);
  }
  int offset=visualLineToOffset(line);
  int logicalLine=myDocument.getLineNumber(offset);
  int maxVisualColumn=0;
  int maxLogicalColumn=0;
  int maxOffset=offset;
  for (  VisualLineFragmentsIterator.Fragment fragment : VisualLineFragmentsIterator.create(myView,offset,false)) {
    int minColumn=fragment.getStartVisualColumn();
    int maxColumn=fragment.getEndVisualColumn();
    if (column < minColumn || column == minColumn && !pos.leansRight) {
      return offsetToLogicalPosition(offset);
    }
    if (column > minColumn && column < maxColumn || column == minColumn || column == maxColumn && !pos.leansRight) {
      return new LogicalPosition(column == maxColumn ? fragment.getEndLogicalLine() : fragment.getStartLogicalLine(),fragment.visualToLogicalColumn(column),fragment.isCollapsedFoldRegion() ? column < maxColumn : fragment.getCurrentInlays() != null ? column == maxColumn : fragment.isRtl() ^ pos.leansRight);
    }
    maxLogicalColumn=logicalLine == fragment.getEndLogicalLine() ? Math.max(maxLogicalColumn,fragment.getMaxLogicalColumn()) : fragment.getMaxLogicalColumn();
    maxVisualColumn=maxColumn;
    logicalLine=fragment.getEndLogicalLine();
    maxOffset=Math.max(maxOffset,fragment.getMaxOffset());
  }
  if (myView.getEditor().getSoftWrapModel().getSoftWrap(maxOffset) == null) {
    int resultColumn=column - maxVisualColumn + maxLogicalColumn;
    if (resultColumn < 0 && maxLogicalColumn > maxVisualColumn) {
      resultColumn=Integer.MAX_VALUE;
    }
    return new LogicalPosition(logicalLine,resultColumn,true);
  }
 else {
    return offsetToLogicalPosition(maxOffset).leanForward(true);
  }
}
