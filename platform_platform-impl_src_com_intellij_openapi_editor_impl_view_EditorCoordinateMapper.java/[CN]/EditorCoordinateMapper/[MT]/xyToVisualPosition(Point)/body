{
  int visualLine=yToVisualLine(Math.max(p.y,0));
  int lastColumn=0;
  float x=getStartX(visualLine);
  if (visualLine < myView.getEditor().getVisibleLineCount()) {
    int visualLineStartOffset=visualLineToOffset(visualLine);
    int maxOffset=0;
    for (    VisualLineFragmentsIterator.Fragment fragment : VisualLineFragmentsIterator.create(myView,visualLineStartOffset,false)) {
      if (p.x <= fragment.getStartX()) {
        int markerWidth=myView.getEditor().getSoftWrapModel().getMinDrawingWidthInPixels(SoftWrapDrawingType.AFTER_SOFT_WRAP);
        float indent=fragment.getStartX() - markerWidth;
        if (p.x <= indent) {
          break;
        }
        boolean after=p.x >= indent + markerWidth / 2;
        return new VisualPosition(visualLine,fragment.getStartVisualColumn() - (after ? 0 : 1),!after);
      }
      float nextX=fragment.getEndX();
      if (p.x <= nextX) {
        int[] column=fragment.xToVisualColumn(p.x);
        return new VisualPosition(visualLine,column[0],column[1] > 0);
      }
      x=nextX;
      lastColumn=fragment.getEndVisualColumn();
      maxOffset=Math.max(maxOffset,fragment.getMaxOffset());
    }
    if (myView.getEditor().getSoftWrapModel().getSoftWrap(maxOffset) != null) {
      int markerWidth=myView.getEditor().getSoftWrapModel().getMinDrawingWidthInPixels(SoftWrapDrawingType.BEFORE_SOFT_WRAP_LINE_FEED);
      if (p.x <= x + markerWidth) {
        boolean after=p.x >= x + markerWidth / 2;
        return new VisualPosition(visualLine,lastColumn + (after ? 1 : 0),!after);
      }
      p.x-=markerWidth;
      lastColumn++;
    }
  }
  int plainSpaceWidth=myView.getPlainSpaceWidth();
  int remainingShift=(int)(p.x - x);
  int additionalColumns=remainingShift <= 0 ? 0 : (remainingShift + plainSpaceWidth / 2) / plainSpaceWidth;
  return new VisualPosition(visualLine,lastColumn + additionalColumns,remainingShift > 0 && additionalColumns == (remainingShift - 1) / plainSpaceWidth);
}
