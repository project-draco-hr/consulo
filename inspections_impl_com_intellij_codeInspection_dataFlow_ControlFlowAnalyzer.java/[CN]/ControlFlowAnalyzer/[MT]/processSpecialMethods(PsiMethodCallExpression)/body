{
  PsiReferenceExpression methodExpression=expression.getMethodExpression();
  PsiExpression qualifierExpression=methodExpression.getQualifierExpression();
  PsiMethod resolved=expression.resolveMethod();
  if (resolved != null) {
    final PsiExpressionList argList=expression.getArgumentList();
    @NonNls String methodName=resolved.getName();
    PsiExpression[] params=argList.getExpressions();
    PsiClass owner=resolved.getContainingClass();
    final int exitPoint=getEndOffset(expression) - 1;
    if (owner != null) {
      final String className=owner.getQualifiedName();
      if ("java.lang.System".equals(className)) {
        if ("exit".equals(methodName)) {
          pushParameters(params,false);
          addInstruction(myInstructionFactory.createReturnInstruction());
          return true;
        }
      }
 else       if ("junit.framework.Assert".equals(className) || "org.junit.Assert".equals(className) || "org.testng.Assert".equals(className)) {
        if ("fail".equals(methodName)) {
          pushParameters(params,false);
          addInstruction(myInstructionFactory.createReturnInstruction());
          return true;
        }
 else         if ("assertTrue".equals(methodName)) {
          pushParameters(params,true);
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertFalse".equals(methodName)) {
          pushParameters(params,true);
          conditionalExit(exitPoint,true);
          return true;
        }
 else         if ("assertNull".equals(methodName)) {
          pushParameters(params,true);
          addInstruction(myInstructionFactory.createPushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(myInstructionFactory.createBinopInstruction("==",null,expression.getProject()));
          conditionalExit(exitPoint,false);
          return true;
        }
 else         if ("assertNotNull".equals(methodName)) {
          pushParameters(params,true);
          addInstruction(myInstructionFactory.createPushInstruction(myFactory.getConstFactory().getNull(),null));
          addInstruction(myInstructionFactory.createBinopInstruction("==",null,expression.getProject()));
          conditionalExit(exitPoint,true);
          return true;
        }
        return false;
      }
    }
    if (qualifierExpression != null) {
      if (qualifierExpression.textMatches("LOG")) {
        final PsiType qualifierType=qualifierExpression.getType();
        if (qualifierType != null && qualifierType.equalsToText("com.intellij.openapi.diagnostic.Logger")) {
          if ("error".equals(methodName)) {
            for (            PsiExpression param : params) {
              param.accept(this);
              addInstruction(myInstructionFactory.createPopInstruction());
            }
            addInstruction(myInstructionFactory.createReturnInstruction());
            return true;
          }
 else           if ("assertTrue".equals(methodName)) {
            params[0].accept(this);
            for (int i=1; i < params.length; i++) {
              params[i].accept(this);
              addInstruction(myInstructionFactory.createPopInstruction());
            }
            conditionalExit(exitPoint,false);
            return true;
          }
        }
      }
    }
  }
  return false;
}
