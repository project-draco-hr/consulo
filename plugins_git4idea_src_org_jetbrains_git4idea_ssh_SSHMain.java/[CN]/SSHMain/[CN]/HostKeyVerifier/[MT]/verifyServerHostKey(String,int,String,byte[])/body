{
  try {
    String s=System.getenv(GitSSHHandler.SSH_IGNORE_KNOWN_HOSTS_ENV);
    if (s != null && Boolean.parseBoolean(s)) {
      return true;
    }
  }
 catch (  Exception ex) {
  }
  try {
    final int result=database.verifyHostkey(hostname,serverHostKeyAlgorithm,serverHostKey);
    final boolean isNew;
switch (result) {
case KnownHosts.HOSTKEY_IS_OK:
      return true;
case KnownHosts.HOSTKEY_IS_NEW:
    isNew=true;
  break;
case KnownHosts.HOSTKEY_HAS_CHANGED:
isNew=false;
break;
default :
throw new IllegalStateException("Unknown verification result: " + result);
}
String fingerprint=KnownHosts.createHexFingerprint(serverHostKeyAlgorithm,serverHostKey);
boolean keyCheck=myXmlRpcClient.verifyServerHostKey(myHandlerNo,hostname,port,serverHostKeyAlgorithm,fingerprint,isNew);
if (keyCheck) {
String hashedHostname=KnownHosts.createHashedHostname(hostname);
database.addHostkey(new String[]{hashedHostname},serverHostKeyAlgorithm,serverHostKey);
try {
KnownHosts.addHostkeyToFile(new File(knownHostPath),new String[]{hashedHostname},serverHostKeyAlgorithm,serverHostKey);
}
 catch (IOException ignore) {
}
return true;
}
 else {
System.err.println(SSHMainBundle.message("sshmain.invald.host.key",serverHostKeyAlgorithm,fingerprint));
return false;
}
}
 catch (Throwable t) {
System.err.println(SSHMainBundle.message("sshmain.failed.to.verify.key",t.getMessage()));
t.printStackTrace();
return false;
}
}
