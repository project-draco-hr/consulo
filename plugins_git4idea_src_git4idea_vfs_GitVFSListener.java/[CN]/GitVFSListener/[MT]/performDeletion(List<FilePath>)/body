{
  final Map<VirtualFile,List<FilePath>> sortedFiles;
  try {
    sortedFiles=GitUtil.sortFilePathsByGitRoot(filesToDelete,true);
  }
 catch (  VcsException e) {
    gitVcs().showMessages(e.getMessage());
    return;
  }
  gitVcs().runInBackground(new Task.Backgroundable(myProject,GitBundle.getString("remove.removing")){
    public void run(    @NotNull ProgressIndicator indicator){
      HashSet<File> filesToRefresh=new HashSet<File>();
      for (      Map.Entry<VirtualFile,List<FilePath>> e : sortedFiles.entrySet()) {
        try {
          final VirtualFile root=e.getKey();
          final File rootFile=new File(root.getPath());
          indicator.setText(root.getPresentableUrl());
          GitFileUtils.delete(myProject,root,e.getValue(),"--ignore-unmatch");
          if (myProject != null && !myProject.isDisposed()) {
            VcsFileUtil.markFilesDirty(myProject,e.getValue());
          }
          for (          FilePath p : e.getValue()) {
            for (File f=p.getIOFile(); f != null && !f.equals(rootFile); f=f.getParentFile()) {
              filesToRefresh.add(f);
            }
          }
        }
 catch (        final VcsException ex) {
          UIUtil.invokeLaterIfNeeded(new Runnable(){
            public void run(){
              gitVcs().showMessages(ex.getMessage());
            }
          }
);
        }
      }
      LocalFileSystem.getInstance().refreshIoFiles(filesToRefresh);
    }
  }
);
}
