{
  final JpsRemoteProto.Message message=(JpsRemoteProto.Message)e.getMessage();
  final UUID sessionId=ProtoUtil.fromProtoUUID(message.getSessionId());
  JpsRemoteProto.Message reply=null;
  if (message.getMessageType() != JpsRemoteProto.Message.Type.REQUEST) {
    reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("Cannot handle message " + message.toString()));
  }
 else   if (!message.hasRequest()) {
    reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("No request in message: " + message.toString()));
  }
 else {
    final JpsRemoteProto.Message.Request request=message.getRequest();
    final JpsRemoteProto.Message.Request.Type requestType=request.getRequestType();
    final ServerState facade=ServerState.getInstance();
switch (requestType) {
case COMPILE_REQUEST:
      reply=startBuild(sessionId,ctx,request.getCompileRequest());
    break;
case RELOAD_PROJECT_COMMAND:
  final JpsRemoteProto.Message.Request.ReloadProjectCommand reloadProjectCommand=request.getReloadProjectCommand();
facade.clearProjectCache(reloadProjectCommand.getProjectIdList());
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case CANCEL_BUILD_COMMAND:
final JpsRemoteProto.Message.Request.CancelBuildCommand cancelCommand=request.getCancelBuildCommand();
final UUID targetSessionId=ProtoUtil.fromProtoUUID(cancelCommand.getTargetSessionId());
synchronized (myBuildsInProgress) {
for (Iterator<Pair<RunnableFuture,CompilationTask>> it=myBuildsInProgress.iterator(); it.hasNext(); ) {
final Pair<RunnableFuture,CompilationTask> pair=it.next();
final CompilationTask task=pair.second;
if (task.getSessionId().equals(targetSessionId)) {
it.remove();
task.cancel();
pair.first.cancel(true);
break;
}
}
}
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case SETUP_COMMAND:
final Map<String,String> pathVars=new HashMap<String,String>();
final JpsRemoteProto.Message.Request.SetupCommand setupCommand=request.getSetupCommand();
for (JpsRemoteProto.Message.Request.SetupCommand.PathVariable variable : setupCommand.getPathVariableList()) {
pathVars.put(variable.getName(),variable.getValue());
}
final List<GlobalLibrary> libs=new ArrayList<GlobalLibrary>();
for (JpsRemoteProto.Message.Request.SetupCommand.GlobalLibrary library : setupCommand.getGlobalLibraryList()) {
libs.add(library.hasHomePath() ? new SdkLibrary(library.getName(),library.getHomePath(),library.getPathList()) : new GlobalLibrary(library.getName(),library.getPathList()));
}
final String globalEncoding=setupCommand.isInitialized() ? setupCommand.getGlobalEncoding() : null;
facade.setGlobals(libs,pathVars,globalEncoding);
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case SHUTDOWN_COMMAND:
myBuildsExecutor.submit(new Runnable(){
public void run(){
final List<RunnableFuture> futures=new ArrayList<RunnableFuture>();
synchronized (myBuildsInProgress) {
for (Iterator<Pair<RunnableFuture,CompilationTask>> it=myBuildsInProgress.iterator(); it.hasNext(); ) {
final Pair<RunnableFuture,CompilationTask> pair=it.next();
it.remove();
pair.second.cancel();
final RunnableFuture future=pair.first;
futures.add(future);
future.cancel(true);
}
}
facade.clearCahedState();
for (RunnableFuture future : futures) {
try {
future.get();
}
 catch (InterruptedException ignored) {
}
catch (ExecutionException ignored) {
}
}
myServer.stop();
}
}
);
break;
case FS_EVENT:
final JpsRemoteProto.Message.Request.FSEvent fsEvent=request.getFsEvent();
final String projectId=fsEvent.getProjectId();
final ProjectDescriptor pd=facade.getProjectDescriptor(projectId);
if (pd != null) {
try {
for (String path : fsEvent.getChangedPathsList()) {
facade.notifyFileChanged(pd,new File(path));
}
for (String path : fsEvent.getDeletedPathsList()) {
facade.notifyFileDeleted(pd,new File(path));
}
}
  finally {
pd.release();
}
}
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
default :
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("Unknown request: " + message));
}
}
if (reply != null) {
Channels.write(ctx.getChannel(),reply);
}
}
