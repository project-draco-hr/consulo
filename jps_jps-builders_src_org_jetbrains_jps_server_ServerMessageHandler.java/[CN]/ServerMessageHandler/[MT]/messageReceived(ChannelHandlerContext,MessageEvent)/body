{
  myServer.pingReceived();
  final JpsRemoteProto.Message message=(JpsRemoteProto.Message)e.getMessage();
  final UUID sessionId=ProtoUtil.fromProtoUUID(message.getSessionId());
  JpsRemoteProto.Message reply=null;
  if (message.getMessageType() != JpsRemoteProto.Message.Type.REQUEST) {
    reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("Cannot handle message " + message.toString()));
  }
 else   if (!message.hasRequest()) {
    reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("No request in message: " + message.toString()));
  }
 else {
    final JpsRemoteProto.Message.Request request=message.getRequest();
    final JpsRemoteProto.Message.Request.Type requestType=request.getRequestType();
    final ServerState facade=ServerState.getInstance();
switch (requestType) {
case COMPILE_REQUEST:
      reply=startBuild(sessionId,ctx,request.getCompileRequest());
    break;
case RELOAD_PROJECT_COMMAND:
  final JpsRemoteProto.Message.Request.ReloadProjectCommand reloadProjectCommand=request.getReloadProjectCommand();
facade.clearProjectCache(reloadProjectCommand.getProjectIdList());
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case CANCEL_BUILD_COMMAND:
final JpsRemoteProto.Message.Request.CancelBuildCommand cancelCommand=request.getCancelBuildCommand();
final UUID targetSessionId=ProtoUtil.fromProtoUUID(cancelCommand.getTargetSessionId());
cancelSession(targetSessionId);
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case SETUP_COMMAND:
final Map<String,String> pathVars=new HashMap<String,String>();
final JpsRemoteProto.Message.Request.SetupCommand setupCommand=request.getSetupCommand();
for (JpsRemoteProto.Message.KeyValuePair variable : setupCommand.getPathVariableList()) {
pathVars.put(variable.getKey(),variable.getValue());
}
final List<GlobalLibrary> libs=new ArrayList<GlobalLibrary>();
for (JpsRemoteProto.Message.Request.SetupCommand.GlobalLibrary library : setupCommand.getGlobalLibraryList()) {
libs.add(library.hasHomePath() ? new SdkLibrary(library.getName(),library.getTypeName(),library.hasVersion() ? library.getVersion() : null,library.getHomePath(),library.getPathList(),library.hasAdditionalDataXml() ? library.getAdditionalDataXml() : null) : new GlobalLibrary(library.getName(),library.getPathList()));
}
final String globalEncoding=setupCommand.hasGlobalEncoding() ? setupCommand.getGlobalEncoding() : null;
final String ignoredPatterns=setupCommand.hasIgnoredFilesPatterns() ? setupCommand.getIgnoredFilesPatterns() : null;
facade.setGlobals(libs,pathVars,globalEncoding,ignoredPatterns);
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case SHUTDOWN_COMMAND:
myAsyncExecutor.execute(new Runnable(){
public void run(){
try {
cancelAllBuildsAndClearState();
}
  finally {
myServer.stop();
}
}
}
);
break;
case FS_EVENT:
final JpsRemoteProto.Message.Request.FSEvent fsEvent=request.getFsEvent();
final String projectId=fsEvent.getProjectId();
final ProjectDescriptor pd=facade.getProjectDescriptor(projectId);
if (pd != null) {
final boolean wasInterrupted=Thread.interrupted();
try {
try {
for (String path : fsEvent.getChangedPathsList()) {
facade.notifyFileChanged(pd,new File(path));
}
for (String path : fsEvent.getDeletedPathsList()) {
facade.notifyFileDeleted(pd,new File(path));
}
}
  finally {
pd.release();
}
}
  finally {
if (wasInterrupted) {
Thread.currentThread().interrupt();
}
}
}
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
break;
case PING:
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createCommandCompletedEvent(null));
default :
reply=ProtoUtil.toMessage(sessionId,ProtoUtil.createFailure("Unknown request: " + message));
}
}
if (reply != null) {
Channels.write(ctx.getChannel(),reply);
}
}
