{
  final Component orig=super.getTableCellRendererComponent(table,value,isSelected,hasFocus,row,column);
  if (myPluginDescriptor != null) {
    myNameLabel.setText(myPluginDescriptor.getName());
    final PluginId pluginId=myPluginDescriptor.getPluginId();
    final String idString=pluginId.getIdString();
    if (myPluginDescriptor.isBundled()) {
      myBundledLabel.setText("Bundled");
    }
 else {
      final String host=myPlugin2host.get(idString);
      if (host != null) {
        String presentableUrl=VfsUtil.urlToPath(host);
        final int idx=presentableUrl.indexOf('/');
        if (idx > -1) {
          presentableUrl=presentableUrl.substring(0,idx);
        }
        myBundledLabel.setText("From " + presentableUrl);
      }
 else {
        if (PluginManagerUISettings.getInstance().myInstalledPlugins.contains(idString)) {
          myBundledLabel.setText("From repository");
        }
 else {
          myBundledLabel.setText("Custom");
        }
      }
    }
    if (myPluginDescriptor instanceof IdeaPluginDescriptorImpl && ((IdeaPluginDescriptorImpl)myPluginDescriptor).isDeleted()) {
      myNameLabel.setIcon(IconLoader.getIcon("/actions/clean.png"));
    }
 else     if (hasNewerVersion(pluginId)) {
      myNameLabel.setIcon(IconLoader.getIcon("/nodes/pluginobsolete.png"));
      myPanel.setToolTipText("Newer version of the plugin is available");
    }
 else {
      myNameLabel.setIcon(IconLoader.getIcon("/nodes/plugin.png"));
    }
    final Color fg=orig.getForeground();
    final Color bg=orig.getBackground();
    final Color grayedFg=isSelected ? fg : Color.GRAY;
    myPanel.setBackground(bg);
    myNameLabel.setBackground(bg);
    myBundledLabel.setBackground(bg);
    myNameLabel.setForeground(fg);
    final boolean wasUpdated=wasUpdated(pluginId);
    if (wasUpdated || PluginManager.getPlugin(pluginId) == null) {
      if (!isSelected) {
        myNameLabel.setForeground(FileStatus.COLOR_ADDED);
      }
      if (wasUpdated) {
        myPanel.setToolTipText("Plugin was updated to the newest version. Changes will be available after restart");
      }
 else {
        myPanel.setToolTipText("Plugin will be activated after restart.");
      }
    }
    myBundledLabel.setForeground(grayedFg);
    final Set<PluginId> required=myDependentToRequiredListMap.get(pluginId);
    if (required != null && required.size() > 0) {
      myNameLabel.setForeground(Color.RED);
      final StringBuilder s=new StringBuilder();
      if (myEnabled.get(pluginId) == null) {
        s.append("Plugin was not loaded.\n");
      }
      if (required.contains(PluginId.getId("com.intellij.modules.ultimate"))) {
        s.append("The plugin requires IntelliJ IDEA Ultimate");
      }
 else {
        s.append("Required plugin").append(required.size() == 1 ? " \"" : "s \"");
        s.append(StringUtil.join(required,new Function<PluginId,String>(){
          @Override public String fun(          final PluginId id){
            final IdeaPluginDescriptor plugin=PluginManager.getPlugin(id);
            return plugin == null ? id.getIdString() : plugin.getName();
          }
        }
,","));
        s.append(required.size() == 1 ? "\" is not enabled!" : "\" are not enabled!");
      }
      myPanel.setToolTipText(s.toString());
    }
    if (PluginManager.isIncompatible(myPluginDescriptor)) {
      myPanel.setToolTipText(IdeBundle.message("plugin.manager.incompatible.tooltip.warning",ApplicationNamesInfo.getInstance().getFullProductName()));
      myNameLabel.setForeground(Color.red);
    }
  }
  return myPanel;
}
