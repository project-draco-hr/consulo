{
  final PsiManager manager=expression.getManager();
  final GlobalSearchScope resolveScope=expression.getResolveScope();
  List<ExpectedTypeInfo[]> typesList=new ArrayList<ExpectedTypeInfo[]>();
  final List<String> expectedMethodNames=new ArrayList<String>();
  final List<String> expectedFieldNames=new ArrayList<String>();
  getExpectedInformation(expression,typesList,expectedMethodNames,expectedFieldNames);
  if (typesList.size() == 1 && (!expectedFieldNames.isEmpty() || !expectedMethodNames.isEmpty())) {
    ExpectedTypeInfo[] infos=typesList.get(0);
    if (infos.length == 1 && infos[0].getKind() == ExpectedTypeInfo.TYPE_OR_SUBTYPE && infos[0].getType().equals(PsiType.getJavaLangObject(manager,resolveScope))) {
      typesList.clear();
    }
  }
  if (typesList.isEmpty()) {
    final JavaPsiFacade facade=JavaPsiFacade.getInstance(manager.getProject());
    final PsiShortNamesCache cache=PsiShortNamesCache.getInstance(expression.getProject());
    PsiElementFactory factory=facade.getElementFactory();
    for (    String fieldName : expectedFieldNames) {
      PsiField[] fields=cache.getFieldsByName(fieldName,resolveScope);
      addMemberInfo(fields,expression,typesList,factory);
    }
    for (    String methodName : expectedMethodNames) {
      PsiMethod[] methods=cache.getMethodsByName(methodName,resolveScope);
      addMemberInfo(methods,expression,typesList,factory);
    }
  }
  ExpectedTypeInfo[] expectedTypes=ExpectedTypeUtil.intersect(typesList);
  if (expectedTypes.length == 0 && !typesList.isEmpty()) {
    List<ExpectedTypeInfo> union=new ArrayList<ExpectedTypeInfo>();
    for (    ExpectedTypeInfo[] aTypesList : typesList) {
      ContainerUtil.addAll(union,(ExpectedTypeInfo[])aTypesList);
    }
    expectedTypes=union.toArray(new ExpectedTypeInfo[union.size()]);
  }
  if (expectedTypes == null || expectedTypes.length == 0) {
    return allowVoidType ? new PsiType[]{PsiType.VOID} : new PsiType[]{PsiType.getJavaLangObject(manager,resolveScope)};
  }
 else {
    final Set<PsiType> typesSet=new HashSet<PsiType>();
    PsiTypeVisitor<PsiType> visitor=new PsiTypeVisitor<PsiType>(){
      @Override @Nullable public PsiType visitType(      PsiType type){
        if (PsiType.NULL.equals(type)) {
          type=PsiType.getJavaLangObject(manager,resolveScope);
        }
 else         if (PsiType.VOID.equals(type) && !allowVoidType) {
          type=PsiType.getJavaLangObject(manager,resolveScope);
        }
        if (!typesSet.contains(type)) {
          if (type instanceof PsiClassType && (!expectedFieldNames.isEmpty() || !expectedMethodNames.isEmpty())) {
            PsiClass aClass=((PsiClassType)type).resolve();
            if (aClass != null) {
              for (              String fieldName : expectedFieldNames) {
                if (aClass.findFieldByName(fieldName,true) == null)                 return null;
              }
              for (              String methodName : expectedMethodNames) {
                PsiMethod[] methods=aClass.findMethodsByName(methodName,true);
                if (methods.length == 0)                 return null;
              }
            }
          }
          typesSet.add(type);
          return type;
        }
        return null;
      }
      @Override public PsiType visitCapturedWildcardType(      PsiCapturedWildcardType capturedWildcardType){
        return capturedWildcardType.getUpperBound().accept(this);
      }
    }
;
    PsiType[] types=ExpectedTypesProvider.processExpectedTypes(expectedTypes,visitor,manager.getProject());
    if (types.length == 0) {
      return allowVoidType ? new PsiType[]{PsiType.VOID} : new PsiType[]{PsiType.getJavaLangObject(manager,resolveScope)};
    }
    return types;
  }
}
