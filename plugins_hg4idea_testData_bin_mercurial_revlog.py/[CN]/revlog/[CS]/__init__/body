def __init__(self, opener, indexfile):
    '\n        create a revlog object\n\n        opener is a function that abstracts the file opening operation\n        and can be used to implement COW semantics or the like.\n        '
    self.indexfile = indexfile
    self.datafile = (indexfile[:(-2)] + '.d')
    self.opener = opener
    self._cache = None
    self._chunkcache = (0, '')
    self.nodemap = {nullid: nullrev, }
    self.index = []
    v = REVLOG_DEFAULT_VERSION
    if (hasattr(opener, 'options') and ('defversion' in opener.options)):
        v = opener.options['defversion']
        if (v & REVLOGNG):
            v |= REVLOGNGINLINEDATA
    i = ''
    try:
        f = self.opener(self.indexfile)
        i = f.read(_prereadsize)
        if (len(i) > 0):
            v = struct.unpack(versionformat, i[:4])[0]
    except IOError as inst:
        if (inst.errno != errno.ENOENT):
            raise
    self.version = v
    self._inline = (v & REVLOGNGINLINEDATA)
    flags = (v & (~ 65535))
    fmt = (v & 65535)
    if ((fmt == REVLOGV0) and flags):
        raise RevlogError((_('index %s unknown flags %#04x for format v0') % (self.indexfile, (flags >> 16))))
    elif ((fmt == REVLOGNG) and (flags & (~ REVLOGNGINLINEDATA))):
        raise RevlogError((_('index %s unknown flags %#04x for revlogng') % (self.indexfile, (flags >> 16))))
    elif (fmt > REVLOGNG):
        raise RevlogError((_('index %s unknown format %d') % (self.indexfile, fmt)))
    self._io = revlogio()
    if (self.version == REVLOGV0):
        self._io = revlogoldio()
    if i:
        try:
            d = self._io.parseindex(f, i, self._inline)
        except (ValueError, IndexError):
            raise RevlogError((_('index %s is corrupted') % self.indexfile))
        (self.index, self.nodemap, self._chunkcache) = d
        if (not self._chunkcache):
            self._chunkclear()
    if ((self.index == []) or isinstance(self.index, lazyindex) or (self.index[(-1)][7] != nullid)):
        self.index.append((0, 0, 0, (-1), (-1), (-1), (-1), nullid))
