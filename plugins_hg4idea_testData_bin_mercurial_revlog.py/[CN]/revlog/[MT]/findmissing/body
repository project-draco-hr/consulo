def findmissing(self, common=None, heads=None):
    "Return the ancestors of heads that are not ancestors of common.\n\n        More specifically, return a list of nodes N such that every N\n        satisfies the following constraints:\n\n          1. N is an ancestor of some node in 'heads'\n          2. N is not an ancestor of any node in 'common'\n\n        The list is sorted by revision number, meaning it is\n        topologically sorted.\n\n        'heads' and 'common' are both lists of node IDs.  If heads is\n        not supplied, uses all of the revlog's heads.  If common is not\n        supplied, uses nullid."
    if (common is None):
        common = [nullid]
    if (heads is None):
        heads = self.heads()
    common = [self.rev(n) for n in common]
    heads = [self.rev(n) for n in heads]
    has = set(self.ancestors(*common))
    has.add(nullrev)
    has.update(common)
    missing = set()
    visit = [r for r in heads if (r not in has)]
    while visit:
        r = visit.pop(0)
        if (r in missing):
            continue
        else:
            missing.add(r)
            for p in self.parentrevs(r):
                if (p not in has):
                    visit.append(p)
    missing = list(missing)
    missing.sort()
    return [self.node(r) for r in missing]
