def group(self, nodelist, lookup, infocollect=None):
    'Calculate a delta group, yielding a sequence of changegroup chunks\n        (strings).\n\n        Given a list of changeset revs, return a set of deltas and\n        metadata corresponding to nodes. the first delta is\n        parent(nodes[0]) -> nodes[0] the receiver is guaranteed to\n        have this parent as it has all history before these\n        changesets. parent is parent[0]\n        '
    revs = [self.rev(n) for n in nodelist]
    if (not revs):
        yield changegroup.closechunk()
        return
    p = self.parentrevs(revs[0])[0]
    revs.insert(0, p)
    for d in xrange((len(revs) - 1)):
        (a, b) = (revs[d], revs[(d + 1)])
        nb = self.node(b)
        if (infocollect is not None):
            infocollect(nb)
        p = self.parents(nb)
        meta = (((nb + p[0]) + p[1]) + lookup(nb))
        if (a == (-1)):
            d = self.revision(nb)
            meta += mdiff.trivialdiffheader(len(d))
        else:
            d = self.revdiff(a, b)
        yield changegroup.chunkheader((len(meta) + len(d)))
        yield meta
        if (len(d) > (2 ** 20)):
            pos = 0
            while (pos < len(d)):
                pos2 = (pos + (2 ** 18))
                yield d[pos:pos2]
                pos = pos2
        else:
            yield d
    yield changegroup.closechunk()
