def _addrevision(self, text, transaction, link, p1, p2, d, ifh, dfh):
    node = hash(text, p1, p2)
    if (node in self.nodemap):
        return node
    curr = len(self)
    prev = (curr - 1)
    base = self.base(prev)
    offset = self.end(prev)
    if curr:
        if (not d):
            ptext = self.revision(self.node(prev))
            d = mdiff.textdiff(ptext, text)
        data = compress(d)
        l = (len(data[1]) + len(data[0]))
        dist = ((l + offset) - self.start(base))
    if ((not curr) or (dist > (len(text) * 2))):
        data = compress(text)
        l = (len(data[1]) + len(data[0]))
        base = curr
    e = (offset_type(offset, 0), l, len(text), base, link, self.rev(p1), self.rev(p2), node)
    self.index.insert((-1), e)
    self.nodemap[node] = curr
    entry = self._io.packentry(e, self.node, self.version, curr)
    if (not self._inline):
        transaction.add(self.datafile, offset)
        transaction.add(self.indexfile, (curr * len(entry)))
        if data[0]:
            dfh.write(data[0])
        dfh.write(data[1])
        dfh.flush()
        ifh.write(entry)
    else:
        offset += (curr * self._io.size)
        transaction.add(self.indexfile, offset, curr)
        ifh.write(entry)
        ifh.write(data[0])
        ifh.write(data[1])
        self.checkinlinesize(transaction, ifh)
    if (type(text) == str):
        self._cache = (node, curr, text)
    return node
