def revision(self, node):
    'return an uncompressed revision of a given node'
    if (node == nullid):
        return ''
    if (self._cache and (self._cache[0] == node)):
        return self._cache[2]
    text = None
    rev = self.rev(node)
    base = self.base(rev)
    if (self.index[rev][0] & 65535):
        raise RevlogError((_('incompatible revision flag %x') % (self.index[rev][0] & 65535)))
    if (self._cache and (self._cache[1] >= base) and (self._cache[1] < rev)):
        base = self._cache[1]
        text = self._cache[2]
    self._loadindex(base, (rev + 1))
    self._chunkraw(base, rev)
    if (text is None):
        text = self._chunk(base)
    bins = [self._chunk(r) for r in xrange((base + 1), (rev + 1))]
    text = mdiff.patches(text, bins)
    (p1, p2) = self.parents(node)
    if (node != hash(text, p1, p2)):
        raise RevlogError((_('integrity check failed on %s:%d') % (self.indexfile, rev)))
    self._cache = (node, rev, text)
    return text
