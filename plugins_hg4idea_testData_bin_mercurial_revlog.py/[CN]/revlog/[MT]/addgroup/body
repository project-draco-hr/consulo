def addgroup(self, revs, linkmapper, transaction):
    '\n        add a delta group\n\n        given a set of deltas, add them to the revision log. the\n        first delta is against its parent, which should be in our\n        log, the rest are against the previous delta.\n        '
    r = len(self)
    t = (r - 1)
    node = None
    base = prev = nullrev
    start = end = textlen = 0
    if r:
        end = self.end(t)
    ifh = self.opener(self.indexfile, 'a+')
    isize = (r * self._io.size)
    if self._inline:
        transaction.add(self.indexfile, (end + isize), r)
        dfh = None
    else:
        transaction.add(self.indexfile, isize, r)
        transaction.add(self.datafile, end)
        dfh = self.opener(self.datafile, 'a')
    try:
        chain = None
        for chunk in revs:
            (node, p1, p2, cs) = struct.unpack('20s20s20s20s', chunk[:80])
            link = linkmapper(cs)
            if (node in self.nodemap):
                chain = node
                continue
            delta = buffer(chunk, 80)
            del chunk
            for p in (p1, p2):
                if (not (p in self.nodemap)):
                    raise LookupError(p, self.indexfile, _('unknown parent'))
            if (not chain):
                chain = p1
                if (not (chain in self.nodemap)):
                    raise LookupError(chain, self.indexfile, _('unknown base'))
            if (chain == prev):
                cdelta = compress(delta)
                cdeltalen = (len(cdelta[0]) + len(cdelta[1]))
                textlen = mdiff.patchedsize(textlen, delta)
            if ((chain != prev) or (((end - start) + cdeltalen) > (textlen * 2))):
                if dfh:
                    dfh.flush()
                ifh.flush()
                text = self.revision(chain)
                if (len(text) == 0):
                    text = buffer(delta, 12)
                else:
                    text = mdiff.patches(text, [delta])
                del delta
                chk = self._addrevision(text, transaction, link, p1, p2, None, ifh, dfh)
                if ((not dfh) and (not self._inline)):
                    dfh = self.opener(self.datafile, 'a')
                    ifh = self.opener(self.indexfile, 'a')
                if (chk != node):
                    raise RevlogError(_('consistency error adding group'))
                textlen = len(text)
            else:
                e = (offset_type(end, 0), cdeltalen, textlen, base, link, self.rev(p1), self.rev(p2), node)
                self.index.insert((-1), e)
                self.nodemap[node] = r
                entry = self._io.packentry(e, self.node, self.version, r)
                if self._inline:
                    ifh.write(entry)
                    ifh.write(cdelta[0])
                    ifh.write(cdelta[1])
                    self.checkinlinesize(transaction, ifh)
                    if (not self._inline):
                        dfh = self.opener(self.datafile, 'a')
                        ifh = self.opener(self.indexfile, 'a')
                else:
                    dfh.write(cdelta[0])
                    dfh.write(cdelta[1])
                    ifh.write(entry)
            (t, r, chain, prev) = (r, (r + 1), node, node)
            base = self.base(t)
            start = self.start(base)
            end = self.end(t)
    finally:
        if dfh:
            dfh.close()
        ifh.close()
    return node
