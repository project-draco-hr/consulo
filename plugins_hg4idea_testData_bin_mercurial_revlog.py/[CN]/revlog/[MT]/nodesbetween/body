def nodesbetween(self, roots=None, heads=None):
    "Return a topological path from 'roots' to 'heads'.\n\n        Return a tuple (nodes, outroots, outheads) where 'nodes' is a\n        topologically sorted list of all nodes N that satisfy both of\n        these constraints:\n\n          1. N is a descendant of some node in 'roots'\n          2. N is an ancestor of some node in 'heads'\n\n        Every node is considered to be both a descendant and an ancestor\n        of itself, so every reachable node in 'roots' and 'heads' will be\n        included in 'nodes'.\n\n        'outroots' is the list of reachable nodes in 'roots', i.e., the\n        subset of 'roots' that is returned in 'nodes'.  Likewise,\n        'outheads' is the subset of 'heads' that is also in 'nodes'.\n\n        'roots' and 'heads' are both lists of node IDs.  If 'roots' is\n        unspecified, uses nullid as the only root.  If 'heads' is\n        unspecified, uses list of all of the revlog's heads."
    nonodes = ([], [], [])
    if (roots is not None):
        roots = list(roots)
        if (not roots):
            return nonodes
        lowestrev = min([self.rev(n) for n in roots])
    else:
        roots = [nullid]
        lowestrev = nullrev
    if ((lowestrev == nullrev) and (heads is None)):
        return ([self.node(r) for r in self], [nullid], list(self.heads()))
    if (heads is None):
        highestrev = (len(self) - 1)
        ancestors = None
        heads = {}
    else:
        heads = list(heads)
        if (not heads):
            return nonodes
        ancestors = set()
        heads = dict.fromkeys(heads, 0)
        nodestotag = set(heads)
        highestrev = max([self.rev(n) for n in nodestotag])
        while nodestotag:
            n = nodestotag.pop()
            if (n == nullid):
                continue
            r = self.rev(n)
            if (r >= lowestrev):
                if (n not in ancestors):
                    ancestors.add(n)
                    nodestotag.update([p for p in self.parents(n) if (p != nullid)])
                elif (n in heads):
                    heads.pop(n)
        if (not ancestors):
            return nonodes
        if (lowestrev > nullrev):
            roots = [n for n in roots if (n in ancestors)]
            if roots:
                lowestrev = min([self.rev(n) for n in roots])
            else:
                return nonodes
        else:
            lowestrev = nullrev
            roots = [nullid]
    descendents = set(roots)
    roots = descendents.copy()
    orderedout = []
    for r in xrange(max(lowestrev, 0), (highestrev + 1)):
        n = self.node(r)
        isdescendent = False
        if (lowestrev == nullrev):
            isdescendent = True
        elif (n in descendents):
            isdescendent = True
            if (n in roots):
                p = tuple(self.parents(n))
                if ((p[0] in descendents) or (p[1] in descendents)):
                    roots.remove(n)
        else:
            p = tuple(self.parents(n))
            if ((p[0] in descendents) or (p[1] in descendents)):
                descendents.add(n)
                isdescendent = True
        if (isdescendent and ((ancestors is None) or (n in ancestors))):
            orderedout.append(n)
            if ((ancestors is not None) and (n in heads)):
                heads[n] = 1
            elif (ancestors is None):
                heads[n] = 1
                for p in self.parents(n):
                    heads.pop(p, None)
    heads = [n for n in heads.iterkeys() if (heads[n] != 0)]
    roots = list(roots)
    assert orderedout
    assert roots
    assert heads
    return (orderedout, roots, heads)
