{
  if (fileName == null) {
    LOG.error("Patch file name shouldn't be null");
    return;
  }
  final VcsCatchingRunnable vcsCatchingRunnable=new VcsCatchingRunnable(){
    @Override public void runImpl() throws VcsException {
      final VirtualFile baseDir=myProject.getBaseDir();
      final File ioBase=new File(baseDir.getPath());
      final List<FilePatch> allPatches=new ArrayList<>();
      for (      VirtualFile virtualFile : patchGroupsToApply.keySet()) {
        final File ioCurrentBase=new File(virtualFile.getPath());
        allPatches.addAll(ContainerUtil.map(patchGroupsToApply.get(virtualFile),new Function<TextFilePatchInProgress,TextFilePatch>(){
          public TextFilePatch fun(          TextFilePatchInProgress patchInProgress){
            final TextFilePatch was=patchInProgress.getPatch();
            was.setBeforeName(PathUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getBeforeName()))));
            was.setAfterName(PathUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getAfterName()))));
            return was;
          }
        }
));
      }
      if (!allPatches.isEmpty()) {
        PatchEP[] patchTransitExtensions=null;
        if (additionalInfo != null) {
          try {
            final Map<String,PatchEP> extensions=new HashMap<>();
            for (            Map.Entry<String,Map<String,CharSequence>> entry : additionalInfo.get().entrySet()) {
              final String filePath=entry.getKey();
              Map<String,CharSequence> extToValue=entry.getValue();
              for (              Map.Entry<String,CharSequence> innerEntry : extToValue.entrySet()) {
                TransitExtension patchEP=(TransitExtension)extensions.get(innerEntry.getKey());
                if (patchEP == null) {
                  patchEP=new TransitExtension(innerEntry.getKey());
                  extensions.put(innerEntry.getKey(),patchEP);
                }
                patchEP.put(filePath,innerEntry.getValue());
              }
            }
            Collection<PatchEP> values=extensions.values();
            patchTransitExtensions=values.toArray(new PatchEP[values.size()]);
          }
 catch (          PatchSyntaxException e) {
            VcsBalloonProblemNotifier.showOverChangesView(myProject,"Can not import additional patch info: " + e.getMessage(),MessageType.ERROR);
          }
        }
        try {
          final ShelvedChangeList shelvedChangeList=ShelveChangesManager.getInstance(myProject).importFilePatches(fileName,allPatches,patchTransitExtensions);
          ShelvedChangesViewManager.getInstance(myProject).activateView(shelvedChangeList);
        }
 catch (        IOException e) {
          throw new VcsException(e);
        }
      }
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(vcsCatchingRunnable,"Import Patch to Shelf",true,myProject);
  if (!vcsCatchingRunnable.get().isEmpty()) {
    AbstractVcsHelper.getInstance(myProject).showErrors(vcsCatchingRunnable.get(),IMPORT_TO_SHELF);
  }
}
