{
  final VcsCatchingRunnable vcsCatchingRunnable=new VcsCatchingRunnable(){
    @Override public void runImpl() throws VcsException {
      final VirtualFile baseDir=myProject.getBaseDir();
      final File ioBase=new File(baseDir.getPath());
      final List<FilePatch> allPatches=new ArrayList<FilePatch>();
      for (      VirtualFile virtualFile : patchGroups.keySet()) {
        final File ioCurrentBase=new File(virtualFile.getPath());
        allPatches.addAll(ObjectsConvertor.convert(patchGroups.get(virtualFile),new Convertor<FilePatchInProgress,TextFilePatch>(){
          public TextFilePatch convert(          FilePatchInProgress o){
            final TextFilePatch was=o.getPatch();
            was.setBeforeName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getBeforeName()))));
            was.setAfterName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getAfterName()))));
            return was;
          }
        }
));
      }
      if (!allPatches.isEmpty()) {
        PatchEP[] patchTransitExtensions=null;
        if (additionalInfo != null) {
          try {
            final Map<String,PatchEP> extensions=new HashMap<String,PatchEP>();
            for (            Map.Entry<String,Map<String,CharSequence>> entry : additionalInfo.get().entrySet()) {
              final String filePath=entry.getKey();
              Map<String,CharSequence> extToValue=entry.getValue();
              for (              Map.Entry<String,CharSequence> innerEntry : extToValue.entrySet()) {
                TransitExtension patchEP=(TransitExtension)extensions.get(innerEntry.getKey());
                if (patchEP == null) {
                  patchEP=new TransitExtension(innerEntry.getKey());
                  extensions.put(innerEntry.getKey(),patchEP);
                }
                patchEP.put(filePath,innerEntry.getValue());
              }
            }
            Collection<PatchEP> values=extensions.values();
            patchTransitExtensions=values.toArray(new PatchEP[values.size()]);
          }
 catch (          PatchSyntaxException e) {
            VcsBalloonProblemNotifier.showOverChangesView(myProject,"Can not import additional patch info: " + e.getMessage(),MessageType.ERROR);
          }
        }
        try {
          final ShelvedChangeList shelvedChangeList=ShelveChangesManager.getInstance(myProject).importFilePatches(fileName,allPatches,patchTransitExtensions);
          ShelvedChangesViewManager.getInstance(myProject).activateView(shelvedChangeList);
        }
 catch (        IOException e) {
          throw new VcsException(e);
        }
      }
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(vcsCatchingRunnable,"Import patch to shelf",true,myProject);
  if (!vcsCatchingRunnable.get().isEmpty()) {
    AbstractVcsHelper.getInstance(myProject).showErrors(vcsCatchingRunnable.get(),IMPORT_TO_SHELF);
  }
}
