{
  final VcsCatchingRunnable vcsCatchingRunnable=new VcsCatchingRunnable(){
    @Override public void runImpl() throws VcsException {
      final VirtualFile baseDir=myProject.getBaseDir();
      final File ioBase=new File(baseDir.getPath());
      final List<FilePatch> allPatches=new ArrayList<FilePatch>();
      for (      VirtualFile virtualFile : patchGroups.keySet()) {
        final File ioCurrentBase=new File(virtualFile.getPath());
        allPatches.addAll(ObjectsConvertor.convert(patchGroups.get(virtualFile),new Convertor<FilePatchInProgress,TextFilePatch>(){
          public TextFilePatch convert(          FilePatchInProgress o){
            final TextFilePatch was=o.getPatch();
            was.setBeforeName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getBeforeName()))));
            was.setAfterName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getAfterName()))));
            return was;
          }
        }
));
      }
      if (!allPatches.isEmpty()) {
        try {
          final ShelvedChangeList shelvedChangeList=ShelveChangesManager.getInstance(myProject).importFilePatches(fileName,allPatches);
          ShelvedChangesViewManager.getInstance(myProject).activateView(shelvedChangeList);
        }
 catch (        IOException e) {
          throw new VcsException(e);
        }
      }
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(vcsCatchingRunnable,"Import patch to shelf",true,myProject);
  if (!vcsCatchingRunnable.get().isEmpty()) {
    AbstractVcsHelper.getInstance(myProject).showErrors(vcsCatchingRunnable.get(),IMPORT_TO_SHELF);
  }
}
