{
  final VcsCatchingRunnable vcsCatchingRunnable=new VcsCatchingRunnable(){
    @Override public void runImpl() throws VcsException {
      final VirtualFile baseDir=myProject.getBaseDir();
      final File ioBase=new File(baseDir.getPath());
      final List<FilePatch> allPatches=new ArrayList<FilePatch>();
      for (      VirtualFile virtualFile : patchGroups.keySet()) {
        final File ioCurrentBase=new File(virtualFile.getPath());
        allPatches.addAll(ObjectsConvertor.convert(patchGroups.get(virtualFile),new Convertor<FilePatchInProgress,TextFilePatch>(){
          public TextFilePatch convert(          FilePatchInProgress o){
            final TextFilePatch was=o.getPatch();
            was.setBeforeName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getBeforeName()))));
            was.setAfterName(FileUtil.toSystemIndependentName(FileUtil.getRelativePath(ioBase,new File(ioCurrentBase,was.getAfterName()))));
            return was;
          }
        }
));
      }
      if (!allPatches.isEmpty()) {
        PatchEP[] patchTransitExtensions=null;
        if (additionalInfo != null) {
          try {
            final List<PatchEP> list=new ArrayList<PatchEP>();
            for (            Map.Entry<String,Map<String,CharSequence>> entry : additionalInfo.get().entrySet()) {
              list.add(new TransitExtension(entry.getKey(),entry.getValue()));
            }
            patchTransitExtensions=list.toArray(new PatchEP[list.size()]);
          }
 catch (          PatchSyntaxException e) {
            VcsBalloonProblemNotifier.showOverChangesView(myProject,"Can not import additional patch info: " + e.getMessage(),MessageType.ERROR);
          }
        }
        try {
          final ShelvedChangeList shelvedChangeList=ShelveChangesManager.getInstance(myProject).importFilePatches(fileName,allPatches,patchTransitExtensions);
          ShelvedChangesViewManager.getInstance(myProject).activateView(shelvedChangeList);
        }
 catch (        IOException e) {
          throw new VcsException(e);
        }
      }
    }
  }
;
  ProgressManager.getInstance().runProcessWithProgressSynchronously(vcsCatchingRunnable,"Import patch to shelf",true,myProject);
  if (!vcsCatchingRunnable.get().isEmpty()) {
    AbstractVcsHelper.getInstance(myProject).showErrors(vcsCatchingRunnable.get(),IMPORT_TO_SHELF);
  }
}
