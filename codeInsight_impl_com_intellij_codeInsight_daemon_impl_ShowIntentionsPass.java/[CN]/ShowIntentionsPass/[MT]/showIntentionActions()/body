{
  DaemonCodeAnalyzerImpl codeAnalyzer=(DaemonCodeAnalyzerImpl)DaemonCodeAnalyzer.getInstance(myProject);
  if (LookupManager.getInstance(myProject).getActiveLookup() != null)   return;
  LogicalPosition caretPos=myEditor.getCaretModel().getLogicalPosition();
  Rectangle visibleArea=myEditor.getScrollingModel().getVisibleArea();
  Point xy=myEditor.logicalPositionToXY(caretPos);
  if (!visibleArea.contains(xy))   return;
  final Editor injectedEditor=InjectedLanguageUtil.getEditorForInjectedLanguage(myEditor,myFile);
  final PsiFile injectedFile=injectedEditor instanceof EditorDelegate ? ((EditorDelegate)injectedEditor).getInjectedFile() : myFile;
  final PsiElement injectedElement=injectedFile.findElementAt(injectedEditor.getCaretModel().getOffset());
  List<HighlightInfo.IntentionActionDescriptor> intentionsToShow=new ArrayList<HighlightInfo.IntentionActionDescriptor>();
  List<HighlightInfo.IntentionActionDescriptor> fixesToShow=new ArrayList<HighlightInfo.IntentionActionDescriptor>();
  int offset=myEditor.getCaretModel().getOffset();
  for (  IntentionAction action : myIntentionActions) {
    if (action instanceof IntentionActionComposite) {
      if (action instanceof QuickFixAction) {
        List<HighlightInfo.IntentionActionDescriptor> availableActions=((IntentionActionComposite)action).getAvailableActions(myEditor,myFile,myPassIdToShowIntentionsFor);
        HighlightInfo info=codeAnalyzer.findHighlightByOffset(myEditor.getDocument(),offset,true);
        if (info == null || info.getSeverity() == HighlightSeverity.ERROR) {
          fixesToShow.addAll(availableActions);
        }
 else {
          intentionsToShow.addAll(availableActions);
        }
      }
    }
 else     if (action instanceof PsiElementBaseIntentionAction && ((PsiElementBaseIntentionAction)action).isAvailable(myProject,injectedEditor,injectedElement) || action.isAvailable(myProject,injectedEditor,injectedFile)) {
      List<IntentionAction> enableDisableIntentionAction=new ArrayList<IntentionAction>();
      enableDisableIntentionAction.add(new IntentionHintComponent.EnableDisableIntentionAction(action));
      intentionsToShow.add(new HighlightInfo.IntentionActionDescriptor(action,enableDisableIntentionAction,null));
    }
  }
  if (!intentionsToShow.isEmpty() || !fixesToShow.isEmpty()) {
    boolean showBulb=false;
    for (    HighlightInfo.IntentionActionDescriptor action : fixesToShow) {
      if (IntentionManagerSettings.getInstance().isShowLightBulb(action.getAction())) {
        showBulb=true;
        break;
      }
    }
    if (!showBulb) {
      for (      HighlightInfo.IntentionActionDescriptor descriptor : intentionsToShow) {
        final IntentionAction action=descriptor.getAction();
        if (IntentionManagerSettings.getInstance().isShowLightBulb(action) && action.isAvailable(myProject,injectedEditor,injectedFile)) {
          showBulb=true;
          break;
        }
      }
    }
    if (showBulb) {
      IntentionHintComponent hintComponent=codeAnalyzer.getLastIntentionHint();
      if (hintComponent != null) {
        hintComponent.updateIfNotShowingPopup(fixesToShow,intentionsToShow);
      }
      if (!HintManager.getInstance().hasShownHintsThatWillHideByOtherHint()) {
        hintComponent=IntentionHintComponent.showIntentionHint(myProject,injectedEditor,intentionsToShow,fixesToShow,false);
        codeAnalyzer.setLastIntentionHint(hintComponent);
      }
    }
  }
}
