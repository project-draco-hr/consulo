{
  LOG.info("Writing " + changes.size() + " incoming changes");
  List<CommittedChangeList> result=new ArrayList<CommittedChangeList>(changes.size());
  boolean wasEmpty=isEmpty();
  openStreams();
  try {
    if (wasEmpty) {
      myHeaderLoaded=true;
      writeHeader();
    }
    myStream.seek(myStream.length());
    IndexEntry[] entries=readLastIndexEntries(0,1);
    Collections.sort(changes,new Comparator<CommittedChangeList>(){
      public int compare(      final CommittedChangeList o1,      final CommittedChangeList o2){
        return o1.getCommitDate().compareTo(o2.getCommitDate());
      }
    }
);
    for (    CommittedChangeList list : changes) {
      boolean duplicate=false;
      for (      IndexEntry entry : entries) {
        if (list.getCommitDate().getTime() == entry.date && list.getNumber() == entry.number) {
          duplicate=true;
          break;
        }
      }
      if (duplicate)       continue;
      result.add(list);
      long position=myStream.getFilePointer();
      myChangesProvider.writeChangeList(myStream,list);
      if (list.getCommitDate().getTime() > myLastCachedDate.getTime()) {
        myLastCachedDate=list.getCommitDate();
      }
      if (list.getCommitDate().getTime() < myFirstCachedDate.getTime()) {
        myFirstCachedDate=list.getCommitDate();
      }
      if (list.getNumber() < myFirstCachedChangelist) {
        myFirstCachedChangelist=list.getNumber();
      }
      writeIndexEntry(list.getNumber(),list.getCommitDate().getTime(),position,false);
      myIncomingCount++;
    }
    writeHeader();
    myHeaderLoaded=true;
  }
  finally {
    closeStreams();
  }
  return result;
}
