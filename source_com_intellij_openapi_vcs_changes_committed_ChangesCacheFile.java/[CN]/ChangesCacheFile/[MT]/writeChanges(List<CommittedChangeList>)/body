{
  List<CommittedChangeList> result=new ArrayList<CommittedChangeList>(changes.size());
  boolean wasEmpty=isEmpty();
  RandomAccessFile stream=new RandomAccessFile(myPath,"rw");
  RandomAccessFile indexStream=new RandomAccessFile(myIndexPath,"rw");
  try {
    if (wasEmpty) {
      writeHeader(stream);
    }
    stream.seek(stream.length());
    IndexEntry[] entries=readLastIndexEntries(indexStream,1);
    Collections.sort(changes,new Comparator<CommittedChangeList>(){
      public int compare(      final CommittedChangeList o1,      final CommittedChangeList o2){
        return o1.getCommitDate().compareTo(o2.getCommitDate());
      }
    }
);
    for (    CommittedChangeList list : changes) {
      boolean duplicate=false;
      for (      IndexEntry entry : entries) {
        if (list.getCommitDate().getTime() == entry.date && list.getNumber() == entry.number) {
          duplicate=true;
          break;
        }
      }
      if (duplicate)       continue;
      result.add(list);
      long position=stream.getFilePointer();
      myChangesProvider.writeChangeList(stream,list);
      if (list.getCommitDate().getTime() > myLastCachedDate.getTime()) {
        myLastCachedDate=list.getCommitDate();
      }
      if (list.getCommitDate().getTime() < myFirstCachedDate.getTime()) {
        myFirstCachedDate=list.getCommitDate();
      }
      if (list.getNumber() < myFirstCachedChangelist) {
        myFirstCachedChangelist=list.getNumber();
      }
      indexStream.writeLong(list.getNumber());
      indexStream.writeLong(list.getCommitDate().getTime());
      indexStream.writeLong(position);
    }
    writeHeader(stream);
    myHeaderLoaded=true;
  }
  finally {
    stream.close();
    indexStream.close();
  }
  return result;
}
