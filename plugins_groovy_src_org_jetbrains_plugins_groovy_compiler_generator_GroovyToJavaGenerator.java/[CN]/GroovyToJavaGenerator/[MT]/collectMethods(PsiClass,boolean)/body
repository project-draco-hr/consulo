{
  List<PsiMethod> methods=new ArrayList<PsiMethod>();
  ContainerUtil.addAll(methods,typeDefinition.getMethods());
  if (classDef) {
    final Collection<MethodSignature> toOverride=OverrideImplementUtil.getMethodSignaturesToOverride(typeDefinition);
    for (    MethodSignature signature : toOverride) {
      if (signature instanceof MethodSignatureBackedByPsiMethod) {
        final PsiMethod method=((MethodSignatureBackedByPsiMethod)signature).getMethod();
        final PsiClass baseClass=method.getContainingClass();
        if (isAbstractInJava(method) && baseClass != null && typeDefinition.isInheritor(baseClass,true)) {
          methods.add(mirrorMethod(typeDefinition,method,baseClass,JAVA_MODIFIERS));
        }
      }
    }
    final PsiElementFactory factory=JavaPsiFacade.getInstance(myProject).getElementFactory();
    methods.add(factory.createMethodFromText("public groovy.lang.MetaClass getMetaClass() {}",null));
    methods.add(factory.createMethodFromText("public void setMetaClass(groovy.lang.MetaClass mc) {}",null));
    methods.add(factory.createMethodFromText("public Object invokeMethod(String name, Object args) {}",null));
    methods.add(factory.createMethodFromText("public Object getProperty(String propertyName) {}",null));
    methods.add(factory.createMethodFromText("public void setProperty(String propertyName, Object newValue) {}",null));
  }
  for (  PsiClass resolve : collectDelegateTypes(typeDefinition)) {
    for (    PsiMethod method : resolve.getAllMethods()) {
      if (method.hasModifierProperty(PsiModifier.ABSTRACT) && !method.hasModifierProperty(PsiModifier.STATIC)) {
        methods.add(mirrorMethod(typeDefinition,method,typeDefinition,PsiModifier.PUBLIC,PsiModifier.PROTECTED,PsiModifier.PRIVATE));
      }
    }
  }
  return methods;
}
