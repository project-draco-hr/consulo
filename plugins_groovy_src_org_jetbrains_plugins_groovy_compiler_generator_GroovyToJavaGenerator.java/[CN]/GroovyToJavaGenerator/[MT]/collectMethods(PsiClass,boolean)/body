{
  Collection<PsiMethod> methods=new LinkedHashSet<PsiMethod>();
  ContainerUtil.addAll(methods,typeDefinition.getMethods());
  if (classDef) {
    final Collection<MethodSignature> toOverride=OverrideImplementUtil.getMethodSignaturesToOverride(typeDefinition);
    for (    MethodSignature signature : toOverride) {
      if (signature instanceof MethodSignatureBackedByPsiMethod) {
        final PsiMethod method=((MethodSignatureBackedByPsiMethod)signature).getMethod();
        final PsiClass baseClass=method.getContainingClass();
        if (isAbstractInJava(method) && baseClass != null && typeDefinition.isInheritor(baseClass,true)) {
          final LightMethodBuilder builder=new LightMethodBuilder(method.getManager(),method.getName());
          final PsiSubstitutor substitutor=TypeConversionUtil.getSuperClassSubstitutor(baseClass,typeDefinition,PsiSubstitutor.EMPTY);
          for (          PsiParameter parameter : method.getParameterList().getParameters()) {
            builder.addParameter(parameter.getName(),substitutor.substitute(parameter.getType()));
          }
          builder.setReturnType(substitutor.substitute(method.getReturnType()));
          for (          String modifier : JAVA_MODIFIERS) {
            if (method.hasModifierProperty(modifier)) {
              builder.addModifier(modifier);
            }
          }
          methods.add(builder);
        }
      }
    }
    final PsiElementFactory factory=JavaPsiFacade.getInstance(myProject).getElementFactory();
    methods.add(factory.createMethodFromText("public groovy.lang.MetaClass getMetaClass() {}",null));
    methods.add(factory.createMethodFromText("public void setMetaClass(groovy.lang.MetaClass mc) {}",null));
    methods.add(factory.createMethodFromText("public Object invokeMethod(String name, Object args) {}",null));
    methods.add(factory.createMethodFromText("public Object getProperty(String propertyName) {}",null));
    methods.add(factory.createMethodFromText("public void setProperty(String propertyName, Object newValue) {}",null));
  }
  for (  PsiClassType type : collectDelegateTypes(typeDefinition)) {
    final PsiClass resolve=type.resolve();
    if (resolve != null) {
      for (      PsiMethod method : resolve.getAllMethods()) {
        if (method.hasModifierProperty(PsiModifier.ABSTRACT) && !method.hasModifierProperty(PsiModifier.STATIC)) {
          methods.add(method);
        }
      }
    }
  }
  return methods;
}
