def _pythonhook(ui, repo, name, hname, funcname, args, throw):
    'call python hook. hook is callable object, looked up as\n    name in python module. if callable returns "true", hook\n    fails, else passes. if hook raises exception, treated as\n    hook failure. exception propagates if throw is "true".\n\n    reason for "true" meaning "hook failed" is so that\n    unmodified commands (e.g. mercurial.commands.update) can\n    be run as hooks without wrappers to convert return values.'
    ui.note((_('calling hook %s: %s\n') % (hname, funcname)))
    obj = funcname
    if (not hasattr(obj, '__call__')):
        d = funcname.rfind('.')
        if (d == (-1)):
            raise util.Abort((_('%s hook is invalid ("%s" not in a module)') % (hname, funcname)))
        modname = funcname[:d]
        oldpaths = sys.path
        if hasattr(sys, 'frozen'):
            (modpath, modfile) = os.path.split(modname)
            if (modpath and modfile):
                sys.path = (sys.path[:] + [modpath])
                modname = modfile
        try:
            obj = __import__(modname)
        except ImportError:
            e1 = (sys.exc_type, sys.exc_value, sys.exc_traceback)
            try:
                obj = __import__(('hgext_%s' % modname))
            except ImportError:
                e2 = (sys.exc_type, sys.exc_value, sys.exc_traceback)
                if ui.tracebackflag:
                    ui.warn(_('exception from first failed import attempt:\n'))
                ui.traceback(e1)
                if ui.tracebackflag:
                    ui.warn(_('exception from second failed import attempt:\n'))
                ui.traceback(e2)
                raise util.Abort((_('%s hook is invalid (import of "%s" failed)') % (hname, modname)))
        sys.path = oldpaths
        try:
            for p in funcname.split('.')[1:]:
                obj = getattr(obj, p)
        except AttributeError:
            raise util.Abort((_('%s hook is invalid ("%s" is not defined)') % (hname, funcname)))
        if (not hasattr(obj, '__call__')):
            raise util.Abort((_('%s hook is invalid ("%s" is not callable)') % (hname, funcname)))
    try:
        r = obj(ui=ui, repo=repo, hooktype=name, **args)
    except KeyboardInterrupt:
        raise
    except Exception as exc:
        if isinstance(exc, util.Abort):
            ui.warn((_('error: %s hook failed: %s\n') % (hname, exc.args[0])))
        else:
            ui.warn((_('error: %s hook raised an exception: %s\n') % (hname, exc)))
        if throw:
            raise
        ui.traceback()
        return True
    if r:
        if throw:
            raise util.Abort((_('%s hook failed') % hname))
        ui.warn((_('warning: %s hook failed\n') % hname))
    return r
