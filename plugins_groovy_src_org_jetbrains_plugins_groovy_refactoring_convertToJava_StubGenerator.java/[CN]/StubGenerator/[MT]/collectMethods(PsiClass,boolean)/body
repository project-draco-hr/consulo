{
  List<PsiMethod> methods=new ArrayList<PsiMethod>();
  for (  PsiMethod method : typeDefinition.getMethods()) {
    if (method instanceof LightMirrorMethod) {
      PsiMethod prototype=((LightMirrorMethod)method).getPrototype();
      PsiClass aClass=prototype.getContainingClass();
      if (prototype.hasModifierProperty(PsiModifier.FINAL) && aClass != null && typeDefinition.isInheritor(aClass,true)) {
        continue;
      }
    }
    methods.add(method);
  }
  if (classDef) {
    final Collection<MethodSignature> toOverride=OverrideImplementUtil.getMethodSignaturesToOverride(typeDefinition);
    for (    MethodSignature signature : toOverride) {
      if (!(signature instanceof MethodSignatureBackedByPsiMethod))       continue;
      final PsiMethod method=((MethodSignatureBackedByPsiMethod)signature).getMethod();
      final PsiClass baseClass=method.getContainingClass();
      if (baseClass == null)       continue;
      final String qname=baseClass.getQualifiedName();
      if (DEFAULT_BASE_CLASS_NAME.equals(qname) || GROOVY_OBJECT_SUPPORT.equals(qname) || GenerationUtil.isAbstractInJava(method) && typeDefinition.isInheritor(baseClass,true)) {
        if (method.isConstructor())         continue;
        methods.add(mirrorMethod(typeDefinition,method,baseClass,signature.getSubstitutor()));
      }
    }
    final Collection<MethodSignature> toImplement=OverrideImplementUtil.getMethodSignaturesToImplement(typeDefinition);
    for (    MethodSignature signature : toImplement) {
      if (!(signature instanceof MethodSignatureBackedByPsiMethod))       continue;
      final PsiMethod resolved=((MethodSignatureBackedByPsiMethod)signature).getMethod();
      final PsiClass baseClass=resolved.getContainingClass();
      if (baseClass == null)       continue;
      if (!DEFAULT_BASE_CLASS_NAME.equals(baseClass.getQualifiedName()))       continue;
      methods.add(mirrorMethod(typeDefinition,resolved,baseClass,signature.getSubstitutor()));
    }
  }
  return methods;
}
