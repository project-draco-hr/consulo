{
  myPsiTodoSearchHelper=new PsiTodoSearchHelper(){
    @NotNull @Override public PsiFile[] findFilesWithTodoItems(){
      final List<Change> changes=new ArrayList<Change>();
      final List<LocalChangeList> changeLists=myChangeListManager.getChangeLists();
      final Map<VirtualFile,Change> allChanges=new HashMap<VirtualFile,Change>();
      for (      LocalChangeList changeList : changeLists) {
        final Collection<Change> currChanges=changeList.getChanges();
        for (        Change currChange : currChanges) {
          if (currChange.getAfterRevision() != null && currChange.getAfterRevision().getFile().getVirtualFile() != null) {
            allChanges.put(currChange.getAfterRevision().getFile().getVirtualFile(),currChange);
          }
        }
      }
      for (Iterator<PsiFile> iterator=myIncludedFiles.iterator(); iterator.hasNext(); ) {
        final PsiFile next=iterator.next();
        final Change change=allChanges.get(next.getVirtualFile());
        if (change != null) {
          changes.add(change);
        }
      }
      final TodoCheckinHandlerWorker worker=new TodoCheckinHandlerWorker(myProject,changes,getTodoTreeStructure().getTodoFilter(),true);
      worker.execute();
      buildMap(worker.inOneList());
      final Set<PsiFile> files=myMap.keySet();
      return files.toArray(new PsiFile[files.size()]);
    }
    @NotNull @Override public TodoItem[] findTodoItems(    @NotNull PsiFile file){
      if (!myIncludedFiles.contains(file))       return EMPTY_ITEMS;
      if (myDirtyFileSet.contains(file.getVirtualFile())) {
        myMap.remove(file);
        final Change change=myChangeListManager.getChange(file.getVirtualFile());
        if (change != null) {
          final TodoCheckinHandlerWorker worker=new TodoCheckinHandlerWorker(myProject,Collections.singletonList(change),getTodoTreeStructure().getTodoFilter(),true);
          worker.execute();
          final List<TodoItem> todoItems=worker.inOneList();
          if (todoItems != null && !todoItems.isEmpty()) {
            for (            TodoItem todoItem : todoItems) {
              myMap.putValue(file,todoItem);
            }
          }
        }
      }
      final Collection<TodoItem> todoItems=myMap.get(file);
      return todoItems == null || todoItems.isEmpty() ? EMPTY_ITEMS : todoItems.toArray(new TodoItem[todoItems.size()]);
    }
    @NotNull @Override public TodoItem[] findTodoItems(    @NotNull PsiFile file,    int startOffset,    int endOffset){
      final TodoItem[] todoItems=findTodoItems(file);
      if (todoItems.length == 0) {
        return todoItems;
      }
      final TextRange textRange=new TextRange(startOffset,endOffset);
      final List<TodoItem> result=new ArrayList<TodoItem>();
      for (      TodoItem todoItem : todoItems) {
        if (todoItem.getTextRange().contains(textRange)) {
          result.add(todoItem);
        }
      }
      return result.isEmpty() ? EMPTY_ITEMS : result.toArray(new TodoItem[result.size()]);
    }
    @Override public int getTodoItemsCount(    @NotNull PsiFile file){
      return findTodoItems(file).length;
    }
    @Override public int getTodoItemsCount(    @NotNull PsiFile file,    @NotNull TodoPattern pattern){
      throw new UnsupportedOperationException();
    }
  }
;
}
