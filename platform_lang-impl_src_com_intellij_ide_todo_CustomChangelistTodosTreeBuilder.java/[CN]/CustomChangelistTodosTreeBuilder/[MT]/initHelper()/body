{
  myPsiTodoSearchHelper=new PsiTodoSearchHelper(){
    @NotNull @Override public PsiFile[] findFilesWithTodoItems(){
      final List<Change> changes=new ArrayList<Change>();
      final List<LocalChangeList> changeLists=myChangeListManager.getChangeLists();
      final Map<VirtualFile,Change> allChanges=new HashMap<VirtualFile,Change>();
      for (      LocalChangeList changeList : changeLists) {
        final Collection<Change> currChanges=changeList.getChanges();
        for (        Change currChange : currChanges) {
          if (currChange.getAfterRevision() != null && currChange.getAfterRevision().getFile().getVirtualFile() != null) {
            allChanges.put(currChange.getAfterRevision().getFile().getVirtualFile(),currChange);
          }
        }
      }
      for (Iterator<PsiFile> iterator=myIncludedFiles.iterator(); iterator.hasNext(); ) {
        final PsiFile next=iterator.next();
        final Change change=allChanges.get(next.getVirtualFile());
        if (change != null) {
          changes.add(change);
        }
      }
      final TodoCheckinHandlerWorker worker=new TodoCheckinHandlerWorker(myProject,changes,getTodoTreeStructure().getTodoFilter(),true);
      worker.execute();
      buildMap(worker.inOneList());
      final Set<PsiFile> files=myMap.keySet();
      return files.toArray(new PsiFile[files.size()]);
    }
    @NotNull @Override public TodoItem[] findTodoItems(    @NotNull PsiFile file){
      return findPatternedTodoItems(file,getTodoTreeStructure().getTodoFilter());
    }
    @NotNull @Override public TodoItem[] findTodoItemsLight(    @NotNull PsiFile file){
      return findTodoItems(file);
    }
    @NotNull @Override public TodoItem[] findTodoItemsLight(    @NotNull PsiFile file,    int startOffset,    int endOffset){
      return findTodoItems(file,startOffset,endOffset);
    }
    @NotNull @Override public TodoItem[] findTodoItems(    @NotNull PsiFile file,    int startOffset,    int endOffset){
      final TodoItem[] todoItems=findTodoItems(file);
      if (todoItems.length == 0) {
        return todoItems;
      }
      final TextRange textRange=new TextRange(startOffset,endOffset);
      final List<TodoItem> result=new ArrayList<TodoItem>();
      for (      TodoItem todoItem : todoItems) {
        if (todoItem.getTextRange().contains(textRange)) {
          result.add(todoItem);
        }
      }
      return result.isEmpty() ? EMPTY_ITEMS : result.toArray(new TodoItem[result.size()]);
    }
    @Override public int getTodoItemsCount(    @NotNull PsiFile file){
      return findTodoItems(file).length;
    }
    @Override public int getTodoItemsCount(    @NotNull PsiFile file,    @NotNull TodoPattern pattern){
      final TodoFilter filter=new TodoFilter();
      filter.addTodoPattern(pattern);
      return findPatternedTodoItems(file,filter).length;
    }
  }
;
}
