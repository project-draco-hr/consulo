{
  final StubIndexKey<K,?> indexKey=extension.getKey();
  final int version=extension.getVersion();
synchronized (state) {
    state.myIndexIdToVersionMap.put(indexKey,version);
  }
  final File versionFile=IndexInfrastructure.getVersionFile(indexKey);
  final boolean versionFileExisted=versionFile.exists();
  final File indexRootDir=IndexInfrastructure.getIndexRootDir(indexKey);
  boolean needRebuild=false;
  if (forceClean || IndexingStamp.versionDiffers(versionFile,version)) {
    final String[] children=indexRootDir.list();
    boolean indexRootHasChildren=children != null && children.length > 0;
    needRebuild=!forceClean && (versionFileExisted || indexRootHasChildren);
    if (needRebuild) {
      LOG.info("Version has changed for stub index " + extension.getKey() + ". The index will be rebuilt.");
    }
    if (indexRootHasChildren)     FileUtil.deleteWithRenaming(indexRootDir);
    IndexingStamp.rewriteVersion(versionFile,version);
  }
  for (int attempt=0; attempt < 2; attempt++) {
    try {
      final MapIndexStorage<K,StubIdList> storage=new MapIndexStorage<K,StubIdList>(IndexInfrastructure.getStorageFile(indexKey),extension.getKeyDescriptor(),StubIdExternalizer.INSTANCE,extension.getCacheSize(),false,extension instanceof StringStubIndexExtension && ((StringStubIndexExtension)extension).traceKeyHashToVirtualFileMapping());
      final MemoryIndexStorage<K,StubIdList> memStorage=new MemoryIndexStorage<K,StubIdList>(storage,indexKey);
      MyIndex<K> index=new MyIndex<K>(new IndexExtension<K,StubIdList,Void>(){
        @NotNull @Override public ID<K,StubIdList> getName(){
          return (ID<K,StubIdList>)indexKey;
        }
        @NotNull @Override public DataIndexer<K,StubIdList,Void> getIndexer(){
          return new DataIndexer<K,StubIdList,Void>(){
            @NotNull @Override public Map<K,StubIdList> map(            Void inputData){
              return Collections.emptyMap();
            }
          }
;
        }
        @NotNull @Override public KeyDescriptor<K> getKeyDescriptor(){
          return extension.getKeyDescriptor();
        }
        @NotNull @Override public DataExternalizer<StubIdList> getValueExternalizer(){
          return StubIdExternalizer.INSTANCE;
        }
        @Override public int getVersion(){
          return extension.getVersion();
        }
      }
,memStorage);
synchronized (state) {
        state.myIndices.put(indexKey,index);
      }
      break;
    }
 catch (    IOException e) {
      needRebuild=true;
      onExceptionInstantiatingIndex(version,versionFile,indexRootDir,e);
    }
catch (    RuntimeException e) {
      Throwable cause=FileBasedIndexImpl.getCauseToRebuildIndex(e);
      if (cause == null)       throw e;
      onExceptionInstantiatingIndex(version,versionFile,indexRootDir,e);
    }
  }
  return needRebuild;
}
