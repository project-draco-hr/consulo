{
  final StubIndexKey<K,?> indexKey=extension.getKey();
  final int version=extension.getVersion();
  myIndexIdToVersionMap.put(indexKey,version);
  final File versionFile=IndexInfrastructure.getVersionFile(indexKey);
  final boolean versionFileExisted=versionFile.exists();
  final File indexRootDir=IndexInfrastructure.getIndexRootDir(indexKey);
  boolean needRebuild=false;
  if (forceClean || IndexingStamp.versionDiffers(versionFile,version)) {
    final String[] children=indexRootDir.list();
    boolean indexRootHasChildren=children != null && children.length > 0;
    needRebuild=!forceClean && (versionFileExisted || indexRootHasChildren);
    if (needRebuild) {
      LOG.info("Version has changed for stub index " + extension.getKey() + ". The index will be rebuilt.");
    }
    if (indexRootHasChildren)     FileUtil.deleteWithRenaming(indexRootDir);
    IndexingStamp.rewriteVersion(versionFile,version);
  }
  for (int attempt=0; attempt < 2; attempt++) {
    try {
      final MapIndexStorage<K,StubIdList> storage=new MapIndexStorage<K,StubIdList>(IndexInfrastructure.getStorageFile(indexKey),extension.getKeyDescriptor(),new StubIdExternalizer(),extension.getCacheSize(),false,extension instanceof StringStubIndexExtension && ((StringStubIndexExtension)extension).traceKeyHashToVirtualFileMapping());
      final MemoryIndexStorage<K,StubIdList> memStorage=new MemoryIndexStorage<K,StubIdList>(storage);
      myIndices.put(indexKey,new MyIndex<K>(memStorage));
      break;
    }
 catch (    IOException e) {
      needRebuild=true;
      onExceptionInstantiatingIndex(version,versionFile,indexRootDir,e);
    }
catch (    RuntimeException e) {
      Throwable cause=FileBasedIndexImpl.getCauseToRebuildIndex(e);
      if (cause == null)       throw e;
      onExceptionInstantiatingIndex(version,versionFile,indexRootDir,e);
    }
  }
  return needRebuild;
}
