{
  FileBasedIndex.getInstance().ensureUpToDate(StubUpdatingIndex.INDEX_ID,project,scope);
  final PersistentFS fs=(PersistentFS)ManagingFS.getInstance();
  final PsiManager psiManager=PsiManager.getInstance(project);
  final List<Psi> result=new ArrayList<Psi>();
  final MyIndex<Key> index=(MyIndex<Key>)myIndices.get(indexKey);
  try {
    try {
      FileBasedIndex.disableUpToDateCheckForCurrentThread();
      index.getReadLock().lock();
      final ValueContainer<TIntArrayList> container=index.getData(key);
      container.forEach(new ValueContainer.ContainerAction<TIntArrayList>(){
        public void perform(        final int id,        final TIntArrayList value){
          final VirtualFile file=IndexInfrastructure.findFileById(fs,id);
          if (file != null && (scope == null || scope.contains(file))) {
            StubTree stubTree=null;
            final PsiFile _psifile=psiManager.findFile(file);
            PsiFileWithStubSupport psiFile=null;
            if (_psifile != null && !(_psifile instanceof PsiPlainTextFile)) {
              if (_psifile instanceof PsiFileWithStubSupport) {
                psiFile=(PsiFileWithStubSupport)_psifile;
                stubTree=psiFile.getStubTree();
                if (stubTree == null && psiFile instanceof PsiFileImpl) {
                  stubTree=((PsiFileImpl)psiFile).calcStubTree();
                }
              }
            }
            if (stubTree != null || psiFile != null) {
              if (stubTree == null) {
                stubTree=StubTree.readFromVFile(project,file);
                if (stubTree != null) {
                  final List<StubElement<?>> plained=stubTree.getPlainList();
                  for (int i=0; i < value.size(); i++) {
                    final StubElement<?> stub=plained.get(value.get(i));
                    final ASTNode tree=psiFile.findTreeForStub(stubTree,stub);
                    if (tree != null) {
                      if (tree.getElementType() == stubType(stub)) {
                        result.add((Psi)tree.getPsi());
                      }
 else {
                        String persistedStubTree=((PsiFileStubImpl)stubTree.getRoot()).printTree();
                        String stubTreeJustBuilt=((PsiFileStubImpl)((IStubFileElementType)((PsiFileImpl)psiFile).getContentElementType()).getBuilder().buildStubTree(psiFile)).printTree();
                        StringBuilder builder=new StringBuilder();
                        builder.append("Oops\n");
                        builder.append("Recorded stub:-----------------------------------\n");
                        builder.append(persistedStubTree);
                        builder.append("\nAST built stub: ------------------------------------\n");
                        builder.append(stubTreeJustBuilt);
                        builder.append("\n");
                        LOG.info(builder.toString());
                        ApplicationManager.getApplication().invokeLater(new Runnable(){
                          public void run(){
                            FileBasedIndex.getInstance().requestReindex(file);
                          }
                        }
,ModalityState.NON_MODAL);
                      }
                    }
                  }
                }
              }
 else {
                final List<StubElement<?>> plained=stubTree.getPlainList();
                for (int i=0; i < value.size(); i++) {
                  result.add((Psi)plained.get(value.get(i)).getPsi());
                }
              }
            }
          }
        }
      }
);
    }
  finally {
      index.getReadLock().unlock();
      FileBasedIndex.enableUpToDateCheckForCurrentThread();
    }
  }
 catch (  StorageException e) {
    forceRebuild(e);
  }
catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException || cause instanceof StorageException) {
      forceRebuild(e);
    }
 else {
      throw e;
    }
  }
  return result;
}
