{
  final FileBasedIndexImpl fileBasedIndex=(FileBasedIndexImpl)FileBasedIndex.getInstance();
  fileBasedIndex.ensureUpToDate(StubUpdatingIndex.INDEX_ID,project,scope);
  final PersistentFS fs=(PersistentFS)ManagingFS.getInstance();
  final MyIndex<Key> index=(MyIndex<Key>)myIndices.get(indexKey);
  try {
    try {
      FileBasedIndexImpl.disableUpToDateCheckForCurrentThread();
      index.getReadLock().lock();
      final ValueContainer<StubIdList> container=index.getData(key);
      final IdFilter finalIdFilter=idFilter != null ? idFilter : fileBasedIndex.projectIndexableFiles(project);
      return container.forEach(new ValueContainer.ContainerAction<StubIdList>(){
        @Override public boolean perform(        final int id,        @NotNull final StubIdList value){
          ProgressManager.checkCanceled();
          if (finalIdFilter != null && !finalIdFilter.contains(id))           return true;
          final VirtualFile file=IndexInfrastructure.findFileByIdIfCached(fs,id);
          if (file == null || scope != null && !scope.contains(file)) {
            return true;
          }
          return myStubProcessingHelper.processStubsInFile(project,file,value,processor);
        }
      }
);
    }
  finally {
      index.getReadLock().unlock();
      FileBasedIndexImpl.enableUpToDateCheckForCurrentThread();
    }
  }
 catch (  StorageException e) {
    forceRebuild(e);
  }
catch (  RuntimeException e) {
    final Throwable cause=FileBasedIndexImpl.getCauseToRebuildIndex(e);
    if (cause != null) {
      forceRebuild(cause);
    }
 else {
      throw e;
    }
  }
  return true;
}
