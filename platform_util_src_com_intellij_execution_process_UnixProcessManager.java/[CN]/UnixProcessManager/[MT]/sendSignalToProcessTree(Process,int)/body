{
  checkCLib();
  int our_pid=C_LIB.getpid();
  int process_pid=getProcessPid(process);
  try {
    String[] psCmd=getPSCmd(false);
    Process p=Runtime.getRuntime().exec(psCmd);
    ProcessInfo processInfo=new ProcessInfo();
    @SuppressWarnings({"IOResourceOpenedButNotSafelyClosed"}) BufferedReader stdInput=new BufferedReader(new InputStreamReader(p.getInputStream()));
    BufferedReader stdError=new BufferedReader(new InputStreamReader(p.getErrorStream()));
    List<Integer> childrenPids=new ArrayList<Integer>();
    boolean result;
    try {
      String s;
      stdInput.readLine();
      int foundPid=0;
      while ((s=stdInput.readLine()) != null) {
        StringTokenizer st=new StringTokenizer(s," ");
        int parent_pid=Integer.parseInt(st.nextToken());
        int pid=Integer.parseInt(st.nextToken());
        processInfo.register(pid,parent_pid);
        if (parent_pid == process_pid) {
          childrenPids.add(pid);
        }
        if (pid == process_pid) {
          if (parent_pid == our_pid) {
            foundPid=pid;
          }
 else {
            throw new IllegalStateException("process is not our child");
          }
        }
      }
      if (foundPid != 0) {
        processInfo.killProcTree(foundPid,signal);
        result=true;
      }
 else {
        for (        Integer pid : childrenPids) {
          processInfo.killProcTree(pid,signal);
        }
        result=false;
      }
      StringBuffer errorStr=new StringBuffer();
      while ((s=stdError.readLine()) != null) {
        errorStr.append(s).append("\n");
      }
      if (errorStr.length() > 0) {
        throw new IllegalStateException("error:" + errorStr.toString());
      }
    }
  finally {
      stdInput.close();
      stdError.close();
    }
    return result;
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}
