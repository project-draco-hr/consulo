{
  if (!file.isInLocalFileSystem() && VcsUtil.isPathRemote(file.getPath())) {
    final SvnChangeList list=ShowAllSubmittedFilesAction.loadRevisions(myProject,file,(SvnRevisionNumber)number,FileUtil.toSystemIndependentName(file.getPath()));
    return new Pair<SvnChangeList,FilePath>(list,new FilePathImpl(file));
  }
  final RootUrlInfo rootUrlInfo=myVcs.getSvnFileUrlMapping().getWcRootForFilePath(new File(file.getPath()));
  if (rootUrlInfo == null)   return null;
  final VirtualFile root=rootUrlInfo.getVirtualFile();
  if (root == null)   return null;
  final SvnRepositoryLocation svnRootLocation=(SvnRepositoryLocation)getLocationFor(new FilePathImpl(root));
  if (svnRootLocation == null)   return null;
  final String url=svnRootLocation.getURL();
  final long revision;
  try {
    revision=Long.parseLong(number.asString());
  }
 catch (  NumberFormatException e) {
    throw new VcsException(e);
  }
  final SvnChangeList[] result=new SvnChangeList[1];
  final SVNLogClient logger;
  final SVNRevision revisionBefore;
  final SVNURL repositoryUrl;
  final SVNURL svnurl;
  final SVNInfo targetInfo;
  try {
    logger=myVcs.createLogClient();
    revisionBefore=SVNRevision.create(revision);
    svnurl=SVNURL.parseURIEncoded(url);
    final SVNWCClient client=myVcs.createWCClient();
    final SVNInfo info=client.doInfo(svnurl,SVNRevision.UNDEFINED,SVNRevision.HEAD);
    targetInfo=client.doInfo(new File(file.getPath()),SVNRevision.WORKING);
    if (info == null) {
      throw new VcsException("Can not get repository URL");
    }
    repositoryUrl=info.getRepositoryRootURL();
  }
 catch (  SVNException e) {
    throw new VcsException(e);
  }
  tryExactHit(svnRootLocation,result,logger,revisionBefore,repositoryUrl,svnurl);
  if (result[0] == null) {
    tryByRoot(result,logger,revisionBefore,repositoryUrl);
    if (result[0] == null) {
      FilePath path=tryStepByStep(svnRootLocation,result,logger,revisionBefore,targetInfo,svnurl);
      path=path == null ? new FilePathImpl(file) : path;
      return new Pair<SvnChangeList,FilePath>(result[0],path);
    }
  }
  if (result[0].getChanges().size() == 1) {
    final Collection<Change> changes=result[0].getChanges();
    final Change change=changes.iterator().next();
    final ContentRevision afterRevision=change.getAfterRevision();
    if (afterRevision != null) {
      return new Pair<SvnChangeList,FilePath>(result[0],afterRevision.getFile());
    }
 else {
      return new Pair<SvnChangeList,FilePath>(result[0],new FilePathImpl(file));
    }
  }
  String relativePath=SVNPathUtil.getRelativePath(targetInfo.getRepositoryRootURL().toString(),targetInfo.getURL().toString());
  relativePath=relativePath.startsWith("/") ? relativePath : "/" + relativePath;
  final Change targetChange=result[0].getByPath(relativePath);
  if (targetChange == null) {
    FilePath path=tryStepByStep(svnRootLocation,result,logger,revisionBefore,targetInfo,svnurl);
    path=path == null ? new FilePathImpl(file) : path;
    return new Pair<SvnChangeList,FilePath>(result[0],path);
  }
  return new Pair<SvnChangeList,FilePath>(result[0],new FilePathImpl(file));
}
