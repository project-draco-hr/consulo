{
  final GrField field;
  if (element.getParent() instanceof GrField) {
    field=(GrField)element.getParent();
  }
 else {
    final PsiReference ref=element.getReference();
    LOG.assertTrue(ref != null);
    PsiElement resolved=ref.resolve();
    if (resolved instanceof GrAccessorMethod) {
      resolved=((GrAccessorMethod)resolved).getProperty();
    }
    LOG.assertTrue(resolved instanceof GrField);
    field=(GrField)resolved;
  }
  final HashSet<PsiReference> usages=new HashSet<PsiReference>();
  usages.addAll(ReferencesSearch.search(field).findAll());
  final GrAccessorMethod[] getters=field.getGetters();
  for (  GrAccessorMethod getter : getters) {
    usages.addAll(MethodReferencesSearch.search(getter).findAll());
  }
  final GrAccessorMethod setter=field.getSetter();
  if (setter != null) {
    usages.addAll(MethodReferencesSearch.search(setter).findAll());
  }
  final String fieldName=field.getName();
  LOG.assertTrue(fieldName != null);
  final Collection<PsiElement> fieldUsages=new HashSet<PsiElement>();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  for (  PsiReference usage : usages) {
    final PsiElement psiElement=usage.getElement();
    if (PsiUtil.isMethodUsage(psiElement))     continue;
    if (!GroovyFileType.GROOVY_LANGUAGE.equals(psiElement.getLanguage())) {
      conflicts.putValue(psiElement,GroovyIntentionsBundle.message("closure.is.accessed.outside.of.groovy",fieldName));
    }
 else {
      if (psiElement instanceof GrReferenceExpression) {
        fieldUsages.add(psiElement);
        if (PsiUtil.isAccessedForWriting((GrExpression)psiElement)) {
          conflicts.putValue(psiElement,GroovyIntentionsBundle.message("write.access.to.closure.variable",fieldName));
        }
      }
 else       if (psiElement instanceof GrArgumentLabel) {
        conflicts.putValue(psiElement,GroovyIntentionsBundle.message("field.is.used.in.argument.label",fieldName));
      }
    }
  }
  final PsiClass containingClass=field.getContainingClass();
  final GrExpression initializer=field.getInitializerGroovy();
  LOG.assertTrue(initializer != null);
  final PsiType type=initializer.getType();
  LOG.assertTrue(type instanceof GrClosureType);
  final GrSignature signature=((GrClosureType)type).getSignature();
  final List<MethodSignature> signatures=GrClosureSignatureUtil.generateAllMethodSignaturesBySignature(fieldName,signature);
  for (  MethodSignature s : signatures) {
    final PsiMethod method=MethodSignatureUtil.findMethodBySignature(containingClass,s,true);
    if (method != null) {
      conflicts.putValue(method,GroovyIntentionsBundle.message("method.with.signature.already.exists",GroovyPresentationUtil.getSignaturePresentation(s)));
    }
  }
  if (conflicts.size() > 0) {
    final ConflictsDialog conflictsDialog=new ConflictsDialog(project,conflicts,new Runnable(){
      @Override public void run(){
        execute(field,fieldUsages);
      }
    }
);
    conflictsDialog.show();
    if (conflictsDialog.getExitCode() != DialogWrapper.OK_EXIT_CODE)     return;
  }
  execute(field,fieldUsages);
}
