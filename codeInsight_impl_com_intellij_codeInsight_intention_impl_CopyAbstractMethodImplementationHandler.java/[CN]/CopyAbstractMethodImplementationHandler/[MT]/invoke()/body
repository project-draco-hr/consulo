{
  ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
    public void run(){
      searchExistingImplementations();
    }
  }
,CodeInsightBundle.message("searching.for.implementations"),false,myProject);
  if (mySourceMethods.isEmpty()) {
    Messages.showErrorDialog(myProject,CodeInsightBundle.message("copy.abstract.method.no.existing.implementations.found"),CodeInsightBundle.message("copy.abstract.method.title"));
    return;
  }
  if (mySourceMethods.size() == 1) {
    copyImplementation(mySourceMethods.get(0));
  }
 else {
    Collections.sort(mySourceMethods,new Comparator<PsiMethod>(){
      public int compare(      final PsiMethod o1,      final PsiMethod o2){
        PsiClass c1=o1.getContainingClass();
        PsiClass c2=o2.getContainingClass();
        return Comparing.compare(c1.getName(),c2.getName());
      }
    }
);
    final PsiMethod[] methodArray=mySourceMethods.toArray(new PsiMethod[mySourceMethods.size()]);
    final JList list=new JList(methodArray);
    list.setCellRenderer(new MethodCellRenderer(true));
    final Runnable runnable=new Runnable(){
      public void run(){
        int index=list.getSelectedIndex();
        if (index < 0)         return;
        PsiMethod element=(PsiMethod)list.getSelectedValue();
        copyImplementation(element);
      }
    }
;
    new PopupChooserBuilder(list).setTitle(CodeInsightBundle.message("copy.abstract.method.popup.title")).setItemChoosenCallback(runnable).createPopup().showInBestPositionFor(myEditor);
  }
}
