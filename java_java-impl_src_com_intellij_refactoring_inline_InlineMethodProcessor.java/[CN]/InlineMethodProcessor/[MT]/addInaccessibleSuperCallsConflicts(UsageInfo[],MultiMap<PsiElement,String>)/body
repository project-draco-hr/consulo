{
  myMethod.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitClass(    PsiClass aClass){
    }
    @Override public void visitAnonymousClass(    PsiAnonymousClass aClass){
    }
    @Override public void visitSuperExpression(    PsiSuperExpression expression){
      super.visitSuperExpression(expression);
      final PsiType type=expression.getType();
      final PsiClass superClass=PsiUtil.resolveClassInType(type);
      if (superClass != null) {
        final Set<PsiClass> targetContainingClasses=new HashSet<PsiClass>();
        for (        UsageInfo info : usagesIn) {
          final PsiElement element=info.getElement();
          if (element != null) {
            final PsiClass targetContainingClass=PsiTreeUtil.getParentOfType(element,PsiClass.class);
            if (targetContainingClass != null && !InheritanceUtil.isInheritorOrSelf(targetContainingClass,superClass,true)) {
              targetContainingClasses.add(targetContainingClass);
            }
          }
        }
        if (!targetContainingClasses.isEmpty()) {
          final PsiMethodCallExpression methodCallExpression=PsiTreeUtil.getParentOfType(expression,PsiMethodCallExpression.class);
          LOG.assertTrue(methodCallExpression != null);
          conflicts.putValue(expression,"Inlined method calls " + methodCallExpression.getText() + " which won't be accessed in "+ StringUtil.join(targetContainingClasses,new Function<PsiClass,String>(){
            public String fun(            PsiClass psiClass){
              return RefactoringUIUtil.getDescription(psiClass,false);
            }
          }
,","));
        }
      }
    }
  }
);
}
