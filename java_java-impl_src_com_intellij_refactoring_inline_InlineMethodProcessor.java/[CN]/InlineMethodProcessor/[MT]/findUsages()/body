{
  if (myInlineThisOnly)   return new UsageInfo[]{new UsageInfo(myReference)};
  Set<UsageInfo> usages=new HashSet<UsageInfo>();
  if (myReference != null) {
    usages.add(new UsageInfo(myReference));
  }
  for (  PsiReference reference : ReferencesSearch.search(myMethod)) {
    usages.add(new UsageInfo(reference.getElement()));
  }
  if (mySearchInComments || mySearchForTextOccurrences) {
    final NonCodeUsageInfoFactory infoFactory=new NonCodeUsageInfoFactory(myMethod,myMethod.getName()){
      @Override public UsageInfo createUsageInfo(      @NotNull PsiElement usage,      int startOffset,      int endOffset){
        if (PsiTreeUtil.isAncestor(myMethod,usage,false))         return null;
        return super.createUsageInfo(usage,startOffset,endOffset);
      }
    }
;
    if (mySearchInComments) {
      String stringToSearch=ElementDescriptionUtil.getElementDescription(myMethod,NonCodeSearchDescriptionLocation.STRINGS_AND_COMMENTS);
      TextOccurrencesUtil.addUsagesInStringsAndComments(myMethod,stringToSearch,usages,infoFactory);
    }
    if (mySearchForTextOccurrences) {
      String stringToSearch=ElementDescriptionUtil.getElementDescription(myMethod,NonCodeSearchDescriptionLocation.NON_JAVA);
      TextOccurrencesUtil.addTextOccurences(myMethod,stringToSearch,GlobalSearchScope.projectScope(myProject),usages,infoFactory);
    }
  }
  return usages.toArray(new UsageInfo[usages.size()]);
}
