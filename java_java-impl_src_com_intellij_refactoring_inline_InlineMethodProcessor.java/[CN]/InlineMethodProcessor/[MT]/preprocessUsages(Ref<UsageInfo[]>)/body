{
  if (!myInlineThisOnly && checkReadOnly()) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myMethod))     return false;
  }
  final UsageInfo[] usagesIn=refUsages.get();
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.putValue(method,message);
    }
    for (    UsageInfo info : usagesIn) {
      final PsiElement element=info.getElement();
      if (element instanceof PsiDocMethodOrFieldRef && !PsiTreeUtil.isAncestor(myMethod,element,false)) {
        conflicts.putValue(element,"Inlined method is used in javadoc");
      }
    }
  }
  addInaccessibleMemberConflicts(myMethod,usagesIn,new ReferencedElementsCollector(),conflicts);
  addInaccessibleSuperCallsConflicts(usagesIn,conflicts);
  return showConflicts(conflicts,usagesIn);
}
