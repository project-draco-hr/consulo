{
  final UsageInfo[] usagesIn=refUsages.get();
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.putValue(method,message);
    }
  }
  addInaccessibleMemberConflicts(myMethod,usagesIn,new ReferencedElementsCollector(),conflicts);
  addInaccessibleSuperCallsConflicts(usagesIn,conflicts);
  if (!myInlineThisOnly) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myMethod))     return false;
  }
  return showConflicts(conflicts);
}
