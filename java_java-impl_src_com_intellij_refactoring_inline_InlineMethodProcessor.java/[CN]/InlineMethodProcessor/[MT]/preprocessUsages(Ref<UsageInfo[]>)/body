{
  UsageInfo[] usagesIn=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.putValue(method,message);
    }
  }
  addInaccessibleMemberConflicts(myMethod,usagesIn,new ReferencedElementsCollector(),conflicts);
  if (!conflicts.isEmpty()) {
    ConflictsDialog dialog=new ConflictsDialog(myProject,conflicts);
    dialog.show();
    if (!dialog.isOK()) {
      if (dialog.isShowConflicts())       prepareSuccessful();
      return false;
    }
  }
  if (!myInlineThisOnly) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myMethod))     return false;
  }
  prepareSuccessful();
  return true;
}
