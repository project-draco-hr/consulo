{
  if (!myInlineThisOnly && checkReadOnly()) {
    if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myMethod))     return false;
  }
  final UsageInfo[] usagesIn=refUsages.get();
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!myInlineThisOnly) {
    final PsiMethod[] superMethods=myMethod.findSuperMethods();
    for (    PsiMethod method : superMethods) {
      final String message=method.hasModifierProperty(PsiModifier.ABSTRACT) ? RefactoringBundle.message("inlined.method.implements.method.from.0",method.getContainingClass().getQualifiedName()) : RefactoringBundle.message("inlined.method.overrides.method.from.0",method.getContainingClass().getQualifiedName());
      conflicts.putValue(method,message);
    }
    for (    UsageInfo info : usagesIn) {
      final PsiElement element=info.getElement();
      if (element instanceof PsiDocMethodOrFieldRef && !PsiTreeUtil.isAncestor(myMethod,element,false)) {
        conflicts.putValue(element,"Inlined method is used in javadoc");
      }
    }
  }
  final PsiReturnStatement[] returnStatements=RefactoringUtil.findReturnStatements(myMethod);
  for (  PsiReturnStatement statement : returnStatements) {
    PsiExpression value=statement.getReturnValue();
    if (value != null && !(value instanceof PsiCallExpression)) {
      for (      UsageInfo info : usagesIn) {
        PsiReference reference=info.getReference();
        InlineUtil.TailCallType type=InlineUtil.getTailCallType(reference);
        if (type == InlineUtil.TailCallType.Simple) {
          conflicts.putValue(statement,"Inlined result won't be a valid statement");
          break;
        }
      }
    }
  }
  addInaccessibleMemberConflicts(myMethod,usagesIn,new ReferencedElementsCollector(),conflicts);
  addInaccessibleSuperCallsConflicts(usagesIn,conflicts);
  return showConflicts(conflicts,usagesIn);
}
