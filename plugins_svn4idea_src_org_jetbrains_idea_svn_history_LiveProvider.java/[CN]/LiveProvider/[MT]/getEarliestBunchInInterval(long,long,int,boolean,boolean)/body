{
  final SVNRevision youngRevision=(earliestRevision == -1) ? SVNRevision.HEAD : SVNRevision.create(earliestRevision);
  try {
    final List<CommittedChangeList> list=myLoader.loadInterval(youngRevision,SVNRevision.create(oldestRevision),desirableSize,includeYoungest,includeOldest);
    if (list.isEmpty()) {
      myEarliestRevisionWasAccessed=(oldestRevision == 0);
      return null;
    }
    myEarliestRevisionWasAccessed=(oldestRevision == 0) && ((list.size() + ((!includeOldest) ? 1 : 0) + ((!includeYoungest) ? 1 : 0)) < desirableSize);
    return new Fragment(Origin.LIVE,list,true,true,null);
  }
 catch (  SVNException e) {
    if (SVNErrorCode.FS_NOT_FOUND.equals(e.getErrorMessage().getErrorCode())) {
      final LatestExistentSearcher searcher=new LatestExistentSearcher(oldestRevision,myYoungestRevision,(oldestRevision != 0),myVcs,SVNURL.parseURIEncoded(myLocation.getURL()));
      final long existent=searcher.execute();
      if ((existent == -1) || (existent == earliestRevision)) {
        myEarliestRevisionWasAccessed=true;
        return null;
      }
      return getEarliestBunchInInterval(existent,oldestRevision,includeYoungest ? desirableSize : (desirableSize + 1),true,includeOldest);
    }
    throw e;
  }
}
