{
  ClassMapCachingNulls<MultiHostInjector> cached=cachedInjectors;
  if (cached != null) {
    return cached;
  }
  Map<Class,MultiHostInjector[]> injectors=ContainerUtil.newHashMap();
  MultiMap<Class<? extends PsiElement>,MultiHostInjector> allInjectors=MultiMap.createLinkedSet();
  allInjectors.putAllValues(myManualInjectors);
  for (  MultiHostInjectorExtensionPoint multiHostInjectorExtensionPoint : MultiHostInjector.EP_NAME.getExtensions(myProject)) {
    Class<PsiElement> key=multiHostInjectorExtensionPoint.getKey();
    MultiHostInjector multiHostInjector=multiHostInjectorExtensionPoint.getInstance(myProject);
    allInjectors.putValue(key,multiHostInjector);
  }
  if (LanguageInjector.EXTENSION_POINT_NAME.getExtensions().length > 0) {
    allInjectors.putValue(PsiLanguageInjectionHost.class,PsiManagerRegisteredInjectorsAdapter.INSTANCE);
  }
  for (  Map.Entry<Class<? extends PsiElement>,Collection<MultiHostInjector>> entry : allInjectors.entrySet()) {
    Class<? extends PsiElement> place=entry.getKey();
    Collection<MultiHostInjector> value=entry.getValue();
    for (    MultiHostInjector injector : value) {
      MultiHostInjector[] existing=injectors.get(place);
      injectors.put(place,existing == null ? new MultiHostInjector[]{injector} : ArrayUtil.append(existing,injector));
    }
  }
  ClassMapCachingNulls<MultiHostInjector> result=new ClassMapCachingNulls<MultiHostInjector>(injectors,new MultiHostInjector[0]);
  cachedInjectors=result;
  return result;
}
