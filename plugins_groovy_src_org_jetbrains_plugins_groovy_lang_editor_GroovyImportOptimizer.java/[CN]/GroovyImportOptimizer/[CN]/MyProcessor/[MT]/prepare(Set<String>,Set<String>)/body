{
  final Project project=myFile.getProject();
  final PsiManager manager=myFile.getManager();
  final CodeStyleSettings settings=CodeStyleSettingsManager.getSettings(project);
  final GroovyElementFactory factory=GroovyElementFactory.getInstance(project);
  TObjectIntHashMap<String> packageCountMap=new TObjectIntHashMap<String>();
  TObjectIntHashMap<String> classCountMap=new TObjectIntHashMap<String>();
  for (  String importedClass : importedClasses) {
    final String packageName=getParentName(importedClass);
    if (isPackageImplicitlyImported(packageName))     continue;
    if (!packageCountMap.containsKey(packageName))     packageCountMap.put(packageName,0);
    packageCountMap.increment(packageName);
  }
  for (  String importedMember : staticallyImportedMembers) {
    final String className=getParentName(importedMember);
    if (!classCountMap.containsKey(className))     packageCountMap.put(className,0);
    classCountMap.increment(className);
  }
  final Set<String> onDemandImportedSimpleClassNames=new HashSet<String>();
  final List<GrImportStatement> result=new ArrayList<GrImportStatement>();
  packageCountMap.forEachEntry(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      if (i >= settings.CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND) {
        result.add(factory.createImportStatementFromText(s,false,true));
        final PsiPackage aPackage=manager.findPackage(s);
        if (aPackage != null) {
          for (          PsiClass clazz : aPackage.getClasses()) {
            onDemandImportedSimpleClassNames.add(clazz.getName());
          }
        }
      }
      return true;
    }
  }
);
  classCountMap.forEachEntry(new TObjectIntProcedure<String>(){
    public boolean execute(    String s,    int i){
      if (i >= settings.NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND) {
        result.add(factory.createImportStatementFromText(s,true,true));
      }
      return true;
    }
  }
);
  for (  String importedClass : importedClasses) {
    final String parentName=getParentName(importedClass);
    if (packageCountMap.get(parentName) >= settings.CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND)     continue;
    if (isClassImplicitlyImported(importedClass) && !onDemandImportedSimpleClassNames.contains(getSimpleName(importedClass)))     continue;
    result.add(factory.createImportStatementFromText(importedClass,false,false));
  }
  for (  String importedMember : staticallyImportedMembers) {
    final String parentName=getParentName(importedMember);
    if (classCountMap.get(parentName) >= settings.CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND)     continue;
    result.add(factory.createImportStatementFromText(importedMember,true,false));
  }
  GrImportStatement[] statements=result.toArray(new GrImportStatement[result.size()]);
  Arrays.sort(statements,new Comparator<GrImportStatement>(){
    public int compare(    GrImportStatement statement1,    GrImportStatement statement2){
      final GrCodeReferenceElement ref1=statement1.getImportReference();
      final GrCodeReferenceElement ref2=statement2.getImportReference();
      String name1=ref1 != null ? PsiUtil.getQualifiedReferenceText(ref1) : null;
      String name2=ref2 != null ? PsiUtil.getQualifiedReferenceText(ref2) : null;
      if (name1 == null)       return name2 == null ? 0 : -1;
      if (name2 == null)       return 1;
      return name1.compareTo(name2);
    }
  }
);
  return statements;
}
