{
  InputStream loggedInputStream=connectionStreams.getLoggedInputStream();
  if (responseName.equalsIgnoreCase("E")) {
    final byte[] line=StreamUtilities.readLineBytes(loggedInputStream);
    responseProcessor.processErrorMessageResponse(prepareMessageAccordingToScr39148(line),responseServices);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("M")) {
    final byte[] line=StreamUtilities.readLineBytes(loggedInputStream);
    responseProcessor.processMessageResponse(prepareMessageAccordingToScr39148(line),responseServices);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("MBinary")) {
    final String fileLengthString=myStreamUtilities.readLine(loggedInputStream);
    try {
      int fileLength=Integer.parseInt(fileLengthString);
      responseProcessor.processBinaryMessageResponse(fileLength,readFromStream(connectionStreams,fileLength),responseServices);
    }
 catch (    NumberFormatException e) {
    }
    return null;
  }
 else   if (responseName.equalsIgnoreCase("MT")) {
    final byte[] text=StreamUtilities.readLineBytes(loggedInputStream);
    responseProcessor.processMessageTaggedResponse(text,responseServices);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Updated")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String entryLine=myStreamUtilities.readLine(loggedInputStream);
    final String mode=myStreamUtilities.readLine(loggedInputStream);
    final String fileLengthString=myStreamUtilities.readLine(loggedInputStream);
    final int fileLength;
    try {
      fileLength=Integer.parseInt(fileLengthString);
      responseProcessor.processUpdatedResponse(relativeLocalDirectory,repositoryFilePath,entryLine,mode,fileLength,clientEnvironment,responseServices,connectionStreams);
    }
 catch (    NumberFormatException ex) {
    }
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Merged")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String entryLine=myStreamUtilities.readLine(loggedInputStream);
    final String mode=myStreamUtilities.readLine(loggedInputStream);
    final String fileLengthString=myStreamUtilities.readLine(loggedInputStream);
    final int fileLength;
    try {
      fileLength=Integer.parseInt(fileLengthString);
      responseProcessor.processMergedResponse(relativeLocalDirectory,repositoryFilePath,entryLine,mode,fileLength,clientEnvironment,responseServices,connectionStreams);
    }
 catch (    NumberFormatException ex) {
    }
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Checked-in")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String entryLine=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processCheckedInResponse(relativeLocalDirectory,repositoryFilePath,entryLine,responseServices,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("New-entry")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String entryLine=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processNewEntryResponse(relativeLocalDirectory,repositoryFilePath,responseServices,entryLine,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Set-static-directory")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processSetStaticDirectoryResponse(relativeLocalDirectory,repositoryFilePath,responseServices,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Clear-static-directory")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryDirectoryPath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processClearStaticDirectoryResponse(relativeLocalDirectory,repositoryDirectoryPath,responseServices,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Set-sticky")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String tag=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processSetStickyResponse(relativeLocalDirectory,repositoryFilePath,tag,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Clear-sticky")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processClearStickyResponse(relativeLocalDirectory,repositoryFilePath,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Notified")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processNotifiedResponse(relativeLocalDirectory,repositoryFilePath,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Removed")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFileName=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processRemovedResponse(relativeLocalDirectory,repositoryFileName,responseServices,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Remove-entry")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processRemoveEntryResponse(relativeLocalDirectory,repositoryFilePath,responseServices,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Copy-file")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String newName=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processCopyFileResponse(relativeLocalDirectory,repositoryFilePath,newName,clientEnvironment);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Mod-time")) {
    final String dateString=myStreamUtilities.readLine(loggedInputStream);
    try {
      final Date modifiedDate=ResponseUtils.parseDateString(dateString);
      responseProcessor.processModTimeResponse(modifiedDate,responseServices);
    }
 catch (    Exception ex) {
      BugLog.getInstance().showException(ex);
    }
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Mode")) {
    final String mode=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processModeResponse(mode,responseServices);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Template")) {
    final String relativeLocalDirectory=myStreamUtilities.readLine(loggedInputStream);
    final String repositoryFilePath=myStreamUtilities.readLine(loggedInputStream);
    final String lengthString=myStreamUtilities.readLine(loggedInputStream);
    final int length;
    try {
      length=Integer.parseInt(lengthString);
      responseProcessor.processTemplateResponse(relativeLocalDirectory,repositoryFilePath,length,clientEnvironment,connectionStreams);
    }
 catch (    NumberFormatException ex) {
    }
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Module-expansion")) {
    final String localPath=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processModuleExpansionResponse(localPath,responseServices);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("ok")) {
    responseProcessor.processOkResponse(responseServices);
    return Boolean.TRUE;
  }
 else   if (responseName.equalsIgnoreCase("error")) {
    final byte[] message=StreamUtilities.readLineBytes(loggedInputStream);
    responseProcessor.processErrorResponse(message,responseServices);
    return Boolean.FALSE;
  }
 else   if (responseName.equals("EntriesExtra")) {
    StreamUtilities.readLineBytes(loggedInputStream);
    return null;
  }
 else   if (responseName.equalsIgnoreCase("Valid-requests")) {
    final String validRequests=myStreamUtilities.readLine(loggedInputStream);
    responseProcessor.processValidRequestsResponse(validRequests,responseServices);
    return null;
  }
 else {
    throw new IOException("Unhandled response: " + responseName + ".");
  }
}
