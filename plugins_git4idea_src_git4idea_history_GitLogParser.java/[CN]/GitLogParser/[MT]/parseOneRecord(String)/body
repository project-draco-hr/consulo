{
  if (line.isEmpty()) {
    return null;
  }
  line=removeRecordStartIndicator(line);
  final List<String> paths=new ArrayList<String>(1);
  final boolean includeStatus=myNameStatusOption == NameStatus.STATUS;
  final List<List<String>> parts=includeStatus ? new ArrayList<List<String>>() : null;
  if (myNameStatusOption != NameStatus.NONE) {
    final String[] infoAndPath=line.split(RECORD_END);
    line=infoAndPath[0];
    if (infoAndPath.length > 1) {
      final List<String> nameAndPathSplit=new ArrayList<String>(Arrays.asList(infoAndPath[infoAndPath.length - 1].split("\n")));
      for (Iterator<String> it=nameAndPathSplit.iterator(); it.hasNext(); ) {
        if (it.next().trim().isEmpty()) {
          it.remove();
        }
      }
      for (      String pathLine : nameAndPathSplit) {
        String[] partsArr;
        if (includeStatus) {
          final int idx=pathLine.indexOf("\t");
          if (idx != -1) {
            final String whatLeft=pathLine.substring(idx).trim();
            partsArr=whatLeft.split("\\t");
            final List<String> strings=new ArrayList<String>(partsArr.length + 1);
            strings.add(pathLine.substring(0,1));
            strings.addAll(Arrays.asList(partsArr));
            parts.add(strings);
          }
 else {
            partsArr=pathLine.split("\\t");
          }
        }
 else {
          partsArr=pathLine.split("\\t");
        }
        paths.addAll(Arrays.asList(partsArr));
      }
    }
  }
 else {
    line=line.substring(0,line.length() - 1);
  }
  final String[] values=line.split(ITEMS_SEPARATOR);
  final Map<GitLogOption,String> res=new HashMap<GitLogOption,String>(values.length);
  int i=0;
  for (; i < values.length && i < myOptions.length; i++) {
    res.put(myOptions[i],values[i]);
  }
  for (; i < myOptions.length; i++) {
    res.put(myOptions[i],"");
  }
  return new GitLogRecord(res,paths,parts,mySupportsRawBody);
}
