{
  if (line.isEmpty()) {
    return null;
  }
  if (line.charAt(0) == RECORD_START.charAt(0)) {
    line=line.substring(1);
  }
  char nameStatus=0;
  final List<String> paths=new ArrayList<String>(1);
  if (myNameStatusOutputted != NameStatus.NONE) {
    final String[] infoAndPath=line.split(RECORD_END);
    line=infoAndPath[0];
    if (infoAndPath.length > 1) {
      final List<String> nameAndPathSplit=new LinkedList<String>(Arrays.asList(infoAndPath[infoAndPath.length - 1].split("[\\s]")));
      for (Iterator<String> it=nameAndPathSplit.iterator(); it.hasNext(); ) {
        if (it.next().trim().isEmpty()) {
          it.remove();
        }
      }
      if (!nameAndPathSplit.isEmpty()) {
        final Iterator<String> pathIterator=nameAndPathSplit.iterator();
        if (myNameStatusOutputted == NameStatus.STATUS) {
          nameStatus=pathIterator.next().charAt(0);
        }
        while (pathIterator.hasNext()) {
          String path=pathIterator.next().trim();
          if (!path.isEmpty()) {
            paths.add(path);
          }
        }
      }
    }
  }
 else {
    line=line.substring(0,line.length() - 1);
  }
  final String[] values=line.split(ITEMS_SEPARATOR);
  final Map<GitLogOption,String> res=new HashMap<GitLogOption,String>(values.length);
  int i=0;
  for (; i < values.length && i < myOptions.length; i++) {
    res.put(myOptions[i],values[i]);
  }
  for (; i < myOptions.length; i++) {
    res.put(myOptions[i],"");
  }
  return new GitLogRecord(res,paths,nameStatus);
}
