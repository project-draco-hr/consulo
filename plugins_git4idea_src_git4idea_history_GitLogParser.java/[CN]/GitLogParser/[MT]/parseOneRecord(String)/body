{
  Matcher matcher=ONE_RECORD.matcher(line);
  if (!matcher.matches()) {
    throwGFE("ONE_RECORD didn't match",line);
  }
  String commitInfo=matcher.group(1);
  if (commitInfo == null) {
    throwGFE("No match for group#1 in",line);
  }
  final Map<GitLogOption,String> res=parseCommitInfo(commitInfo);
  final List<String> paths=new ArrayList<String>(1);
  final List<GitLogStatusInfo> statuses=new ArrayList<GitLogStatusInfo>();
  if (myNameStatusOption != NameStatus.NONE) {
    String pathsAndStatuses=matcher.group(2);
    if (pathsAndStatuses == null) {
      throwGFE("No match for group#2 in",line);
    }
    if (myNameStatusOption == NameStatus.NAME) {
      Matcher pathsMatcher=NAME_ONLY.matcher(pathsAndStatuses);
      while (pathsMatcher.find()) {
        String path1=pathsMatcher.group(1);
        String path2=pathsMatcher.group(2);
        assertNotNull(path1,"path",pathsAndStatuses);
        paths.add(path1);
        if (path2 != null) {
          paths.add(path2);
        }
      }
    }
 else {
      Matcher nameStatusMatcher=NAME_STATUS.matcher(pathsAndStatuses);
      while (nameStatusMatcher.find()) {
        String status=nameStatusMatcher.group(1);
        String path1=nameStatusMatcher.group(2);
        String path2=nameStatusMatcher.group(3);
        assertNotNull(status,"status",pathsAndStatuses);
        assertNotNull(path1,"path1",pathsAndStatuses);
        paths.add(path1);
        if (path2 != null) {
          paths.add(path2);
        }
        statuses.add(new GitLogStatusInfo(GitChangeType.fromString(status),path1,path2));
      }
    }
  }
  return new GitLogRecord(res,paths,statuses,mySupportsRawBody);
}
