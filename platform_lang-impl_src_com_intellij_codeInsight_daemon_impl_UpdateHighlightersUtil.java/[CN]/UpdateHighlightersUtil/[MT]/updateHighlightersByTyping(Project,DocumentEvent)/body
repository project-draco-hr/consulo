{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final Document document=e.getDocument();
  if (document instanceof DocumentEx && ((DocumentEx)document).isInBulkUpdate())   return;
  final MarkupModel markup=document.getMarkupModel(project);
  assertMarkupConsistent(markup,project);
  Editor[] editors=EditorFactory.getInstance().getEditors(document,project);
  if (editors.length <= 0)   return;
  final int start=e.getOffset();
  final int end=start + Math.max(e.getOldLength(),e.getNewLength());
  final boolean[] highlightersChanged={false};
  final List<HighlightInfo> removed=new ArrayList<HighlightInfo>();
  final boolean[] documentChangedInsideHighlighter={false};
  DaemonCodeAnalyzerImpl.processHighlights(document,project,null,start,end,new Processor<HighlightInfo>(){
    public boolean process(    HighlightInfo info){
      RangeHighlighter highlighter=info.highlighter;
      boolean toRemove=false;
      if (info.needUpdateOnTyping()) {
        int highlighterStart=highlighter.getStartOffset();
        int highlighterEnd=highlighter.getEndOffset();
        if (info.isAfterEndOfLine) {
          if (highlighterStart < document.getTextLength()) {
            highlighterStart+=1;
          }
          if (highlighterEnd < document.getTextLength()) {
            highlighterEnd+=1;
          }
        }
        if (!highlighter.isValid()) {
          toRemove=true;
        }
 else         if (start < highlighterEnd && highlighterStart <= end) {
          documentChangedInsideHighlighter[0]=true;
          toRemove=true;
        }
      }
      if (toRemove) {
        highlightersChanged[0]=true;
        removed.add(info);
      }
      return true;
    }
  }
);
  for (  HighlightInfo info : removed) {
    if (!info.highlighter.isValid() || info.type.equals(HighlightInfoType.WRONG_REF)) {
      info.highlighter.dispose();
    }
  }
  assertMarkupConsistent(markup,project);
  if (highlightersChanged[0] || documentChangedInsideHighlighter[0]) {
    disableWhiteSpaceOptimization(document);
  }
}
