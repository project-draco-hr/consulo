{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final Document document=e.getDocument();
  if (document instanceof DocumentEx && ((DocumentEx)document).isInBulkUpdate())   return;
  final MarkupModel markup=DocumentMarkupModel.forDocument(document,project,true);
  assertMarkupConsistent(markup,project);
  final int start=e.getOffset() - 1;
  final int end=start + Math.max(e.getOldLength(),e.getNewLength());
  final List<HighlightInfo> toRemove=new ArrayList<HighlightInfo>();
  DaemonCodeAnalyzerImpl.processHighlights(document,project,null,start,end,new Processor<HighlightInfo>(){
    @Override public boolean process(    HighlightInfo info){
      RangeHighlighter highlighter=info.highlighter;
      boolean remove=false;
      if (info.needUpdateOnTyping()) {
        int highlighterStart=highlighter.getStartOffset();
        int highlighterEnd=highlighter.getEndOffset();
        if (info.isAfterEndOfLine) {
          if (highlighterStart < document.getTextLength()) {
            highlighterStart+=1;
          }
          if (highlighterEnd < document.getTextLength()) {
            highlighterEnd+=1;
          }
        }
        if (!highlighter.isValid() || start < highlighterEnd && highlighterStart <= end) {
          remove=true;
        }
      }
      if (remove) {
        toRemove.add(info);
      }
      return true;
    }
  }
);
  for (  HighlightInfo info : toRemove) {
    if (!info.highlighter.isValid() || info.type.equals(HighlightInfoType.WRONG_REF)) {
      info.highlighter.dispose();
    }
  }
  assertMarkupConsistent(markup,project);
  if (!toRemove.isEmpty()) {
    disableWhiteSpaceOptimization(document);
  }
}
