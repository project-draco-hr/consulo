{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final PsiFile psiFile=PsiDocumentManager.getInstance(project).getPsiFile(document);
  cleanFileLevelHighlights(project,group,psiFile);
  final MarkupModel markup=DocumentMarkupModel.forDocument(document,project,true);
  assertMarkupConsistent(markup,project);
  final SeverityRegistrar severityRegistrar=SeverityRegistrar.getInstance(project);
  final HighlightersRecycler infosToRemove=new HighlightersRecycler();
  ContainerUtil.quickSort(infos,BY_START_OFFSET_NODUPS);
  DaemonCodeAnalyzerImpl.processHighlightsOverlappingOutside(document,project,null,range.getStartOffset(),range.getEndOffset(),new Processor<HighlightInfo>(){
    @Override public boolean process(    HighlightInfo info){
      if (info.group == group) {
        RangeHighlighter highlighter=info.highlighter;
        int hiStart=highlighter.getStartOffset();
        int hiEnd=highlighter.getEndOffset();
        if (!info.fromInjection && hiEnd < document.getTextLength() && (hiEnd <= startOffset || hiStart >= endOffset))         return true;
        boolean toRemove=!(hiEnd == document.getTextLength() && range.getEndOffset() == document.getTextLength()) && !range.containsRange(hiStart,hiEnd);
        if (toRemove) {
          infosToRemove.recycleHighlighter(highlighter);
          info.highlighter=null;
        }
      }
      return true;
    }
  }
);
  final Map<TextRange,RangeMarker> ranges2markersCache=new THashMap<TextRange,RangeMarker>(10);
  final boolean[] changed={false};
  RangeMarkerTree.sweep(new RangeMarkerTree.Generator<HighlightInfo>(){
    @Override public boolean generate(    Processor<HighlightInfo> processor){
      return ContainerUtil.process(infos,processor);
    }
  }
,new SweepProcessor<HighlightInfo>(){
    @Override public boolean process(    int offset,    HighlightInfo info,    boolean atStart,    Collection<HighlightInfo> overlappingIntervals){
      if (!atStart)       return true;
      if (!info.fromInjection && info.getEndOffset() < document.getTextLength() && (info.getEndOffset() <= startOffset || info.getStartOffset() >= endOffset))       return true;
      if (info.isFileLevelAnnotation && psiFile != null && psiFile.getViewProvider().isPhysical()) {
        addFileLevelHighlight(project,group,info,psiFile);
        changed[0]=true;
        return true;
      }
      if (isWarningCoveredByError(info,overlappingIntervals,severityRegistrar)) {
        return true;
      }
      if (info.getStartOffset() < range.getStartOffset() || info.getEndOffset() > range.getEndOffset()) {
        createOrReuseHighlighterFor(info,colorsScheme,document,group,psiFile,(MarkupModelEx)markup,infosToRemove,ranges2markersCache,severityRegistrar);
        changed[0]=true;
      }
      return true;
    }
  }
);
  for (  RangeHighlighter highlighter : infosToRemove.forAllInGarbageBin()) {
    highlighter.dispose();
    changed[0]=true;
  }
  if (changed[0]) {
    clearWhiteSpaceOptimizationFlag(document);
  }
  assertMarkupConsistent(markup,project);
}
