{
  executor.setKeepAliveTime(1,TimeUnit.NANOSECONDS);
  executor.setCorePoolSize(0);
  ReentrantLock mainLock=ReflectionUtil.getField(executor.getClass(),executor,ReentrantLock.class,"mainLock");
  Set workers;
  mainLock.lock();
  try {
    HashSet workersField=ReflectionUtil.getField(executor.getClass(),executor,HashSet.class,"workers");
    workers=new HashSet(workersField);
  }
  finally {
    mainLock.unlock();
  }
  for (  Object worker : workers) {
    Thread thread=ReflectionUtil.getField(worker.getClass(),worker,Thread.class,"thread");
    try {
      thread.join(unit.toMillis(timeout));
    }
 catch (    InterruptedException e) {
      String trace="Thread leaked: " + thread + "; "+ thread.getState()+ " ("+ thread.isAlive()+ ")\n--- its stacktrace:\n";
      for (      final StackTraceElement stackTraceElement : thread.getStackTrace()) {
        trace+=" at " + stackTraceElement + "\n";
      }
      trace+="---\n";
      System.err.println("Executor " + executor + " is still active after "+ unit.toSeconds(timeout)+ " seconds://///\n"+ "Thread "+ thread+ " dump:\n"+ trace+ "all thread dump:\n"+ ThreadDumper.dumpThreadsToString()+ "\n/////");
      break;
    }
  }
}
