{
  ProgressIndicatorProvider.checkCanceled();
  ApplicationManager.getApplication().assertReadAccessAllowed();
  int clearCountOnStart=myClearCount.intValue();
  ConcurrentMap<TRef,Getter<TResult>> map=getMap(isPhysical,incompleteCode,isPoly);
  Getter<TResult> reference=map.get(ref);
  TResult result=reference == null ? null : reference.get();
  if (result != null) {
    return result;
  }
  RecursionGuard.StackStamp stamp=myGuard.markStack();
  result=needToPreventRecursion ? myGuard.doPreventingRecursion(Trinity.create(ref,incompleteCode,isPoly),true,new Computable<TResult>(){
    @Override public TResult compute(){
      return resolver.resolve(ref,incompleteCode);
    }
  }
) : resolver.resolve(ref,incompleteCode);
  PsiElement element=result instanceof ResolveResult ? ((ResolveResult)result).getElement() : null;
  LOG.assertTrue(element == null || element.isValid(),result);
  if (stamp.mayCacheNow() && clearCountOnStart == myClearCount.intValue()) {
    cache(ref,map,result,isPoly);
  }
  return result;
}
