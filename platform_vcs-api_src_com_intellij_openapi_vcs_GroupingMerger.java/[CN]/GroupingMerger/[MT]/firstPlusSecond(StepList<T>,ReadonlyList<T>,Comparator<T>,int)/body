{
  final int wasSize=first.getSize();
  if (second.getSize() == 0) {
    return wasSize;
  }
  int idx;
  if (idxFrom == -1) {
    idx=stolenBinarySearch(first,second.get(0),comparator,0);
    if (idx < 0) {
      idx=-(idx + 1);
    }
  }
 else {
    idx=idxFrom;
  }
  if (idx > 0 && (!filter(first.get(idx - 1)))) {
    --idx;
  }
  final ReadonlyList<T> remergePart=first.cut(idx);
  if (idx > 0) {
    myCurrentGroup=getGroup(first.get(idx - 1));
  }
  final int finalIdx=idx;
  willBeRecountFrom(idx,wasSize);
  merge(remergePart,second,comparator,new PairConsumer<T,Integer>(){
    @Override public void consume(    T t,    Integer integer){
      doForGroup(t,first);
      first.add(t);
      int was=integer + finalIdx;
      oldBecame(was,first.getSize() - 1);
    }
  }
,new Consumer<T>(){
    @Override public void consume(    T t){
      doForGroup(t,first);
      final T wrapped=wrapItem(t);
      first.add(wrapped);
      afterConsumed(wrapped,first.getSize() - 1);
    }
  }
);
  return idx;
}
