{
  ProgressManager.progress("Creating patch for theirs changes");
  final VirtualFile baseForPatch=ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>(){
    @Override public VirtualFile compute(){
      return ChangesUtil.findValidParent(newFilePath);
    }
  }
);
  final Project project=myVcs.getProject();
  final List<FilePatch> patches=IdeaTextPatchBuilder.buildPatch(project,changes,baseForPatch.getPath(),false);
  ProgressManager.progress("Applying patch to " + newFilePath.getPath());
  final ChangeListManager clManager=ChangeListManager.getInstance(project);
  final LocalChangeList changeList=clManager.getChangeList(myChange);
  final PatchApplier<BinaryFilePatch> patchApplier=new PatchApplier<BinaryFilePatch>(project,baseForPatch,patches,changeList,null,null);
  patchApplier.scheduleSelf(false,context,true);
  context.last(new TaskDescriptor("Accepting working state",Where.POOLED){
    @Override public void run(    ContinuationContext context){
      try {
        new SvnTreeConflictResolver(myVcs,oldFilePath,myCommittedRevision,null).resolveSelectMineFull(description);
      }
 catch (      VcsException e1) {
        context.handleException(e1);
      }
    }
  }
);
  context.last(new TaskDescriptor("",Where.AWT){
    @Override public void run(    ContinuationContext context){
      VcsBalloonProblemNotifier.showOverChangesView(myVcs.getProject(),"Theirs changes merged for " + filePath(myPath),MessageType.INFO);
    }
  }
);
}
