def filemerge(repo, mynode, orig, fcd, fco, fca):
    'perform a 3-way merge in the working directory\n\n    mynode = parent node before merge\n    orig = original local filename before merge\n    fco = other file context\n    fca = ancestor file context\n    fcd = local file context for current/destination file\n    '

    def temp(prefix, ctx):
        pre = ('%s~%s.' % (os.path.basename(ctx.path()), prefix))
        (fd, name) = tempfile.mkstemp(prefix=pre)
        data = repo.wwritedata(ctx.path(), ctx.data())
        f = os.fdopen(fd, 'wb')
        f.write(data)
        f.close()
        return name

    def isbin(ctx):
        try:
            return util.binary(ctx.data())
        except IOError:
            return False
    if (not fco.cmp(fcd.data())):
        return None
    if (fca == fco):
        fca = fcd.parents()[0]
    ui = repo.ui
    fd = fcd.path()
    binary = (isbin(fcd) or isbin(fco) or isbin(fca))
    symlink = ('l' in (fcd.flags() + fco.flags()))
    (tool, toolpath) = _picktool(repo, ui, fd, binary, symlink)
    ui.debug(("picked tool '%s' for %s (binary %s symlink %s)\n" % (tool, fd, binary, symlink)))
    if ((not tool) or (tool == 'internal:prompt')):
        tool = 'internal:local'
        if ui.promptchoice((_(' no tool found to merge %s\nkeep (l)ocal or take (o)ther?') % fd), (_('&Local'), _('&Other')), 0):
            tool = 'internal:other'
    if (tool == 'internal:local'):
        return 0
    if (tool == 'internal:other'):
        repo.wwrite(fd, fco.data(), fco.flags())
        return 0
    if (tool == 'internal:fail'):
        return 1
    a = repo.wjoin(fd)
    b = temp('base', fca)
    c = temp('other', fco)
    out = ''
    back = (a + '.orig')
    util.copyfile(a, back)
    if (orig != fco.path()):
        ui.status((_('merging %s and %s to %s\n') % (orig, fco.path(), fd)))
    else:
        ui.status((_('merging %s\n') % fd))
    ui.debug(('my %s other %s ancestor %s\n' % (fcd, fco, fca)))
    if _toolbool(ui, tool, 'premerge', (not (binary or symlink))):
        r = simplemerge.simplemerge(ui, a, b, c, quiet=True)
        if (not r):
            ui.debug(' premerge successful\n')
            os.unlink(back)
            os.unlink(b)
            os.unlink(c)
            return 0
        util.copyfile(back, a)
    env = dict(HG_FILE=fd, HG_MY_NODE=short(mynode), HG_OTHER_NODE=str(fco.changectx()), HG_BASE_NODE=str(fca.changectx()), HG_MY_ISLINK=('l' in fcd.flags()), HG_OTHER_ISLINK=('l' in fco.flags()), HG_BASE_ISLINK=('l' in fca.flags()))
    if (tool == 'internal:merge'):
        r = simplemerge.simplemerge(ui, a, b, c, label=['local', 'other'])
    elif (tool == 'internal:dump'):
        a = repo.wjoin(fd)
        util.copyfile(a, (a + '.local'))
        repo.wwrite((fd + '.other'), fco.data(), fco.flags())
        repo.wwrite((fd + '.base'), fca.data(), fca.flags())
        return 1
    else:
        args = _toolstr(ui, tool, 'args', '$local $base $other')
        if ('$output' in args):
            (out, a) = (a, back)
        replace = dict(local=a, base=b, other=c, output=out)
        args = re.sub('\\$(local|base|other|output)', (lambda x: ('"%s"' % util.localpath(replace[x.group()[1:]]))), args)
        r = util.system(((toolpath + ' ') + args), cwd=repo.root, environ=env)
    if ((not r) and _toolbool(ui, tool, 'checkconflicts')):
        if re.match('^(<<<<<<< .*|=======|>>>>>>> .*)$', fcd.data()):
            r = 1
    if ((not r) and _toolbool(ui, tool, 'checkchanged')):
        if filecmp.cmp(repo.wjoin(fd), back):
            if ui.promptchoice((_(' output file %s appears unchanged\nwas merge successful (yn)?') % fd), (_('&Yes'), _('&No')), 1):
                r = 1
    if _toolbool(ui, tool, 'fixeol'):
        _matcheol(repo.wjoin(fd), back)
    if r:
        ui.warn((_('merging %s failed!\n') % fd))
    else:
        os.unlink(back)
    os.unlink(b)
    os.unlink(c)
    return r
