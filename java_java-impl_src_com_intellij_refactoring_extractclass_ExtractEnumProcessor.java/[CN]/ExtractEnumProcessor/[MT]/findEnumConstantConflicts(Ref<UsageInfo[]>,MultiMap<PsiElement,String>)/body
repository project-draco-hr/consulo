{
  if (hasUsages2Migrate()) {
    final List<UsageInfo> resolvableConflicts=new ArrayList<UsageInfo>();
    for (    UsageInfo failedUsage : myTypeMigrationProcessor.getLabeler().getFailedUsages()) {
      final PsiElement element=failedUsage.getElement();
      if (element instanceof PsiReferenceExpression) {
        resolvableConflicts.add(new FixableUsageInfo(element){
          @Override public void fixUsage() throws IncorrectOperationException {
            final PsiReferenceExpression expression=(PsiReferenceExpression)element;
            final String link=PropertyUtil.suggestGetterName("value",expression.getType()) + "()";
            MutationUtils.replaceExpression(expression.getReferenceName() + "." + link,expression);
          }
        }
);
      }
 else       if (element != null) {
        resolvableConflicts.add(new ConflictUsageInfo(element,null));
      }
    }
    if (!resolvableConflicts.isEmpty()) {
      final List<UsageInfo> usageInfos=new ArrayList<UsageInfo>(Arrays.asList(refUsages.get()));
      for (Iterator<UsageInfo> iterator=resolvableConflicts.iterator(); iterator.hasNext(); ) {
        final UsageInfo conflict=iterator.next();
        for (        UsageInfo usageInfo : usageInfos) {
          if (conflict.getElement() == usageInfo.getElement()) {
            iterator.remove();
            break;
          }
        }
      }
      resolvableConflicts.addAll(0,usageInfos);
      refUsages.set(resolvableConflicts.toArray(new UsageInfo[resolvableConflicts.size()]));
    }
  }
}
