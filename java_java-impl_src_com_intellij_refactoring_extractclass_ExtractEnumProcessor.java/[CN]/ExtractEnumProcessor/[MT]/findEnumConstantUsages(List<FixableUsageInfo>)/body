{
  final List<FixableUsageInfo> result=new ArrayList<FixableUsageInfo>();
  if (!myEnumConstants.isEmpty()) {
    final Set<PsiSwitchStatement> switchStatements=new HashSet<PsiSwitchStatement>();
    for (    UsageInfo usage : fieldUsages) {
      if (usage instanceof ReplaceStaticVariableAccess) {
        final PsiElement element=usage.getElement();
        final PsiSwitchStatement switchStatement=PsiTreeUtil.getParentOfType(element,PsiSwitchStatement.class);
        if (switchStatement != null) {
          switchStatements.add(switchStatement);
        }
      }
    }
    final PsiConstantEvaluationHelper evaluationHelper=JavaPsiFacade.getInstance(myProject).getConstantEvaluationHelper();
    final Set<Object> enumValues=new HashSet<Object>();
    for (    PsiField enumConstant : myEnumConstants) {
      enumValues.add(evaluationHelper.computeConstantExpression(enumConstant.getInitializer()));
    }
    final PsiType enumValueType=myEnumConstants.get(0).getType();
    for (    PsiSwitchStatement switchStatement : switchStatements) {
      final PsiStatement errStatement=EnumConstantsUtil.isEnumSwitch(switchStatement,enumValueType,enumValues);
      if (errStatement != null) {
        String description=null;
        if (errStatement instanceof PsiSwitchLabelStatement) {
          final PsiExpression caseValue=((PsiSwitchLabelStatement)errStatement).getCaseValue();
          if (caseValue != null) {
            description=caseValue.getText() + " can not be replaced with enum";
          }
        }
        result.add(new ConflictUsageInfo(errStatement,description));
      }
 else {
        final PsiExpression expression=switchStatement.getExpression();
        if (expression instanceof PsiReferenceExpression) {
          final PsiElement element=((PsiReferenceExpression)expression).resolve();
          if (element != null) {
            if (!element.getManager().isInProject(element)) {
              result.add(new ConflictUsageInfo(expression,StringUtil.capitalize(RefactoringUIUtil.getDescription(element,false)) + " is out of project"));
            }
          }
        }
 else {
          result.add(new ConflictUsageInfo(expression,null));
        }
      }
    }
    final TypeMigrationRules rules=new TypeMigrationRules(myEnumConstants.get(0).getType());
    rules.addConversionDescriptor(new EnumTypeConversionRule(myEnumConstants));
    rules.setMigrationRootType(JavaPsiFacade.getElementFactory(myProject).createType(myClass));
    rules.setBoundScope(GlobalSearchScope.projectScope(myProject));
    myTypeMigrationProcessor=new TypeMigrationProcessor(myProject,PsiUtilCore.toPsiElementArray(myEnumConstants),rules);
    for (    UsageInfo usageInfo : myTypeMigrationProcessor.findUsages()) {
      final PsiElement migrateElement=usageInfo.getElement();
      if (migrateElement instanceof PsiField) {
        final PsiField enumConstantField=(PsiField)migrateElement;
        if (enumConstantField.hasModifierProperty(PsiModifier.STATIC) && enumConstantField.hasModifierProperty(PsiModifier.FINAL) && enumConstantField.hasInitializer()&& !myEnumConstants.contains(enumConstantField)) {
          continue;
        }
      }
      result.add(new EnumTypeMigrationUsageInfo(usageInfo));
    }
  }
  return result;
}
