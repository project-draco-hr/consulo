{
  if (!(type instanceof PsiClassType)) {
    return;
  }
  if (!GppTypeConverter.hasTypedContext(place)) {
    return;
  }
  final Project project=place.getProject();
  final Map<String,List<PsiMethod>> map=CachedValuesManager.getManager(project).getCachedValue(project,CACHED_STDLIB,new CachedValueProvider<Map<String,List<PsiMethod>>>(){
    public Result<Map<String,List<PsiMethod>>> compute(){
      final GroovyPsiManager manager=GroovyPsiManager.getInstance(project);
      final Map<String,List<PsiMethod>> result=new HashMap<String,List<PsiMethod>>();
      final NotNullFunction<PsiMethod,PsiMethod> nonStaticConverter=new NotNullFunction<PsiMethod,PsiMethod>(){
        @NotNull public PsiMethod fun(        PsiMethod method){
          return new GppGdkMethod(method,false);
        }
      }
;
      for (      String qname : STDLIB_CLASSES) {
        manager.addCategoryMethods(qname,result,nonStaticConverter);
      }
      manager.addCategoryMethods("org.mbte.groovypp.runtime.DefaultGroovyPPStaticMethods",result,new NotNullFunction<PsiMethod,PsiMethod>(){
        @NotNull public PsiMethod fun(        PsiMethod method){
          return new GppGdkMethod(method,true);
        }
      }
);
      return Result.create(result,ProjectRootManager.getInstance(project));
    }
  }
,false);
  for (  String className : ResolveUtil.getAllSuperTypes(type,place).keySet()) {
    final List<PsiMethod> methods=map.get(className);
    if (methods != null) {
      for (      PsiMethod method : methods) {
        if (!ResolveUtil.processElement(processor,method,state)) {
          return;
        }
      }
    }
  }
}
