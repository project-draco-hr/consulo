{
  if (!(type instanceof PsiClassType)) {
    return true;
  }
  if (!GppTypeConverter.hasTypedContext(place)) {
    return true;
  }
  final String className=TypeConversionUtil.erasure(type).getCanonicalText();
  final Project project=place.getProject();
  final Map<String,List<PsiMethod>> map=CachedValuesManager.getManager(project).getCachedValue(project,CACHED_STDLIB,new CachedValueProvider<Map<String,List<PsiMethod>>>(){
    public Result<Map<String,List<PsiMethod>>> compute(){
      final GroovyPsiManager manager=GroovyPsiManager.getInstance(project);
      final Map<String,List<PsiMethod>> result=new HashMap<String,List<PsiMethod>>();
      final NotNullFunction<PsiMethod,PsiMethod> nonStaticConverter=new NotNullFunction<PsiMethod,PsiMethod>(){
        @NotNull public PsiMethod fun(        PsiMethod method){
          return new GppGdkMethod(method,false);
        }
      }
;
      for (      String qname : STDLIB_CLASSES) {
        manager.addCategoryMethods(qname,result,nonStaticConverter);
      }
      manager.addCategoryMethods("org.mbte.groovypp.runtime.DefaultGroovyPPStaticMethods",result,new NotNullFunction<PsiMethod,PsiMethod>(){
        @NotNull public PsiMethod fun(        PsiMethod method){
          return new GppGdkMethod(method,true);
        }
      }
);
      return Result.create(result,ProjectRootManager.getInstance(project));
    }
  }
,false);
  final List<PsiMethod> methods=map.get(className);
  if (methods == null) {
    return true;
  }
  for (  PsiMethod method : methods) {
    if (!ResolveUtil.processElement(processor,method)) {
      return false;
    }
  }
  return true;
}
