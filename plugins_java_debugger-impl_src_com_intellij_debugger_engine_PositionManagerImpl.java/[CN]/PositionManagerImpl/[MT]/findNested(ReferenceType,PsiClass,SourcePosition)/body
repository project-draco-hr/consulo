{
  final VirtualMachineProxyImpl vmProxy=myDebugProcess.getVirtualMachineProxy();
  if (fromClass.isPrepared()) {
    final List<ReferenceType> nestedTypes=vmProxy.nestedTypes(fromClass);
    try {
      final int lineNumber=classPosition.getLine() + 1;
      for (      ReferenceType nested : nestedTypes) {
        final ReferenceType found=findNested(nested,classToFind,classPosition);
        if (found != null) {
          return fromClass.locationsOfLine(lineNumber).isEmpty() ? found : fromClass;
        }
      }
      if (fromClass.locationsOfLine(lineNumber).size() > 0) {
        return fromClass;
      }
      int rangeBegin=Integer.MAX_VALUE;
      int rangeEnd=Integer.MIN_VALUE;
      for (      Location location : fromClass.allLineLocations()) {
        final int locationLine=location.lineNumber() - 1;
        rangeBegin=Math.min(rangeBegin,locationLine);
        rangeEnd=Math.max(rangeEnd,locationLine);
      }
      if (classPosition.getLine() >= rangeBegin && classPosition.getLine() <= rangeEnd) {
        final int finalRangeBegin=rangeBegin;
        final int finalRangeEnd=rangeEnd;
        return ApplicationManager.getApplication().runReadAction(new NullableComputable<ReferenceType>(){
          public ReferenceType compute(){
            if (!classToFind.isValid()) {
              return null;
            }
            final int line=Math.min(finalRangeBegin + 1,finalRangeEnd);
            final SourcePosition candidatePosition=SourcePosition.createFromLine(classToFind.getContainingFile(),line);
            return classToFind.equals(JVMNameUtil.getClassAt(candidatePosition)) ? fromClass : null;
          }
        }
);
      }
    }
 catch (    AbsentInformationException ignored) {
    }
  }
  return null;
}
