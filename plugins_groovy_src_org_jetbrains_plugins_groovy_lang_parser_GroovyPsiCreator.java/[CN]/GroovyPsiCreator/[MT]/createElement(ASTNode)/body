{
  IElementType elem=node.getElementType();
  if (elem instanceof GroovyElementType.PsiCreator) {
    return ((GroovyElementType.PsiCreator)elem).createPsi(node);
  }
  if (elem instanceof IGroovyDocElementType) {
    return GroovyDocPsiCreator.createElement(node);
  }
  if (elem == LITERAL)   return new GrLiteralImpl(node);
  if (elem == LABEL)   return new GrLabelImpl(node);
  if (elem == LIST_OR_MAP)   return new GrListOrMapImpl(node);
  if (elem == MODIFIERS)   return new GrModifierListImpl(node);
  if (elem == ANNOTATION)   return new GrAnnotationImpl(node);
  if (elem == ANNOTATION_ARGUMENTS)   return new GrAnnotationArgumentListImpl(node);
  if (elem == ANNOTATION_ARRAY_INITIALIZER)   return new GrAnnotationArrrayInitializerImpl(node);
  if (elem == ANNOTATION_MEMBER_VALUE_PAIR)   return new GrAnnotationNameValuePairImpl(node);
  if (elem == DEFAULT_ANNOTATION_VALUE)   return new GrDefaultAnnotationValueImpl(node);
  if (elem == THROW_CLAUSE)   return new GrThrowsClauseImpl(node);
  if (elem == IMPORT_STATEMENT)   return new GrImportStatementImpl(node);
  if (elem == PACKAGE_DEFINITION)   return new GrPackageDefinitionImpl(node);
  if (elem == LABELED_STATEMENT)   return new GrLabeledStatementImpl(node);
  if (elem == IF_STATEMENT)   return new GrIfStatementImpl(node);
  if (elem == FOR_STATEMENT)   return new GrForStatementImpl(node);
  if (elem == FOR_IN_CLAUSE)   return new GrForInClauseImpl(node);
  if (elem == FOR_TRADITIONAL_CLAUSE)   return new GrTraditionalForClauseImpl(node);
  if (elem == WHILE_STATEMENT)   return new GrWhileStatementImpl(node);
  if (elem == TRY_BLOCK_STATEMENT)   return new GrTryCatchStatementImpl(node);
  if (elem == CATCH_CLAUSE)   return new GrCatchClauseImpl(node);
  if (elem == FINALLY_CLAUSE)   return new GrFinallyClauseImpl(node);
  if (elem == SYNCHRONIZED_STATEMENT)   return new GrSynchronizedStatementImpl(node);
  if (elem == SWITCH_STATEMENT)   return new GrSwitchStatementImpl(node);
  if (elem == CASE_LABEL)   return new GrCaseLabelImpl(node);
  if (elem == CASE_SECTION)   return new GrCaseSectionImpl(node);
  if (elem == VARIABLE_DEFINITION || elem == VARIABLE_DEFINITION_ERROR)   return new GrVariableDeclarationBase.GrVariables(node);
  if (elem == MULTIPLE_VARIABLE_DEFINITION)   return new GrVariableDeclarationBase.GrMultipleVariables(node);
  if (elem == TUPLE_DECLARATION || elem == TUPLE_ERROR)   return new GrTupleDeclarationImpl(node);
  if (elem == TUPLE_EXPRESSION)   return new GrTupleExpressionImpl(node);
  if (elem == VARIABLE)   return new GrVariableImpl(node);
  if (elem == FIELD)   return new GrFieldImpl(node);
  if (elem == CLASS_INITIALIZER)   return new GrClassInitializerImpl(node);
  if (elem == CLASS_DEFINITION)   return new GrClassDefinitionImpl(node);
  if (elem == INTERFACE_DEFINITION)   return new GrInterfaceDefinitionImpl(node);
  if (elem == ENUM_DEFINITION)   return new GrEnumTypeDefinitionImpl(node);
  if (elem == ANNOTATION_DEFINITION)   return new GrAnnotationTypeDefinitionImpl(node);
  if (elem == ANNOTATION_METHOD)   return new GrAnnotationMethodImpl(node);
  if (elem == REFERENCE_ELEMENT)   return new GrCodeReferenceElementImpl(node);
  if (elem == CLASS_TYPE_ELEMENT)   return new GrClassTypeElementImpl(node);
  if (elem == IMPLEMENTS_CLAUSE)   return new GrImplementsClauseImpl(node);
  if (elem == EXTENDS_CLAUSE)   return new GrExtendsClauseImpl(node);
  if (elem == CLASS_BODY)   return new GrTypeDefinitionBodyBase.GrClassBody(node);
  if (elem == ENUM_BODY)   return new GrTypeDefinitionBodyBase.GrEnumBody(node);
  if (elem == BLOCK_STATEMENT)   return new GrBlockStatementImpl(node);
  if (elem == EXPLICIT_CONSTRUCTOR)   return new GrConstructorInvocationImpl(node);
  if (elem == ENUM_CONSTANTS)   return new GrEnumConstantListImpl(node);
  if (elem == ENUM_CONSTANT)   return new GrEnumConstantImpl(node);
  if (elem == CONSTRUCTOR_DEFINITION)   return new GrConstructorImpl(node);
  if (elem == METHOD_DEFINITION)   return new GrMethodImpl(node);
  if (elem == PARAMETERS_LIST)   return new GrParameterListImpl(node);
  if (elem == PARAMETER)   return new GrParameterImpl(node);
  if (elem == TYPE_ARGUMENT)   return new GrWildcardTypeArgumentImpl(node);
  if (elem == TYPE_ARGUMENTS)   return new GrTypeArgumentListImpl(node);
  if (elem == TYPE_PARAMETER_LIST)   return new GrTypeParameterListImpl(node);
  if (elem == TYPE_PARAMETER)   return new GrTypeParameterImpl(node);
  if (elem == TYPE_PARAMETER_EXTENDS_BOUND_LIST)   return new GrTypeParameterParameterExtendsListImpl(node);
  if (elem == RETURN_STATEMENT)   return new GrReturnStatementImpl(node);
  if (elem == THROW_STATEMENT)   return new GrThrowStatementImpl(node);
  if (elem == ASSERT_STATEMENT)   return new GrAssertStatementImpl(node);
  if (elem == BREAK_STATEMENT)   return new GrBreakStatementImpl(node);
  if (elem == CONTINUE_STATEMENT)   return new GrContinueStatementImpl(node);
  if (elem == CALL_EXPRESSION)   return new GrApplicationStatementImpl(node);
  if (elem == COMMAND_ARGUMENTS)   return new GrCommandArgumentListImpl(node);
  if (elem == CONDITIONAL_EXPRESSION)   return new GrConditionalExprImpl(node);
  if (elem == ELVIS_EXPRESSION)   return new GrElvisExprImpl(node);
  if (elem == ASSIGNMENT_EXPRESSION)   return new GrAssignmentExpressionImpl(node);
  if (elem == LOGICAL_OR_EXPRESSION)   return new GrLogicalExpressionImpl(node);
  if (elem == LOGICAL_AND_EXPRESSION)   return new GrLogicalExpressionImpl(node);
  if (elem == EXCLUSIVE_OR_EXPRESSION)   return new GrBitwiseExpressionImpl(node);
  if (elem == INCLUSIVE_OR_EXPRESSION)   return new GrBitwiseExpressionImpl(node);
  if (elem == AND_EXPRESSION)   return new GrBitwiseExpressionImpl(node);
  if (elem == REGEX_MATCH_EXPRESSION)   return new GrLogicalExpressionImpl(node);
  if (elem == REGEX_FIND_EXPRESSION)   return new GrRegexFindExpressionImpl(node);
  if (elem == EQUALITY_EXPRESSION)   return new GrRelationalExpressionImpl(node);
  if (elem == RELATIONAL_EXPRESSION)   return new GrRelationalExpressionImpl(node);
  if (elem == SHIFT_EXPRESSION)   return new GrShiftExpressionImpl(node);
  if (elem == RANGE_EXPRESSION)   return new GrRangeExpressionImpl(node);
  if (TokenSets.SHIFT_SIGNS.contains(elem))   return new GrOperationSignImpl(node);
  if (elem == ADDITIVE_EXPRESSION)   return new GrAdditiveExpressionImpl(node);
  if (elem == MULTIPLICATIVE_EXPRESSION)   return new GrMultiplicativeExpressionImpl(node);
  if (elem == POWER_EXPRESSION)   return new GrPowerExpressionImpl(node);
  if (elem == POWER_EXPRESSION_SIMPLE)   return new GrPowerExpressionImpl(node);
  if (elem == UNARY_EXPRESSION)   return new GrUnaryExpressionImpl(node);
  if (elem == CAST_EXPRESSION)   return new GrTypeCastExpressionImpl(node);
  if (elem == SAFE_CAST_EXPRESSION)   return new GrSafeCastExpressionImpl(node);
  if (elem == INSTANCEOF_EXPRESSION)   return new GrInstanceofExpressionImpl(node);
  if (elem == BUILT_IN_TYPE_EXPRESSION)   return new GrBuiltinTypeClassExpressionImpl(node);
  if (elem == ARRAY_TYPE)   return new GrArrayTypeElementImpl(node);
  if (elem == BUILT_IN_TYPE)   return new GrBuiltInTypeElementImpl(node);
  if (elem == DISJUNCTION_TYPE_ELEMENT)   return new GrDisjunctionTypeElementImpl(node);
  if (elem == GSTRING)   return new GrStringImpl(node);
  if (elem == REGEX)   return new GrRegexImpl(node);
  if (elem == GSTRING_INJECTION)   return new GrStringInjectionImpl(node);
  if (elem == REFERENCE_EXPRESSION)   return new GrReferenceExpressionImpl(node);
  if (elem == THIS_REFERENCE_EXPRESSION)   return new GrThisReferenceExpressionImpl(node);
  if (elem == SUPER_REFERENCE_EXPRESSION)   return new GrSuperReferenceExpressionImpl(node);
  if (elem == PARENTHESIZED_EXPRESSION)   return new GrParenthesizedExpressionImpl(node);
  if (elem == NEW_EXPRESSION)   return new GrNewExpressionImpl(node);
  if (elem == ANONYMOUS_CLASS_DEFINITION)   return new GrAnonymousClassDefinitionImpl(node);
  if (elem == ENUM_CONSTANT_INITIALIZER)   return new GrEnumConstantInitializerImpl(node);
  if (elem == ARRAY_DECLARATOR)   return new GrArrayDeclarationImpl(node);
  if (elem == PATH_PROPERTY_REFERENCE)   return new GrPropertySelectionImpl(node);
  if (elem == PATH_METHOD_CALL)   return new GrMethodCallExpressionImpl(node);
  if (elem == PATH_INDEX_PROPERTY)   return new GrIndexPropertyImpl(node);
  if (elem == ARGUMENTS)   return new GrArgumentListImpl(node);
  if (elem == NAMED_ARGUMENT)   return new GrNamedArgumentImpl(node);
  if (elem == SPREAD_ARGUMENT)   return new GrSpreadArgumentImpl(node);
  if (elem == ARGUMENT_LABEL)   return new GrArgumentLabelImpl(node);
  if (elem == BALANCED_BRACKETS)   return new GroovyASTPsiElementImpl(node);
  if (elem == mREGEX_LITERAL || elem == mDOLLAR_SLASH_REGEX_LITERAL)   return new GroovyASTPsiElementImpl(node);
  return new ASTWrapperPsiElement(node);
}
