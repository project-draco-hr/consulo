{
  if (myTree.getNodesInExecution().contains(this)) {
    return false;
  }
  myTree.getNodesInExecution().add(this);
  action.beforeTreeExecution(myObject);
  if (myChildren != null) {
    final ObjectNode<T>[] children=myChildren.toArray(new ObjectNode[myChildren.size()]);
    for (int i=children.length - 1; i >= 0; i--) {
      children[i].execute(disposeTree,action);
    }
  }
  if (disposeTree) {
    myChildren=null;
  }
  try {
    action.execute(myObject);
  }
 catch (  Throwable e) {
    LOG.error(e);
  }
  if (disposeTree) {
    myTree.getObject2NodeMap().remove(myObject);
    if (myParent != null) {
      myParent.removeChild(this);
    }
 else {
      myTree.getRootObjects().remove(myObject);
    }
  }
  myTree.getNodesInExecution().remove(this);
  return true;
}
