{
  if ((element instanceof PsiFile && ((PsiFile)element).getVirtualFile() != null) || element instanceof PsiDirectory) {
    final PsiElement targetContainer=myTargetContainerFinder.getTargetContainer(dataContext);
    MoveFilesOrDirectoriesUtil.doMove(project,new PsiElement[]{element},targetContainer,null);
    return true;
  }
 else   if (element instanceof PsiField) {
    MoveMembersImpl.doMove(project,new PsiElement[]{element},null,null);
    return true;
  }
 else   if (element instanceof PsiMethod) {
    PsiMethod method=(PsiMethod)element;
    if (!method.hasModifierProperty(PsiModifier.STATIC)) {
      new MoveInstanceMethodHandler().invoke(project,new PsiElement[]{method},dataContext);
    }
 else {
      MoveMembersImpl.doMove(project,new PsiElement[]{method},null,null);
    }
    return true;
  }
 else   if (element instanceof PsiClass) {
    PsiClass aClass=(PsiClass)element;
    final PsiClass containingClass=aClass.getContainingClass();
    if (containingClass != null) {
      FeatureUsageTracker.getInstance().triggerFeatureUsed("refactoring.move.moveInner");
      if (!aClass.hasModifierProperty(PsiModifier.STATIC)) {
        if (containingClass instanceof JspClass) {
          CommonRefactoringUtil.showErrorMessage(REFACTORING_NAME,RefactoringBundle.message("move.nonstatic.class.from.jsp.not.supported"),null,project);
          return true;
        }
        MoveInnerImpl.doMove(project,new PsiElement[]{aClass},null);
      }
 else {
        SelectInnerOrMembersRefactoringDialog dialog=new SelectInnerOrMembersRefactoringDialog(aClass,project);
        dialog.show();
        if (dialog.isOK()) {
          MoveType type=dialog.getRefactoringType();
          if (type == MoveType.INNER_TO_UPPER) {
            MoveInnerImpl.doMove(project,new PsiElement[]{aClass},null);
          }
 else           if (type == MoveType.MEMBERS) {
            MoveMembersImpl.doMove(project,new PsiElement[]{aClass},null,null);
          }
        }
      }
      return true;
    }
    if (!(element instanceof PsiAnonymousClass)) {
      MoveClassesOrPackagesImpl.doMove(project,new PsiElement[]{aClass},myTargetContainerFinder.getTargetContainer(dataContext),null);
    }
 else {
      new AnonymousToInnerHandler().invoke(project,(PsiAnonymousClass)element);
    }
    return true;
  }
  return false;
}
