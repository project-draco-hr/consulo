{
  if (!(file instanceof PropertiesFile))   return null;
  PropertiesFile propertiesFile=(PropertiesFile)file;
  final List<IProperty> properties=propertiesFile.getProperties();
  List<ProblemDescriptor> problemDescriptors=new ArrayList<ProblemDescriptor>();
  for (  IProperty property : properties) {
    @NonNls String name=property.getName();
    if (name != null) {
      if (name.startsWith("log4j"))       continue;
      if (name.startsWith(REGEXP + ".") || name.endsWith("." + REGEXP))       continue;
    }
    String value=property.getValue();
    Set<Integer> parameters=new HashSet<Integer>();
    if (value != null) {
      int index=value.indexOf('{');
      while (index != -1) {
        value=value.substring(index + 1);
        final int comma=value.indexOf(',');
        final int brace=value.indexOf('}');
        if (brace == -1)         break;
        if (comma == -1) {
          index=brace;
        }
 else {
          index=Math.min(comma,brace);
        }
        try {
          parameters.add(new Integer(value.substring(0,index)));
        }
 catch (        NumberFormatException e) {
          break;
        }
        index=value.indexOf('{');
      }
      for (      Integer integer : parameters) {
        for (int i=0; i < integer.intValue(); i++) {
          if (!parameters.contains(new Integer(i))) {
            ASTNode[] nodes=property.getPsiElement().getNode().getChildren(null);
            PsiElement valElement=nodes.length < 3 ? property.getPsiElement() : nodes[2].getPsi();
            final String message=PropertiesBundle.message("unused.message.format.parameter.problem.descriptor",integer.toString(),Integer.toString(i));
            final String propertyKey=property.getKey();
            final LocalQuickFix[] fixes=isOnTheFly ? new LocalQuickFix[]{new RenameElementFix(((Property)property),propertyKey == null ? REGEXP : propertyKey + "." + REGEXP)} : null;
            problemDescriptors.add(manager.createProblemDescriptor(valElement,message,isOnTheFly,fixes,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
            break;
          }
        }
      }
    }
  }
  return problemDescriptors.isEmpty() ? null : problemDescriptors.toArray(new ProblemDescriptor[problemDescriptors.size()]);
}
