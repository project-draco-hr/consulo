{
  final List<String> namespaces;
  if (prefix.isEmpty()) {
    namespaces=new ArrayList<String>(Arrays.asList(tag.knownNamespaces()));
    namespaces.add(XmlUtil.EMPTY_URI);
  }
 else {
    namespaces=new ArrayList<String>(Collections.singletonList(tag.getNamespace()));
  }
  XmlExtension xmlExtension=XmlExtension.getExtension(tag.getContainingFile());
  List<String> nsInfo=new ArrayList<String>();
  @SuppressWarnings("unchecked") List<XmlElementDescriptor> variants=TagNameVariantCollector.getTagDescriptors(tag,namespaces,nsInfo);
  for (int i=0; i < variants.size(); i++) {
    XmlElementDescriptor descriptor=variants.get(i);
    String qname=descriptor.getName(tag);
    if (!prefix.isEmpty() && qname.startsWith(prefix + ":")) {
      qname=qname.substring(prefix.length() + 1);
    }
    PsiElement declaration=descriptor.getDeclaration();
    LookupElementBuilder lookupElement=declaration == null ? LookupElementBuilder.create(qname) : LookupElementBuilder.create(declaration,qname);
    final int separator=qname.indexOf(':');
    if (separator > 0) {
      lookupElement=lookupElement.withLookupString(qname.substring(separator + 1));
    }
    String ns=nsInfo.get(i);
    if (StringUtil.isNotEmpty(ns)) {
      lookupElement=lookupElement.withTypeText(ns,true);
    }
    if (descriptor instanceof PsiPresentableMetaData) {
      lookupElement=lookupElement.withIcon(((PsiPresentableMetaData)descriptor).getIcon());
    }
    if (xmlExtension.useXmlTagInsertHandler()) {
      elements.add(lookupElement.withInsertHandler(XmlTagInsertHandler.INSTANCE));
    }
 else {
      elements.add(lookupElement);
    }
  }
}
