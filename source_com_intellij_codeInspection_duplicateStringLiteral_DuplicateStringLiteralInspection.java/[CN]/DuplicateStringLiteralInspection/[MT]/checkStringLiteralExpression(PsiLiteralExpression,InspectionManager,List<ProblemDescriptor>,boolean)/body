{
  if (!(originalExpression.getValue() instanceof String))   return;
  final GlobalSearchScope scope=GlobalSearchScope.projectScope(originalExpression.getProject());
  final String stringToFind=(String)originalExpression.getValue();
  final PsiSearchHelper searchHelper=originalExpression.getManager().getSearchHelper();
  final List<String> words=StringUtil.getWordsIn(stringToFind);
  if (words.size() == 0)   return;
  Collections.sort(words,new Comparator<String>(){
    public int compare(    final String o1,    final String o2){
      return o2.length() - o1.length();
    }
  }
);
  Set<PsiFile> resultFiles=null;
  for (  String word : words) {
    if (word.length() >= MIN_STRING_LENGTH) {
      final Set<PsiFile> files=new THashSet<PsiFile>();
      searchHelper.processAllFilesWithWordInLiterals(word,scope,new CommonProcessors.CollectProcessor<PsiFile>(files));
      if (resultFiles == null) {
        resultFiles=files;
      }
 else {
        resultFiles.retainAll(files);
      }
      if (resultFiles.size() == 0)       return;
    }
  }
  if (resultFiles == null || resultFiles.size() == 0)   return;
  final List<PsiExpression> foundExpr=new ArrayList<PsiExpression>();
  for (  PsiFile file : resultFiles) {
    char[] text=file.textToCharArray();
    StringSearcher searcher=new StringSearcher(stringToFind);
    for (int offset=LowLevelSearchUtil.searchWord(text,0,text.length,searcher); offset >= 0; offset=LowLevelSearchUtil.searchWord(text,offset + searcher.getPattern().length(),text.length,searcher)) {
      PsiElement element=file.findElementAt(offset);
      if (!(element.getParent() instanceof PsiLiteralExpression))       continue;
      PsiLiteralExpression expression=(PsiLiteralExpression)element.getParent();
      if (expression != originalExpression && Comparing.equal(stringToFind,expression.getValue())) {
        foundExpr.add(expression);
      }
    }
  }
  if (foundExpr.size() == 0)   return;
  Set<PsiClass> classes=new THashSet<PsiClass>();
  for (  PsiElement aClass : foundExpr) {
    do {
      aClass=PsiTreeUtil.getParentOfType(aClass,PsiClass.class);
    }
 while (aClass != null && ((PsiClass)aClass).getQualifiedName() == null);
    if (aClass != null) {
      classes.add((PsiClass)aClass);
    }
  }
  if (classes.size() == 0)   return;
  String msg;
  if (isOnTheFly) {
    msg="<html><body>Duplicate string literal found in ";
    int i=0;
    for (    final PsiClass aClass : classes) {
      if (i > 10) {
        msg+="<br>... (" + (classes.size() - i) + " more)";
        break;
      }
      msg+=(i == 0 ? "" : ", ") + "<br>&nbsp;&nbsp;&nbsp;'<b>" + aClass.getQualifiedName()+ "</b>'";
      if (aClass.getContainingFile() == originalExpression.getContainingFile()) {
        msg+=" (in this file)";
      }
      i++;
    }
    msg+="</body></html>";
  }
 else {
    msg="Duplicate string literal found in ";
    int i=0;
    for (    final PsiClass aClass : classes) {
      if (i > 10) {
        msg+="... (" + (classes.size() - i) + " more)";
        break;
      }
      msg+=(i == 0 ? "" : ", ") + "'" + aClass.getQualifiedName()+ "'";
      i++;
    }
  }
  Collection<LocalQuickFix> fixes=new ArrayList<LocalQuickFix>();
  final LocalQuickFix introduceConstFix=createIntroduceConstFix(foundExpr,originalExpression);
  fixes.add(introduceConstFix);
  createReplaceFixes(foundExpr,originalExpression,fixes);
  LocalQuickFix[] array=fixes.toArray(new LocalQuickFix[fixes.size()]);
  ProblemDescriptor problemDescriptor=manager.createProblemDescriptor(originalExpression,msg,array,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
  allProblems.add(problemDescriptor);
}
