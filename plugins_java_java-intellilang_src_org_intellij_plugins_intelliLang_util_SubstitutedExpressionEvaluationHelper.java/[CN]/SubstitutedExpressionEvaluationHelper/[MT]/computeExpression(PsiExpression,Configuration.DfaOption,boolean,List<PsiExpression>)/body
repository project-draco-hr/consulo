{
  final ConcurrentMap<PsiElement,Object> map=new ConcurrentHashMap<PsiElement,Object>();
  return myHelper.computeExpression(e,false,new PsiConstantEvaluationHelper.AuxEvaluator(){
    @Nullable public Object computeExpression(    final PsiExpression o,    final PsiConstantEvaluationHelper.AuxEvaluator auxEvaluator){
      PsiType resolvedType=null;
      if (o instanceof PsiMethodCallExpression) {
        final PsiMethodCallExpression c=(PsiMethodCallExpression)o;
        final PsiMethod m=(PsiMethod)c.getMethodExpression().resolve();
        final PsiType returnType=m != null ? m.getReturnType() : null;
        if (returnType != null && returnType != PsiType.VOID) {
          final Object substituted=calcSubstituted(m);
          if (substituted != null)           return substituted;
        }
        resolvedType=returnType;
      }
 else       if (o instanceof PsiReferenceExpression) {
        final PsiElement resolved=((PsiReferenceExpression)o).resolve();
        if (resolved instanceof PsiModifierListOwner) {
          final Object substituted=calcSubstituted((PsiModifierListOwner)resolved);
          if (substituted != null)           return substituted;
          if (resolved instanceof PsiVariable) {
            final PsiVariable psiVariable=(PsiVariable)resolved;
            resolvedType=psiVariable.getType();
            final Collection<PsiExpression> values;
            if (dfaOption == Configuration.DfaOption.ASSIGNMENTS) {
              values=DfaPsiUtil.getVariableAssignmentsInFile(psiVariable,true,o);
            }
 else             if (dfaOption == Configuration.DfaOption.DFA) {
              final Collection<PsiExpression> realValues=DfaUtil.getCachedVariableValues(psiVariable,o);
              values=realValues == null ? DfaPsiUtil.getVariableAssignmentsInFile(psiVariable,true,o) : realValues;
            }
 else {
              values=Collections.<PsiExpression>emptyList();
            }
            for (            PsiExpression value : values) {
              final Object computedValue=auxEvaluator.computeExpression(value,this);
              if (computedValue != null) {
                return computedValue;
              }
            }
          }
        }
      }
      if (uncomputables != null)       uncomputables.add(o);
      if (includeUncomputablesAsLiterals) {
        if (resolvedType != null) {
          if (PsiPrimitiveType.DOUBLE.isAssignableFrom(resolvedType))           return 1;
        }
        final StringBuilder sb=new StringBuilder();
        o.accept(new PsiRecursiveElementWalkingVisitor(){
          @Override public void visitElement(          PsiElement element){
            if (element instanceof PsiExpressionList)             return;
            if (element instanceof PsiIdentifier) {
              if (sb.length() > 0)               sb.append(".");
              sb.append(element.getText());
            }
            super.visitElement(element);
          }
        }
);
        return sb.toString();
      }
      return null;
    }
    public ConcurrentMap<PsiElement,Object> getCacheMap(    final boolean overflow){
      return map;
    }
  }
);
}
