{
  final Project project=context.getProject();
  if (!RmicConfiguration.getOptions(project).IS_EANABLED) {
    return ProcessingItem.EMPTY_ARRAY;
  }
  final ProgressIndicator progressIndicator=context.getProgressIndicator();
  progressIndicator.pushState();
  try {
    progressIndicator.setText(CompilerBundle.message("progress.generating.rmi.stubs"));
    final Map<Pair<Module,File>,List<RmicProcessingItem>> sortedByModuleAndOutputPath=new HashMap<Pair<Module,File>,List<RmicProcessingItem>>();
    for (    ProcessingItem item1 : items) {
      final RmicProcessingItem item=(RmicProcessingItem)item1;
      final Pair<Module,File> moduleOutputPair=new Pair<Module,File>(item.getModule(),item.getOutputDir());
      List<RmicProcessingItem> dirItems=sortedByModuleAndOutputPath.get(moduleOutputPair);
      if (dirItems == null) {
        dirItems=new ArrayList<RmicProcessingItem>();
        sortedByModuleAndOutputPath.put(moduleOutputPair,dirItems);
      }
      dirItems.add(item);
    }
    final List<ProcessingItem> processed=new ArrayList<ProcessingItem>();
    final JavacOutputParserPool parserPool=new JavacOutputParserPool(project,context);
    for (    final Pair<Module,File> pair : sortedByModuleAndOutputPath.keySet()) {
      if (progressIndicator.isCanceled()) {
        break;
      }
      final List<RmicProcessingItem> dirItems=sortedByModuleAndOutputPath.get(pair);
      try {
        for (Iterator itemIterator=dirItems.iterator(); itemIterator.hasNext(); ) {
          final RmicProcessingItem item=(RmicProcessingItem)itemIterator.next();
          item.deleteGeneratedFiles();
          if (!item.isRemoteObject()) {
            itemIterator.remove();
          }
        }
        if (!dirItems.isEmpty()) {
          final RmicProcessingItem[] successfullyProcessed=invokeRmic(context,parserPool,pair.getFirst(),dirItems,pair.getSecond());
          ContainerUtil.addAll(processed,successfullyProcessed);
        }
        progressIndicator.setFraction(((double)processed.size()) / ((double)items.length));
      }
 catch (      IOException e) {
        context.addMessage(CompilerMessageCategory.ERROR,e.getMessage(),null,-1,-1);
        LOG.info(e);
      }
    }
    final ProcessingItem[] processedItems=processed.toArray(new ProcessingItem[processed.size()]);
    final List<File> filesToRefresh=new ArrayList<File>(processedItems.length * 3);
    for (    ProcessingItem processedItem : processedItems) {
      RmicProcessingItem item=(RmicProcessingItem)processedItem;
      item.updateState();
      filesToRefresh.add(item.myStub);
      filesToRefresh.add(item.mySkel);
      filesToRefresh.add(item.myTie);
    }
    CompilerUtil.refreshIOFiles(filesToRefresh);
    return processedItems;
  }
  finally {
    progressIndicator.popState();
  }
}
