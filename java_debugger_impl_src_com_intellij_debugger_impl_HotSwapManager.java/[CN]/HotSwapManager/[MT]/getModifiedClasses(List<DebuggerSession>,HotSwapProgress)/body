{
  final Map<DebuggerSession,Map<String,HotSwapFile>> modifiedClasses=new HashMap<DebuggerSession,Map<String,HotSwapFile>>();
  final MultiProcessCommand scanClassesCommand=new MultiProcessCommand();
  swapProgress.setCancelWorker(new Runnable(){
    public void run(){
      scanClassesCommand.cancel();
    }
  }
);
  final Set<Project> projectsToRefresh=new HashSet<Project>();
  for (  final DebuggerSession debuggerSession : sessions) {
    if (debuggerSession.isAttached()) {
      projectsToRefresh.add(debuggerSession.getProject());
      scanClassesCommand.addCommand(debuggerSession.getProcess(),new DebuggerCommandImpl(){
        protected void action() throws Exception {
          swapProgress.setDebuggerSession(debuggerSession);
          HashMap<String,HotSwapFile> sessionClasses=getInstance(swapProgress.getProject()).getModifiedClasses(debuggerSession,swapProgress);
          if (!sessionClasses.isEmpty()) {
            modifiedClasses.put(debuggerSession,sessionClasses);
          }
        }
      }
);
    }
  }
  swapProgress.setTitle(DebuggerBundle.message("progress.hotswap.scanning.classes"));
  if (!scanClassesCommand.isEmpty()) {
    final Collection<VirtualFile> roots=ApplicationManager.getApplication().runReadAction(new Computable<Collection<VirtualFile>>(){
      public Collection<VirtualFile> compute(){
        final Set<VirtualFile> result=new HashSet<VirtualFile>();
        for (        Project project : projectsToRefresh) {
          for (          VirtualFile file : OrderEnumerator.orderEntries(project).withoutSdk().getPathsList().getRootDirs()) {
            if (!file.getFileSystem().isReadOnly()) {
              result.add(file);
            }
          }
        }
        return result;
      }
    }
);
    if (!roots.isEmpty()) {
      RefreshQueue.getInstance().refresh(false,true,null,roots.toArray(new VirtualFile[roots.size()]));
    }
    scanClassesCommand.run();
  }
  return swapProgress.isCancelled() ? new HashMap<DebuggerSession,Map<String,HotSwapFile>>() : modifiedClasses;
}
