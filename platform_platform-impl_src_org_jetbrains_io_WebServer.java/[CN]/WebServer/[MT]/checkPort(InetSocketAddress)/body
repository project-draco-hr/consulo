{
  final ClientBootstrap bootstrap=new ClientBootstrap(new OioClientSocketChannelFactory(new PooledThreadExecutor()));
  bootstrap.setOption("child.tcpNoDelay",true);
  final AtomicBoolean result=new AtomicBoolean(false);
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  bootstrap.setPipeline(pipeline(new HttpResponseDecoder(),new HttpRequestEncoder(),new SimpleChannelUpstreamHandler(){
    @Override public void messageReceived(    ChannelHandlerContext context,    MessageEvent e) throws Exception {
      try {
        if (e.getMessage() instanceof HttpResponse) {
          HttpResponse response=(HttpResponse)e.getMessage();
          if (response.getStatus().equals(OK) && response.getContent().toString(CharsetUtil.US_ASCII).equals(getApplicationStartTime())) {
            LOG.info("port check: current OS must be marked as normal");
            result.set(true);
          }
        }
      }
  finally {
        semaphore.up();
      }
    }
    @Override public void exceptionCaught(    ChannelHandlerContext ctx,    ExceptionEvent e) throws Exception {
      try {
        LOG.error(e.getCause());
      }
  finally {
        semaphore.up();
      }
    }
  }
));
  ChannelFuture connectFuture=null;
  try {
    connectFuture=bootstrap.connect(remoteAddress);
    if (!waitComplete(connectFuture,"connect")) {
      return false;
    }
    ChannelFuture writeFuture=connectFuture.getChannel().write(new DefaultHttpRequest(HTTP_1_1,HttpMethod.GET,START_TIME_PATH));
    if (!waitComplete(writeFuture,"write")) {
      return false;
    }
    try {
      if (!semaphore.waitForUnsafe(30000)) {
        LOG.info("port check: semaphore down timeout");
      }
    }
 catch (    InterruptedException e) {
      LOG.info("port check: semaphore interrupted",e);
    }
  }
  finally {
    if (connectFuture != null) {
      connectFuture.getChannel().close().awaitUninterruptibly();
    }
    bootstrap.releaseExternalResources();
  }
  return result.get();
}
