{
  if (!checkBases) {
    CachedValue<Map<String,PsiClass>> cache=myInnerClassesMapCache;
    if (cache == null) {
      final CachedValuesManager manager=CachedValuesManager.getManager(myClass.getProject());
      final Object[] dependencies={PsiModificationTracker.OUT_OF_CODE_BLOCK_MODIFICATION_COUNT,myTreeChangeTracker};
      myInnerClassesMapCache=cache=manager.createCachedValue(new CachedValueProvider<Map<String,PsiClass>>(){
        @Override public Result<Map<String,PsiClass>> compute(){
          return Result.create(getInnerClassesMap(),dependencies);
        }
      }
,false);
    }
    final Map<String,PsiClass> inners=cache.getValue();
    return inners != null ? inners.get(name) : null;
  }
  return PsiClassImplUtil.findInnerByName(myClass,name,checkBases);
}
