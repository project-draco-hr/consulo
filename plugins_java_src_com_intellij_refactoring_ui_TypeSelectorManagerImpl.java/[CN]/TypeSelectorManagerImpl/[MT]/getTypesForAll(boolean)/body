{
  final ArrayList<ExpectedTypeInfo[]> expectedTypesFromAll=new ArrayList<ExpectedTypeInfo[]>();
  for (  PsiExpression occurrence : myOccurrences) {
    final ExpectedTypeInfo[] expectedTypes=ExpectedTypesProvider.getExpectedTypes(occurrence,false,myOccurrenceClassProvider,isUsedAfter());
    if (expectedTypes.length > 0) {
      expectedTypesFromAll.add(expectedTypes);
    }
  }
  final ArrayList<PsiType> allowedTypes=new ArrayList<PsiType>();
  RefactoringHierarchyUtil.processSuperTypes(getDefaultType(),new RefactoringHierarchyUtil.SuperTypeVisitor(){
    public void visitType(    PsiType aType){
      checkIfAllowed(aType);
    }
    public void visitClass(    PsiClass aClass){
      checkIfAllowed(myFactory.createType(aClass));
    }
    private void checkIfAllowed(    PsiType type){
      NextInfo:       for (      ExpectedTypeInfo[] expectedTypes : expectedTypesFromAll) {
        for (        final ExpectedTypeInfo info : expectedTypes) {
          if (ExpectedTypeUtil.matches(type,info))           continue NextInfo;
        }
        return;
      }
      allowedTypes.add(type);
    }
  }
);
  final ArrayList<PsiType> result=normalizeTypeList(allowedTypes);
  if (!areTypesDirected) {
    Collections.reverse(result);
  }
  return result.toArray(new PsiType[result.size()]);
}
