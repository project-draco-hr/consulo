{
  boolean useOptimization=true;
  boolean hasNonTabs=false;
  boolean hasTabs=false;
  final int maxScanIndex=Math.min(start + columnNumber + 1,end);
  for (int i=start; i < maxScanIndex; i++) {
    if (text.charAt(i) == '\t') {
      hasTabs=true;
      if (hasNonTabs) {
        useOptimization=false;
        break;
      }
    }
 else {
      hasNonTabs=true;
    }
  }
  if (editor == null || useOptimization) {
    if (!hasTabs)     return Math.min(start + columnNumber,end);
    int shift=0;
    int offset=start;
    for (; offset < end && offset + shift < start + columnNumber; offset++) {
      if (text.charAt(offset) == '\t') {
        shift+=getTabLength(offset + shift - start,tabSize) - 1;
      }
    }
    if (offset + shift > start + columnNumber) {
      offset--;
    }
    return offset;
  }
  EditorEx editorImpl=(EditorEx)editor;
  int offset=start;
  IterationState state=new IterationState(editorImpl,offset,false);
  int fontType=state.getMergedAttributes().getFontType();
  int column=0;
  int x=0;
  int spaceSize=getSpaceWidth(fontType,editorImpl);
  while (column < columnNumber) {
    if (offset >= state.getEndOffset()) {
      state.advance();
      fontType=state.getMergedAttributes().getFontType();
    }
    char c=offset < end ? text.charAt(offset++) : ' ';
    if (c == '\t') {
      int prevX=x;
      x=nextTabStop(x,editorImpl);
      column+=(x - prevX) / spaceSize;
    }
 else {
      x+=charWidth(c,fontType,editorImpl);
      column++;
    }
  }
  if (column == columnNumber && offset < end && text.charAt(offset) == '\t' && (nextTabStop(x,editorImpl) - x) / spaceSize == 0) {
    offset++;
  }
  if (column > columnNumber)   offset--;
  return offset;
}
