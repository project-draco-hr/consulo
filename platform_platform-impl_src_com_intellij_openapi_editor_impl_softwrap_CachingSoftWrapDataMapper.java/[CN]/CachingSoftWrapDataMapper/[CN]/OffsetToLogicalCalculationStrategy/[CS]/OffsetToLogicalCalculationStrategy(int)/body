{
  super(new Computable<Pair<CacheEntry,LogicalPosition>>(){
    @Override public Pair<CacheEntry,LogicalPosition> compute(){
      if (targetOffset >= myEditor.getDocument().getTextLength()) {
        if (myCache.isEmpty()) {
          return new Pair<CacheEntry,LogicalPosition>(null,new LogicalPosition(0,0,0,0,0,0,0));
        }
 else {
          CacheEntry lastEntry=myCache.get(myCache.size() - 1);
          LogicalPosition eager=new LogicalPosition(lastEntry.endLogicalLine,lastEntry.endLogicalColumn + 1,lastEntry.endSoftWrapLinesBefore,lastEntry.endSoftWrapLinesCurrent,lastEntry.endSoftWrapColumnDiff,lastEntry.endFoldedLines,lastEntry.endFoldingColumnDiff);
          return new Pair<CacheEntry,LogicalPosition>(null,eager);
        }
      }
      int start=0;
      int end=myCache.size() - 1;
      while (start <= end) {
        int i=(end + start) >>> 1;
        CacheEntry cacheEntry=myCache.get(i);
        if (cacheEntry.endOffset < targetOffset) {
          start=i + 1;
          continue;
        }
        if (cacheEntry.startOffset > targetOffset) {
          end=i - 1;
          continue;
        }
        if (targetOffset == cacheEntry.endOffset && i < myCache.size() - 1) {
          CacheEntry nextLineCacheEntry=myCache.get(i + 1);
          if (nextLineCacheEntry.startOffset == targetOffset) {
            return new Pair<CacheEntry,LogicalPosition>(nextLineCacheEntry,null);
          }
        }
        return new Pair<CacheEntry,LogicalPosition>(cacheEntry,null);
      }
      throw new IllegalStateException(String.format("Can't map offset (%d) to logical position. Reason: no cached information information about target visual line is found. " + "Registered entries: %s",targetOffset,myCache));
    }
  }
);
  myTargetOffset=targetOffset;
}
