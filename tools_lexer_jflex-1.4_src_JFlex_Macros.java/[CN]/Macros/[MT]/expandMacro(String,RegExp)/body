{
switch (definition.type) {
case sym.BAR:
case sym.CONCAT:
    RegExp2 binary=(RegExp2)definition;
  binary.r1=expandMacro(name,binary.r1);
binary.r2=expandMacro(name,binary.r2);
return definition;
case sym.STAR:
case sym.PLUS:
case sym.QUESTION:
case sym.BANG:
case sym.TILDE:
RegExp1 unary=(RegExp1)definition;
unary.content=expandMacro(name,(RegExp)unary.content);
return definition;
case sym.MACROUSE:
String usename=(String)((RegExp1)definition).content;
if (name.equals(usename)) throw new MacroException(ErrorMessages.get(ErrorMessages.MACRO_CYCLE,name));
RegExp usedef=getDefinition(usename);
if (usedef == null) throw new MacroException(ErrorMessages.get(ErrorMessages.MACRO_DEF_MISSING,usename,name));
markUsed(usename);
return expandMacro(name,usedef);
case sym.STRING:
case sym.STRING_I:
case sym.CHAR:
case sym.CHAR_I:
case sym.CCLASS:
case sym.CCLASSNOT:
return definition;
default :
throw new MacroException("unknown expression type " + definition.type + " in macro expansion");
}
}
