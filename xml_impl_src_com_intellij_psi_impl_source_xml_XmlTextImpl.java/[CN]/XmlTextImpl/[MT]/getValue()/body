{
  String displayText=myDisplayText;
  if (displayText != null)   return displayText;
  StringBuilder buffer=new StringBuilder();
  ASTNode child=getFirstChildNode();
  final TIntArrayList gapsStarts=new TIntArrayList();
  final TIntArrayList gapsShifts=new TIntArrayList();
  while (child != null) {
    final int start=buffer.length();
    IElementType elementType=child.getElementType();
    if (elementType == XmlElementType.XML_CDATA) {
      final ASTNode cdata=child;
      child=cdata.getFirstChildNode();
    }
 else     if (elementType == XmlTokenType.XML_CHAR_ENTITY_REF) {
      String text=child.getText();
      LOG.assertTrue(text != null,child);
      buffer.append(XmlUtil.getCharFromEntityRef(text));
    }
 else     if (elementType == XmlTokenType.XML_WHITE_SPACE || elementType == XmlTokenType.XML_DATA_CHARACTERS || elementType == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {
      buffer.append(child.getText());
    }
 else     if (elementType == TokenType.ERROR_ELEMENT || elementType == TokenType.NEW_LINE_INDENT) {
      buffer.append(child.getText());
    }
    int end=buffer.length();
    int originalLength=child.getTextLength();
    if (end - start != originalLength) {
      gapsStarts.add(end);
      gapsShifts.add(originalLength - (end - start));
    }
    final ASTNode next=child.getTreeNext();
    if (next == null && child.getTreeParent().getElementType() == XmlElementType.XML_CDATA) {
      child=child.getTreeParent().getTreeNext();
    }
 else {
      child=next;
    }
  }
  int[] gapDisplayStarts=ArrayUtil.newIntArray(gapsShifts.size());
  int[] gapPhysicalStarts=ArrayUtil.newIntArray(gapsShifts.size());
  int currentGapsSum=0;
  for (int i=0; i < gapDisplayStarts.length; i++) {
    currentGapsSum+=gapsShifts.get(i);
    gapDisplayStarts[i]=gapsStarts.get(i);
    gapPhysicalStarts[i]=gapDisplayStarts[i] + currentGapsSum;
  }
  myGapDisplayStarts=gapDisplayStarts;
  myGapPhysicalStarts=gapPhysicalStarts;
  String text=buffer.toString();
  myDisplayText=text;
  return text;
}
