{
  if (myData != null) {
    return;
  }
  ObjectInputStream oIn=null;
  try {
    oIn=new ObjectInputStream(new ByteArrayInputStream(myRawData)){
      @Override protected Class<?> resolveClass(      ObjectStreamClass desc) throws IOException, ClassNotFoundException {
        String name=desc.getName();
        for (        ClassLoader loader : loaders) {
          try {
            return Class.forName(name,false,loader);
          }
 catch (          ClassNotFoundException e) {
          }
        }
        return super.resolveClass(desc);
      }
      @Override protected Class<?> resolveProxyClass(      String[] interfaces) throws IOException, ClassNotFoundException {
        for (        ClassLoader loader : loaders) {
          try {
            return doResolveProxyClass(interfaces,loader);
          }
 catch (          ClassNotFoundException e) {
          }
        }
        return super.resolveProxyClass(interfaces);
      }
      private Class<?> doResolveProxyClass(      @NotNull String[] interfaces,      @NotNull ClassLoader loader) throws ClassNotFoundException {
        ClassLoader nonPublicLoader=null;
        boolean hasNonPublicInterface=false;
        Class[] classObjs=new Class[interfaces.length];
        for (int i=0; i < interfaces.length; i++) {
          Class cl=Class.forName(interfaces[i],false,loader);
          if ((cl.getModifiers() & Modifier.PUBLIC) == 0) {
            if (hasNonPublicInterface) {
              if (nonPublicLoader != cl.getClassLoader()) {
                throw new IllegalAccessError("conflicting non-public interface class loaders");
              }
            }
 else {
              nonPublicLoader=cl.getClassLoader();
              hasNonPublicInterface=true;
            }
          }
          classObjs[i]=cl;
        }
        try {
          return Proxy.getProxyClass(hasNonPublicInterface ? nonPublicLoader : loader,classObjs);
        }
 catch (        IllegalArgumentException e) {
          throw new ClassNotFoundException(null,e);
        }
      }
    }
;
    myData=(T)oIn.readObject();
    myRawData=null;
  }
 catch (  IOException e) {
    throw new IllegalStateException(String.format("Can't deserialize target data of key '%s'. Given class loaders: %s",myKey,Arrays.toString(loaders)),e);
  }
catch (  ClassNotFoundException e) {
    throw new IllegalStateException(String.format("Can't deserialize target data of key '%s'. Given class loaders: %s",myKey,Arrays.toString(loaders)),e);
  }
 finally {
    StreamUtil.closeStream(oIn);
  }
}
