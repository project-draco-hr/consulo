{
  for (Iterator<UsageInfo> iterator=usageInfoSet.iterator(); iterator.hasNext(); ) {
    UsageInfo usageInfo=iterator.next();
    final PsiElement element=usageInfo.getElement();
    if (element == null || !isToBeChanged(usageInfo)) {
      iterator.remove();
    }
  }
  LocalHistoryAction action=LocalHistory.getInstance().startAction(getCommandName());
  final UsageInfo[] writableUsageInfos=usageInfoSet.toArray(new UsageInfo[usageInfoSet.size()]);
  try {
    PsiDocumentManager.getInstance(myProject).commitAllDocuments();
    RefactoringListenerManagerImpl listenerManager=(RefactoringListenerManagerImpl)RefactoringListenerManager.getInstance(myProject);
    myTransaction=listenerManager.startTransaction();
    final Map<RefactoringHelper,Object> preparedData=new LinkedHashMap<RefactoringHelper,Object>();
    final Runnable prepareHelpersRunnable=new Runnable(){
      @Override public void run(){
        for (        final RefactoringHelper helper : Extensions.getExtensions(RefactoringHelper.EP_NAME)) {
          Object operation=ApplicationManager.getApplication().runReadAction(new Computable<Object>(){
            @Override public Object compute(){
              return helper.prepareOperation(writableUsageInfos);
            }
          }
);
          preparedData.put(helper,operation);
        }
      }
    }
;
    ProgressManager.getInstance().runProcessWithProgressSynchronously(prepareHelpersRunnable,"Prepare ...",false,myProject);
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      @Override public void run(){
        final String refactoringId=getRefactoringId();
        if (refactoringId != null) {
          RefactoringEventData data=getBeforeData();
          if (data != null) {
            data.addUsages(usageInfoSet);
          }
          myProject.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringStarted(refactoringId,data);
        }
        try {
          if (refactoringId != null) {
            UndoableAction action=new UndoRefactoringAction(myProject,refactoringId);
            UndoManager.getInstance(myProject).undoableActionPerformed(action);
          }
          performRefactoring(writableUsageInfos);
        }
  finally {
          if (refactoringId != null) {
            myProject.getMessageBus().syncPublisher(RefactoringEventListener.REFACTORING_EVENT_TOPIC).refactoringDone(refactoringId,getAfterData(writableUsageInfos));
          }
        }
      }
    }
);
    for (    Map.Entry<RefactoringHelper,Object> e : preparedData.entrySet()) {
      e.getKey().performOperation(myProject,e.getValue());
    }
    myTransaction.commit();
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      @Override public void run(){
        performPsiSpoilingRefactoring();
      }
    }
);
  }
  finally {
    action.finish();
  }
  int count=writableUsageInfos.length;
  if (count > 0) {
    StatusBarUtil.setStatusBarInfo(myProject,RefactoringBundle.message("statusBar.refactoring.result",count));
  }
 else {
    if (!isPreviewUsages(writableUsageInfos)) {
      StatusBarUtil.setStatusBarInfo(myProject,RefactoringBundle.message("statusBar.noUsages"));
    }
  }
}
