{
  Collection<FilePatch> allFailed=ContainerUtil.concat(group,new Function<PatchApplier,Collection<? extends FilePatch>>(){
    @Override public Collection<FilePatch> fun(    PatchApplier applier){
      return applier.getFailedPatches();
    }
  }
);
  boolean shouldInformAboutBinaries=ContainerUtil.exists(group,new Condition<PatchApplier>(){
    @Override public boolean value(    PatchApplier applier){
      return !applier.getBinaryPatches().isEmpty();
    }
  }
);
  final UndoApplyPatchDialog undoApplyPatchDialog=new UndoApplyPatchDialog(project,ContainerUtil.map(allFailed,new Function<FilePatch,FilePath>(){
    @Override public FilePath fun(    FilePatch filePatch){
      String path=filePatch.getAfterName() == null ? filePatch.getBeforeName() : filePatch.getAfterName();
      return VcsUtil.getFilePath(path);
    }
  }
),shouldInformAboutBinaries);
  undoApplyPatchDialog.show();
  if (undoApplyPatchDialog.isOK()) {
    rollbackUnderProgress(project,project.getBaseDir(),beforeLabel);
  }
}
