{
  List<ExpectedTypeInfo[]> typesList=new ArrayList<ExpectedTypeInfo[]>();
  List<String> expectedMethodNames=new ArrayList<String>();
  List<String> expectedFieldNames=new ArrayList<String>();
  getExpectedInformation(expression,typesList,expectedMethodNames,expectedFieldNames);
  final List<PsiVariable> list=new ArrayList<PsiVariable>();
  VariablesProcessor varproc=new VariablesProcessor("",true,list){
    public boolean execute(    PsiElement element,    PsiSubstitutor substitutor){
      if (!(element instanceof PsiField) || element.getManager().getResolveHelper().isAccessible(((PsiField)element),expression,null)) {
        return super.execute(element,substitutor);
      }
      return true;
    }
  }
;
  PsiScopesUtil.treeWalkUp(varproc,expression,null);
  PsiVariable[] allVars=varproc.getResultsAsArray();
  ExpectedTypeInfo[] infos=ExpectedTypeUtil.intersect(typesList);
  List<PsiVariable> result=new ArrayList<PsiVariable>();
  nextVar:   for (  PsiVariable variable : allVars) {
    PsiType varType=variable.getType();
    boolean matched=infos.length == 0;
    for (    ExpectedTypeInfo info : infos) {
      if (ExpectedTypeUtil.matches(varType,info)) {
        matched=true;
        break;
      }
    }
    if (matched) {
      if (!expectedFieldNames.isEmpty() && !expectedMethodNames.isEmpty()) {
        if (!(varType instanceof PsiClassType))         continue nextVar;
        PsiClass aClass=((PsiClassType)varType).resolve();
        if (aClass == null)         continue nextVar;
        for (        String name : expectedFieldNames) {
          if (aClass.findFieldByName(name,true) == null)           continue nextVar;
        }
        for (        String name : expectedMethodNames) {
          PsiMethod[] methods=aClass.findMethodsByName(name,true);
          if (methods == null || methods.length == 0)           continue nextVar;
        }
      }
      result.add(variable);
    }
  }
  return result.toArray(new PsiVariable[result.size()]);
}
