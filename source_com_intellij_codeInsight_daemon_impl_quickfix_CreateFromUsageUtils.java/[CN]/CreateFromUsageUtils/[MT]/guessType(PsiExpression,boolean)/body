{
  final PsiManager manager=expression.getManager();
  final GlobalSearchScope resolveScope=expression.getResolveScope();
  List<ExpectedTypeInfo[]> typesList=new ArrayList<ExpectedTypeInfo[]>();
  final List<String> expectedMethodNames=new ArrayList<String>();
  final List<String> expectedFieldNames=new ArrayList<String>();
  getExpectedInformation(expression,typesList,expectedMethodNames,expectedFieldNames);
  if (typesList.size() == 1 && (expectedFieldNames.size() > 0 || expectedMethodNames.size() > 0)) {
    ExpectedTypeInfo[] infos=typesList.get(0);
    if (infos.length == 1 && infos[0].getKind() == ExpectedTypeInfo.TYPE_OR_SUBTYPE && infos[0].getType().equals(PsiType.getJavaLangObject(manager,resolveScope))) {
      typesList.clear();
    }
  }
  if (typesList.size() == 0) {
    PsiElementFactory factory=manager.getElementFactory();
    for (    String fieldName : expectedFieldNames) {
      PsiField[] fields=manager.getShortNamesCache().getFieldsByName(fieldName,resolveScope);
      addMemberInfo(fields,expression,typesList,factory);
    }
    for (    String methodName : expectedMethodNames) {
      PsiMethod[] methods=manager.getShortNamesCache().getMethodsByName(methodName,resolveScope);
      addMemberInfo(methods,expression,typesList,factory);
    }
  }
  ExpectedTypeInfo[] expectedTypes=ExpectedTypeUtil.intersect(typesList);
  if (expectedTypes.length == 0 && !typesList.isEmpty()) {
    List<ExpectedTypeInfo> union=new ArrayList<ExpectedTypeInfo>();
    for (    ExpectedTypeInfo[] aTypesList : typesList) {
      union.addAll(Arrays.asList((ExpectedTypeInfo[])aTypesList));
    }
    expectedTypes=union.toArray(new ExpectedTypeInfo[union.size()]);
  }
  if (expectedTypes == null || expectedTypes.length == 0) {
    return allowVoidType ? new PsiType[]{PsiType.VOID} : new PsiType[]{PsiType.getJavaLangObject(manager,resolveScope)};
  }
 else {
    final Set<PsiType> typesSet=new HashSet<PsiType>();
    PsiTypeVisitor<PsiType> visitor=new PsiTypeVisitor<PsiType>(){
      public PsiType visitType(      PsiType type){
        if (PsiType.NULL.equals(type)) {
          type=PsiType.getJavaLangObject(manager,resolveScope);
        }
 else         if (PsiType.VOID.equals(type) && !allowVoidType) {
          type=PsiType.getJavaLangObject(manager,resolveScope);
        }
        if (!typesSet.contains(type)) {
          if (type instanceof PsiClassType && (expectedFieldNames.size() > 0 || expectedMethodNames.size() > 0)) {
            PsiClass aClass=((PsiClassType)type).resolve();
            if (aClass != null) {
              for (Iterator<String> i=expectedFieldNames.iterator(); i.hasNext(); ) {
                String fieldName=i.next();
                if (aClass.findFieldByName(fieldName,true) == null)                 return null;
              }
              for (Iterator<String> i=expectedMethodNames.iterator(); i.hasNext(); ) {
                String methodName=i.next();
                PsiMethod[] methods=aClass.findMethodsByName(methodName,true);
                if (methods == null || methods.length == 0)                 return null;
              }
            }
          }
          typesSet.add(type);
          return type;
        }
        return null;
      }
      public PsiType visitCapturedWildcardType(      PsiCapturedWildcardType capturedWildcardType){
        return capturedWildcardType.getUpperBound().accept(this);
      }
    }
;
    ExpectedTypesProvider provider=ExpectedTypesProvider.getInstance(manager.getProject());
    PsiType[] types=provider.processExpectedTypes(expectedTypes,visitor,manager.getProject());
    if (types.length == 0) {
      return allowVoidType ? new PsiType[]{PsiType.VOID} : new PsiType[]{PsiType.getJavaLangObject(manager,resolveScope)};
    }
    return types;
  }
}
