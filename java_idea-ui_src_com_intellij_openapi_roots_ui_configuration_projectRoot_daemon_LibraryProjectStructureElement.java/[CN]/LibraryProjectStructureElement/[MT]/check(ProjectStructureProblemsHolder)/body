{
  if (((LibraryEx)myLibrary).isDisposed())   return;
  final LibraryEx library=(LibraryEx)myContext.getLibraryModel(myLibrary);
  if (library == null || library.isDisposed())   return;
  final String libraryName=library.getName();
  final List<String> invalidClasses=library.getInvalidRootUrls(OrderRootType.CLASSES);
  if (!invalidClasses.isEmpty()) {
    final String description=createInvalidRootsDescription(invalidClasses,libraryName);
    problemsHolder.registerError(ProjectBundle.message("project.roots.tooltip.library.misconfigured",libraryName),description,createPlace(),new RemoveInvalidRootsQuickFix(Collections.singletonMap(OrderRootType.CLASSES,invalidClasses),library));
  }
  final List<String> invalidJavadocs=library.getInvalidRootUrls(JavadocOrderRootType.getInstance());
  final List<String> invalidSources=library.getInvalidRootUrls(OrderRootType.SOURCES);
  if (!invalidJavadocs.isEmpty() || !invalidSources.isEmpty()) {
    final Map<OrderRootType,List<String>> invalidRoots=new HashMap<OrderRootType,List<String>>();
    invalidRoots.put(OrderRootType.SOURCES,invalidSources);
    invalidRoots.put(JavadocOrderRootType.getInstance(),invalidJavadocs);
    final String description=createInvalidRootsDescription(ContainerUtil.concat(invalidJavadocs,invalidSources),libraryName);
    problemsHolder.registerWarning(ProjectBundle.message("project.roots.tooltip.library.misconfigured",libraryName),description,createPlace(),new RemoveInvalidRootsQuickFix(invalidRoots,library));
  }
}
