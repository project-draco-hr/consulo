{
  final Set<PsiMember> moving=new HashSet<PsiMember>(membersToMove);
  if (abstractMethods != null) {
    moving.addAll(abstractMethods);
  }
  if (scope instanceof PsiReferenceExpression) {
    PsiReferenceExpression refExpr=(PsiReferenceExpression)scope;
    PsiElement refElement=refExpr.resolve();
    if (refElement instanceof PsiMember) {
      if (!RefactoringHierarchyUtil.willBeInTargetClass(refElement,moving,targetClass,false)) {
        PsiExpression qualifier=refExpr.getQualifierExpression();
        PsiClass accessClass=(PsiClass)(qualifier != null ? PsiUtil.getAccessObjectClass(qualifier).getElement() : null);
        checkAccessibility((PsiMember)refElement,context,accessClass,member,conflicts);
      }
    }
  }
 else   if (scope instanceof PsiNewExpression) {
    final PsiNewExpression newExpression=(PsiNewExpression)scope;
    final PsiAnonymousClass anonymousClass=newExpression.getAnonymousClass();
    if (anonymousClass != null) {
      if (!RefactoringHierarchyUtil.willBeInTargetClass(anonymousClass,moving,targetClass,false)) {
        checkAccessibility(anonymousClass,context,anonymousClass,member,conflicts);
      }
    }
 else {
      final PsiMethod refElement=newExpression.resolveConstructor();
      if (refElement != null) {
        if (!RefactoringHierarchyUtil.willBeInTargetClass(refElement,moving,targetClass,false)) {
          checkAccessibility(refElement,context,null,member,conflicts);
        }
      }
    }
  }
 else   if (scope instanceof PsiJavaCodeReferenceElement) {
    PsiJavaCodeReferenceElement refExpr=(PsiJavaCodeReferenceElement)scope;
    PsiElement refElement=refExpr.resolve();
    if (refElement instanceof PsiMember) {
      if (!RefactoringHierarchyUtil.willBeInTargetClass(refElement,moving,targetClass,false)) {
        checkAccessibility((PsiMember)refElement,context,null,member,conflicts);
      }
    }
  }
  PsiElement[] children=scope.getChildren();
  for (  PsiElement child : children) {
    if (!(child instanceof PsiWhiteSpace)) {
      checkUsedElements(member,child,membersToMove,abstractMethods,targetClass,context,conflicts);
    }
  }
}
