{
  final GitSimpleHandler handler=new GitSimpleHandler(project,root,GitCommand.BRANCH);
  handler.setNoSSH(true);
  handler.setSilent(true);
  handler.addParameters("--no-color");
  boolean remoteOnly=false;
  if (remoteWanted && localWanted) {
    handler.addParameters("-a");
    remoteOnly=false;
  }
 else   if (remoteWanted) {
    handler.addParameters("-r");
    remoteOnly=true;
  }
  if (containingCommit != null) {
    handler.addParameters("--contains",containingCommit);
  }
  final String output=handler.run();
  if (output.trim().length() == 0) {
    String head;
    try {
      head=FileUtil.loadFile(new File(root.getPath(),GitRepositoryFiles.GIT_HEAD),GitUtil.UTF8_ENCODING).trim();
      final String prefix="ref: refs/heads/";
      return head.startsWith(prefix) ? new GitBranch(head.substring(prefix.length()),true,false) : null;
    }
 catch (    IOException e) {
      LOG.info(e);
      return null;
    }
  }
  final String[] split=output.split("\n");
  GitBranch currentBranch=null;
  String activeRemoteName=null;
  for (  String b : split) {
    boolean current=b.charAt(0) == '*';
    b=b.substring(2).trim();
    if (b.equals(NO_BRANCH_NAME)) {
      continue;
    }
    String remotePrefix=null;
    if (b.startsWith("remotes/")) {
      remotePrefix="remotes/";
    }
 else     if (b.startsWith(REFS_REMOTES_PREFIX)) {
      remotePrefix=REFS_REMOTES_PREFIX;
    }
    boolean isRemote=remotePrefix != null || remoteOnly;
    if (isRemote) {
      if (!remoteOnly) {
        b=b.substring(remotePrefix.length());
      }
      final int idx=b.indexOf("HEAD ->");
      if (idx > 0) {
        activeRemoteName=b.substring(idx + "HEAD ->".length() + (remotePrefix == null ? 0 : remotePrefix.length()));
        continue;
      }
    }
    final GitBranch branch=new GitBranch(b,current,isRemote);
    if (current) {
      currentBranch=branch;
    }
    if (branches != null && ((isRemote && remoteWanted) || (!isRemote && localWanted))) {
      branches.add(branch);
    }
  }
  if (activeRemoteName != null) {
    for (    GitBranch branch : branches) {
      if (activeRemoteName.equals(branch.getName())) {
        branch.setActive(true);
        break;
      }
    }
  }
  return currentBranch;
}
