{
  ColumnInfo[] columnInfos={new ClassColumnInfo(myColumnNames[CLASS_OR_ELEMENT_NAME_COLUMN]),new PropertyTypeColumnInfo(myColumnNames[TYPE_COLUMN])};
  myTreeTableModel=new ListTreeTableModelOnColumns(myTreeRoot,columnInfos);
  myTreeTable=new TreeTable(myTreeTableModel);
  final MyColoredTreeCellRenderer treeCellRenderer=new MyColoredTreeCellRenderer();
  myTreeTable.setDefaultRenderer(String.class,new TableCellRenderer(){
    public Component getTableCellRendererComponent(    JTable table,    Object value,    boolean isSelected,    boolean hasFocus,    int row,    int column){
      if (value instanceof String) {
        return new JLabel(QuickfixUtil.shortenType((String)value));
      }
      return new JLabel();
    }
  }
);
  myTreeTable.setTreeCellRenderer(treeCellRenderer);
  myTreeTable.setRootVisible(false);
  myTreeTable.setSelectionMode(DefaultTreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
  final MyPropertyTypeCellEditor typeCellEditor=new MyPropertyTypeCellEditor(project);
  typeCellEditor.addCellEditorListener(new CellEditorListener(){
    public void editingStopped(    ChangeEvent e){
      final TreeTableTree tree=getTree();
      String newTypeValue=((MyPropertyTypeCellEditor)e.getSource()).getCellEditorValue();
      if (newTypeValue == null || tree == null) {
        myTreeTable.editingStopped(e);
        return;
      }
      try {
        GrTypeElement typeElement=GroovyPsiElementFactory.getInstance(project).createTypeElement(newTypeValue);
        String canonical=typeElement.getType().getCanonicalText();
        if (canonical != null)         newTypeValue=canonical;
      }
 catch (      IncorrectOperationException ex) {
      }
      final TreePath editingTypePath=tree.getSelectionPath();
      if (editingTypePath == null)       return;
      final TreePath editingClassPath=editingTypePath.getParentPath();
      Object oldTypeValue=myTreeTable.getValueAt(tree.getRowForPath(editingTypePath),TYPE_COLUMN);
      if (!(oldTypeValue instanceof String)) {
        myTreeTable.editingStopped(e);
        return;
      }
      final Object editingPropertyObject=myTreeTable.getValueAt(tree.getRowForPath(editingTypePath),CLASS_OR_ELEMENT_NAME_COLUMN);
      final Object editingClassObject=myTreeTable.getValueAt(tree.getRowForPath(editingClassPath),CLASS_OR_ELEMENT_NAME_COLUMN);
      if (!(editingPropertyObject instanceof DItemElement) || !(editingClassObject instanceof DClassElement)) {
        myTreeTable.editingStopped(e);
        return;
      }
      final DItemElement dynamicElement=(DItemElement)editingPropertyObject;
      final String name=dynamicElement.getName();
      final String className=((DClassElement)editingClassObject).getName();
      if (dynamicElement instanceof DPropertyElement) {
        DynamicManager.getInstance(project).replaceDynamicPropertyType(className,name,(String)oldTypeValue,newTypeValue);
      }
 else       if (dynamicElement instanceof DMethodElement) {
        final List<MyPair> myPairList=((DMethodElement)dynamicElement).getPairs();
        DynamicManager.getInstance(project).replaceDynamicMethodType(className,name,myPairList,(String)oldTypeValue,newTypeValue);
      }
    }
    public void editingCanceled(    ChangeEvent e){
      System.out.println("editing canceled");
      myTreeTable.editingCanceled(e);
    }
  }
);
  RefactoringListenerManager.getInstance(project).addListenerProvider(new RefactoringElementListenerProvider(){
    @Nullable public RefactoringElementListener getListener(    final PsiElement element){
      if (element instanceof GrDynamicImplicitElement) {
        return new RefactoringElementListener(){
          public void elementMoved(          PsiElement newElement){
            renameElement(newElement,project,element);
          }
          public void elementRenamed(          PsiElement newElement){
            renameElement(newElement,project,element);
          }
          private void renameElement(          PsiElement newElement,          Project project,          PsiElement element){
          }
        }
;
      }
      return null;
    }
  }
);
  myTreeTable.setDefaultEditor(String.class,typeCellEditor);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      deleteRow(project);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0),JComponent.WHEN_FOCUSED);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      final int selectionRow=myTreeTable.getTree().getLeadSelectionRow();
      myTreeTable.editCellAt(selectionRow,CLASS_OR_ELEMENT_NAME_COLUMN,event);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),JComponent.WHEN_FOCUSED);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      final int selectionRow=myTreeTable.getTree().getLeadSelectionRow();
      myTreeTable.editCellAt(selectionRow,TYPE_COLUMN,event);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_F2,KeyEvent.CTRL_MASK),JComponent.WHEN_FOCUSED);
  myTreeTable.getTree().setShowsRootHandles(true);
  myTreeTable.getTableHeader().setReorderingAllowed(false);
  myTreeTable.setPreferredScrollableViewportSize(new Dimension(300,myTreeTable.getRowHeight() * 10));
  myTreeTable.getColumn(myColumnNames[CLASS_OR_ELEMENT_NAME_COLUMN]).setPreferredWidth(200);
  myTreeTable.getColumn(myColumnNames[TYPE_COLUMN]).setPreferredWidth(160);
  JScrollPane scrollpane=ScrollPaneFactory.createScrollPane(myTreeTable);
  scrollpane.setPreferredSize(new Dimension(600,400));
  return scrollpane;
}
