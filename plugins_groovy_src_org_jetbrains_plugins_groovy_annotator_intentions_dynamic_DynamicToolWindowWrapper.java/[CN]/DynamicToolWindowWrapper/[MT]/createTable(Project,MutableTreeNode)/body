{
  ColumnInfo[] columnInfos={new ClassColumnInfo(myColumnNames[CLASS_OR_PROPERTY_NAME_COLUMN]),new PropertyTypeColumnInfo(myColumnNames[PROPERTY_TYPE_COLUMN])};
  myTreeTableModel=new ListTreeTableModelOnColumns(myTreeRoot,columnInfos);
  myTreeTable=new TreeTable(myTreeTableModel){
    public void editingStopped(    ChangeEvent e){
      final TableCellEditor tableCellEditor=getCellEditor();
      final Object value=tableCellEditor.getCellEditorValue();
      final TreePath editingPath=getTree().getSelectionPath();
      final TreePath parentPath=editingPath.getParentPath();
      final Object editingCell=getValueAt(getTree().getRowForPath(editingPath),1);
      final Object parentCell=getValueAt(getTree().getRowForPath(parentPath),0);
      if (!(value instanceof String))       super.editingStopped(e);
      if (!value.toString().matches(IDENTIFIER_REGEXP))       super.editingStopped(e);
      if (editingCell instanceof DPClassNode) {
      }
 else       if (editingCell instanceof DPPropertyElement) {
      }
 else       if (editingCell instanceof DPPropertyTypeElement) {
        final DPPropertyTypeElement typeCell=(DPPropertyTypeElement)editingCell;
        final Object cell=getValueAt(getTree().getRowForPath(editingPath),0);
        if (!(cell instanceof DPPropertyElement) || !(parentCell instanceof DPContainingClassElement))         super.editingStopped(e);
        DPPropertyElement propertyCell=((DPPropertyElement)cell);
        final String name=propertyCell.getPropertyName();
        final String type=typeCell.getPropertyType();
        final String className=((DPContainingClassElement)parentCell).getContainingClassName();
        DynamicPropertiesManager.getInstance(project).replaceDynamicPropertyType(new DynamicPropertyVirtual(name,className,getModule(project).getName(),type),new DynamicPropertyVirtual(name,className,getModule(project).getName(),value.toString()));
      }
      super.editingCanceled(e);
    }
  }
;
  myTreeTable.setRootVisible(false);
  myTreeTable.setSelectionMode(DefaultTreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      storeState(project);
      deleteRow(project);
      restoreState(project);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,0),JComponent.WHEN_FOCUSED);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      storeState(project);
      final int selectionRow=myTreeTable.getTree().getLeadSelectionRow();
      myTreeTable.editCellAt(selectionRow,CLASS_OR_PROPERTY_NAME_COLUMN,event);
      restoreState(project);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_F2,0),JComponent.WHEN_FOCUSED);
  myTreeTable.registerKeyboardAction(new ActionListener(){
    public void actionPerformed(    ActionEvent event){
      storeState(project);
      final int selectionRow=myTreeTable.getTree().getLeadSelectionRow();
      myTreeTable.editCellAt(selectionRow,PROPERTY_TYPE_COLUMN,event);
      restoreState(project);
    }
  }
,KeyStroke.getKeyStroke(KeyEvent.VK_F2,KeyEvent.CTRL_MASK),JComponent.WHEN_FOCUSED);
  myTreeTable.getTree().setShowsRootHandles(true);
  myTreeTable.getTableHeader().setReorderingAllowed(false);
  myTreeTable.setTreeCellRenderer(new MyColoredTreeCellRenderer());
  myTreeTable.setPreferredScrollableViewportSize(new Dimension(300,myTreeTable.getRowHeight() * 10));
  myTreeTable.getColumn(myColumnNames[CLASS_OR_PROPERTY_NAME_COLUMN]).setPreferredWidth(200);
  myTreeTable.getColumn(myColumnNames[PROPERTY_TYPE_COLUMN]).setPreferredWidth(160);
  myTreeTable.addMouseListener(new MouseAdapter(){
    public void mouseClicked(    MouseEvent e){
      final Point point=e.getPoint();
      if (e.getClickCount() == 2) {
        myTreeTable.editCellAt(myTreeTable.rowAtPoint(point),myTreeTable.columnAtPoint(point),e);
      }
    }
  }
);
  JScrollPane scrollpane=ScrollPaneFactory.createScrollPane(myTreeTable);
  scrollpane.setPreferredSize(new Dimension(600,400));
  return scrollpane;
}
