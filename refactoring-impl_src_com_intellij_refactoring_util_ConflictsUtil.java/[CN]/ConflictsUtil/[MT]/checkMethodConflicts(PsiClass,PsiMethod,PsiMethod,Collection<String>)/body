{
  if (prototype == null)   return;
  PsiMethod method=aClass.findMethodBySignature(prototype,true);
  if (method != null && method != refactoredMethod) {
    if (method.getContainingClass().equals(aClass)) {
      final String classDescr=aClass instanceof PsiAnonymousClass ? RefactoringBundle.message("current.class") : getDescription(aClass,false);
      conflicts.add(RefactoringBundle.message("method.0.is.already.defined.in.the.1",getMethodPrototypeString(prototype),classDescr));
    }
 else {
      if (!method.hasModifierProperty(PsiModifier.PRIVATE)) {
        String protoMethodInfo=getMethodPrototypeString(prototype);
        String className=getDescription(method.getContainingClass(),false);
        if (!prototype.hasModifierProperty(PsiModifier.PRIVATE)) {
          boolean isMethodAbstract=method.hasModifierProperty(PsiModifier.ABSTRACT);
          boolean isMyMethodAbstract=refactoredMethod != null && refactoredMethod.hasModifierProperty(PsiModifier.ABSTRACT);
          final String conflict=isMethodAbstract != isMyMethodAbstract ? RefactoringBundle.message("method.0.will.implement.method.of.the.base.class",protoMethodInfo,className) : RefactoringBundle.message("method.0.will.override.a.method.of.the.base.class",protoMethodInfo,className);
          conflicts.add(conflict);
        }
 else {
          conflicts.add(RefactoringBundle.message("method.0.will.hide.method.of.the.base.class",protoMethodInfo,className));
        }
      }
    }
  }
}
