{
  final Graph<Chunk<ModifiableRootModel>> graph=ModuleCompilerUtil.toChunkGraph(myContext.getModulesConfigurator().createGraphGenerator());
  final Collection<Chunk<ModifiableRootModel>> chunks=graph.getNodes();
  String cycles="";
  int count=0;
  for (  Chunk<ModifiableRootModel> chunk : chunks) {
    final Set<ModifiableRootModel> modules=chunk.getNodes();
    String cycle="";
    for (    ModifiableRootModel model : modules) {
      cycle+=", " + model.getModule().getName();
    }
    if (modules.size() > 1) {
      @NonNls final String br="<br>&nbsp;&nbsp;&nbsp;&nbsp;";
      cycles+=br + (++count) + ". "+ cycle.substring(2);
    }
  }
  if (count > 0) {
    @NonNls final String leftBrace="<html>";
    @NonNls final String rightBrace="</html>";
    final String fullDescription=leftBrace + ProjectBundle.message("module.circular.dependency.warning",cycles,count) + rightBrace;
    final Project project=myContext.getProject();
    for (    Chunk<ModifiableRootModel> chunk : chunks) {
      final Set<ModifiableRootModel> nodes=chunk.getNodes();
      if (nodes.size() > 1) {
        final PlaceInProjectStructureBase place=new PlaceInProjectStructureBase(project,ProjectStructureConfigurable.getInstance(project).createModulesPlace(),this);
        StringBuilder names=new StringBuilder();
        for (        ModifiableRootModel model : nodes) {
          if (names.length() > 0)           names.append(", ");
          names.append(model.getModule().getName());
        }
        problemsHolder.registerProblem(new CircularDependencyProblemDescription("Circular dependency between modules " + names,fullDescription,place));
      }
    }
  }
}
