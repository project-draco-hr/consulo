{
  final Graph<Chunk<ModifiableRootModel>> graph=ModuleCompilerUtil.toChunkGraph(myContext.getModulesConfigurator().createGraphGenerator());
  final Collection<Chunk<ModifiableRootModel>> chunks=graph.getNodes();
  List<String> cycles=new ArrayList<String>();
  for (  Chunk<ModifiableRootModel> chunk : chunks) {
    final Set<ModifiableRootModel> modules=chunk.getNodes();
    List<String> names=new ArrayList<String>();
    for (    ModifiableRootModel model : modules) {
      names.add(model.getModule().getName());
    }
    if (modules.size() > 1) {
      cycles.add(StringUtil.join(names,", "));
    }
  }
  if (!cycles.isEmpty()) {
    final Project project=myContext.getProject();
    final PlaceInProjectStructureBase place=new PlaceInProjectStructureBase(project,ProjectStructureConfigurable.getInstance(project).createModulesPlace(),this);
    final String message;
    final String description;
    if (cycles.size() > 1) {
      message="Circular dependencies";
      @NonNls final String br="<br>&nbsp;&nbsp;&nbsp;&nbsp;";
      StringBuilder cyclesString=new StringBuilder();
      for (int i=0; i < cycles.size(); i++) {
        cyclesString.append(br).append(i + 1).append(". ").append(cycles.get(i));
      }
      description=ProjectBundle.message("module.circular.dependency.warning.description",cyclesString);
    }
 else {
      message=ProjectBundle.message("module.circular.dependency.warning.short",cycles.get(0));
      description=null;
    }
    problemsHolder.registerProblem(new ProjectStructureProblemDescription(message,description,place,ProjectStructureProblemType.warning("module-circular-dependency"),Collections.<ConfigurationErrorQuickFix>emptyList()));
  }
}
