{
  super(method,manager);
  ownerClass.add(this);
  myDerivedMethods=new ArrayList<RefMethod>(0);
  setConstructor(method.isConstructor());
  setFlag(method.getReturnType() == null || PsiType.VOID == method.getReturnType(),IS_RETURN_VALUE_USED_MASK);
  if (!isReturnValueUsed()) {
    myReturnValueTemplate=RETURN_VALUE_UNDEFINED;
  }
  if (isConstructor()) {
    addReference(getOwnerClass(),getOwnerClass().getElement(),method,false,true,null);
    setCanBeStatic(false);
  }
  if (getOwnerClass().isInterface() || !(getOwnerClass().getOwner() instanceof RefPackage)) {
    setCanBeStatic(false);
  }
  if (getOwnerClass().isInterface()) {
    setAbstract(false);
  }
 else {
    setAbstract(method.hasModifierProperty(PsiModifier.ABSTRACT));
  }
  setAppMain(RefUtil.isAppMain(method,this));
  setLibraryOverride(method.hasModifierProperty(PsiModifier.NATIVE));
  mySuperMethods=new ArrayList<RefMethod>(0);
  initializeSuperMethods(method);
  if (isLibraryOverride()) {
    getOwnerClass().addLibraryOverrideMethod(this);
    setCanBeStatic(false);
  }
  if (getSuperMethods().size() > 0 || isAbstract()) {
    setCanBeStatic(false);
  }
  if (getOwnerClass().isTestCase() && method.getName().startsWith("test")) {
    setCanBeStatic(false);
  }
  PsiParameter[] paramList=method.getParameterList().getParameters();
  myParameters=new RefParameter[paramList.length];
  for (int i=0; i < paramList.length; i++) {
    PsiParameter parameter=paramList[i];
    myParameters[i]=getRefManager().getParameterReference(parameter,i);
  }
  if (isConstructor() || isAbstract() || isStatic()|| getAccessModifier() == PsiModifier.PRIVATE || ownerClass.isAnonymous() || ownerClass.isInterface()) {
    setCanBeFinal(false);
  }
  if (method.hasModifierProperty(PsiModifier.NATIVE)) {
    updateReturnValueTemplate(null);
    updateThrowsList(null);
  }
  if (getAccessModifier() == PsiModifier.PRIVATE && !(getOwnerClass().getOwner() instanceof RefElement)) {
    setCanBeFinal(false);
  }
  collectUncaughtExceptions(method);
}
