{
  final HttpClient httpClient=getHttpClient();
  if (!isLoginAnonymously())   login(httpClient);
  final GetMethod getMethod=new GetMethod(getFullTasksUrl());
  httpClient.executeMethod(getMethod);
  final String response=getMethod.getResponseBodyAsString(Integer.MAX_VALUE);
  final String taskPatternWithoutPlaceholders=myTaskPattern.replaceAll("\\{.+?\\}","");
  Matcher matcher=Pattern.compile(taskPatternWithoutPlaceholders,Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL| Pattern.UNICODE_CASE| Pattern.CANON_EQ).matcher(response);
  final List<String> placeholders=getPlaceholders(myTaskPattern);
  if (matcher.groupCount() != 2 || !placeholders.contains(ID_PLACEHOLDER) || !placeholders.contains(SUMMARY_PLACEHOLDER)) {
    throw new Exception("Incorrect Task Pattern");
  }
  List<Task> tasks=new ArrayList<Task>();
  while (matcher.find()) {
    final String id=matcher.group(placeholders.indexOf(ID_PLACEHOLDER) + 1);
    final String description=matcher.group(placeholders.indexOf(SUMMARY_PLACEHOLDER) + 1);
    tasks.add(new Task(){
      @NotNull @Override public String getId(){
        return id;
      }
      @NotNull @Override public String getSummary(){
        return description;
      }
      @Nullable @Override public String getDescription(){
        return null;
      }
      @NotNull @Override public Comment[] getComments(){
        return new Comment[0];
      }
      @Nullable @Override public Icon getIcon(){
        return TasksIcons.Other;
      }
      @NotNull @Override public TaskType getType(){
        return TaskType.OTHER;
      }
      @Nullable @Override public Date getUpdated(){
        return null;
      }
      @Nullable @Override public Date getCreated(){
        return null;
      }
      @Override public boolean isClosed(){
        return false;
      }
      @Override public boolean isIssue(){
        return true;
      }
      @Nullable @Override public String getIssueUrl(){
        return null;
      }
    }
);
  }
  return tasks.toArray(new Task[tasks.size()]);
}
