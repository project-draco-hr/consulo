{
  file.getViewProvider().beforeContentsSynchronized();
  final PsiFileImpl fileImpl=(PsiFileImpl)file;
  Project project=fileImpl.getProject();
  final CharTable charTable=fileImpl.getTreeElement().getCharTable();
  final int textLength=file.getTextLength() + lengthShift;
  final FileElement treeFileElement=fileImpl.getTreeElement();
  if (treeFileElement.getElementType() instanceof ITemplateDataElementType || treeFileElement.getFirstChildNode() instanceof ChameleonElement) {
    makeFullParse(treeFileElement,newFileText,textLength,fileImpl);
    return;
  }
  final ASTNode leafAtStart=treeFileElement.findLeafElementAt(startOffset);
  final ASTNode leafAtEnd=treeFileElement.findLeafElementAt(endOffset);
  ASTNode parent=leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart,leafAtEnd) : treeFileElement;
  Language baseLanguage=file.getViewProvider().getBaseLanguage();
  int minErrorLevel=Integer.MAX_VALUE;
  ASTNode bestReparseable=null;
  ASTNode prevReparseable=null;
  boolean theOnlyReparseable=false;
  while (parent != null && !(parent instanceof FileElement)) {
    IElementType elementType=parent.getElementType();
    if (elementType instanceof IChameleonElementType) {
      final TextRange textRange=parent.getTextRange();
      final IChameleonElementType reparseable=(IChameleonElementType)elementType;
      if (reparseable.getLanguage() == baseLanguage) {
        boolean languageChanged=false;
        if (prevReparseable != null) {
          languageChanged=prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();
        }
        CharSequence newTextStr=newFileText.subSequence(textRange.getStartOffset(),textRange.getStartOffset() + textRange.getLength() + lengthShift);
        if (reparseable.isParsable(newTextStr,project)) {
          final ChameleonElement chameleon=(ChameleonElement)Factory.createSingleLeafElement(reparseable,newFileText,textRange.getStartOffset(),textRange.getEndOffset() + lengthShift,charTable,file.getManager(),fileImpl);
          TreeElement reparsed=ChameleonElement.reparse(charTable,reparseable,(CompositeElement)parent.getTreeParent(),chameleon);
          mergeTrees(fileImpl,parent,reparsed);
          return;
        }
        if (reparseable instanceof IErrorCounterChameleonElementType) {
          int currentErrorLevel=((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr,project);
          if (currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR) {
            prevReparseable=parent;
          }
 else           if (Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)) {
            theOnlyReparseable=bestReparseable == null;
            bestReparseable=parent;
            minErrorLevel=currentErrorLevel;
            if (languageChanged)             break;
          }
        }
      }
    }
    parent=parent.getTreeParent();
  }
  if (bestReparseable != null && !theOnlyReparseable) {
    final TextRange textRange=bestReparseable.getTextRange();
    final ChameleonElement chameleon=(ChameleonElement)ASTFactory.leaf(bestReparseable.getElementType(),newFileText,textRange.getStartOffset(),textRange.getEndOffset() + lengthShift,treeFileElement.getCharTable());
    chameleon.putUserData(CharTable.CHAR_TABLE_KEY,treeFileElement.getCharTable());
    chameleon.setTreeParent((CompositeElement)parent);
    bestReparseable.replaceAllChildrenToChildrenOf(chameleon.transform(treeFileElement.getCharTable()).getTreeParent());
  }
 else {
    makeFullParse(parent,newFileText,textLength,fileImpl);
  }
}
