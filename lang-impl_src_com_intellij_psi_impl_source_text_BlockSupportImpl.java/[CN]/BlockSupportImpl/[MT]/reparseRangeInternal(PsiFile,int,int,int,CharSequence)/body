{
  file.getViewProvider().beforeContentsSynchronized();
  final PsiFileImpl fileImpl=(PsiFileImpl)file;
  Project project=fileImpl.getProject();
  final CharTable charTable=fileImpl.getTreeElement().getCharTable();
  final int textLength=file.getTextLength() + lengthShift;
  final FileElement treeFileElement=fileImpl.getTreeElement();
  if (true) {
    makeFullParse(treeFileElement,newFileText,textLength,fileImpl);
    return;
  }
  final ASTNode leafAtStart=treeFileElement.findLeafElementAt(startOffset);
  final ASTNode leafAtEnd=treeFileElement.findLeafElementAt(endOffset);
  ASTNode parent=leafAtStart != null && leafAtEnd != null ? TreeUtil.findCommonParent(leafAtStart,leafAtEnd) : treeFileElement;
  Language baseLanguage=file.getViewProvider().getBaseLanguage();
  int minErrorLevel=Integer.MAX_VALUE;
  ASTNode bestReparseable=null;
  ASTNode prevReparseable=null;
  boolean theOnlyReparseable=false;
  while (parent != null && !(parent instanceof FileElement)) {
    IElementType elementType=parent.getElementType();
    if (elementType instanceof IChameleonElementType) {
      final TextRange textRange=parent.getTextRange();
      final IChameleonElementType reparseable=(IChameleonElementType)elementType;
      if (reparseable.getLanguage() == baseLanguage) {
        boolean languageChanged=false;
        if (prevReparseable != null) {
          languageChanged=prevReparseable.getElementType().getLanguage() != reparseable.getLanguage();
        }
        CharSequence newTextStr=newFileText.subSequence(textRange.getStartOffset(),textRange.getStartOffset() + textRange.getLength() + lengthShift);
        if (reparseable instanceof IErrorCounterChameleonElementType) {
          int currentErrorLevel=((IErrorCounterChameleonElementType)reparseable).getErrorsCount(newTextStr,project);
          if (currentErrorLevel == IErrorCounterChameleonElementType.FATAL_ERROR) {
            prevReparseable=parent;
          }
 else           if (Math.abs(currentErrorLevel) < Math.abs(minErrorLevel)) {
            theOnlyReparseable=bestReparseable == null;
            bestReparseable=parent;
            minErrorLevel=currentErrorLevel;
            if (languageChanged)             break;
          }
        }
      }
    }
    parent=parent.getTreeParent();
  }
  if (bestReparseable != null && !theOnlyReparseable) {
  }
 else {
    makeFullParse(parent,newFileText,textLength,fileImpl);
  }
}
