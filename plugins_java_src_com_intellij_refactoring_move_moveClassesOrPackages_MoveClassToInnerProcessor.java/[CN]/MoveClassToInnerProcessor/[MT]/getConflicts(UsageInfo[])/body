{
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  for (  PsiClass classToMove : myClassesToMove) {
    final PsiClass innerClass=myTargetClass.findInnerClassByName(classToMove.getName(),false);
    if (innerClass != null) {
      conflicts.putValue(innerClass,RefactoringBundle.message("move.to.inner.duplicate.inner.class",CommonRefactoringUtil.htmlEmphasize(myTargetClass.getQualifiedName()),CommonRefactoringUtil.htmlEmphasize(classToMove.getName())));
    }
  }
  for (int i=0; i < myClassesToMove.length; i++) {
    PsiClass classToMove=myClassesToMove[i];
    String classToMoveVisibility=VisibilityUtil.getVisibilityModifier(classToMove.getModifierList());
    String targetClassVisibility=VisibilityUtil.getVisibilityModifier(myTargetClass.getModifierList());
    boolean moveToOtherPackage=!Comparing.equal(mySourcePackage[i],myTargetPackage);
    if (moveToOtherPackage) {
      classToMove.accept(new PackageLocalsUsageCollector(myClassesToMove,new PackageWrapper(myTargetPackage),conflicts));
    }
    ConflictsCollector collector=new ConflictsCollector(classToMove,conflicts);
    if ((moveToOtherPackage && (classToMoveVisibility.equals(PsiModifier.PACKAGE_LOCAL) || targetClassVisibility.equals(PsiModifier.PACKAGE_LOCAL))) || targetClassVisibility.equals(PsiModifier.PRIVATE)) {
      detectInaccessibleClassUsages(usages,collector,mySourceVisibility[i]);
    }
    if (moveToOtherPackage) {
      detectInaccessibleMemberUsages(collector);
    }
  }
  return conflicts;
}
