{
  if (elements.length != 1 || !(elements[0] instanceof PsiMethod))   return;
  final PsiMethod method=((PsiMethod)elements[0]);
  if (!method.hasModifierProperty(PsiModifier.STATIC)) {
    String message="Cannot perform the refactoring\n" + "Method " + method.getName() + " is not static.";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.CONVERT_TO_INSTANCE_METHOD,project);
    return;
  }
  final PsiParameter[] parameters=method.getParameterList().getParameters();
  List<PsiParameter> suitableParameters=new ArrayList<PsiParameter>();
  boolean classTypesFound=false;
  boolean resolvableClassesFound=false;
  boolean classesInProjectFound=false;
  for (int i=0; i < parameters.length; i++) {
    final PsiParameter parameter=parameters[i];
    final PsiType type=parameter.getType();
    if (type instanceof PsiClassType && !((PsiClassType)type).hasParameters()) {
      classTypesFound=true;
      final PsiClass psiClass=((PsiClassType)type).resolve();
      if (psiClass != null && !(psiClass instanceof PsiTypeParameter)) {
        resolvableClassesFound=true;
        final boolean inProject=method.getManager().isInProject(psiClass);
        if (inProject) {
          classesInProjectFound=true;
          suitableParameters.add(parameter);
        }
      }
    }
  }
  if (suitableParameters.isEmpty()) {
    String message=null;
    if (!classTypesFound) {
      message="There are no parameters that have a reference type";
    }
 else     if (!resolvableClassesFound) {
      message="All reference type parametres have unknown types";
    }
 else     if (!classesInProjectFound) {
      message="All reference type parameters have types that are not in project";
    }
    LOG.assertTrue(message != null);
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,"Cannot perform refactoring.\n" + message,HelpID.CONVERT_TO_INSTANCE_METHOD,project);
    return;
  }
  new ConvertToInstanceMethodDialog(method,suitableParameters.toArray(new PsiParameter[suitableParameters.size()])).show();
}
