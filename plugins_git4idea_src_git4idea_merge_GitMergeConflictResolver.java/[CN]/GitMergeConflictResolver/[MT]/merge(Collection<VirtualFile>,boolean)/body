{
  try {
    final Collection<VirtualFile> initiallyUnmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,roots);
    if (initiallyUnmergedFiles.isEmpty()) {
      LOG.info("merge: no unmerged files");
      return mergeDialogInvokedFromNotification ? true : proceedIfNothingToMerge();
    }
 else {
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          final MergeProvider mergeProvider=myReverseMerge ? myVcs.getReverseMergeProvider() : myVcs.getMergeProvider();
          myVcsHelper.showMergeDialog(new ArrayList<VirtualFile>(initiallyUnmergedFiles),mergeProvider,myMergeDialogCustomizer);
        }
      }
);
      final Collection<VirtualFile> unmergedFilesAfterResolve=GitMergeUtil.getUnmergedFiles(myProject,roots);
      if (unmergedFilesAfterResolve.isEmpty()) {
        LOG.info("merge no more unmerged files");
        return mergeDialogInvokedFromNotification ? true : proceedAfterAllMerged();
      }
 else {
        LOG.info("mergeFiles unmerged files remain: " + unmergedFilesAfterResolve);
        if (mergeDialogInvokedFromNotification) {
          GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification("Not all conflicts resolved","You should <a href='resolve'>resolve</a> all conflicts before update. <br>" + myErrorNotificationAdditionalDescription,NotificationType.WARNING,new ResolveNotificationListener(roots)).notify(myProject);
        }
 else {
          notifyUnresolvedRemain(roots);
        }
      }
    }
  }
 catch (  VcsException e) {
    LOG.info("mergeFiles ",e);
    final String description=mergeDialogInvokedFromNotification ? "Be sure to resolve all conflicts before update. <br/>" : "Be sure to resolve all conflicts first. ";
    GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification("Not all conflicts resolved",description + myErrorNotificationAdditionalDescription + "<br/>"+ e.getLocalizedMessage(),NotificationType.ERROR,new ResolveNotificationListener(roots)).notify(myProject);
  }
  return false;
}
