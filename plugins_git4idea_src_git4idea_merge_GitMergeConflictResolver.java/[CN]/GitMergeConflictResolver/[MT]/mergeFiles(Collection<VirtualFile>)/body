{
  try {
    Collection<VirtualFile> unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,roots);
    if (unmergedFiles.isEmpty()) {
      return proceedIfNothingToMerge();
    }
 else {
      final Collection<VirtualFile> finalUnmergedFiles=unmergedFiles;
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          final MergeProvider mergeProvider=myReverseMerge ? myVcs.getReverseMergeProvider() : myVcs.getMergeProvider();
          myVcsHelper.showMergeDialog(new ArrayList<VirtualFile>(finalUnmergedFiles),mergeProvider,myMergeDialogTitle);
        }
      }
);
      unmergedFiles=GitMergeUtil.getUnmergedFiles(myProject,roots);
      if (unmergedFiles.isEmpty()) {
        return proceedAfterAllMerged();
      }
 else {
        Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,myErrorNotificationTitle,"You have to <a href='resolve'>resolve</a> all conflicts first." + myErrorNotificationAdditionalDescription,NotificationType.WARNING,new ResolveNotificationListener(roots)),myProject);
      }
    }
  }
 catch (  VcsException e) {
    Notifications.Bus.notify(new Notification(GitVcs.IMPORTANT_ERROR_NOTIFICATION,myErrorNotificationTitle,"Be sure to resolve all conflicts first. " + myErrorNotificationAdditionalDescription + "<br/>"+ e.getLocalizedMessage(),NotificationType.ERROR),myProject);
  }
  return false;
}
