{
  final VcsFileRevision[] revisionsToLoad=revisionsNeededToBeLoaded(revisions);
  final List<VcsFileRevision> toBeLoaded=new LinkedList<VcsFileRevision>();
  for (  VcsFileRevision revision : revisionsToLoad) {
    if (myCachedContents.containsKey(revision.getRevisionNumber()))     continue;
    toBeLoaded.add(revision);
  }
  if (toBeLoaded.isEmpty())   return;
  final VcsException[] exception=new VcsException[1];
  final Runnable process=new Runnable(){
    public void run(){
      ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
      progressIndicator.pushState();
      Collections.sort(toBeLoaded,new Comparator<VcsFileRevision>(){
        @Override public int compare(        VcsFileRevision o1,        VcsFileRevision o2){
          return o1.getRevisionNumber().compareTo(o2.getRevisionNumber());
        }
      }
);
      progressIndicator.setIndeterminate(false);
      try {
        for (int i=0; i < toBeLoaded.size(); i++) {
          progressIndicator.checkCanceled();
          final VcsFileRevision vcsFileRevision=toBeLoaded.get(i);
          progressIndicator.setText2(VcsBundle.message("progress.text2.loading.revision",vcsFileRevision.getRevisionNumber()));
          progressIndicator.setFraction((double)i / (double)toBeLoaded.size());
          if (!myCachedContents.containsKey(vcsFileRevision.getRevisionNumber())) {
            try {
              vcsFileRevision.loadContent();
            }
 catch (            final VcsException e) {
              exception[0]=new VcsException(e);
              LOG.info(e);
              return;
            }
catch (            ProcessCanceledException ex) {
              return;
            }
catch (            IOException e) {
              exception[0]=new VcsException(e);
              LOG.info(e);
              return;
            }
            String content=null;
            try {
              final byte[] byteContent=vcsFileRevision.getContent();
              if (byteContent != null) {
                content=new String(byteContent,myFile.getCharset().name());
              }
            }
 catch (            IOException e) {
              exception[0]=new VcsException(e);
              LOG.info(e);
              return;
            }
catch (            VcsException e) {
              exception[0]=new VcsException(e);
              LOG.info(e);
              return;
            }
            myCachedContents.put(vcsFileRevision.getRevisionNumber(),content);
          }
        }
      }
  finally {
        progressIndicator.popState();
      }
    }
  }
;
  if (ApplicationManager.getApplication().isDispatchThread()) {
    boolean loaded=ProgressManager.getInstance().runProcessWithProgressSynchronously(CancelHelper.getInstance(myProject).proxyRunnable(process),VcsBundle.message("progress.title.loading.contents"),true,myProject);
    if (!loaded)     throw new VcsException("Load of revision contents canceled");
  }
 else {
    process.run();
  }
  if (exception[0] != null) {
    throw exception[0];
  }
}
