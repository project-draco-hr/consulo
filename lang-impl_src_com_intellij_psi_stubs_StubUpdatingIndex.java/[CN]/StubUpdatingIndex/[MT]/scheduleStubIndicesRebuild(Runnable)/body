{
  final Runnable rebuildRunnable=new Runnable(){
    public void run(){
      final StubIndexImpl stubIndex=(StubIndexImpl)StubIndexImpl.getInstance();
      final Collection<StubIndexKey> allIndexKeys=stubIndex.getAllStubIndexKeys();
      try {
        for (        StubIndexKey key : allIndexKeys) {
          stubIndex.getWriteLock(key).lock();
        }
        stubIndex.clearAllIndices();
        final Map<StubIndexKey,Map<Object,TIntArrayList>> empty=Collections.emptyMap();
        FileBasedIndex.getInstance().processAllValues(INDEX_ID,new FileBasedIndex.AllValuesProcessor<SerializedStubTree>(){
          public void process(          final int inputId,          final SerializedStubTree value){
            final Map<StubIndexKey,Map<Object,TIntArrayList>> stubTree=new StubTree((PsiFileStub)value.getStub()).indexStubTree();
            updateStubIndices(getAffectedIndices(empty,stubTree),inputId,empty,stubTree);
          }
        }
);
      }
  finally {
        for (        StubIndexKey key : allIndexKeys) {
          stubIndex.getWriteLock(key).unlock();
        }
        if (finishCallback != null) {
          finishCallback.run();
        }
      }
    }
  }
;
  final Application application=ApplicationManager.getApplication();
  if (application.isUnitTestMode()) {
    rebuildRunnable.run();
  }
 else {
    SwingUtilities.invokeLater(new Runnable(){
      public void run(){
        new Task.Modal(null,"Updating index",false){
          public void run(          @NotNull final ProgressIndicator indicator){
            rebuildRunnable.run();
          }
        }
.queue();
      }
    }
);
  }
}
