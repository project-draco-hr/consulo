{
  ChangelistConflictTracker.Options options=myManager.getConflictTracker().getOptions();
  if (!options.TRACKING_ENABLED || !options.SHOW_DIALOG) {
    return Collections.emptyList();
  }
  ArrayList<VirtualFile> denied=new ArrayList<VirtualFile>();
  for (  VirtualFile file : files) {
    if (file != null && !myManager.getConflictTracker().isWritingAllowed(file)) {
      denied.add(file);
    }
  }
  if (!denied.isEmpty()) {
    HashSet<ChangeList> changeLists=new HashSet<ChangeList>();
    ArrayList<Change> changes=new ArrayList<Change>();
    for (    VirtualFile file : denied) {
      changeLists.add(myManager.getChangeList(file));
      changes.add(myManager.getChange(file));
    }
    ChangelistConflictDialog dialog;
    final int savedEventCount=IdeEventQueue.getInstance().getEventCount();
    do {
      dialog=new ChangelistConflictDialog(myProject,new ArrayList<ChangeList>(changeLists),denied);
      dialog.show();
    }
 while (dialog.isOK() && !dialog.getResolution().resolveConflict(myProject,changes));
    IdeEventQueue.getInstance().setEventCount(savedEventCount);
    if (dialog.isOK()) {
      options.LAST_RESOLUTION=dialog.getResolution();
      return Collections.emptyList();
    }
  }
  return denied;
}
