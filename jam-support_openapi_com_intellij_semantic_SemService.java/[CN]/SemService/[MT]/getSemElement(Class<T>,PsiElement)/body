{
  final ConcurrentMap<Class,SemElement> map=myCache.get(psi);
  final T cached=(T)map.get(c);
  if (cached != null) {
    return cached;
  }
  final Collection<NullableFunction<PsiElement,? extends SemElement>> producers=myProducers.get(c);
  if (producers.isEmpty()) {
    return null;
  }
  for (  final NullableFunction<PsiElement,? extends SemElement> producer : producers) {
    final SemElement element=producer.fun(psi);
    if (element != null) {
      return (T)ConcurrencyUtil.cacheOrGet(map,c,element);
    }
  }
  return null;
}
