{
  final ConcurrentMap<SemKey,SemElement> map=myCache.get(psi);
  T cached=(T)map.get(c);
  if (cached != null) {
    return cached;
  }
  List<SemKey> inheritors=new ArrayList<SemKey>();
  for (  final SemKey key : myProducers.keySet()) {
    if (key.isKindOf(c)) {
      inheritors.add(key);
      cached=(T)map.get(key);
      if (cached != null) {
        return (T)ConcurrencyUtil.cacheOrGet(map,c,cached);
      }
    }
  }
  for (  final SemKey key : inheritors) {
    final Collection<NullableFunction<PsiElement,? extends SemElement>> producers=myProducers.get(key);
    if (!producers.isEmpty()) {
      for (      final NullableFunction<PsiElement,? extends SemElement> producer : producers) {
        final SemElement element=producer.fun(psi);
        if (element != null) {
          return (T)ConcurrencyUtil.cacheOrGet(map,c,element);
        }
      }
    }
  }
  return null;
}
