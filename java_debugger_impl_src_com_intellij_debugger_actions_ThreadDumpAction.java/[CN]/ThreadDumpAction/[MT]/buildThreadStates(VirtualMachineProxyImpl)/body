{
  final List<ThreadReference> threads=vmProxy.getVirtualMachine().allThreads();
  final List<ThreadState> result=new ArrayList<ThreadState>();
  final Map<String,ThreadState> nameToThreadMap=new HashMap<String,ThreadState>();
  final Map<String,String> waitingMap=new HashMap<String,String>();
  for (  ThreadReference threadReference : threads) {
    final StringBuilder buffer=new StringBuilder();
    boolean hasEmptyStack=true;
    final int threadStatus=threadReference.status();
    if (threadStatus == ThreadReference.THREAD_STATUS_ZOMBIE) {
      continue;
    }
    final String threadName=threadName(threadReference);
    final ThreadState threadState=new ThreadState(threadName,threadStatusToState(threadStatus));
    nameToThreadMap.put(threadName,threadState);
    result.add(threadState);
    threadState.setJavaThreadState(threadStatusToJavaThreadState(threadStatus));
    buffer.append("\"").append(threadName).append("\"");
    ReferenceType referenceType=threadReference.referenceType();
    if (referenceType != null) {
      Field daemon=referenceType.fieldByName("daemon");
      if (daemon != null) {
        Value value=threadReference.getValue(daemon);
        if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {
          buffer.append(" ").append(DebuggerBundle.message("threads.export.attribute.label.daemon"));
          threadState.setDaemon(true);
        }
      }
      Field priority=referenceType.fieldByName("priority");
      if (priority != null) {
        Value value=threadReference.getValue(priority);
        if (value instanceof IntegerValue) {
          buffer.append(" ").append(DebuggerBundle.message("threads.export.attribute.label.priority",((IntegerValue)value).intValue()));
        }
      }
      Field tid=referenceType.fieldByName("tid");
      if (tid != null) {
        Value value=threadReference.getValue(tid);
        if (value instanceof LongValue) {
          buffer.append(" ").append(DebuggerBundle.message("threads.export.attribute.label.tid",Long.toHexString(((LongValue)value).longValue())));
          buffer.append(" nid=NA");
        }
      }
    }
    final String state=threadState.getState();
    if (state != null) {
      buffer.append(" ").append(state);
    }
    buffer.append("\n  java.lang.Thread.State: ").append(threadState.getJavaThreadState());
    try {
      if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {
        List<ObjectReference> list=threadReference.ownedMonitors();
        for (        ObjectReference reference : list) {
          if (!vmProxy.canGetMonitorFrameInfo()) {
            buffer.append("\n\t ").append(renderLockedObject(reference));
          }
          final List<ThreadReference> waiting=reference.waitingThreads();
          for (          ThreadReference thread : waiting) {
            final String waitingThreadName=threadName(thread);
            waitingMap.put(waitingThreadName,threadName);
            buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.label.blocks.thread",waitingThreadName));
          }
        }
      }
      ObjectReference waitedMonitor=vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;
      if (waitedMonitor != null) {
        if (vmProxy.canGetMonitorInfo()) {
          ThreadReference waitedMonitorOwner=waitedMonitor.owningThread();
          if (waitedMonitorOwner != null) {
            final String monitorOwningThreadName=threadName(waitedMonitorOwner);
            waitingMap.put(threadName,monitorOwningThreadName);
            buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.label.waiting.for.thread",monitorOwningThreadName,renderObject(waitedMonitor)));
          }
        }
      }
      final List<StackFrame> frames=threadReference.frames();
      hasEmptyStack=frames.size() == 0;
      final TIntObjectHashMap<List<ObjectReference>> lockedAt=new TIntObjectHashMap<List<ObjectReference>>();
      if (vmProxy.canGetMonitorFrameInfo()) {
        for (        MonitorInfo info : threadReference.ownedMonitorsAndFrames()) {
          final int stackDepth=info.stackDepth();
          List<ObjectReference> monitors;
          if ((monitors=lockedAt.get(stackDepth)) == null) {
            lockedAt.put(stackDepth,monitors=new SmartList<ObjectReference>());
          }
          monitors.add(info.monitor());
        }
      }
      for (int i=0, framesSize=frames.size(); i < framesSize; i++) {
        final StackFrame stackFrame=frames.get(i);
        final Location location=stackFrame.location();
        buffer.append("\n\t  ").append(renderLocation(location));
        final List<ObjectReference> monitors=lockedAt.get(i);
        if (monitors != null) {
          for (          ObjectReference monitor : monitors) {
            buffer.append("\n\t  - ").append(renderLockedObject(monitor));
          }
        }
      }
    }
 catch (    IncompatibleThreadStateException e) {
      buffer.append("\n\t ").append(DebuggerBundle.message("threads.export.attribute.error.incompatible.state"));
    }
    threadState.setStackTrace(buffer.toString(),hasEmptyStack);
    ThreadDumpParser.inferThreadStateDetail(threadState);
  }
  for (  String waiting : waitingMap.keySet()) {
    final ThreadState waitingThread=nameToThreadMap.get(waiting);
    final ThreadState awaitedThread=nameToThreadMap.get(waitingMap.get(waiting));
    awaitedThread.addWaitingThread(waitingThread);
  }
  for (  ThreadState thread : result) {
    for (    ThreadState awaitingThread : thread.getAwaitingThreads()) {
      if (awaitingThread.isAwaitedBy(thread)) {
        thread.addDeadlockedThread(awaitingThread);
        awaitingThread.addDeadlockedThread(thread);
      }
    }
  }
  ThreadDumpParser.sortThreads(result);
  return result;
}
