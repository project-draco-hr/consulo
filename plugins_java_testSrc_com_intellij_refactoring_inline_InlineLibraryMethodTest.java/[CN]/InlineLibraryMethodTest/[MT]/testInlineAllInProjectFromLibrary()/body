{
  configureByText(JavaFileType.INSTANCE,"package mycompany;\n" + "public class File {\n" + " public static File createTempFile(String pr, String postfix){return createTempFile(pr, postfix, null);}\n"+ " public static File createTempFile(String pr, String postfix, String base){return new File();}\n"+ "}");
  @NonNls String fileName="/refactoring/inlineMethod/" + getTestName(false) + ".java";
  configureByFile(fileName);
  PsiClass fileClass=getJavaFacade().findClass("mycompany.File");
  assertNotNull(fileClass);
  final PsiFile file=fileClass.getContainingFile();
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    public void run(){
      try {
        ((VirtualFileSystemEntry)file.getVirtualFile()).setWritable(false);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
);
  PsiElement element=null;
  PsiMethod[] createTempFiles=fileClass.findMethodsByName("createTempFile",false);
  for (  PsiMethod createTempFile : createTempFiles) {
    if (createTempFile.getParameterList().getParametersCount() == 2) {
      element=createTempFile;
      break;
    }
  }
  assertNotNull(element);
  PsiMethod method=(PsiMethod)element;
  final boolean condition=InlineMethodProcessor.checkBadReturns(method) && !InlineUtil.allUsagesAreTailCalls(method);
  assertFalse("Bad returns found",condition);
  final InlineMethodProcessor processor=new InlineMethodProcessor(getProject(),method,null,myEditor,false);
  processor.run();
  checkResultByFile(fileName + ".after");
}
