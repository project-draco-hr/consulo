{
  Object value=expression.getValue();
  if (!(value instanceof String))   return;
  String stringValue=(String)value;
  if (stringValue.trim().length() == 0) {
    return;
  }
  Set<PsiModifierListOwner> nonNlsTargets=new THashSet<PsiModifierListOwner>();
  if (canBeI18ned(expression,stringValue,nonNlsTargets)) {
    final String description=CodeInsightBundle.message("inspection.i18n.message.general.with.value","#ref");
    List<LocalQuickFix> fixes=new ArrayList<LocalQuickFix>();
    if (I18nizeConcatenationQuickFix.getEnclosingLiteralConcatenation(expression) != null) {
      fixes.add(I18N_CONCATENATION_QUICK_FIX);
    }
    fixes.add(I18N_QUICK_FIX);
    if (!isNotConstantFieldInitializer(expression)) {
      fixes.add(createIntroduceConstantFix());
    }
    final Project project=expression.getManager().getProject();
    final JavaPsiFacade facade=JavaPsiFacade.getInstance(project);
    if (PsiUtil.getLanguageLevel(expression).hasEnumKeywordAndAutoboxing()) {
      for (      PsiModifierListOwner element : nonNlsTargets) {
        if (!AnnotationUtil.isAnnotated(element,AnnotationUtil.NLS,true)) {
          if (!element.getManager().isInProject(element) || facade.findClass(AnnotationUtil.NON_NLS,element.getResolveScope()) != null) {
            fixes.add(new AddAnnotationFix(AnnotationUtil.NON_NLS,element));
          }
        }
      }
    }
    LocalQuickFix[] farr=fixes.toArray(new LocalQuickFix[fixes.size()]);
    final ProblemDescriptor problem=myManager.createProblemDescriptor(expression,description,myOnTheFly,farr,ProblemHighlightType.GENERIC_ERROR_OR_WARNING);
    myProblems.add(problem);
  }
}
