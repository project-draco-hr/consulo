{
  LOG.assertTrue(!Thread.holdsLock(PsiLock.LOCK),"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.");
  final ProgressIndicator progress=ProgressManager.getInstance().getProgressIndicator();
  if (progress != null) {
    progress.pushState();
    progress.setText(PsiBundle.message("psi.scanning.files.progress"));
  }
  myManager.startBatchFilesProcessingMode();
  try {
    List<String> words=StringUtil.getWordsIn(searcher.getPattern());
    if (words.isEmpty())     return true;
    Set<PsiFile> fileSet=new THashSet<PsiFile>();
    Set<PsiFile> copy=new THashSet<PsiFile>();
    final Application application=ApplicationManager.getApplication();
    for (    final String word : words) {
      PsiFile[] psiFiles=application.runReadAction(new Computable<PsiFile[]>(){
        public PsiFile[] compute(){
          return myManager.getCacheManager().getFilesWithWord(word,searchContext,scope,caseSensitively);
        }
      }
);
      if (fileSet.isEmpty()) {
        fileSet.addAll(Arrays.asList(psiFiles));
      }
 else {
        for (        PsiFile psiFile : psiFiles) {
          if (fileSet.contains(psiFile)) {
            copy.add(psiFile);
          }
        }
        Set<PsiFile> tmp=copy;
        copy=fileSet;
        fileSet=tmp;
        copy.clear();
      }
      if (fileSet.isEmpty())       break;
    }
    if (progress != null) {
      progress.setText(PsiBundle.message("psi.search.for.word.progress",searcher.getPattern()));
    }
    final AtomicInteger counter=new AtomicInteger(0);
    final AtomicBoolean canceled=new AtomicBoolean(false);
    final AtomicBoolean pceThrown=new AtomicBoolean(false);
    final int size=fileSet.size();
    boolean completed=JobUtil.invokeConcurrentlyUnderMyProgress(new ArrayList<PsiFile>(fileSet),new Processor<PsiFile>(){
      public boolean process(      final PsiFile file){
        if (file instanceof PsiBinaryFile)         return true;
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          public void run(){
            try {
              PsiElement[] psiRoots=file.getPsiRoots();
              Set<PsiElement> processed=new HashSet<PsiElement>(psiRoots.length * 2,(float)0.5);
              for (              PsiElement psiRoot : psiRoots) {
                ProgressManager.checkCanceled();
                if (!processed.add(psiRoot))                 continue;
                if (!LowLevelSearchUtil.processElementsContainingWordInElement(processor,psiRoot,searcher,false)) {
                  canceled.set(true);
                  return;
                }
              }
              if (progress != null) {
                double fraction=(double)counter.incrementAndGet() / size;
                progress.setFraction(fraction);
              }
              myManager.dropResolveCaches();
            }
 catch (            ProcessCanceledException e) {
              canceled.set(true);
              pceThrown.set(true);
            }
          }
        }
);
        return !canceled.get();
      }
    }
,"Process usages in files");
    if (pceThrown.get()) {
      throw new ProcessCanceledException();
    }
    return completed;
  }
  finally {
    if (progress != null) {
      progress.popState();
    }
    myManager.finishBatchFilesProcessingMode();
  }
}
