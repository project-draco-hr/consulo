{
  if (myUpdateProgress.isCanceled())   return;
  log(myUpdateProgress,myPass,"Started. ");
  for (  ScheduledPass successor : mySuccessorsOnSubmit) {
    int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
    if (predecessorsToRun == 0) {
      submit(successor);
    }
  }
  ((ProgressManagerImpl)ProgressManager.getInstance()).executeProcessUnderProgress(new Runnable(){
    @Override public void run(){
      boolean success=ApplicationManagerEx.getApplicationEx().tryRunReadAction(new Runnable(){
        @Override public void run(){
          try {
            if (DumbService.getInstance(myProject).isDumb() && !DumbService.isDumbAware(myPass)) {
              return;
            }
            if (!myUpdateProgress.isCanceled()) {
              myPass.collectInformation(myUpdateProgress);
            }
          }
 catch (          ProcessCanceledException e) {
            log(myUpdateProgress,myPass,"Canceled ");
            myUpdateProgress.cancel(e);
          }
catch (          RuntimeException e) {
            myUpdateProgress.cancel(e);
            LOG.error(e);
            throw e;
          }
catch (          Error e) {
            myUpdateProgress.cancel(e);
            LOG.error(e);
            throw e;
          }
        }
      }
);
      if (!success) {
        myUpdateProgress.cancel();
      }
    }
  }
,myUpdateProgress);
  log(myUpdateProgress,myPass,"Finished. ");
  if (!myUpdateProgress.isCanceled()) {
    applyInformationToEditors(myFileEditors,myPass,myUpdateProgress,myThreadsToStartCountdown);
    for (    ScheduledPass successor : mySuccessorsOnCompletion) {
      int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
      if (predecessorsToRun == 0) {
        submit(successor);
      }
    }
  }
}
