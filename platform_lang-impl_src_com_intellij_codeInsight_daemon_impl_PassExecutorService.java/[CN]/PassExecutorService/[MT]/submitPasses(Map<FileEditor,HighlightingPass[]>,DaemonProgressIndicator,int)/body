{
  if (isDisposed())   return;
  int id=1;
  Map<Pair<Document,Integer>,ScheduledPass> toBeSubmitted=new THashMap<Pair<Document,Integer>,ScheduledPass>(passesMap.size());
  Map<Document,List<FileEditor>> documentToEditors=new HashMap<Document,List<FileEditor>>();
  Map<FileEditor,List<TextEditorHighlightingPass>> textPasses=new HashMap<FileEditor,List<TextEditorHighlightingPass>>(passesMap.size());
  for (  Map.Entry<FileEditor,HighlightingPass[]> entry : passesMap.entrySet()) {
    FileEditor fileEditor=entry.getKey();
    HighlightingPass[] passes=entry.getValue();
    Document document=null;
    if (fileEditor instanceof TextEditor) {
      Editor editor=((TextEditor)fileEditor).getEditor();
      LOG.assertTrue(!(editor instanceof EditorWindow));
      document=editor.getDocument();
    }
    for (int i=0; i < passes.length; i++) {
      final HighlightingPass pass=passes[i];
      TextEditorHighlightingPass textEditorHighlightingPass;
      if (pass instanceof TextEditorHighlightingPass) {
        textEditorHighlightingPass=(TextEditorHighlightingPass)pass;
      }
 else {
        textEditorHighlightingPass=new TextEditorHighlightingPass(myProject,document,true){
          @Override public void doCollectInformation(          ProgressIndicator progress){
            pass.collectInformation(progress);
          }
          @Override public void doApplyInformationToEditor(){
            pass.applyInformationToEditor();
          }
        }
;
        textEditorHighlightingPass.setId(id++);
        if (i > 0) {
          textEditorHighlightingPass.setCompletionPredecessorIds(new int[]{i - 1});
        }
      }
      document=textEditorHighlightingPass.getDocument();
      List<TextEditorHighlightingPass> textPassesForDocument=textPasses.get(fileEditor);
      if (textPassesForDocument == null) {
        textPassesForDocument=new SmartList<TextEditorHighlightingPass>();
        textPasses.put(fileEditor,textPassesForDocument);
      }
      textPassesForDocument.add(textEditorHighlightingPass);
      List<FileEditor> editors=documentToEditors.get(document);
      if (editors == null) {
        editors=new SmartList<FileEditor>();
        documentToEditors.put(document,editors);
      }
      if (!editors.contains(fileEditor))       editors.add(fileEditor);
    }
  }
  List<ScheduledPass> freePasses=new ArrayList<ScheduledPass>(documentToEditors.size() * 5);
  List<ScheduledPass> dependentPasses=new ArrayList<ScheduledPass>(documentToEditors.size() * 10);
  final AtomicInteger threadsToStartCountdown=new AtomicInteger(0);
  for (  List<FileEditor> fileEditors : documentToEditors.values()) {
    List<TextEditorHighlightingPass> passes=textPasses.get(fileEditors.get(0));
    threadsToStartCountdown.addAndGet(passes.size());
    ContainerUtil.quickSort(passes,new Comparator<TextEditorHighlightingPass>(){
      @Override public int compare(      final TextEditorHighlightingPass o1,      final TextEditorHighlightingPass o2){
        return o1.getId() - o2.getId();
      }
    }
);
    int passId=-1;
    TextEditorHighlightingPass currentPass=null;
    for (int i=0; i <= passes.size(); i++) {
      int newId=-1;
      if (i < passes.size()) {
        currentPass=passes.get(i);
        newId=currentPass.getId();
      }
      if (newId != passId) {
        createScheduledPass(fileEditors,currentPass,toBeSubmitted,passes,freePasses,dependentPasses,updateProgress,threadsToStartCountdown,jobPriority);
        passId=newId;
      }
    }
  }
  log(updateProgress,null,"---------------------starting------------------------ " + threadsToStartCountdown.get(),freePasses);
  for (  ScheduledPass dependentPass : dependentPasses) {
    mySubmittedPasses.put(dependentPass,JobImpl.NULL_JOB);
  }
  for (  ScheduledPass freePass : freePasses) {
    submit(freePass);
  }
}
