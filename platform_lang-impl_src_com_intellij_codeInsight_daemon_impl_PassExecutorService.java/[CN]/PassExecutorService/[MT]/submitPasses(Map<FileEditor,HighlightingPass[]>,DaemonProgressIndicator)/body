{
  if (isDisposed())   return;
  MultiMap<Document,FileEditor> documentToEditors=MultiMap.createSet();
  MultiMap<FileEditor,TextEditorHighlightingPass> documentBoundPasses=MultiMap.createSmartList();
  MultiMap<FileEditor,EditorBoundHighlightingPass> editorBoundPasses=MultiMap.createSmartList();
  for (  Map.Entry<FileEditor,HighlightingPass[]> entry : passesMap.entrySet()) {
    FileEditor fileEditor=entry.getKey();
    HighlightingPass[] passes=entry.getValue();
    Document document=null;
    if (fileEditor instanceof TextEditor) {
      Editor editor=((TextEditor)fileEditor).getEditor();
      LOG.assertTrue(!(editor instanceof EditorWindow));
      document=editor.getDocument();
    }
    int prevId=0;
    for (    final HighlightingPass pass : passes) {
      if (pass instanceof EditorBoundHighlightingPass) {
        EditorBoundHighlightingPass editorPass=(EditorBoundHighlightingPass)pass;
        editorPass.setId(nextPassId.incrementAndGet());
        editorBoundPasses.putValue(fileEditor,editorPass);
      }
 else {
        TextEditorHighlightingPass textEditorHighlightingPass=convertToTextHighlightingPass(pass,document,nextPassId,prevId);
        document=textEditorHighlightingPass.getDocument();
        documentBoundPasses.putValue(fileEditor,textEditorHighlightingPass);
        if (document != null) {
          documentToEditors.putValue(document,fileEditor);
        }
        prevId=textEditorHighlightingPass.getId();
      }
    }
  }
  List<ScheduledPass> freePasses=new ArrayList<ScheduledPass>(documentToEditors.size() * 5);
  List<ScheduledPass> dependentPasses=new ArrayList<ScheduledPass>(documentToEditors.size() * 10);
  Map<Pair<FileEditor,Integer>,ScheduledPass> toBeSubmitted=new THashMap<Pair<FileEditor,Integer>,ScheduledPass>(passesMap.size());
  final AtomicInteger threadsToStartCountdown=new AtomicInteger(0);
  for (  Map.Entry<Document,Collection<FileEditor>> entry : documentToEditors.entrySet()) {
    Collection<FileEditor> fileEditors=entry.getValue();
    Document document=entry.getKey();
    FileEditor preferredFileEditor=getPreferredFileEditor(document,fileEditors);
    List<TextEditorHighlightingPass> passes=(List<TextEditorHighlightingPass>)documentBoundPasses.get(preferredFileEditor);
    if (passes.isEmpty()) {
      continue;
    }
    sortById(passes);
    for (    TextEditorHighlightingPass currentPass : passes) {
      createScheduledPass(preferredFileEditor,currentPass,toBeSubmitted,passes,freePasses,dependentPasses,updateProgress,threadsToStartCountdown);
    }
  }
  for (  Map.Entry<FileEditor,Collection<EditorBoundHighlightingPass>> entry : editorBoundPasses.entrySet()) {
    FileEditor fileEditor=entry.getKey();
    Collection<EditorBoundHighlightingPass> createdEditorBoundPasses=entry.getValue();
    List<TextEditorHighlightingPass> createdDocumentBoundPasses=(List<TextEditorHighlightingPass>)documentBoundPasses.get(fileEditor);
    List<TextEditorHighlightingPass> allCreatedPasses=new ArrayList<TextEditorHighlightingPass>(createdDocumentBoundPasses);
    allCreatedPasses.addAll(createdEditorBoundPasses);
    for (    EditorBoundHighlightingPass pass : createdEditorBoundPasses) {
      createScheduledPass(fileEditor,pass,toBeSubmitted,allCreatedPasses,freePasses,dependentPasses,updateProgress,threadsToStartCountdown);
    }
  }
  if (CHECK_CONSISTENCY) {
    assertConsistency(freePasses,toBeSubmitted,threadsToStartCountdown);
  }
  log(updateProgress,null,"---------------------starting------------------------ " + threadsToStartCountdown.get(),freePasses);
  for (  ScheduledPass dependentPass : dependentPasses) {
    mySubmittedPasses.put(dependentPass,Job.NULL_JOB);
  }
  for (  ScheduledPass freePass : freePasses) {
    submit(freePass);
  }
}
