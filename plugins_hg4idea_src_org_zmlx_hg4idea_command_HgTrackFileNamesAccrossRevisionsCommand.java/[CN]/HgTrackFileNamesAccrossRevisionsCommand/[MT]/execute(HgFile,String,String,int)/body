{
  if (hgFile == null || hgFile.getRepo() == null) {
    return null;
  }
  HgCommandExecutor hgCommandExecutor=new HgCommandExecutor(project);
  HgCommandResult result=execute(hgCommandExecutor,hgFile.getRepo(),limit,hgFile,currentRevision,givenRevision);
  String output=result.getRawOutput();
  String[] changeSets=output.split(HgChangesetUtil.CHANGESET_SEPARATOR);
  String currentFileName=hgFile.getRelativePath();
  currentFileName=currentFileName.replaceAll("\\\\","/");
  for (  String line : changeSets) {
    try {
      String[] attributes=line.split(HgChangesetUtil.ITEM_SEPARATOR);
      if (attributes.length != TEMPLATE_ITEMS.length) {
        LOG.debug("Wrong format. Skipping line " + line);
        continue;
      }
      String revisionString=attributes[REVISION_INDEX];
      if (revisionString.equals(givenRevision)) {
        return currentFileName;
      }
      Set<String> filesDeleted;
      Map<String,String> copies;
      filesDeleted=parseFileList(attributes[FILES_DELETED_INDEX]);
      copies=parseCopiesFileList(attributes[FILES_COPIED_INDEX]);
      Iterator<String> keys=copies.keySet().iterator();
      while (keys.hasNext()) {
        String s=keys.next();
        if (!filesDeleted.contains(s)) {
          keys.remove();
        }
      }
      if (copies.containsValue(currentFileName)) {
        for (        String key : copies.keySet()) {
          if (copies.get(key).equals(currentFileName)) {
            currentFileName=key;
            break;
          }
        }
      }
    }
 catch (    NumberFormatException e) {
      LOG.warn("Error parsing rev in line " + line);
    }
  }
  return null;
}
