{
  for (int i=1; i < myProduction.size() - 1; i++) {
    final ProductionMarker item=myProduction.get(i);
    if (item instanceof StartMarker && ((StartMarker)item).myDoneMarker == null) {
      LOG.error(UNBALANCED_MESSAGE);
    }
    final int prevProductionLexIndex=myProduction.get(i - 1).myLexemeIndex;
    int idx=item.myLexemeIndex;
    while (idx > prevProductionLexIndex && whitespaceOrComment(myLexTypes[idx - 1]))     idx--;
    final int wsStartIndex=idx;
    int wsEndIndex=item.myLexemeIndex;
    while (wsEndIndex < myLexemeCount && whitespaceOrComment(myLexTypes[wsEndIndex]))     wsEndIndex++;
    final List<IElementType> wsTokens=CollectionFactory.arrayList(myLexTypes,wsStartIndex,wsEndIndex);
    final boolean atEnd=wsStartIndex == 0 || wsEndIndex == myLexemeCount;
    final WhitespacesAndCommentsBinder.TokenTextGetter getter=new WhitespacesAndCommentsBinder.TokenTextGetter(){
      @Override public CharSequence get(      final int i){
        return myText.subSequence(myLexStarts[wsStartIndex + i],myLexStarts[wsStartIndex + i + 1]);
      }
    }
;
    item.myLexemeIndex=wsStartIndex + item.myEdgeTokenBinder.getEdgePosition(wsTokens,atEnd,getter);
  }
}
