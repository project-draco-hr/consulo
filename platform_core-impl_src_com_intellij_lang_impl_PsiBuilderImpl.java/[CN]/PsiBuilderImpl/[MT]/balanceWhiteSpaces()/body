{
  RelativeTokenTypesView wsTokens=new RelativeTokenTypesView();
  RelativeTokenTextView tokenTextGetter=new RelativeTokenTextView();
  int lastIndex=0;
  for (int i=1, size=myProduction.size() - 1; i < size; i++) {
    ProductionMarker item=myProduction.get(i);
    if (item instanceof StartMarker) {
      assertMarkersBalanced(((StartMarker)item).myDoneMarker != null,item);
    }
    boolean recursive=item.myEdgeTokenBinder instanceof WhitespacesAndCommentsBinder.RecursiveBinder;
    int prevProductionLexIndex=recursive ? 0 : myProduction.get(i - 1).myLexemeIndex;
    int wsStartIndex=Math.max(item.myLexemeIndex,lastIndex);
    while (wsStartIndex > prevProductionLexIndex && whitespaceOrComment(myLexTypes[wsStartIndex - 1]))     wsStartIndex--;
    int wsEndIndex=item.myLexemeIndex;
    while (wsEndIndex < myLexemeCount && whitespaceOrComment(myLexTypes[wsEndIndex]))     wsEndIndex++;
    if (wsStartIndex != wsEndIndex) {
      wsTokens.configure(wsStartIndex,wsEndIndex);
      tokenTextGetter.configure(wsStartIndex);
      boolean atEnd=wsStartIndex == 0 || wsEndIndex == myLexemeCount;
      item.myLexemeIndex=wsStartIndex + item.myEdgeTokenBinder.getEdgePosition(wsTokens,atEnd,tokenTextGetter);
      if (recursive) {
        for (int k=i - 1; k > 1; k--) {
          ProductionMarker prev=myProduction.get(k);
          if (prev.myLexemeIndex >= item.myLexemeIndex) {
            prev.myLexemeIndex=item.myLexemeIndex;
          }
 else {
            break;
          }
        }
      }
    }
 else     if (item.myLexemeIndex < wsStartIndex) {
      item.myLexemeIndex=wsStartIndex;
    }
    lastIndex=item.myLexemeIndex;
  }
}
