{
  if (myProduction.isEmpty()) {
    LOG.error("Parser produced no markers. Text:\n" + myText);
  }
  StartMarker rootMarker=(StartMarker)myProduction.get(0);
  if (rootMarker.myFirstChild != null)   return rootMarker;
  myTokenTypeChecked=true;
  balanceWhiteSpaces();
  rootMarker.myParent=rootMarker.myFirstChild=rootMarker.myLastChild=rootMarker.myNext=null;
  StartMarker curNode=rootMarker;
  final Stack<StartMarker> nodes=ContainerUtil.newStack();
  nodes.push(rootMarker);
  int lastErrorIndex=-1;
  int maxDepth=0;
  int curDepth=0;
  for (int i=1; i < myProduction.size(); i++) {
    final ProductionMarker item=myProduction.get(i);
    if (curNode == null)     LOG.error("Unexpected end of the production");
    item.myParent=curNode;
    if (item instanceof StartMarker) {
      final StartMarker marker=(StartMarker)item;
      marker.myFirstChild=marker.myLastChild=marker.myNext=null;
      curNode.addChild(marker);
      nodes.push(curNode);
      curNode=marker;
      curDepth++;
      if (curDepth > maxDepth)       maxDepth=curDepth;
    }
 else     if (item instanceof DoneMarker) {
      assertMarkersBalanced(((DoneMarker)item).myStart == curNode,item);
      curNode=nodes.pop();
      curDepth--;
    }
 else     if (item instanceof ErrorItem) {
      int curToken=item.myLexemeIndex;
      if (curToken == lastErrorIndex)       continue;
      lastErrorIndex=curToken;
      curNode.addChild(item);
    }
  }
  if (myCurrentLexeme < myLexemeCount) {
    final List<IElementType> missed=ContainerUtil.newArrayList(myLexTypes,myCurrentLexeme,myLexemeCount);
    LOG.error("Tokens " + missed + " were not inserted into the tree. "+ (myFile != null ? myFile.getLanguage() + ", " : "")+ "Text:\n"+ myText);
  }
  if (rootMarker.myDoneMarker.myLexemeIndex < myLexemeCount) {
    final List<IElementType> missed=ContainerUtil.newArrayList(myLexTypes,rootMarker.myDoneMarker.myLexemeIndex,myLexemeCount);
    LOG.error("Tokens " + missed + " are outside of root element \""+ rootMarker.myType+ "\". Text:\n"+ myText);
  }
  if (myLexStarts.length <= myCurrentLexeme + 1) {
    resizeLexemes(myCurrentLexeme + 1);
  }
  myLexStarts[myCurrentLexeme]=myText.length();
  myLexStarts[myCurrentLexeme + 1]=0;
  myLexTypes[myCurrentLexeme]=null;
  assertMarkersBalanced(curNode == rootMarker,curNode);
  checkTreeDepth(maxDepth,rootMarker.getTokenType() instanceof IFileElementType);
  clearCachedTokenType();
  return rootMarker;
}
