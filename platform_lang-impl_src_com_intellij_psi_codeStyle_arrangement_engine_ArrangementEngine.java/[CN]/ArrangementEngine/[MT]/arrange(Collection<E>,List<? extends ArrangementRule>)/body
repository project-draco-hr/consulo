{
  List<E> arranged=new ArrayList<E>();
  Set<E> unprocessed=new LinkedHashSet<E>();
  List<Pair<Set<ArrangementEntry>,E>> dependent=new ArrayList<Pair<Set<ArrangementEntry>,E>>();
  for (  E entry : entries) {
    List<? extends ArrangementEntry> dependencies=entry.getDependencies();
    if (dependencies == null) {
      unprocessed.add(entry);
    }
 else {
      if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) {
        arranged.add(entry);
      }
 else {
        Set<ArrangementEntry> first=new HashSet<ArrangementEntry>(dependencies);
        dependent.add(Pair.create(first,entry));
      }
    }
  }
  Set<E> matched=new HashSet<E>();
  for (  ArrangementRule rule : rules) {
    matched.clear();
    for (    E entry : unprocessed) {
      if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) {
        arranged.add(entry);
        matched.add(entry);
      }
    }
    unprocessed.removeAll(matched);
  }
  arranged.addAll(unprocessed);
  for (int i=0; i < arranged.size() && !dependent.isEmpty(); i++) {
    E e=arranged.get(i);
    for (Iterator<Pair<Set<ArrangementEntry>,E>> iterator=dependent.iterator(); iterator.hasNext(); ) {
      Pair<Set<ArrangementEntry>,E> pair=iterator.next();
      pair.first.remove(e);
      if (pair.first.isEmpty()) {
        iterator.remove();
        arranged.add(i + 1,pair.second);
        i++;
      }
    }
  }
  return arranged;
}
