{
  List<E> arranged=ContainerUtilRt.newArrayList();
  Set<E> unprocessed=ContainerUtilRt.newLinkedHashSet();
  List<Pair<Set<ArrangementEntry>,E>> dependent=ContainerUtilRt.newArrayList();
  for (  E entry : entries) {
    List<? extends ArrangementEntry> dependencies=entry.getDependencies();
    if (dependencies == null) {
      unprocessed.add(entry);
    }
 else {
      if (dependencies.size() == 1 && dependencies.get(0) == entry.getParent()) {
        arranged.add(entry);
      }
 else {
        Set<ArrangementEntry> first=new HashSet<ArrangementEntry>(dependencies);
        dependent.add(Pair.create(first,entry));
      }
    }
  }
  Set<E> matched=new HashSet<E>();
  MultiMap<ArrangementMatchRule,E> elementsByRule=new MultiMap<ArrangementMatchRule,E>();
  for (  ArrangementMatchRule rule : rulesByPriority) {
    matched.clear();
    for (    E entry : unprocessed) {
      if (entry.canBeMatched() && rule.getMatcher().isMatched(entry)) {
        elementsByRule.putValue(rule,entry);
        matched.add(entry);
      }
    }
    unprocessed.removeAll(matched);
  }
  for (  ArrangementSectionRule sectionRule : sectionRules) {
    for (    ArrangementMatchRule rule : sectionRule.getMatchRules()) {
      final Collection<E> arrangedEntries=arrangeByRule(arranged,elementsByRule,rule);
      if (entryToSection != null && arrangedEntries != null) {
        for (        E entry : arrangedEntries) {
          entryToSection.put(entry,sectionRule);
        }
      }
    }
  }
  arranged.addAll(unprocessed);
  for (int i=0; i < arranged.size() && !dependent.isEmpty(); i++) {
    E e=arranged.get(i);
    List<E> shouldBeAddedAfterCurrentElement=ContainerUtil.newArrayList();
    for (Iterator<Pair<Set<ArrangementEntry>,E>> iterator=dependent.iterator(); iterator.hasNext(); ) {
      Pair<Set<ArrangementEntry>,E> pair=iterator.next();
      pair.first.remove(e);
      if (pair.first.isEmpty()) {
        iterator.remove();
        shouldBeAddedAfterCurrentElement.add(pair.second);
      }
    }
    if (entryToSection != null && entryToSection.containsKey(e)) {
      final ArrangementSectionRule rule=entryToSection.get(e);
      for (      E e1 : shouldBeAddedAfterCurrentElement) {
        entryToSection.put(e1,rule);
      }
    }
    arranged.addAll(i + 1,shouldBeAddedAfterCurrentElement);
  }
  return arranged;
}
