{
  List<ArrangementEntry> entries=new ArrayList<ArrangementEntry>();
  Stack<StackEntry> stack=new Stack<StackEntry>();
  entries.addAll(entriesToProcess);
  stack.push(new StackEntry(0,entriesToProcess.size()));
  while (!stack.isEmpty()) {
    StackEntry stackEntry=stack.peek();
    if (stackEntry.current >= stackEntry.end) {
      List<ArrangementEntry> subEntries=entries.subList(stackEntry.start,stackEntry.end);
      if (subEntries.size() > 1) {
        doArrange(arrangementRules,subEntries,document);
      }
      subEntries.clear();
      stack.pop();
    }
 else {
      ArrangementEntry entry=entries.get(stackEntry.current++);
      Collection<? extends ArrangementEntry> children=entry.getChildren();
      if (!children.isEmpty()) {
        entries.addAll(children);
        stack.push(new StackEntry(stackEntry.end,children.size()));
      }
    }
  }
}
