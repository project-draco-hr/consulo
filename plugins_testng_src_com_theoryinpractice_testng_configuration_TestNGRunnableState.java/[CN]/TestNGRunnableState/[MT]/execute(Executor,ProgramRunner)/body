{
  OSProcessHandler processHandler=startProcess();
  final TreeRootNode unboundOutputRoot=new TreeRootNode();
  final TestNGConsoleView console=new TestNGConsoleView(config,runnerSettings,myConfigurationPerRunnerSettings,unboundOutputRoot,executor);
  console.initUI();
  unboundOutputRoot.setPrinter(console.getPrinter());
  Disposer.register(console,unboundOutputRoot);
  for (  RunConfigurationExtension ext : Extensions.getExtensions(RunConfigurationExtension.EP_NAME)) {
    ext.handleStartProcess(config,processHandler);
  }
  processHandler.addProcessListener(new ProcessAdapter(){
    @Override public void processTerminated(    final ProcessEvent event){
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          final Project project=config.getProject();
          if (project.isDisposed())           return;
          final TestConsoleProperties consoleProperties=console.getProperties();
          if (consoleProperties == null)           return;
          final String testRunDebugId=consoleProperties.isDebug() ? ToolWindowId.DEBUG : ToolWindowId.RUN;
          final TestNGResults resultsView=console.getResultsView();
          final ToolWindowManager toolWindowManager=ToolWindowManager.getInstance(project);
          if (!Comparing.strEqual(toolWindowManager.getActiveToolWindowId(),testRunDebugId)) {
            toolWindowManager.notifyByBalloon(testRunDebugId,resultsView == null || resultsView.getStatus() == MessageHelper.SKIPPED_TEST ? MessageType.WARNING : (resultsView.getStatus() == MessageHelper.FAILED_TEST ? MessageType.ERROR : MessageType.INFO),resultsView == null ? "Tests were not started" : resultsView.getStatusLine(),null,null);
          }
        }
      }
);
    }
    @Override public void startNotified(    final ProcessEvent event){
      TestNGRemoteListener listener=new TestNGRemoteListener(console,unboundOutputRoot);
      client.prepareListening(listener,port);
      final SearchingForTestsTask task=createSearchingForTestsTask(myServerSocket,config,myTempFile);
      mySearchForTestIndicator=new BackgroundableProcessIndicator(task){
        @Override public void cancel(){
          try {
            if (!myServerSocket.isClosed()) {
              new Socket(InetAddress.getLocalHost(),myServerSocket.getLocalPort());
            }
          }
 catch (          Throwable e) {
            LOG.info(e);
          }
          super.cancel();
        }
      }
;
      ProgressManagerImpl.runProcessWithProgressAsynchronously(task,mySearchForTestIndicator);
    }
    @Override public void processWillTerminate(    ProcessEvent event,    boolean willBeDestroyed){
      final TestNGResults resultsView=console.getResultsView();
      if (resultsView != null) {
        resultsView.finish();
      }
    }
    @Override public void onTextAvailable(    final ProcessEvent event,    final Key outputType){
      final TestProxy currentTest=console.getCurrentTest();
      final String text=event.getText();
      final ConsoleViewContentType consoleViewType=ConsoleViewContentType.getConsoleViewType(outputType);
      final Printable printable=new Printable(){
        public void printOn(        final Printer printer){
          printer.print(text,consoleViewType);
        }
      }
;
      if (currentTest != null) {
        currentTest.addLast(printable);
      }
 else {
        unboundOutputRoot.addLast(printable);
      }
    }
  }
);
  console.attachToProcess(processHandler);
  RerunFailedTestsAction rerunFailedTestsAction=new RerunFailedTestsAction(console.getComponent());
  rerunFailedTestsAction.init(console.getProperties(),runnerSettings,myConfigurationPerRunnerSettings);
  rerunFailedTestsAction.setModelProvider(new Getter<TestFrameworkRunningModel>(){
    public TestFrameworkRunningModel get(){
      return console.getResultsView();
    }
  }
);
  final DefaultExecutionResult result=new DefaultExecutionResult(console,processHandler);
  result.setRestartActions(rerunFailedTestsAction);
  return result;
}
