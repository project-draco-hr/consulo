def _fetch_revisions(self, from_revnum, to_revnum):
    if (from_revnum < to_revnum):
        (from_revnum, to_revnum) = (to_revnum, from_revnum)
    self.child_cset = None

    def parselogentry(orig_paths, revnum, author, date, message):
        'Return the parsed commit object or None, and True if\n            the revision is a branch root.\n            '
        self.ui.debug(('parsing revision %d (%d changes)\n' % (revnum, len(orig_paths))))
        branched = False
        rev = self.revid(revnum)
        if ((rev in self.commits) or (revnum < to_revnum)):
            return (None, branched)
        parents = []
        orig_paths = sorted(orig_paths.iteritems())
        root_paths = [(p, e) for (p, e) in orig_paths if self.module.startswith(p)]
        if root_paths:
            (path, ent) = root_paths[(-1)]
            if ent.copyfrom_path:
                branched = True
                newpath = (ent.copyfrom_path + self.module[len(path):])
                previd = self.latest(newpath, ent.copyfrom_rev)
                if (previd is not None):
                    (prevmodule, prevnum) = self.revsplit(previd)[1:]
                    if (prevnum >= self.startrev):
                        parents = [previd]
                        self.ui.note((_('found parent of branch %s at %d: %s\n') % (self.module, prevnum, prevmodule)))
            else:
                self.ui.debug("no copyfrom path, don't know what to do.\n")
        paths = []
        for (path, ent) in orig_paths:
            if (self.getrelpath(path) is None):
                continue
            paths.append((path, ent))
        date = util.parsedate((date[:19] + ' UTC'), ['%Y-%m-%dT%H:%M:%S'])
        log = ((message and self.recode(message)) or '')
        author = ((author and self.recode(author)) or '')
        try:
            branch = self.module.split('/')[(-1)]
            if (branch == 'trunk'):
                branch = ''
        except IndexError:
            branch = None
        cset = commit(author=author, date=util.datestr(date), desc=log, parents=parents, branch=branch, rev=rev)
        self.commits[rev] = cset
        self.paths[rev] = (paths, cset.parents)
        if (self.child_cset and (not self.child_cset.parents)):
            self.child_cset.parents[:] = [rev]
        self.child_cset = cset
        return (cset, branched)
    self.ui.note((_('fetching revision log for "%s" from %d to %d\n') % (self.module, from_revnum, to_revnum)))
    try:
        firstcset = None
        lastonbranch = False
        stream = self._getlog([self.module], from_revnum, to_revnum)
        try:
            for entry in stream:
                (paths, revnum, author, date, message) = entry
                if (revnum < self.startrev):
                    lastonbranch = True
                    break
                if (not paths):
                    self.ui.debug(('revision %d has no entries\n' % revnum))
                    lastonbranch = (lastonbranch or (revnum == 0))
                    continue
                (cset, lastonbranch) = parselogentry(paths, revnum, author, date, message)
                if cset:
                    firstcset = cset
                if lastonbranch:
                    break
        finally:
            stream.close()
        if ((not lastonbranch) and firstcset and (not firstcset.parents)):
            try:
                firstrevnum = self.revnum(firstcset.rev)
                if (firstrevnum > 1):
                    latest = self.latest(self.module, (firstrevnum - 1))
                    if latest:
                        firstcset.parents.append(latest)
            except SvnPathNotFound:
                pass
    except SubversionException as (inst, num):
        if (num == svn.core.SVN_ERR_FS_NO_SUCH_REVISION):
            raise util.Abort((_('svn: branch has no revision %s') % to_revnum))
        raise
