{
  final BlockInfo info=myStack.peek();
  final TextRange textRange=info.getBlock().getTextRange();
  final Wrap wrap=info.getWrap();
  whiteSpace.arrangeLineFeeds(spaceProperty);
  boolean wrapIsPresent=whiteSpace.containsLineFeeds();
  if (shouldUseWrap(wrap) || wrapIsPresent) {
    whiteSpace.ensureLineFeed();
    if (wrap != null && wrap.getFirstEntry() >= 0) {
      myReparseFromOffset=wrap.getFirstEntry();
      wrap.skipFirstEntry();
      return false;
    }
  }
 else   if (wrapCanBeUsedInTheFuture(wrap) && !wrapIsPresent) {
    wrap.saveFirstEntry(textRange.getStartOffset());
  }
  final int wsLineFeeds=whiteSpace.getLineFeeds();
  if (wsLineFeeds > 0) {
    myCurrentLine+=wsLineFeeds;
    myCurrentOffset=whiteSpace.getSpaces();
  }
 else {
    myCurrentOffset+=whiteSpace.getSpaces();
  }
  if (!onTheSameLine(whiteSpace)) {
    final int before=whiteSpace.getSpaces();
    int alignOffset=getAlignOffset(info.getAlignment());
    if (alignOffset == -1) {
      int indent=calculateIndent();
      setFirstElementIsProcessed(indent);
      whiteSpace.setSpaces(indent);
    }
 else {
      setFirstElementIsProcessed(alignOffset);
      whiteSpace.setSpaces(alignOffset);
    }
    final int after=whiteSpace.getSpaces();
    myCurrentOffset+=after - before;
  }
 else {
    setElementIsProcessed(myCurrentOffset);
    whiteSpace.arrangeSpaces(spaceProperty);
  }
  setAlignOffset(info.getAlignment(),info.getCurrentIndent(),myCurrentLine);
  final int blockLineFeeds=getLineFeeds(textRange);
  if (blockLineFeeds > 0) {
    myCurrentLine+=blockLineFeeds;
    myCurrentOffset=getLastLineLength(textRange);
  }
 else {
    myCurrentOffset+=textRange.getLength();
  }
  return true;
}
