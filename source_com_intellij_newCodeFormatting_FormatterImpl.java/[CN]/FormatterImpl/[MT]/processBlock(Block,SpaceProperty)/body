{
  final WhiteSpace whiteSpace=myWhiteSpaceBeforeBlock.get(rootBlock);
  final BlockInfo info=new BlockInfo(rootBlock);
  info.setAlignment(rootBlock.getAlignment());
  info.setWrap(rootBlock.getWrap());
  BlockInfo parent=myStack.isEmpty() ? null : myStack.peek();
  myStack.push(info);
  if (parent != null && !parent.isFirstElementProcessed()) {
    if (info.getAlignment() == null) {
      info.setAlignment(parent.getAlignment());
    }
    if (info.getWrap() == null) {
      info.setWrap(parent.getWrap());
    }
  }
  final boolean subResult;
  try {
    final List<Block> subBlocks=rootBlock.getSubBlocks();
    if (subBlocks.isEmpty()) {
      subResult=processToken(spaceProperty,whiteSpace);
    }
 else {
      subResult=processCompositeBlock(subBlocks,spaceProperty,rootBlock);
    }
  }
  finally {
    myStack.pop();
  }
  if (!subResult && rootBlock.getTextRange().getStartOffset() <= myReparseFromOffset) {
    return processBlock(rootBlock,spaceProperty);
  }
 else {
    return subResult;
  }
}
