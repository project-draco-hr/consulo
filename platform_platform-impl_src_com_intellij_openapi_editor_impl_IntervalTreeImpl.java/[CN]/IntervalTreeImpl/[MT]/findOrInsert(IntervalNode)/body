{
  node.color=Color.RED;
  node.setParent(null);
  node.setValid(true);
  node.maxEnd=0;
  node.delta=0;
  node.setLeft(null);
  node.setRight(null);
  List<IntervalNode> gced=new ArrayList<IntervalNode>();
  if (root == null) {
    root=node;
  }
 else {
    IntervalNode current=getRoot();
    int delta=0;
    loop:     while (true) {
      delta+=current.delta;
      int compResult=compareNodes(node,0,current,delta,gced);
      if (compResult == 0) {
        return current;
      }
      if (compResult < 0) {
        if (current.getLeft() == null) {
          current.setLeft(node);
          break loop;
        }
        current=current.getLeft();
      }
 else {
        if (current.getRight() == null) {
          current.setRight(node);
          break loop;
        }
        current=current.getRight();
      }
    }
    node.delta=-delta;
    node.setParent(current);
  }
  linkNode(node);
  correctMaxUp(node);
  onInsertNode();
  assertUnderWriteLock();
  keySize+=node.intervals.size();
  insertCase1(node);
  verifyProperties();
  deleteNodes(gced);
  return node;
}
