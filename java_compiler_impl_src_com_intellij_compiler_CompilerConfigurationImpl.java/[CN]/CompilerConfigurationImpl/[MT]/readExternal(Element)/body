{
  DefaultJDOMExternalizer.readExternal(this,parentNode);
  Element node=parentNode.getChild(EXCLUDE_FROM_COMPILE);
  if (node != null) {
    myExcludedEntriesConfiguration.readExternal(node);
  }
  try {
    removeRegexpPatterns();
    node=parentNode.getChild(RESOURCE_EXTENSIONS);
    if (node != null) {
      for (      final Object o : node.getChildren(ENTRY)) {
        Element element=(Element)o;
        String pattern=element.getAttributeValue(NAME);
        if (pattern != null && !"".equals(pattern)) {
          addRegexpPattern(pattern);
        }
      }
    }
    removeWildcardPatterns();
    node=parentNode.getChild(WILDCARD_RESOURCE_PATTERNS);
    if (node != null) {
      myWildcardPatternsInitialized=true;
      for (      final Object o : node.getChildren(ENTRY)) {
        final Element element=(Element)o;
        String pattern=element.getAttributeValue(NAME);
        if (pattern != null && !"".equals(pattern)) {
          addWildcardResourcePattern(pattern);
        }
      }
    }
  }
 catch (  MalformedPatternException e) {
    throw new InvalidDataException(e);
  }
  final Element annotationProcessingSettings=parentNode.getChild(ANNOTATION_PROCESSING);
  if (annotationProcessingSettings != null) {
    myEnableAnnotationProcessors=Boolean.valueOf(annotationProcessingSettings.getAttributeValue("enabled","false"));
    myObtainProcessorsFromClasspath=Boolean.valueOf(annotationProcessingSettings.getAttributeValue("useClasspath","true"));
    final StringBuilder pathBuilder=new StringBuilder();
    for (    Element pathElement : ((Collection<Element>)annotationProcessingSettings.getChildren("processorPath"))) {
      final String path=pathElement.getAttributeValue("value");
      if (path != null) {
        if (pathBuilder.length() > 0) {
          pathBuilder.append(File.pathSeparator);
        }
        pathBuilder.append(path);
      }
    }
    myProcessorPath=pathBuilder.toString();
    myProcessorsMap.clear();
    for (    Element processorChild : ((Collection<Element>)annotationProcessingSettings.getChildren("processor"))) {
      final String name=processorChild.getAttributeValue("name");
      final String options=processorChild.getAttributeValue("options","");
      myProcessorsMap.put(name,options);
    }
    myExcludedModules.clear();
    myExcludedModuleNames.clear();
    final Collection<Element> excluded=(Collection<Element>)annotationProcessingSettings.getChildren("excludeModule");
    if (excluded.size() > 0) {
      final Map<String,Module> moduleMap=new com.intellij.util.containers.HashMap<String,Module>();
      for (      Module module : myModuleManager.getModules()) {
        moduleMap.put(module.getName(),module);
      }
      for (      Element moduleElement : excluded) {
        final String name=moduleElement.getAttributeValue("name");
        if (name != null) {
          final Module module=moduleMap.get(name);
          if (module != null) {
            myExcludedModules.add(module);
          }
 else {
            myExcludedModuleNames.add(name);
          }
        }
      }
    }
  }
}
