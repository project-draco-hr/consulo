{
  final Set<PsiMethod> siblingMethods=new HashSet<PsiMethod>();
  final Stack<PsiMethod> pendingMethods=new Stack<PsiMethod>();
  pendingMethods.add(method);
  while (!pendingMethods.isEmpty()) {
    final PsiMethod methodToAnalyze=pendingMethods.pop();
    siblingMethods.add(methodToAnalyze);
    final Iterable<PsiMethod> overridingMethods=OverridingMethodsSearch.search(methodToAnalyze,methodToAnalyze.getUseScope(),false);
    for (    PsiMethod overridingMethod : overridingMethods) {
      if (!siblingMethods.contains(overridingMethod) && !pendingMethods.contains(overridingMethod)) {
        pendingMethods.add(overridingMethod);
      }
    }
    final PsiMethod[] superMethods=methodToAnalyze.findSuperMethods();
    for (    PsiMethod superMethod : superMethods) {
      if (!siblingMethods.contains(superMethod) && !pendingMethods.contains(superMethod)) {
        pendingMethods.add(superMethod);
      }
    }
  }
  return siblingMethods;
}
