{
  forceAppender(myPath);
  checkCancellation();
  long startedTime=System.nanoTime();
  long chunk=tailChunkAddress;
  int chunkCount=0;
  byte[] result=null;
  RAReader reader=myCompactionModeReader;
  FileAccessorCache.Handle<RAReader> readerHandle=null;
  if (reader == null) {
    readerHandle=myCompressedAppendableFile != null ? null : ourReadersCache.get(myPath);
    reader=myCompressedAppendableFile != null ? null : readerHandle.get();
  }
  try {
    while (chunk != 0) {
      if (chunk < 0 || chunk > mySize)       throw new PersistentEnumeratorBase.CorruptedException(myFile);
      int len=(int)Math.min(myBuffer.length,mySize - chunk);
      if (myCompressedAppendableFile != null) {
        DataInputStream stream=myCompressedAppendableFile.getStream(chunk);
        stream.readFully(myBuffer,0,len);
        stream.close();
      }
 else {
        reader.get(chunk,myBuffer,0,len);
      }
      myBufferStreamWrapper.init(myBuffer,0,len);
      final int chunkSize=DataInputOutputUtil.readINT(myBufferDataStreamWrapper);
      if (chunkSize < 0) {
        throw new IOException("Value storage corrupted: negative chunk size: " + chunkSize);
      }
      final long prevChunkAddress=readPrevChunkAddress(chunk);
      final int headerOffset=len - myBufferStreamWrapper.available();
      byte[] b=new byte[(result != null ? result.length : 0) + chunkSize];
      if (result != null)       System.arraycopy(result,0,b,b.length - result.length,result.length);
      result=b;
      checkPreconditions(result,chunkSize,0);
      if (chunkSize < myBuffer.length - headerOffset) {
        System.arraycopy(myBuffer,headerOffset,result,0,chunkSize);
      }
 else {
        if (myCompressedAppendableFile != null) {
          DataInputStream stream=myCompressedAppendableFile.getStream(chunk + headerOffset);
          stream.readFully(result,0,chunkSize);
          stream.close();
        }
 else {
          reader.get(chunk + headerOffset,result,0,chunkSize);
        }
      }
      if (prevChunkAddress >= chunk)       throw new PersistentEnumeratorBase.CorruptedException(myFile);
      chunk=prevChunkAddress;
      chunkCount++;
      if (prevChunkAddress != 0)       checkCancellation();
      if (result.length > mySize && myCompressedAppendableFile == null) {
        throw new PersistentEnumeratorBase.CorruptedException(myFile);
      }
    }
  }
 catch (  OutOfMemoryError error) {
    result=null;
    throw new PersistentEnumeratorBase.CorruptedException(myFile);
  }
 finally {
    if (readerHandle != null) {
      readerHandle.release();
    }
  }
  if (chunkCount > 1 && !myCompactionMode) {
    checkCancellation();
    long endCompactionTime=System.nanoTime();
    long diff=endCompactionTime - startedTime;
    myChunksRemovalTime+=diff;
    myChunks+=chunkCount;
    if (ourDumpChunkRemovalTime && chunkCount > 2) {
      System.out.println("Removed " + chunkCount + " chunks for "+ (diff / 1000000)+ "ms, bytes: "+ result.length+ ", total: "+ (myChunksRemovalTime / 1000000)+ "ms for "+ myChunks+ " chunks in "+ myPath);
    }
    long l=appendBytes(new ByteSequence(result),0);
    return new ReadResult(l,result);
  }
  return new ReadResult(tailChunkAddress,result);
}
