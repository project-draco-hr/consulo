{
  final BuildDataPaths dataPaths=context.getProjectDescriptor().dataManager.getDataPaths();
  final MavenProjectConfiguration projectConfig=JpsMavenExtensionService.getInstance().getMavenProjectConfiguration(dataPaths);
  final MavenModuleResourceConfiguration config=target.getModuleResourcesConfiguration(dataPaths);
  if (config == null) {
    return;
  }
  final Set<String> filteringExcludedExtensions=config.getFilteringExcludedExtensions();
  final String encoding=context.getProjectDescriptor().getEncodingConfiguration().getPreferredModuleEncoding(target.getModule());
  final Date timestamp=new Date();
  @Nullable final Map<MavenResourcesTarget,Set<File>> cleanedSources;
  if (context.isProjectRebuild()) {
    cleanedSources=null;
  }
 else {
    cleanedSources=BuildOperations.cleanOutputsCorrespondingToChangedFiles(context,holder);
  }
  holder.processDirtyFiles(new FileProcessor<MavenResourceRootDescriptor,MavenResourcesTarget>(){
    private Map<String,String> myProperties;
    private Pattern myDelimitersPattern;
    @Override public boolean apply(    MavenResourcesTarget target,    File file,    MavenResourceRootDescriptor rd) throws IOException {
      final String relPath=FileUtil.getRelativePath(rd.getRootFile(),file);
      if (relPath == null) {
        return true;
      }
      final String sourcePath=file.getPath();
      if (!rd.isIncluded(relPath)) {
        return true;
      }
      final File outputDir=MavenResourcesTarget.getOutputDir(target.getModuleOutputDir(),rd.getConfiguration());
      if (outputDir == null) {
        return true;
      }
      final File outputFile=new File(outputDir,relPath);
      boolean shouldFilter=rd.getConfiguration().isFiltered && !filteringExcludedExtensions.contains(getExtension(file));
      if (shouldFilter && file.length() > FILTERING_SIZE_LIMIT) {
        context.processMessage(new CompilerMessage("MavenResources",BuildMessage.Kind.WARNING,"File is too big to be filtered. Most likely it is a binary file and should be excluded from filtering",sourcePath));
        shouldFilter=false;
      }
      try {
        context.processMessage(new ProgressMessage("Copying resources... [" + target.getModule().getName() + "]"));
        if (shouldFilter) {
          copyWithFiltering(file,outputFile);
        }
 else {
          FileUtil.copyContent(file,outputFile);
        }
        outputConsumer.registerOutputFile(outputFile,Collections.singleton(sourcePath));
      }
 catch (      UnsupportedEncodingException e) {
        context.processMessage(new CompilerMessage(BUILDER_NAME,BuildMessage.Kind.INFO,"Resource was not copied: " + e.getMessage(),sourcePath));
      }
 finally {
        if (cleanedSources != null) {
          final Set<File> files=cleanedSources.get(target);
          if (files != null) {
            files.remove(file);
          }
        }
      }
      return !context.getCancelStatus().isCanceled();
    }
    private void copyWithFiltering(    File file,    File outputFile) throws IOException {
      PrintWriter writer;
      try {
        writer=encoding != null ? new PrintWriter(outputFile,encoding) : new PrintWriter(outputFile);
      }
 catch (      FileNotFoundException e) {
        FileUtil.createIfDoesntExist(outputFile);
        writer=encoding != null ? new PrintWriter(outputFile,encoding) : new PrintWriter(outputFile);
      }
      try {
        final byte[] bytes=FileUtil.loadFileBytes(file);
        final String text=encoding != null ? new String(bytes,encoding) : new String(bytes);
        doFilterText(getDelimitersPattern(),text,projectConfig,config,endsWith(file.getName(),".properties") ? "\\" : null,getProperties(),null,writer);
      }
  finally {
        writer.close();
      }
    }
    private Pattern getDelimitersPattern(){
      Pattern pattern=myDelimitersPattern;
      if (pattern == null) {
        pattern=Pattern.compile(config.delimitersPattern);
        myDelimitersPattern=pattern;
      }
      return pattern;
    }
    private Map<String,String> getProperties(){
      Map<String,String> props=myProperties;
      if (props == null) {
        props=new HashMap<String,String>(config.properties);
        String timestampFormat=props.get(MAVEN_BUILD_TIMESTAMP_FORMAT_PROPERTY);
        if (timestampFormat == null) {
          timestampFormat="yyyyMMdd-HHmm";
        }
        props.put(MAVEN_BUILD_TIMESTAMP_PROPERTY,new SimpleDateFormat(timestampFormat).format(timestamp));
        myProperties=props;
      }
      return props;
    }
  }
);
  context.checkCanceled();
  if (cleanedSources != null) {
    for (    Map.Entry<MavenResourcesTarget,Set<File>> entry : cleanedSources.entrySet()) {
      final Set<File> files=entry.getValue();
      if (!files.isEmpty()) {
        final SourceToOutputMapping mapping=context.getProjectDescriptor().dataManager.getSourceToOutputMap(entry.getKey());
        for (        File file : files) {
          mapping.remove(file.getPath());
        }
      }
    }
  }
  context.processMessage(new ProgressMessage(""));
}
