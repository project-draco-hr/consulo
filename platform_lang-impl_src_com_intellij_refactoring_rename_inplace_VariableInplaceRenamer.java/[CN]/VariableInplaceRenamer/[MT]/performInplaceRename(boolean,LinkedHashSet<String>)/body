{
  if (InjectedLanguageUtil.isInInjectedLanguagePrefixSuffix(myElementToRename)) {
    return false;
  }
  final FileViewProvider fileViewProvider=myElementToRename.getContainingFile().getViewProvider();
  VirtualFile file=getTopLevelVirtualFile(fileViewProvider);
  SearchScope referencesSearchScope=getReferencesSearchScope(file);
  final Collection<PsiReference> refs=ReferencesSearch.search(myElementToRename,referencesSearchScope,false).findAll();
  addReferenceAtCaret(refs);
  for (  PsiReference ref : refs) {
    final FileViewProvider usageViewProvider=ref.getElement().getContainingFile().getViewProvider();
    if (getTopLevelVirtualFile(usageViewProvider) != file) {
      return false;
    }
  }
  while (!ourRenamersStack.isEmpty()) {
    ourRenamersStack.peek().finish();
  }
  PsiElement scope=checkLocalScope();
  if (scope == null) {
    return false;
  }
  final PsiFile containingFile=scope.getContainingFile();
  if (containingFile == null) {
    return false;
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(myProject,myElementToRename))   return false;
  myEditor.putUserData(INPLACE_RENAMER,this);
  ourRenamersStack.push(this);
  final List<Pair<PsiElement,TextRange>> stringUsages=new ArrayList<Pair<PsiElement,TextRange>>();
  collectAdditionalElementsToRename(processTextOccurrences,stringUsages);
  if (appendAdditionalElement(stringUsages)) {
    return runRenameTemplate(nameSuggestions,refs,stringUsages,scope,containingFile);
  }
 else {
    new RenameChooser(myEditor).showChooser(refs,stringUsages,nameSuggestions,scope,containingFile);
  }
  return true;
}
