{
  myStartLine=myDocument.getLineNumber(myStartOffset);
  myEndLine=myDocument.getLineNumber(myEndOffset);
  if (myEndLine > myStartLine && myDocument.getLineStartOffset(myEndLine) == myEndOffset) {
    myEndLine--;
  }
  myStartOffsets=new int[myEndLine - myStartLine + 1];
  myEndOffsets=new int[myEndLine - myStartLine + 1];
  myCommenters=new Commenter[myEndLine - myStartLine + 1];
  myCommenterStateMap=new THashMap<SelfManagingCommenter,CommenterDataHolder>();
  CharSequence chars=myDocument.getCharsSequence();
  boolean singleline=myStartLine == myEndLine;
  int offset=myDocument.getLineStartOffset(myStartLine);
  offset=CharArrayUtil.shiftForward(myDocument.getCharsSequence(),offset," \t");
  final Language languageSuitableForCompleteFragment=PsiUtilBase.reallyEvaluateLanguageInRange(offset,CharArrayUtil.shiftBackward(myDocument.getCharsSequence(),myDocument.getLineEndOffset(myEndLine)," \t\n"),myFile);
  Commenter blockSuitableCommenter=languageSuitableForCompleteFragment == null ? LanguageCommenters.INSTANCE.forLanguage(myFile.getLanguage()) : null;
  if (blockSuitableCommenter == null && myFile.getFileType() instanceof CustomSyntaxTableFileType) {
    blockSuitableCommenter=new Commenter(){
      final SyntaxTable mySyntaxTable=((CustomSyntaxTableFileType)myFile.getFileType()).getSyntaxTable();
      @Override @Nullable public String getLineCommentPrefix(){
        return mySyntaxTable.getLineComment();
      }
      @Override @Nullable public String getBlockCommentPrefix(){
        return mySyntaxTable.getStartComment();
      }
      @Override @Nullable public String getBlockCommentSuffix(){
        return mySyntaxTable.getEndComment();
      }
      @Override public String getCommentedBlockCommentPrefix(){
        return null;
      }
      @Override public String getCommentedBlockCommentSuffix(){
        return null;
      }
    }
;
  }
  boolean allLineCommented=true;
  boolean commentWithIndent=!CodeStyleSettingsManager.getSettings(myProject).LINE_COMMENT_AT_FIRST_COLUMN;
  for (int line=myStartLine; line <= myEndLine; line++) {
    Commenter commenter=blockSuitableCommenter != null ? blockSuitableCommenter : findCommenter(line);
    if (commenter == null)     return;
    if (commenter.getLineCommentPrefix() == null && (commenter.getBlockCommentPrefix() == null || commenter.getBlockCommentSuffix() == null)) {
      return;
    }
    if (commenter instanceof SelfManagingCommenter && myCommenterStateMap.get(commenter) == null) {
      final SelfManagingCommenter selfManagingCommenter=(SelfManagingCommenter)commenter;
      CommenterDataHolder state=selfManagingCommenter.createLineCommentingState(myStartLine,myEndLine,myDocument,myFile);
      if (state == null)       state=SelfManagingCommenter.EMPTY_STATE;
      myCommenterStateMap.put(selfManagingCommenter,state);
    }
    myCommenters[line - myStartLine]=commenter;
    if (!isLineCommented(line,chars,commenter) && (singleline || !isLineEmpty(line))) {
      allLineCommented=false;
      if (commenter instanceof IndentedCommenter) {
        final Boolean value=((IndentedCommenter)commenter).forceIndentedLineComment();
        if (value != null) {
          commentWithIndent=value;
        }
      }
      break;
    }
  }
  if (!allLineCommented) {
    if (!commentWithIndent) {
      doDefaultCommenting(blockSuitableCommenter);
    }
 else {
      doIndentCommenting(blockSuitableCommenter);
    }
  }
 else {
    for (int line=myEndLine; line >= myStartLine; line--) {
      uncommentLine(line);
    }
  }
}
