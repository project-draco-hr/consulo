{
  final CompositeBlockWrapper info=new CompositeBlockWrapper(rootBlock,myCurrentWhiteSpace,parent);
  if (index == 0) {
    info.arrangeParentTextRange();
  }
  if (myRootBlockWrapper == null)   myRootBlockWrapper=info;
  boolean blocksMayBeOfInterest=false;
  if (myPositionOfInterest != -1) {
    myResult.put(info,rootBlock);
    blocksMayBeOfInterest=true;
  }
  Block previous=null;
  List<Block> subBlocks=rootBlock.getSubBlocks();
  final int subBlocksCount=subBlocks.size();
  List<AbstractBlockWrapper> list=new ArrayList<AbstractBlockWrapper>(subBlocksCount);
  final boolean blocksAreReadOnly=rootBlock instanceof ReadOnlyBlockContainer || blocksMayBeOfInterest;
  for (int i=0; i < subBlocksCount; i++) {
    final Block block=subBlocks.get(i);
    if (previous != null) {
      myCurrentSpaceProperty=(SpacingImpl)rootBlock.getSpacing(previous,block);
    }
 else     if (myLastBlock != null) {
      myCurrentSpaceProperty=(SpacingImpl)rootBlock.getSpacing(myLastBlock,block);
    }
    boolean childBlockIsRightBlock=false;
    if (i == subBlocksCount - 1 && rootBlockIsRightBlock) {
      childBlockIsRightBlock=true;
    }
    final AbstractBlockWrapper wrapper=buildFrom(block,i,info,currentWrapParent,rootBlock,childBlockIsRightBlock);
    list.add(wrapper);
    if (wrapper.getIndent() == null) {
      wrapper.setIndent((IndentImpl)block.getIndent());
    }
    previous=block;
    if (!blocksAreReadOnly && !(subBlocks instanceof Unmodifiable) && !(subBlocks instanceof ImmutableCollection)) {
      subBlocks.set(i,null);
    }
  }
  setDefaultIndents(list);
  info.setChildren(list);
  return info;
}
