{
  final TodoItem[] todoItems=ApplicationManager.getApplication().runReadAction(new Computable<TodoItem[]>(){
    @Override public TodoItem[] compute(){
      final PsiFile psiFile=PsiFileFactory.getInstance(myProject).createFileFromText((myOldRevision ? "old" : "") + myFileName,myFileType,myText);
      final PsiSearchHelper helper=PsiSearchHelper.SERVICE.getInstance(myProject);
      return helper.findTodoItemsLight(psiFile);
    }
  }
);
  final StepIntersection<TodoItem,TextRange> stepIntersection=new StepIntersection<TodoItem,TextRange>(new Convertor<TodoItem,TextRange>(){
    @Override public TextRange convert(    TodoItem o){
      return o.getTextRange();
    }
  }
,Convertor.SELF,myRanges,new Getter<String>(){
    @Override public String get(){
      return "";
    }
  }
);
  final List<TodoItem> filtered=stepIntersection.process(Arrays.asList(todoItems));
  final List<Pair<TextRange,TextAttributes>> result=new ArrayList<Pair<TextRange,TextAttributes>>(filtered.size());
  int offset=0;
  for (  TextRange range : myRanges) {
    Iterator<TodoItem> iterator=filtered.iterator();
    while (iterator.hasNext()) {
      TodoItem item=iterator.next();
      if (range.contains(item.getTextRange())) {
        TextRange todoRange=new TextRange(offset - range.getStartOffset() + item.getTextRange().getStartOffset(),offset - range.getStartOffset() + item.getTextRange().getEndOffset());
        result.add(new Pair<TextRange,TextAttributes>(todoRange,item.getPattern().getAttributes().getTextAttributes()));
        iterator.remove();
      }
 else {
        break;
      }
    }
    offset+=range.getLength() + 1 + myAdditionalOffset;
  }
  return result;
}
