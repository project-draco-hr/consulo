def relink(ui, repo, origin=None, **opts):
    'recreate hardlinks between two repositories\n\n    When repositories are cloned locally, their data files will be\n    hardlinked so that they only use the space of a single repository.\n\n    Unfortunately, subsequent pulls into either repository will break\n    hardlinks for any files touched by the new changesets, even if\n    both repositories end up pulling the same changes.\n\n    Similarly, passing --rev to "hg clone" will fail to use any\n    hardlinks, falling back to a complete copy of the source\n    repository.\n\n    This command lets you recreate those hardlinks and reclaim that\n    wasted space.\n\n    This repository will be relinked to share space with ORIGIN, which\n    must be on the same local disk. If ORIGIN is omitted, looks for\n    "default-relink", then "default", in [paths].\n\n    Do not attempt any read operations on this repository while the\n    command is running. (Both repositories will be locked against\n    writes.)\n    '
    if ((not hasattr(util, 'samefile')) or (not hasattr(util, 'samedevice'))):
        raise util.Abort(_('hardlinks are not supported on this system'))
    src = hg.repository(cmdutil.remoteui(repo, opts), ui.expandpath((origin or 'default-relink'), (origin or 'default')))
    if (not src.local()):
        raise util.Abort('must specify local origin repository')
    ui.status((_('relinking %s to %s\n') % (src.store.path, repo.store.path)))
    locallock = repo.lock()
    try:
        remotelock = src.lock()
        try:
            candidates = sorted(collect(src.store.path, ui))
            targets = prune(candidates, src.store.path, repo.store.path, ui)
            do_relink(src.store.path, repo.store.path, targets, ui)
        finally:
            remotelock.release()
    finally:
        locallock.release()
