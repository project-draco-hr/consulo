{
  UsageInfo[] usagesIn=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  ReferencedElementsCollector collector=new ReferencedElementsCollector();
  PsiExpression initializer=myField.getInitializer();
  LOG.assertTrue(initializer != null);
  initializer.accept(collector);
  HashSet<PsiMember> referencedWithVisibility=collector.myReferencedMembers;
  PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(myField.getProject()).getResolveHelper();
  for (  UsageInfo info : usagesIn) {
    PsiElement element=info.getElement();
    if (element instanceof PsiExpression && isAccessedForWriting((PsiExpression)element)) {
      String message=RefactoringBundle.message("0.is.used.for.writing.in.1",RefactoringUIUtil.getDescription(myField,true),RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(element),true));
      conflicts.putValue(element,message);
    }
    for (    PsiMember member : referencedWithVisibility) {
      if (!resolveHelper.isAccessible(member,element,null)) {
        String message=RefactoringBundle.message("0.will.not.be.accessible.from.1.after.inlining",RefactoringUIUtil.getDescription(member,true),RefactoringUIUtil.getDescription(ConflictsUtil.getContainer(element),true));
        conflicts.putValue(member,message);
      }
    }
  }
  if (!myInlineThisOnly) {
    for (    UsageInfo info : usagesIn) {
      if (info instanceof UsageFromJavaDoc) {
        final PsiElement element=info.getElement();
        if (element instanceof PsiDocMethodOrFieldRef && !PsiTreeUtil.isAncestor(myField,element,false)) {
          conflicts.putValue(element,"Inlined method is used in javadoc");
        }
      }
    }
  }
  return showConflicts(conflicts,usagesIn);
}
