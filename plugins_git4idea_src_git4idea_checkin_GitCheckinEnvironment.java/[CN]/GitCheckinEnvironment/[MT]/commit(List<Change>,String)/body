{
  List<VcsException> exceptions=new ArrayList<VcsException>();
  Map<VirtualFile,List<Change>> sortedChanges=sortChangesByGitRoot(changes);
  for (  Map.Entry<VirtualFile,List<Change>> entry : sortedChanges.entrySet()) {
    Set<FilePath> files=new HashSet<FilePath>();
    final VirtualFile root=entry.getKey();
    try {
      File messageFile=createMessageFile(root,message);
      try {
        final Set<FilePath> added=new HashSet<FilePath>();
        final Set<FilePath> removed=new HashSet<FilePath>();
        for (        Change change : entry.getValue()) {
switch (change.getType()) {
case NEW:
case MODIFICATION:
            added.add(change.getAfterRevision().getFile());
          break;
case DELETED:
        removed.add(change.getBeforeRevision().getFile());
      break;
case MOVED:
    added.add(change.getAfterRevision().getFile());
  removed.add(change.getBeforeRevision().getFile());
break;
default :
throw new IllegalStateException("Unknown change type: " + change.getType());
}
}
try {
if (updateIndex(myProject,root,added,removed,exceptions)) {
try {
files.addAll(added);
files.addAll(removed);
commit(myProject,root,files,messageFile,myNextCommitAuthor).run();
}
 catch (VcsException ex) {
if (!isMergeCommit(ex)) {
throw ex;
}
if (!mergeCommit(myProject,root,added,removed,messageFile,myNextCommitAuthor,exceptions)) {
throw ex;
}
}
}
if (myNextCommitIsPushed != null && myNextCommitIsPushed.booleanValue()) {
Collection<VcsException> problems=GitHandlerUtil.doSynchronouslyWithExceptions(GitPushUtils.preparePush(myProject,root));
for (VcsException e : problems) {
if (!isNoOrigin(e)) {
exceptions.add(e);
}
}
}
}
  finally {
if (!messageFile.delete()) {
log.warn("Failed to remove temporary file: " + messageFile);
}
}
}
 catch (VcsException e) {
exceptions.add(e);
}
}
 catch (IOException ex) {
exceptions.add(new VcsException("Creation of commit message file failed",ex));
}
}
return exceptions;
}
