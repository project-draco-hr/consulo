{
  if (where == null)   return null;
  final Ref<ArrayList<ProblemDescriptor>> problemList=new Ref<ArrayList<ProblemDescriptor>>();
  where.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitMethod(    PsiMethod method){
    }
    @Override public void visitClass(    PsiClass aClass){
    }
    @Override public void visitBinaryExpression(    PsiBinaryExpression expression){
      super.visitBinaryExpression(expression);
      IElementType opSign=expression.getOperationSign().getTokenType();
      if (opSign == JavaTokenType.EQEQ || opSign == JavaTokenType.NE) {
        PsiExpression lOperand=expression.getLOperand();
        PsiExpression rOperand=expression.getROperand();
        if (rOperand == null || isNullLiteral(lOperand) || isNullLiteral(rOperand))         return;
        PsiType lType=lOperand.getType();
        PsiType rType=rOperand.getType();
        if (isCheckedType(lType) || isCheckedType(rType)) {
          if (problemList.get() == null)           problemList.set(new ArrayList<ProblemDescriptor>());
          problemList.get().add(manager.createProblemDescriptor(expression,DESCRIPTION_TEMPLATE,myQuickFix,ProblemHighlightType.GENERIC_ERROR_OR_WARNING));
        }
      }
    }
  }
);
  return problemList.get() == null ? null : problemList.get().toArray(new ProblemDescriptor[problemList.get().size()]);
}
