{
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
  final PsiMethod method=LambdaUtil.getFunctionalInterfaceMethod(functionalInterfaceType);
  if (method != null) {
    final Pair<PsiType,ConstraintType> constraintFromFormalParams=inferConstraintFromLambdaFormalParams(typeParam,resolveResult,method,lambdaExpression);
    if (constraintFromFormalParams != null)     return constraintFromFormalParams;
    final PsiParameter[] methodParameters=method.getParameterList().getParameters();
    final PsiSubstitutor subst=resolveResult.getSubstitutor();
    final PsiType returnType=subst.substitute(method.getReturnType());
    if (returnType != null && returnType != PsiType.VOID) {
      final List<PsiExpression> expressions=lambdaExpression.getReturnExpressions();
      for (      final PsiExpression expression : expressions) {
        final boolean independent=LambdaUtil.isFreeFromTypeInferenceArgs(methodParameters,lambdaExpression,expression);
        if (!independent && lowerBound != PsiType.NULL) {
          return null;
        }
        PsiType exprType=independent ? expression.getType() : ourGuard.doPreventingRecursion(lambdaExpression,true,new Computable<PsiType>(){
          @Override public PsiType compute(){
            return expression.getType();
          }
        }
);
        if (exprType instanceof PsiLambdaParameterType) {
          final PsiParameter parameter=((PsiLambdaParameterType)exprType).getParameter();
          final int parameterIndex=lambdaExpression.getParameterList().getParameterIndex(parameter);
          if (parameterIndex > -1) {
            exprType=subst.substitute(methodParameters[parameterIndex].getType());
          }
        }
 else         if (exprType instanceof PsiLambdaExpressionType) {
          return inferConstraintFromFunctionalInterfaceMethod(typeParam,((PsiLambdaExpressionType)exprType).getExpression(),returnType,lowerBound);
        }
        if (exprType == null) {
          return FAILED_INFERENCE;
        }
        Pair<PsiType,ConstraintType> constraint=getSubstitutionForTypeParameterConstraint(typeParam,returnType,exprType,false,PsiUtil.getLanguageLevel(method));
        if (constraint != null) {
          return constraint;
        }
      }
    }
    for (    PsiParameter parameter : methodParameters) {
      if (LambdaUtil.dependsOnTypeParams(parameter.getType(),lambdaExpression)) {
        return getFailedInferenceConstraint(typeParam);
      }
    }
  }
  return null;
}
