{
  final PsiClassType.ClassResolveResult resolveResult=PsiUtil.resolveGenericsClassInType(functionalInterfaceType);
  final PsiMethod method=LambdaUtil.getFunctionalInterfaceMethod(resolveResult);
  if (method != null) {
    final PsiSubstitutor subst=LambdaUtil.getSubstitutor(method,resolveResult);
    final Pair<PsiType,ConstraintType> constraintFromFormalParams=inferConstraintFromLambdaFormalParams(typeParam,subst,method,lambdaExpression);
    if (constraintFromFormalParams != null)     return constraintFromFormalParams;
    final PsiParameter[] methodParameters=method.getParameterList().getParameters();
    if (methodParamsDependOn(typeParam,lambdaExpression,functionalInterfaceType,methodParameters,subst)) {
      if (lowerBound != PsiType.NULL) {
        return null;
      }
      return getFailedInferenceConstraint(typeParam);
    }
    final Set<PsiParameterList> lists=LambdaUtil.ourParams.get();
    if (lists != null && lists.contains(lambdaExpression.getParameterList())) {
      return null;
    }
    final PsiType returnType=subst.substitute(method.getReturnType());
    if (returnType != null && returnType != PsiType.VOID) {
      Pair<PsiType,ConstraintType> constraint=null;
      final List<PsiExpression> expressions=LambdaUtil.getReturnExpressions(lambdaExpression);
      for (      final PsiExpression expression : expressions) {
        final boolean independent=LambdaUtil.isFreeFromTypeInferenceArgs(methodParameters,lambdaExpression,expression,subst,functionalInterfaceType,typeParam);
        if (!independent) {
          if (lowerBound != PsiType.NULL) {
            return null;
          }
          continue;
        }
        PsiType exprType=expression.getType();
        if (exprType instanceof PsiLambdaParameterType) {
          final PsiParameter parameter=((PsiLambdaParameterType)exprType).getParameter();
          final int parameterIndex=lambdaExpression.getParameterList().getParameterIndex(parameter);
          if (parameterIndex > -1) {
            exprType=subst.substitute(methodParameters[parameterIndex].getType());
          }
        }
 else         if (exprType instanceof PsiLambdaExpressionType) {
          return inferConstraintFromFunctionalInterfaceMethod(typeParam,((PsiLambdaExpressionType)exprType).getExpression(),returnType,lowerBound);
        }
 else         if (exprType == null && independent) {
          return null;
        }
        if (exprType == null) {
          return FAILED_INFERENCE;
        }
        final Pair<PsiType,ConstraintType> returnExprConstraint=getSubstitutionForTypeParameterConstraint(typeParam,GenericsUtil.eliminateWildcards(returnType),exprType,true,PsiUtil.getLanguageLevel(method));
        if (returnExprConstraint != null) {
          if (returnExprConstraint == FAILED_INFERENCE)           return returnExprConstraint;
          if (constraint != null) {
            final PsiType leastUpperBound=GenericsUtil.getLeastUpperBound(constraint.getFirst(),returnExprConstraint.getFirst(),typeParam.getManager());
            constraint=new Pair<PsiType,ConstraintType>(leastUpperBound,ConstraintType.SUPERTYPE);
          }
 else {
            constraint=returnExprConstraint;
          }
        }
      }
      if (constraint != null)       return constraint;
    }
  }
  return null;
}
