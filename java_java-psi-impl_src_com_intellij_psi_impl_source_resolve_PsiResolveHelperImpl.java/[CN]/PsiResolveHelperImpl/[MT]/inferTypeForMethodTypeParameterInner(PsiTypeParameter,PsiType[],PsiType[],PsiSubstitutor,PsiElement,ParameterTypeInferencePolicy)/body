{
  PsiWildcardType wildcardToCapture=null;
  Pair<PsiType,ConstraintType> rawInference=null;
  PsiType lowerBound=PsiType.NULL;
  PsiType upperBound=PsiType.NULL;
  if (paramTypes.length > 0) {
    sortLambdaExpressionsLast(paramTypes,argTypes);
    boolean rawType=false;
    boolean nullPassed=false;
    for (int j=0; j < argTypes.length; j++) {
      PsiType argumentType=argTypes[j];
      if (argumentType == null)       continue;
      if (j >= paramTypes.length)       break;
      PsiType parameterType=paramTypes[j];
      if (parameterType == null)       break;
      rawType|=parameterType instanceof PsiClassType && ((PsiClassType)parameterType).isRaw();
      nullPassed|=argumentType == PsiType.NULL;
      if (parameterType instanceof PsiEllipsisType) {
        parameterType=((PsiEllipsisType)parameterType).getComponentType();
        if (argTypes.length == paramTypes.length && argumentType instanceof PsiArrayType && !(((PsiArrayType)argumentType).getComponentType() instanceof PsiPrimitiveType)) {
          argumentType=((PsiArrayType)argumentType).getComponentType();
        }
      }
      final Pair<PsiType,ConstraintType> currentSubstitution;
      if (argumentType instanceof PsiLambdaExpressionType) {
        currentSubstitution=inferSubstitutionFromLambda(typeParameter,(PsiLambdaExpressionType)argumentType,lowerBound,partialSubstitutor);
        if (rawType) {
          if (currentSubstitution == FAILED_INFERENCE || (currentSubstitution == null && lowerBound == PsiType.NULL))           return RAW_INFERENCE;
        }
        if (nullPassed && currentSubstitution == null)         return RAW_INFERENCE;
      }
 else       if (argumentType instanceof PsiMethodReferenceType) {
        final PsiMethodReferenceExpression referenceExpression=((PsiMethodReferenceType)argumentType).getExpression();
        currentSubstitution=inferConstraintFromFunctionalInterfaceMethod(typeParameter,referenceExpression,partialSubstitutor.substitute(parameterType),partialSubstitutor,policy);
      }
 else {
        currentSubstitution=getSubstitutionForTypeParameterConstraint(typeParameter,parameterType,argumentType,true,PsiUtil.getLanguageLevel(typeParameter));
      }
      if (currentSubstitution == null)       continue;
      if (currentSubstitution == FAILED_INFERENCE) {
        return getFailedInferenceConstraint(typeParameter);
      }
      final ConstraintType constraintType=currentSubstitution.getSecond();
      final PsiType type=currentSubstitution.getFirst();
      if (type == null) {
        rawInference=RAW_INFERENCE;
        continue;
      }
switch (constraintType) {
case EQUALS:
        if (!(type instanceof PsiWildcardType))         return currentSubstitution;
      if (wildcardToCapture != null)       return getFailedInferenceConstraint(typeParameter);
    wildcardToCapture=(PsiWildcardType)type;
  break;
case SUPERTYPE:
if (PsiType.NULL.equals(lowerBound)) {
  lowerBound=type;
}
 else if (!lowerBound.equals(type)) {
  lowerBound=GenericsUtil.getLeastUpperBound(lowerBound,type,typeParameter.getManager());
  if (lowerBound == null)   return getFailedInferenceConstraint(typeParameter);
}
break;
case SUBTYPE:
if (PsiType.NULL.equals(upperBound) || TypeConversionUtil.isAssignable(upperBound,type)) {
upperBound=type;
}
}
}
}
if (wildcardToCapture != null) {
if (lowerBound != PsiType.NULL) {
if (!wildcardToCapture.isAssignableFrom(lowerBound)) return getFailedInferenceConstraint(typeParameter);
if (wildcardToCapture.isSuper()) {
return new Pair<PsiType,ConstraintType>(wildcardToCapture,ConstraintType.SUPERTYPE);
}
lowerBound=GenericsUtil.getLeastUpperBound(lowerBound,wildcardToCapture,typeParameter.getManager());
}
 else {
if (upperBound != PsiType.NULL && !upperBound.isAssignableFrom(wildcardToCapture)) return getFailedInferenceConstraint(typeParameter);
return new Pair<PsiType,ConstraintType>(wildcardToCapture,ConstraintType.EQUALS);
}
}
if (rawInference != null) return rawInference;
if (lowerBound != PsiType.NULL) return new Pair<PsiType,ConstraintType>(lowerBound,ConstraintType.EQUALS);
if (parent != null) {
final Pair<PsiType,ConstraintType> constraint=inferMethodTypeParameterFromParent(typeParameter,partialSubstitutor,parent,policy);
if (constraint != null) {
if (constraint.getSecond() != ConstraintType.SUBTYPE) {
return constraint;
}
if (upperBound != PsiType.NULL) {
return new Pair<PsiType,ConstraintType>(upperBound,ConstraintType.SUBTYPE);
}
return constraint;
}
}
if (upperBound != PsiType.NULL) return new Pair<PsiType,ConstraintType>(upperBound,ConstraintType.SUBTYPE);
return null;
}
