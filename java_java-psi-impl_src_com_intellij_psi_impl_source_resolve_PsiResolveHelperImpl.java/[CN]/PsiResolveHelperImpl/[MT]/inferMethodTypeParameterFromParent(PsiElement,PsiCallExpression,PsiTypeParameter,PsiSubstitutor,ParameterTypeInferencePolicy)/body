{
  Pair<PsiType,ConstraintType> constraint=null;
  PsiType expectedType=null;
  if (parent instanceof PsiVariable) {
    if (methodCall.equals(skipParenthesizedExprDown(((PsiVariable)parent).getInitializer()))) {
      expectedType=((PsiVariable)parent).getType();
    }
  }
 else   if (parent instanceof PsiAssignmentExpression) {
    if (methodCall.equals(skipParenthesizedExprDown(((PsiAssignmentExpression)parent).getRExpression()))) {
      expectedType=((PsiAssignmentExpression)parent).getLExpression().getType();
    }
  }
 else   if (parent instanceof PsiReturnStatement) {
    PsiMethod method=PsiTreeUtil.getParentOfType(parent,PsiMethod.class);
    if (method != null) {
      expectedType=method.getReturnType();
    }
  }
 else   if (parent instanceof PsiExpressionList) {
    final PsiElement pParent=parent.getParent();
    if (pParent instanceof PsiCallExpression && parent.equals(((PsiCallExpression)pParent).getArgumentList())) {
      constraint=policy.inferTypeConstraintFromCallContext(methodCall,(PsiExpressionList)parent,(PsiCallExpression)pParent,typeParameter);
    }
  }
  final PsiManager manager=typeParameter.getManager();
  final GlobalSearchScope scope=parent.getResolveScope();
  PsiType returnType=null;
  if (constraint == null) {
    if (expectedType == null) {
      expectedType=policy.getDefaultExpectedType(methodCall);
    }
    returnType=((PsiMethod)typeParameter.getOwner()).getReturnType();
    constraint=getSubstitutionForTypeParameterConstraint(typeParameter,returnType,expectedType,false,PsiUtil.getLanguageLevel(parent));
    if (constraint != null) {
      PsiType guess=constraint.getFirst();
      if (guess != null && !guess.equals(PsiType.NULL) && constraint.getSecond() == ConstraintType.SUPERTYPE && guess instanceof PsiIntersectionType) {
        for (        PsiType conjuct : ((PsiIntersectionType)guess).getConjuncts()) {
          if (!conjuct.isAssignableFrom(expectedType)) {
            return FAILED_INFERENCE;
          }
        }
      }
    }
  }
  final Pair<PsiType,ConstraintType> result;
  if (constraint == null) {
    final PsiSubstitutor finalSubstitutor=substitutor.put(typeParameter,null);
    PsiClassType[] superTypes=typeParameter.getSuperTypes();
    if (superTypes.length == 0)     return null;
    PsiType superType=finalSubstitutor.substitute(superTypes[0]);
    if (superType == null)     superType=PsiType.getJavaLangObject(manager,scope);
    if (superType == null)     return null;
    return policy.getInferredTypeWithNoConstraint(manager,superType);
  }
 else {
    PsiType guess=constraint.getFirst();
    guess=policy.adjustInferredType(manager,guess,constraint.getSecond());
    if (returnType instanceof PsiClassType && typeParameter.equals(((PsiClassType)returnType).resolve())) {
      PsiClassType[] extendsTypes=typeParameter.getExtendsListTypes();
      PsiSubstitutor newSubstitutor=substitutor.put(typeParameter,guess);
      for (      PsiClassType extendsType1 : extendsTypes) {
        PsiType extendsType=newSubstitutor.substitute(extendsType1);
        if (guess != null && !extendsType.isAssignableFrom(guess)) {
          if (guess.isAssignableFrom(extendsType)) {
            guess=extendsType;
            newSubstitutor=substitutor.put(typeParameter,guess);
          }
 else {
            break;
          }
        }
      }
    }
    result=new Pair<PsiType,ConstraintType>(guess,constraint.getSecond());
  }
  return result;
}
