{
  if (!FILE_PROTOCOL_ID.equals(protocolId)) {
    return Collections.emptyList();
  }
  final String normalizedPath=path.replace(File.separatorChar,'/');
  final int lineNoSeparatorIndex=normalizedPath.lastIndexOf(':');
  final String filePath;
  final int lineNumber;
  if (lineNoSeparatorIndex >= 0) {
    final String lineNumStr=normalizedPath.substring(lineNoSeparatorIndex + 1);
    int lineNum=0;
    try {
      lineNum=Integer.parseInt(lineNumStr);
    }
 catch (    NumberFormatException e) {
      LOG.warn(protocolId + ": Malformed location path: " + path,e);
    }
    filePath=normalizedPath.substring(0,lineNoSeparatorIndex);
    lineNumber=lineNum;
  }
 else {
    lineNumber=1;
    filePath=normalizedPath;
  }
  final List<VirtualFile> virtualFiles=LocationProviderUtil.findSuitableFilesFor(filePath);
  if (virtualFiles.isEmpty()) {
    return Collections.emptyList();
  }
  final List<Location> locations=new ArrayList<Location>(2);
  for (  VirtualFile file : virtualFiles) {
    locations.add(createLocationFor(project,file,lineNumber));
  }
  return locations;
}
