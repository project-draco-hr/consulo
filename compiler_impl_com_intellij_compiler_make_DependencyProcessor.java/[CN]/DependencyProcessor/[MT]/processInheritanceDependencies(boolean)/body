{
  final Cache oldCache=myDependencyCache.getCache();
  final Cache newCache=myDependencyCache.getNewClassesCache();
  final boolean becameFinal=!CacheUtils.isFinal(oldCache,myQName) && CacheUtils.isFinal(newCache,myQName);
  final SymbolTable symbolTable=myDependencyCache.getSymbolTable();
  final Set<MemberInfo> removedConcreteMethods=fetchNonAbstractMethods(myRemovedMembers);
  myDependencyCache.getCacheNavigator().walkSubClasses(myQName,new ClassInfoProcessor(){
    public boolean process(    final int subclassQName) throws CacheCorruptedException {
      if (myDependencyCache.isClassInfoMarked(subclassQName)) {
        return true;
      }
      final int subclassId=oldCache.getClassId(subclassQName);
      if (subclassId == Cache.UNKNOWN) {
        return true;
      }
      if (hasRemovedMethods && myIsRemoteInterface && !CacheUtils.isInterface(oldCache,subclassQName)) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: methods were removed from remote interface: "+ myDependencyCache.resolve(myQName));
          }
        }
        return true;
      }
      if (mySuperClassAdded || mySuperInterfaceAdded) {
        if (myDependencyCache.markClass(subclassQName)) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the superlist of "+ myDependencyCache.resolve(myQName)+ " is changed");
          }
        }
        return true;
      }
      if (becameFinal) {
        if (myQName == oldCache.getSuperQualifiedName(subclassId)) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class "+ myDependencyCache.resolve(myQName)+ " was made final");
            }
          }
          return true;
        }
      }
      final int subclassDeclarationId=oldCache.getClassDeclarationId(subclassQName);
      for (      final MemberInfo member : myAddedMembers) {
        if (member instanceof MethodInfo) {
          final MethodInfo method=(MethodInfo)member;
          if (method.isAbstract()) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added abstract method to "+ myDependencyCache.resolve(myQName));
              }
            }
            return true;
          }
          if (!method.isPrivate()) {
            int derivedMethod=oldCache.findMethodsBySignature(subclassDeclarationId,method.getDescriptor(symbolTable),symbolTable);
            if (derivedMethod != Cache.UNKNOWN) {
              if (!method.getReturnTypeDescriptor(symbolTable).equals(CacheUtils.getMethodReturnTypeDescriptor(oldCache,derivedMethod,symbolTable))) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: return types of method "+ method+ " in base and derived classes are different");
                  }
                }
                return true;
              }
              if (MakeUtil.isMoreAccessible(method.getFlags(),oldCache.getMethodFlags(derivedMethod))) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the method "+ method+ " in derived class is less accessible than in base class");
                  }
                }
                return true;
              }
              if (!CacheUtils.areArraysContentsEqual(method.getThrownExceptions(),oldCache.getMethodThrownExceptions(derivedMethod))) {
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: exception lists of "+ method+ " in base and derived classes are different");
                  }
                }
                return true;
              }
            }
            if (hasGenericsNameClashes(method,oldCache,subclassQName)) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: found method with the same name, different generic signature, but the same erasure as "+ method);
                }
              }
              return true;
            }
          }
        }
 else         if (member instanceof FieldInfo) {
          if (oldCache.findFieldByName(subclassDeclarationId,member.getName()) != Cache.UNKNOWN) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: added field "+ member+ " to base class");
              }
            }
            return true;
          }
        }
      }
      for (      final MemberInfo changedMember : myChangedMembers) {
        if (changedMember instanceof MethodInfo) {
          final MethodInfo oldMethod=(MethodInfo)changedMember;
          MethodChangeDescription changeDescription=(MethodChangeDescription)myChangeDescriptions.get(oldMethod);
          if (changeDescription.becameAbstract) {
            if (!ClsUtil.isAbstract(oldCache.getFlags(subclassId))) {
              if (myDependencyCache.markClass(subclassQName)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
                }
              }
              return true;
            }
          }
          final String oldMethodDescriptor=oldMethod.getDescriptor(symbolTable);
          final int derivedMethod=oldCache.findMethodsBySignature(subclassDeclarationId,oldMethodDescriptor,symbolTable);
          if (derivedMethod != Cache.UNKNOWN) {
            if (myDependencyCache.markClass(subclassQName)) {
              if (LOG.isDebugEnabled()) {
                LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method "+ oldMethod);
              }
            }
            return true;
          }
          myDependencyCache.getCacheNavigator().walkSuperInterfaces(subclassQName,new ClassInfoProcessor(){
            boolean found=false;
            public boolean process(            final int ifaceQName) throws CacheCorruptedException {
              if (found) {
                return false;
              }
              final int implementee=oldCache.findMethodsBySignature(oldCache.getClassDeclarationId(ifaceQName),oldMethodDescriptor,symbolTable);
              if (implementee != Cache.UNKNOWN) {
                found=true;
                if (myDependencyCache.markClass(subclassQName)) {
                  if (LOG.isDebugEnabled()) {
                    LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: changed base method, implementing corresponding method inherited from an interface"+ oldMethod);
                  }
                }
              }
              return !found;
            }
          }
);
          if (myDependencyCache.isClassInfoMarked(subclassQName)) {
            return true;
          }
        }
      }
      if (!ClsUtil.isAbstract(oldCache.getFlags(subclassId))) {
        if (hasUnimplementedAbstractMethods(subclassQName,new HashSet<MemberInfo>(removedConcreteMethods))) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent class " + myDependencyCache.resolve(subclassQName) + "; reason: the class should be declared abstract because abstract method implementation was removed from its superclass: "+ myDependencyCache.resolve(myQName));
            }
          }
          return true;
        }
      }
      if (hasRemovedMethods) {
        if (myDependencyCache.hasOverrideAnnotatedMethods(subclassQName,myProject)) {
          if (myDependencyCache.markClass(subclassQName)) {
            if (LOG.isDebugEnabled()) {
              LOG.debug("Mark dependent subclass " + myDependencyCache.resolve(subclassQName) + "; reason: the class has methods annotated with @Override and some methods were changed or removed in a base class"+ myDependencyCache.resolve(myQName));
            }
          }
          return true;
        }
      }
      return true;
    }
  }
);
}
