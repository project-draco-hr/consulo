{
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(myMethodCall.getProject());
  PsiMethodCallExpression element=myMethodCall.getElement();
  PsiReferenceExpression reference=element.getMethodExpression();
  PsiExpressionList argumentList=element.getArgumentList();
  String name=reference.getReferenceName();
  List<PsiMethod> list=new ArrayList<PsiMethod>();
  if (name == null)   return list;
  GlobalSearchScope scope=element.getResolveScope();
  PsiMethod[] methods=cache.getMethodsByNameIfNotMoreThan(name,scope,20);
  List<PsiMethod> applicableList=new ArrayList<PsiMethod>();
  final PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(element.getProject()).getResolveHelper();
  for (  PsiMethod method : methods) {
    ProgressManager.checkCanceled();
    if (JavaCompletionUtil.isInExcludedPackage(method))     continue;
    if (!method.hasModifierProperty(PsiModifier.STATIC))     continue;
    PsiFile file=method.getContainingFile();
    if (file instanceof PsiJavaFile && ((PsiJavaFile)file).getPackageName().length() != 0 && PsiUtil.isAccessible(method,element,method.getContainingClass())) {
      list.add(method);
      PsiSubstitutor substitutorForMethod=resolveHelper.inferTypeArguments(method.getTypeParameters(),method.getParameterList().getParameters(),argumentList.getExpressions(),PsiSubstitutor.EMPTY,element.getParent(),DefaultParameterTypeInferencePolicy.INSTANCE);
      if (PsiUtil.isApplicable(method,substitutorForMethod,argumentList)) {
        applicableList.add(method);
      }
    }
  }
  List<PsiMethod> result=applicableList.isEmpty() ? list : applicableList;
  for (int i=result.size() - 1; i >= 0; i--) {
    ProgressManager.checkCanceled();
    PsiMethod method=result.get(i);
    PsiClass containingClass=method.getContainingClass();
    for (int j=i + 1; j < result.size(); j++) {
      PsiMethod exMethod=result.get(j);
      if (!Comparing.strEqual(exMethod.getName(),method.getName()))       continue;
      PsiClass exContainingClass=exMethod.getContainingClass();
      if (containingClass != null && exContainingClass != null && !Comparing.equal(containingClass.getQualifiedName(),exContainingClass.getQualifiedName()))       continue;
      result.remove(i);
      break;
    }
    if (isExcluded(method)) {
      result.remove(i);
    }
  }
  Collections.sort(result,new PsiProximityComparator(argumentList));
  return result;
}
