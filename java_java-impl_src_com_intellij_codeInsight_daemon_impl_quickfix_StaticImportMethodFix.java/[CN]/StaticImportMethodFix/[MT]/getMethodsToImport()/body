{
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(myMethodCall.getProject());
  final PsiMethodCallExpression element=myMethodCall.getElement();
  PsiReferenceExpression reference=element.getMethodExpression();
  final PsiExpressionList argumentList=element.getArgumentList();
  String name=reference.getReferenceName();
  final List<PsiMethod> list=new ArrayList<PsiMethod>();
  if (name == null)   return list;
  GlobalSearchScope scope=element.getResolveScope();
  final Map<PsiClass,Boolean> possibleClasses=new HashMap<PsiClass,Boolean>();
  final PsiType expectedType=getExpectedType();
  final List<PsiMethod> applicableList=new ArrayList<PsiMethod>();
  final PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(element.getProject()).getResolveHelper();
  final Map<PsiClass,PsiMethod> deprecated=new HashMap<PsiClass,PsiMethod>();
class RegisterMethodsProcessor {
    private void registerMethod(    PsiClass containingClass,    PsiMethod method){
      final Boolean alreadyMentioned=possibleClasses.get(containingClass);
      if (alreadyMentioned == Boolean.TRUE)       return;
      if (alreadyMentioned == null) {
        list.add(method);
        possibleClasses.put(containingClass,false);
      }
      PsiSubstitutor substitutorForMethod=resolveHelper.inferTypeArguments(method.getTypeParameters(),method.getParameterList().getParameters(),argumentList.getExpressions(),PsiSubstitutor.EMPTY,element.getParent(),DefaultParameterTypeInferencePolicy.INSTANCE);
      if (PsiUtil.isApplicable(method,substitutorForMethod,argumentList)) {
        final PsiType returnType=substitutorForMethod.substitute(method.getReturnType());
        if (expectedType == null || returnType == null || TypeConversionUtil.isAssignable(expectedType,returnType)) {
          applicableList.add(method);
          possibleClasses.put(containingClass,true);
        }
      }
    }
  }
  final RegisterMethodsProcessor registrar=new RegisterMethodsProcessor();
  cache.processMethodsWithName(name,scope,new Processor<PsiMethod>(){
    @Override public boolean process(    PsiMethod method){
      ProgressManager.checkCanceled();
      if (JavaCompletionUtil.isInExcludedPackage(method,false) || !method.hasModifierProperty(PsiModifier.STATIC))       return true;
      PsiFile file=method.getContainingFile();
      final PsiClass containingClass=method.getContainingClass();
      if (file instanceof PsiJavaFile && !((PsiJavaFile)file).getPackageName().isEmpty() && PsiUtil.isAccessible(method,element,containingClass)) {
        if (method.isDeprecated()) {
          deprecated.put(containingClass,method);
          return processCondition();
        }
        registrar.registerMethod(containingClass,method);
      }
      return processCondition();
    }
    private boolean processCondition(){
      return (applicableList.isEmpty() ? list : applicableList).size() + deprecated.size() < 50;
    }
  }
);
  for (  Map.Entry<PsiClass,PsiMethod> deprecatedMethod : deprecated.entrySet()) {
    registrar.registerMethod(deprecatedMethod.getKey(),deprecatedMethod.getValue());
  }
  List<PsiMethod> result=applicableList.isEmpty() ? list : applicableList;
  for (int i=result.size() - 1; i >= 0; i--) {
    ProgressManager.checkCanceled();
    PsiMethod method=result.get(i);
    if (isExcluded(method)) {
      result.remove(i);
    }
  }
  Collections.sort(result,new PsiProximityComparator(argumentList));
  return result;
}
