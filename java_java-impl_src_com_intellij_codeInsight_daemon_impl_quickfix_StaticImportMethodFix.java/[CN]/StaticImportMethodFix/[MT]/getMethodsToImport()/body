{
  PsiShortNamesCache cache=PsiShortNamesCache.getInstance(myMethodCall.getProject());
  final PsiMethodCallExpression element=myMethodCall.getElement();
  PsiReferenceExpression reference=element.getMethodExpression();
  final PsiExpressionList argumentList=element.getArgumentList();
  String name=reference.getReferenceName();
  final List<PsiMethod> list=new ArrayList<PsiMethod>();
  if (name == null)   return list;
  GlobalSearchScope scope=element.getResolveScope();
  final PsiType expectedType=getExpectedType();
  final List<PsiMethod> applicableList=new ArrayList<PsiMethod>();
  final PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(element.getProject()).getResolveHelper();
  cache.processMethodsWithName(name,scope,new Processor<PsiMethod>(){
    private final Set<PsiClass> myPossibleClasses=new HashSet<PsiClass>();
    @Override public boolean process(    PsiMethod method){
      ProgressManager.checkCanceled();
      if (JavaCompletionUtil.isInExcludedPackage(method,false) || !method.hasModifierProperty(PsiModifier.STATIC))       return true;
      PsiFile file=method.getContainingFile();
      final PsiClass containingClass=method.getContainingClass();
      if (file instanceof PsiJavaFile && !((PsiJavaFile)file).getPackageName().isEmpty() && PsiUtil.isAccessible(method,element,containingClass)) {
        if (!myPossibleClasses.add(containingClass))         return true;
        list.add(method);
        PsiSubstitutor substitutorForMethod=resolveHelper.inferTypeArguments(method.getTypeParameters(),method.getParameterList().getParameters(),argumentList.getExpressions(),PsiSubstitutor.EMPTY,element.getParent(),DefaultParameterTypeInferencePolicy.INSTANCE);
        if (PsiUtil.isApplicable(method,substitutorForMethod,argumentList)) {
          if (expectedType == null || TypeConversionUtil.isAssignable(expectedType,substitutorForMethod.substitute(method.getReturnType()))) {
            applicableList.add(method);
          }
        }
      }
      return (applicableList.isEmpty() ? list : applicableList).size() < 50;
    }
  }
);
  List<PsiMethod> result=applicableList.isEmpty() ? list : applicableList;
  for (int i=result.size() - 1; i >= 0; i--) {
    ProgressManager.checkCanceled();
    PsiMethod method=result.get(i);
    if (isExcluded(method)) {
      result.remove(i);
    }
  }
  Collections.sort(result,new PsiProximityComparator(argumentList));
  return result;
}
