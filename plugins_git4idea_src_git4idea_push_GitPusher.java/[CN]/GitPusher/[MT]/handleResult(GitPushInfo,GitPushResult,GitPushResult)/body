{
  result.mergeFrom(previousResult);
  if (result.isEmpty()) {
    return;
  }
  if (result.totalSuccess()) {
    int commitsPushed=pushInfo.getCommits().commitsNumber();
    String message="Pushed " + commits(commitsPushed);
    GitVcs.NOTIFICATION_GROUP_ID.createNotification(message,NotificationType.INFORMATION).notify(myProject);
  }
 else   if (result.wasError()) {
    GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification("Push failed",getResultDescriptionWithOptionalReposIndication(pushInfo,result),NotificationType.ERROR,null).notify(myProject);
  }
 else {
    Map<GitRepository,GitBranch> rejectedPushesForCurrentBranch=getRejectedPushesForCurrentBranch(result);
    if (!rejectedPushesForCurrentBranch.isEmpty()) {
      final GitRejectedPushUpdateDialog dialog=new GitRejectedPushUpdateDialog(myProject,rejectedPushesForCurrentBranch.keySet());
      final AtomicInteger exitCode=new AtomicInteger();
      UIUtil.invokeAndWaitIfNeeded(new Runnable(){
        @Override public void run(){
          dialog.show();
          exitCode.set(dialog.getExitCode());
        }
      }
);
      Set<VirtualFile> roots=getRootsToUpdate(rejectedPushesForCurrentBranch,dialog.updateAll());
      boolean pushAgain=false;
switch (exitCode.get()) {
case GitRejectedPushUpdateDialog.MERGE_EXIT_CODE:
        pushAgain=update(roots,true);
      break;
case GitRejectedPushUpdateDialog.REBASE_EXIT_CODE:
    pushAgain=update(roots,false);
  break;
}
if (pushAgain) {
GitPushInfo newPushInfo=new GitPushInfo(pushInfo.getCommits().retainAll(rejectedPushesForCurrentBranch),pushInfo.getPushSpec());
GitPushResult adjustedPushResult=result.remove(rejectedPushesForCurrentBranch);
push(newPushInfo,adjustedPushResult);
return;
}
}
GitVcs.IMPORTANT_ERROR_NOTIFICATION.createNotification("Push rejected",getResultDescriptionWithOptionalReposIndication(pushInfo,result),NotificationType.WARNING,null).notify(myProject);
}
}
