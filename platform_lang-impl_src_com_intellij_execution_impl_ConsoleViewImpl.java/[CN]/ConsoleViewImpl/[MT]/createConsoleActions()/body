{
  final CommonActionsManager actionsManager=CommonActionsManager.getInstance();
  final AnAction prevAction=actionsManager.createPrevOccurenceAction(this);
  prevAction.getTemplatePresentation().setText(getPreviousOccurenceActionName());
  final AnAction nextAction=actionsManager.createNextOccurenceAction(this);
  nextAction.getTemplatePresentation().setText(getNextOccurenceActionName());
  final AnAction switchSoftWrapsAction=new ToggleUseSoftWrapsToolbarAction(SoftWrapAppliancePlaces.CONSOLE){
    /** 
 * There is a possible case that more than console is open and user toggles soft wraps mode at one of them. We want
 * to update another console(s) representation as well when they are switched on after that. Hence, we remember last 
 * used soft wraps mode and perform update if we see that the current value differs from the stored.
 */
    private boolean myLastIsSelected;
    @Override protected Editor getEditor(    AnActionEvent e){
      return myEditor;
    }
    @Override public boolean isSelected(    AnActionEvent e){
      boolean result=super.isSelected(e);
      if (result ^ myLastIsSelected) {
        setSelected(null,result);
      }
      return myLastIsSelected=result;
    }
    @Override public void setSelected(    AnActionEvent e,    final boolean state){
      super.setSelected(e,state);
      final String placeholder=myCommandLineFolding.getPlaceholder(0);
      if (myEditor == null || (state && placeholder == null)) {
        return;
      }
      final FoldingModel foldingModel=myEditor.getFoldingModel();
      FoldRegion[] foldRegions=foldingModel.getAllFoldRegions();
      Runnable foldTask=null;
      final int endFoldRegionOffset=myEditor.getDocument().getLineEndOffset(0);
      Runnable addCollapsedFoldRegionTask=new Runnable(){
        @Override public void run(){
          FoldRegion foldRegion=foldingModel.addFoldRegion(0,endFoldRegionOffset,placeholder == null ? "..." : placeholder);
          if (foldRegion != null) {
            foldRegion.setExpanded(false);
          }
        }
      }
;
      if (foldRegions.length <= 0) {
        if (!state) {
          return;
        }
        foldTask=addCollapsedFoldRegionTask;
      }
 else {
        final FoldRegion foldRegion=foldRegions[0];
        if (foldRegion.getStartOffset() == 0 && foldRegion.getEndOffset() == endFoldRegionOffset) {
          foldTask=new Runnable(){
            @Override public void run(){
              foldRegion.setExpanded(!state);
            }
          }
;
        }
 else         if (state) {
          foldTask=addCollapsedFoldRegionTask;
        }
      }
      if (foldTask != null) {
        foldingModel.runBatchFoldingOperation(foldTask);
      }
    }
  }
;
  final AnAction autoScrollToTheEndAction=new ScrollToTheEndToolbarAction(myEditor);
  final AnAction[] consoleActions=new AnAction[6 + customActions.size()];
  consoleActions[0]=prevAction;
  consoleActions[1]=nextAction;
  consoleActions[2]=switchSoftWrapsAction;
  consoleActions[3]=autoScrollToTheEndAction;
  consoleActions[4]=ActionManager.getInstance().getAction("Print");
  consoleActions[5]=new ClearAllAction();
  for (int i=0; i < customActions.size(); ++i) {
    consoleActions[i + 6]=customActions.get(i);
  }
  ConsoleActionsPostProcessor[] postProcessors=Extensions.getExtensions(ConsoleActionsPostProcessor.EP_NAME);
  AnAction[] result=consoleActions;
  for (  ConsoleActionsPostProcessor postProcessor : postProcessors) {
    result=postProcessor.postProcess(this,result);
  }
  return result;
}
