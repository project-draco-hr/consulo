{
  if (myEditor == null) {
    myEditor=createEditor();
    myHyperlinks=new EditorHyperlinkSupport(myEditor,myProject);
    requestFlushImmediately();
    add(createCenterComponent(),BorderLayout.CENTER);
    myEditor.getDocument().addDocumentListener(new DocumentAdapter(){
      public void documentChanged(      DocumentEvent e){
        if (e.getNewLength() == 0 && e.getOffset() == 0) {
synchronized (LOCK) {
            int toRemoveLen=e.getOldLength();
            int tIndex=findTokenInfoIndexByOffset(toRemoveLen);
            ArrayList<TokenInfo> newTokens=new ArrayList<TokenInfo>(myTokens.subList(tIndex,myTokens.size()));
            for (            TokenInfo token : newTokens) {
              token.startOffset-=toRemoveLen;
              token.endOffset-=toRemoveLen;
            }
            if (!newTokens.isEmpty()) {
              newTokens.get(0).startOffset=0;
            }
            myContentSize-=Math.min(myContentSize,toRemoveLen);
            myTokens=newTokens;
          }
        }
      }
    }
);
    myEditor.getScrollingModel().addVisibleAreaListener(new VisibleAreaListener(){
      @Override public void visibleAreaChanged(      VisibleAreaEvent e){
        final Rectangle oldRectangle=e.getOldRectangle();
        final Rectangle newRectangle=e.getNewRectangle();
        if (oldRectangle == null || newRectangle == null) {
          return;
        }
        if (oldRectangle.height <= 0 && newRectangle.height > 0 && myEditor.getSoftWrapModel().isSoftWrappingEnabled() && myEditor.getCaretModel().getOffset() == myEditor.getDocument().getTextLength()) {
          EditorUtil.scrollToTheEnd(myEditor);
        }
      }
    }
);
  }
  return this;
}
