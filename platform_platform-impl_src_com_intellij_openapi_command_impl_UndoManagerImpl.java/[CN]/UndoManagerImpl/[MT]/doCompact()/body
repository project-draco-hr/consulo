{
  Collection<DocumentReference> refs=collectReferencesWithoutMergers();
  Collection<DocumentReference> openDocs=new HashSet<DocumentReference>();
  for (  DocumentReference each : refs) {
    VirtualFile file=each.getFile();
    if (file == null) {
      Document document=each.getDocument();
      if (document != null && EditorFactory.getInstance().getEditors(document,myProject).length > 0) {
        openDocs.add(each);
      }
    }
 else {
      if (myProject != null && FileEditorManager.getInstance(myProject).isFileOpen(file)) {
        openDocs.add(each);
      }
    }
  }
  refs.removeAll(openDocs);
  if (refs.size() <= FREE_QUEUES_LIMIT)   return;
  DocumentReference[] backSorted=refs.toArray(new DocumentReference[refs.size()]);
  Arrays.sort(backSorted,new Comparator<DocumentReference>(){
    @Override public int compare(    DocumentReference a,    DocumentReference b){
      return getLastCommandTimestamp(a) - getLastCommandTimestamp(b);
    }
  }
);
  for (int i=0; i < backSorted.length - FREE_QUEUES_LIMIT; i++) {
    DocumentReference each=backSorted[i];
    if (getLastCommandTimestamp(each) + COMMANDS_TO_KEEP_LIVE_QUEUES > myCommandTimestamp)     break;
    clearUndoRedoQueue(each);
  }
}
