{
  assertWritable();
  if (!isValid(root))   return;
  VfsUtilCore.visitChildrenRecursively(root,new VirtualFileVisitor(){
    private final Stack<OrderEntry[]> myEntries=new Stack<OrderEntry[]>();
    @Override public boolean visitFile(    @NotNull VirtualFile file){
      if (progress != null) {
        progress.checkCanceled();
      }
      if (!file.isDirectory() && !file.equals(root) || isIgnored(file))       return false;
      int fileId=((NewVirtualFile)file).getId();
      DirectoryInfo info=getInfo(fileId);
      if (info == null)       return false;
      if (module != null) {
        if (info.getModule() != module || !info.isInModuleSource())         return false;
      }
 else       if (libraryClassRoot != null) {
        if (!libraryClassRoot.equals(info.getLibraryClassRoot()) || info.isInModuleSource())         return false;
      }
 else       if (librarySourceRoot != null) {
        if (!info.isInLibrarySource() || !librarySourceRoot.equals(info.getSourceRoot()) || info.hasLibraryClassRoot())         return false;
      }
      OrderEntry[] oldParentEntries=myEntries.isEmpty() ? null : myEntries.peek();
      OrderEntry[] oldEntries=info.getOrderEntries();
      myEntries.push(oldEntries);
      OrderEntry[] newOrderEntries=info.calcNewOrderEntries(orderEntries,parentInfo,oldParentEntries);
      with(fileId,info,null,null,null,null,0,newOrderEntries);
      return true;
    }
    @Override public void afterChildrenVisited(    @NotNull VirtualFile file){
      myEntries.pop();
    }
  }
);
}
