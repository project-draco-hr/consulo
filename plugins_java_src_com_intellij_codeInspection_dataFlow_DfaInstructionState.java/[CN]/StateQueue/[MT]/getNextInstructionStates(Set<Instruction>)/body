{
  DfaInstructionState state=myQueue.poll();
  final Instruction instruction=state.getInstruction();
  mySet.remove(Pair.create(instruction,state.getMemoryState()));
  DfaInstructionState next=myQueue.peek();
  if (next == null || next.compareTo(state) != 0)   return Collections.singletonList(state);
  List<DfaMemoryStateImpl> memoryStates=ContainerUtil.newArrayList();
  memoryStates.add((DfaMemoryStateImpl)state.getMemoryState());
  while (!myQueue.isEmpty() && myQueue.peek().compareTo(state) == 0) {
    DfaMemoryState anotherState=myQueue.poll().getMemoryState();
    mySet.remove(Pair.create(instruction,anotherState));
    memoryStates.add((DfaMemoryStateImpl)anotherState);
  }
  if (memoryStates.size() > 1 && joinInstructions.contains(instruction)) {
    StateMerger merger=new StateMerger();
    while (true) {
      List<DfaMemoryStateImpl> nextStates=merger.mergeByEquality(memoryStates);
      if (nextStates == null)       nextStates=merger.mergeByType(memoryStates);
      if (nextStates == null)       nextStates=merger.mergeByNullability(memoryStates);
      if (nextStates == null)       nextStates=merger.mergeByUnknowns(memoryStates);
      if (nextStates == null)       break;
      memoryStates=nextStates;
    }
  }
  return ContainerUtil.map(memoryStates,new Function<DfaMemoryStateImpl,DfaInstructionState>(){
    @Override public DfaInstructionState fun(    DfaMemoryStateImpl state){
      return new DfaInstructionState(instruction,state);
    }
  }
);
}
