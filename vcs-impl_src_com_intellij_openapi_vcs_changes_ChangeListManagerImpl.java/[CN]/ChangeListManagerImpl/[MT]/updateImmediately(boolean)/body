{
  try {
synchronized (myPendingUpdatesLock) {
      myUpdateInProgress=true;
    }
    if (myDisposed)     throw new DisposedException();
    final VcsDirtyScopeManagerImpl dirtyScopeManager=((VcsDirtyScopeManagerImpl)VcsDirtyScopeManager.getInstance(myProject));
    final boolean wasEverythingDirty=dirtyScopeManager.isEverythingDirty();
    final List<VcsDirtyScope> scopes=dirtyScopeManager.retrieveScopes();
    final VirtualFileHolder unversionedHolder;
    final VirtualFileHolder modifiedWithoutEditingHolder;
    final VirtualFileHolder ignoredHolder;
    final DeletedFilesHolder deletedHolder;
    final SwitchedFileHolder switchedHolder;
    if (wasEverythingDirty) {
      myUpdateException=null;
    }
    if (updateUnversionedFiles) {
      unversionedHolder=myUnversionedFilesHolder.copy();
      deletedHolder=myDeletedFilesHolder.copy();
      modifiedWithoutEditingHolder=myModifiedWithoutEditingHolder.copy();
      ignoredHolder=myIgnoredFilesHolder.copy();
      switchedHolder=mySwitchedFilesHolder.copy();
      if (wasEverythingDirty) {
        unversionedHolder.cleanAll();
        deletedHolder.cleanAll();
        modifiedWithoutEditingHolder.cleanAll();
        ignoredHolder.cleanAll();
        switchedHolder.cleanAll();
      }
    }
 else {
      unversionedHolder=myUnversionedFilesHolder;
      deletedHolder=myDeletedFilesHolder;
      modifiedWithoutEditingHolder=myModifiedWithoutEditingHolder;
      ignoredHolder=myIgnoredFilesHolder;
      switchedHolder=mySwitchedFilesHolder;
    }
    if (wasEverythingDirty) {
      notifyStartProcessingChanges(null);
    }
    for (    final VcsDirtyScope scope : scopes) {
      final AbstractVcs vcs=scope.getVcs();
      if (vcs == null)       continue;
      myCurrentlyUpdatingScope=scope;
      ChangesViewManager.getInstance(myProject).updateProgressText(VcsBundle.message("changes.update.progress.message",vcs.getDisplayName()),false);
      if (!wasEverythingDirty) {
        notifyStartProcessingChanges(scope);
      }
      if (updateUnversionedFiles && !wasEverythingDirty) {
        unversionedHolder.cleanScope(scope);
        deletedHolder.cleanScope(scope);
        modifiedWithoutEditingHolder.cleanScope(scope);
        ignoredHolder.cleanScope(scope);
        switchedHolder.cleanScope(scope);
      }
      try {
        final ChangeProvider changeProvider=vcs.getChangeProvider();
        if (changeProvider != null) {
          try {
            myUpdateChangesProgressIndicator=new EmptyProgressIndicator();
            changeProvider.getChanges(scope,new ChangelistBuilder(){
              public void processChange(              final Change change){
                processChangeInList(change,(ChangeList)null);
              }
              public void processChangeInList(              final Change change,              final String changeListName){
                LocalChangeList list=null;
                if (changeListName != null) {
                  list=findChangeList(changeListName);
                  if (list == null) {
                    list=addChangeList(changeListName,null);
                  }
                }
                processChangeInList(change,list);
              }
              public void processChangeInList(              final Change change,              final ChangeList changeList){
                if (myDisposed)                 throw new DisposedException();
                final String fileName=ChangesUtil.getFilePath(change).getName();
                if (FileTypeManager.getInstance().isFileIgnored(fileName))                 return;
                ApplicationManager.getApplication().runReadAction(new Runnable(){
                  public void run(){
                    if (isUnder(change,scope)) {
                      try {
synchronized (myChangeLists) {
                          if (changeList instanceof LocalChangeListImpl) {
                            ((LocalChangeListImpl)changeList).addChange(change);
                          }
 else {
                            for (                            LocalChangeList list : myChangeLists) {
                              if (list == myDefaultChangelist)                               continue;
                              if (((LocalChangeListImpl)list).processChange(change))                               return;
                            }
                            myDefaultChangelist.processChange(change);
                          }
                        }
                      }
  finally {
                        ChangesViewManager.getInstance(myProject).scheduleRefresh();
                      }
                    }
                  }
                }
);
              }
              public void processUnversionedFile(              VirtualFile file){
                if (file == null || !updateUnversionedFiles)                 return;
                if (myDisposed)                 throw new DisposedException();
                if (ExcludedFileIndex.getInstance(myProject).isExcludedFile(file))                 return;
                if (scope.belongsTo(new FilePathImpl(file))) {
                  if (isIgnoredFile(file)) {
                    ignoredHolder.addFile(file);
                  }
 else {
                    unversionedHolder.addFile(file);
                  }
                  switchedHolder.removeFile(file);
                  ChangesViewManager.getInstance(myProject).scheduleRefresh();
                }
              }
              public void processLocallyDeletedFile(              FilePath file){
                if (!updateUnversionedFiles)                 return;
                if (myDisposed)                 throw new DisposedException();
                if (FileTypeManager.getInstance().isFileIgnored(file.getName()))                 return;
                if (scope.belongsTo(file)) {
                  deletedHolder.addFile(file);
                  ChangesViewManager.getInstance(myProject).scheduleRefresh();
                }
              }
              public void processModifiedWithoutCheckout(              VirtualFile file){
                if (file == null || !updateUnversionedFiles)                 return;
                if (myDisposed)                 throw new DisposedException();
                if (ExcludedFileIndex.getInstance(myProject).isExcludedFile(file))                 return;
                if (scope.belongsTo(new FilePathImpl(file))) {
                  modifiedWithoutEditingHolder.addFile(file);
                  ChangesViewManager.getInstance(myProject).scheduleRefresh();
                }
              }
              public void processIgnoredFile(              VirtualFile file){
                if (file == null || !updateUnversionedFiles)                 return;
                if (myDisposed)                 throw new DisposedException();
                if (ExcludedFileIndex.getInstance(myProject).isExcludedFile(file))                 return;
                if (scope.belongsTo(new FilePathImpl(file))) {
                  ignoredHolder.addFile(file);
                  ChangesViewManager.getInstance(myProject).scheduleRefresh();
                }
              }
              public void processSwitchedFile(              final VirtualFile file,              final String branch,              final boolean recursive){
                if (file == null || !updateUnversionedFiles)                 return;
                if (myDisposed)                 throw new DisposedException();
                if (ExcludedFileIndex.getInstance(myProject).isExcludedFile(file))                 return;
                if (scope.belongsTo(new FilePathImpl(file))) {
                  switchedHolder.addFile(file,branch,recursive);
                }
              }
              public boolean isUpdatingUnversionedFiles(){
                return updateUnversionedFiles;
              }
            }
,myUpdateChangesProgressIndicator);
          }
 catch (          VcsException e) {
            LOG.info(e);
            if (myUpdateException == null) {
              myUpdateException=e;
            }
          }
        }
      }
  finally {
        myCurrentlyUpdatingScope=null;
        if (!myDisposed && !wasEverythingDirty) {
          notifyDoneProcessingChanges();
        }
      }
    }
    if (wasEverythingDirty) {
      notifyDoneProcessingChanges();
    }
    if (updateUnversionedFiles) {
      boolean statusChanged=(!myUnversionedFilesHolder.equals(unversionedHolder)) || (!myDeletedFilesHolder.equals(deletedHolder)) || (!myModifiedWithoutEditingHolder.equals(modifiedWithoutEditingHolder))|| (!myIgnoredFilesHolder.equals(ignoredHolder))|| (!mySwitchedFilesHolder.equals(switchedHolder));
      myUnversionedFilesHolder=unversionedHolder;
      myDeletedFilesHolder=deletedHolder;
      myModifiedWithoutEditingHolder=modifiedWithoutEditingHolder;
      myIgnoredFilesHolder=ignoredHolder;
      mySwitchedFilesHolder=switchedHolder;
      if (statusChanged) {
        myListeners.getMulticaster().unchangedFileStatusChanged();
      }
    }
  }
 catch (  DisposedException e) {
  }
catch (  ProcessCanceledException e) {
  }
catch (  Exception ex) {
    LOG.error(ex);
  }
catch (  AssertionError ex) {
    LOG.error(ex);
  }
 finally {
    myListeners.getMulticaster().changeListUpdateDone();
synchronized (myPendingUpdatesLock) {
      myUpdateInProgress=false;
      myPendingUpdatesLock.notifyAll();
    }
  }
}
