{
  List<Map.Entry<LocalInspectionTool,Collection<String>>> entries=new ArrayList<Map.Entry<LocalInspectionTool,Collection<String>>>(tools.entrySet());
  boolean result=JobUtil.invokeConcurrentlyUnderProgress(entries,indicator,myFailFastOnAcquireReadAction,new Processor<Map.Entry<LocalInspectionTool,Collection<String>>>(){
    @Override public boolean process(    final Map.Entry<LocalInspectionTool,Collection<String>> pair){
      indicator.checkCanceled();
      ApplicationManager.getApplication().assertReadAccessAllowed();
      final LocalInspectionTool tool=pair.getKey();
      final boolean[] applyIncrementally={isOnTheFly};
      ProblemsHolder holder=new ProblemsHolder(iManager,myFile,isOnTheFly){
        @Override public void registerProblem(        @NotNull ProblemDescriptor descriptor){
          super.registerProblem(descriptor);
          if (applyIncrementally[0]) {
            addDescriptorIncrementally(descriptor,tool,indicator);
          }
        }
      }
;
      PsiElementVisitor visitor=createVisitorAndAcceptElements(tool,holder,isOnTheFly,session,elements,pair.getValue());
synchronized (init) {
        init.add(Trinity.create(tool,holder,visitor));
      }
      advanceProgress(1);
      if (holder.hasResults()) {
        appendDescriptors(myFile,holder.getResults(),tool);
      }
      applyIncrementally[0]=false;
      return true;
    }
  }
);
  if (!result)   throw new ProcessCanceledException();
  inspectInjectedPsi(elements,isOnTheFly,indicator,iManager,true,checkDumbAwareness,wrappers);
}
