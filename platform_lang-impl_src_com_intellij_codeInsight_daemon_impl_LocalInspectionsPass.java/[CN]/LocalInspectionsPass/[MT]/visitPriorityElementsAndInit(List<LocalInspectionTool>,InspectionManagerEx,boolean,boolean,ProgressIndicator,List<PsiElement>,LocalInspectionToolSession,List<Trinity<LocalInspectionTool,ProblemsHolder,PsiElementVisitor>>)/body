{
  boolean result=JobUtil.invokeConcurrentlyUnderMyProgress(tools,new Processor<LocalInspectionTool>(){
    public boolean process(    final LocalInspectionTool tool){
      final ProgressManager progressManager=ProgressManager.getInstance();
      indicator.checkCanceled();
      ProgressIndicator localIndicator=progressManager.getProgressIndicator();
      ProgressIndicator original=((ProgressWrapper)localIndicator).getOriginalProgressIndicator();
      LOG.assertTrue(original == indicator,original);
      ApplicationManager.getApplication().assertReadAccessAllowed();
      ProblemsHolder holder=new ProblemsHolder(iManager,myFile,isOnTheFly){
        @Override public void registerProblem(        @NotNull ProblemDescriptor descriptor){
          super.registerProblem(descriptor);
          addDescriptorIncrementally(myDocument,descriptor,tool,ignoreSuppressed,indicator);
        }
      }
;
      PsiElementVisitor elementVisitor=tool.buildVisitor(holder,isOnTheFly,session);
synchronized (init) {
        init.add(Trinity.create(tool,holder,elementVisitor));
      }
      if (elementVisitor == null) {
        LOG.error("Tool " + tool + " must not return null from the buildVisitor() method");
      }
      tool.inspectionStarted(session);
      for (      PsiElement element : elements) {
        indicator.checkCanceled();
        element.accept(elementVisitor);
      }
      advanceProgress(elements.size());
      if (holder.hasResults()) {
        appendDescriptors(myFile,holder.getResults(),tool,ignoreSuppressed);
      }
      return true;
    }
  }
,myFailFastOnAcquireReadAction);
  if (!result)   throw new ProcessCanceledException();
  inspectInjectedPsi(elements,tools,isOnTheFly,ignoreSuppressed,indicator,session);
}
