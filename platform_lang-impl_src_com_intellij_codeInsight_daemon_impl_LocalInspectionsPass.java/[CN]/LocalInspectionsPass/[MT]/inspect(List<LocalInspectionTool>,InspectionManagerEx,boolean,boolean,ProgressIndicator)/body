{
  myFailFastOnAcquireReadAction=failFastOnAcquireReadAction;
  if (tools.isEmpty())   return;
  ArrayList<PsiElement> inside=new ArrayList<PsiElement>();
  ArrayList<PsiElement> outside=new ArrayList<PsiElement>();
  Divider.divideInsideAndOutside(myFile,myStartOffset,myEndOffset,myPriorityRange,inside,outside,HighlightLevelUtil.AnalysisLevel.HIGHLIGHT_AND_INSPECT,true);
  setProgressLimit(1L * tools.size() * 2);
  final LocalInspectionToolSession session=new LocalInspectionToolSession(myFile,myStartOffset,myEndOffset);
  List<Trinity<LocalInspectionTool,ProblemsHolder,PsiElementVisitor>> init=new ArrayList<Trinity<LocalInspectionTool,ProblemsHolder,PsiElementVisitor>>();
  boolean finished=false;
  try {
    visitPriorityElementsAndInit(tools,iManager,isOnTheFly,indicator,inside,session,init);
    visitRestElementsAndCleanup(tools,iManager,isOnTheFly,indicator,outside,session,init);
    finished=true;
  }
  finally {
    if (!finished) {
synchronized (init) {
        for (        Trinity<LocalInspectionTool,ProblemsHolder,PsiElementVisitor> trinity : init) {
          List<ProblemDescriptor> results=trinity.second.getResults();
          if (results != null) {
            for (            ProblemDescriptor pd : results) {
              ((ProblemDescriptorImpl)pd).dispose();
            }
          }
        }
      }
    }
  }
  indicator.checkCanceled();
  myInfos=new ArrayList<HighlightInfo>();
  addHighlightsFromResults(myInfos);
}
