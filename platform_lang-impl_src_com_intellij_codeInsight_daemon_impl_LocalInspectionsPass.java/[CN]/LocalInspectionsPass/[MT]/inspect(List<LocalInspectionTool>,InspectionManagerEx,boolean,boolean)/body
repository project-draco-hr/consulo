{
  if (tools.isEmpty())   return;
  final PsiElement[] elements=getElementsIntersectingRange(myFile,myStartOffset,myEndOffset);
  setProgressLimit(1L * tools.size() * elements.length);
  final LocalInspectionToolSession session=new LocalInspectionToolSession(myFile,myStartOffset,myEndOffset);
  final ProgressIndicator indicator=ProgressManager.getInstance().getProgressIndicator();
  LOG.assertTrue(indicator != null);
  JobUtil.invokeConcurrentlyUnderMyProgress(tools,new Processor<LocalInspectionTool>(){
    public boolean process(    final LocalInspectionTool tool){
      final ProgressManager progressManager=ProgressManager.getInstance();
      indicator.checkCanceled();
      ProgressIndicator localIndicator=progressManager.getProgressIndicator();
      ProgressIndicator original=((ProgressWrapper)localIndicator).getOriginalProgressIndicator();
      LOG.assertTrue(original == indicator,original);
      ApplicationManager.getApplication().assertReadAccessAllowed();
      ProblemsHolder holder=new ProblemsHolder(iManager,myFile,isOnTheFly);
      PsiElementVisitor elementVisitor=tool.buildVisitor(holder,isOnTheFly);
      if (elementVisitor == null) {
        LOG.error("Tool " + tool + " must not return null from the buildVisitor() method");
      }
      tool.inspectionStarted(session);
      for (      PsiElement element : elements) {
        indicator.checkCanceled();
        element.accept(elementVisitor);
      }
      tool.inspectionFinished(session);
      advanceProgress(elements.length);
      if (holder.hasResults()) {
        appendDescriptors(holder.getResults(),tool,ignoreSuppressed,indicator);
      }
      return true;
    }
  }
,"Inspection tools",myPriority);
  indicator.checkCanceled();
  inspectInjectedPsi(elements,tools);
  myInfos=new ArrayList<HighlightInfo>(myDescriptors.size());
  addHighlightsFromDescriptors(myInfos);
  addHighlightsFromInjectedPsiProblems(myInfos);
}
