{
  final Map<MavenProject,MavenProjectChanges> projectsToImportWithChanges;
  final boolean importModuleGroupsRequired;
synchronized (myImportingDataLock) {
    projectsToImportWithChanges=new LinkedHashMap<MavenProject,MavenProjectChanges>(myProjectsToImport);
    myProjectsToImport.clear();
    importModuleGroupsRequired=myImportModuleGroupsRequired;
    myImportModuleGroupsRequired=false;
  }
  final Ref<MavenProjectImporter> importer=new Ref<MavenProjectImporter>();
  final Ref<List<MavenProjectsProcessorTask>> postTasks=new Ref<List<MavenProjectsProcessorTask>>();
  final Runnable r=new Runnable(){
    public void run(){
      MavenProjectImporter projectImporter=new MavenProjectImporter(myProject,myProjectsTree,getFileToModuleMapping(modelsProvider),projectsToImportWithChanges,importModuleGroupsRequired,modelsProvider,getImportingSettings());
      importer.set(projectImporter);
      postTasks.set(projectImporter.importProject());
    }
  }
;
  if (ApplicationManager.getApplication().isDispatchThread()) {
    r.run();
  }
 else {
    MavenUtil.runInBackground(myProject,ProjectBundle.message("maven.project.importing"),false,new MavenTask(){
      public void run(      MavenProgressIndicator indicator) throws MavenProcessCanceledException {
        r.run();
      }
    }
).waitFor();
  }
  VirtualFileManager fm=VirtualFileManager.getInstance();
  if (isNormalProject()) {
    fm.asyncRefresh(null);
  }
 else {
    fm.syncRefresh();
  }
  if (postTasks.get() != null) {
    schedulePostImportTasks(postTasks.get());
  }
  myImportingQueue.restartTimer();
  MavenProjectImporter projectImporter=importer.get();
  if (projectImporter == null)   return Collections.emptyList();
  return projectImporter.getCreatedModules();
}
