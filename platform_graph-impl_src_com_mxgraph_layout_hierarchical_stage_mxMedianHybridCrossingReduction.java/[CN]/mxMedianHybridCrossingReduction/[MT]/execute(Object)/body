{
  mxGraphHierarchyModel model=layout.getModel();
  nestedBestRanks=new mxGraphAbstractHierarchyCell[model.ranks.size()][];
  for (int i=0; i < nestedBestRanks.length; i++) {
    mxGraphHierarchyRank rank=model.ranks.get(new Integer(i));
    nestedBestRanks[i]=new mxGraphAbstractHierarchyCell[rank.size()];
    rank.toArray(nestedBestRanks[i]);
  }
  iterationsWithoutImprovement=0;
  currentBestCrossings=calculateCrossings(model);
  for (int i=0; i < maxIterations && iterationsWithoutImprovement < maxNoImprovementIterations; i++) {
    weightedMedian(i,model);
    transpose(i,model);
    int candidateCrossings=calculateCrossings(model);
    if (candidateCrossings < currentBestCrossings) {
      currentBestCrossings=candidateCrossings;
      iterationsWithoutImprovement=0;
      for (int j=0; j < nestedBestRanks.length; j++) {
        mxGraphHierarchyRank rank=model.ranks.get(new Integer(j));
        Iterator<mxGraphAbstractHierarchyCell> iter=rank.iterator();
        for (int k=0; k < rank.size(); k++) {
          mxGraphAbstractHierarchyCell cell=iter.next();
          nestedBestRanks[j][cell.getGeneralPurposeVariable(j)]=cell;
        }
      }
    }
 else {
      iterationsWithoutImprovement++;
      for (int j=0; j < nestedBestRanks.length; j++) {
        mxGraphHierarchyRank rank=model.ranks.get(new Integer(j));
        Iterator<mxGraphAbstractHierarchyCell> iter=rank.iterator();
        for (int k=0; k < rank.size(); k++) {
          mxGraphAbstractHierarchyCell cell=iter.next();
          cell.setGeneralPurposeVariable(j,k);
        }
      }
    }
    if (currentBestCrossings == 0) {
      break;
    }
  }
  Map<Integer,mxGraphHierarchyRank> ranks=new LinkedHashMap<Integer,mxGraphHierarchyRank>(model.maxRank + 1);
  mxGraphHierarchyRank[] rankList=new mxGraphHierarchyRank[model.maxRank + 1];
  for (int i=0; i < model.maxRank + 1; i++) {
    rankList[i]=new mxGraphHierarchyRank();
    ranks.put(new Integer(i),rankList[i]);
  }
  for (int i=0; i < nestedBestRanks.length; i++) {
    for (int j=0; j < nestedBestRanks[i].length; j++) {
      rankList[i].add(nestedBestRanks[i][j]);
    }
  }
  model.ranks=ranks;
}
