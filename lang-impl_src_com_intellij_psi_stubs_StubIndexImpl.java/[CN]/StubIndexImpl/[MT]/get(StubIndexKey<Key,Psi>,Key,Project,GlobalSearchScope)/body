{
  checkRebuild();
  FileBasedIndex.getInstance().ensureUpToDate(StubUpdatingIndex.INDEX_ID);
  final PersistentFS fs=(PersistentFS)ManagingFS.getInstance();
  final PsiManager psiManager=PsiManager.getInstance(project);
  final List<Psi> result=new ArrayList<Psi>();
  final MyIndex<Key> index=(MyIndex<Key>)myIndices.get(indexKey);
  try {
    try {
      index.getReadLock().lock();
      final ValueContainer<TIntArrayList> container=index.getData(key);
      container.forEach(new ValueContainer.ContainerAction<TIntArrayList>(){
        public void perform(        final int id,        final TIntArrayList value){
          final VirtualFile file=IndexInfrastructure.findFileById(fs,id);
          if (file != null && (scope == null || scope.contains(file))) {
            final PsiFileWithStubSupport psiFile=(PsiFileWithStubSupport)psiManager.findFile(file);
            if (psiFile != null) {
              StubTree stubTree=psiFile.getStubTree();
              if (stubTree == null) {
                stubTree=StubTree.readFromVFile(file);
                if (stubTree != null) {
                  final List<StubElement<?>> plained=stubTree.getPlainList();
                  for (int i=0; i < value.size(); i++) {
                    final StubElement<?> stub=plained.get(value.get(i));
                    final ASTNode tree=psiFile.findTreeForStub(stubTree,stub);
                    if (tree != null) {
                      if (tree.getElementType() == stub.getStubType()) {
                        result.add((Psi)tree.getPsi());
                      }
 else {
                        System.out.println("Oops");
                      }
                    }
                  }
                }
              }
 else {
                final List<StubElement<?>> plained=stubTree.getPlainList();
                for (int i=0; i < value.size(); i++) {
                  result.add((Psi)plained.get(value.get(i)).getPsi());
                }
              }
            }
          }
        }
      }
);
    }
  finally {
      index.getReadLock().unlock();
    }
  }
 catch (  StorageException e) {
    forceRebuild(e);
  }
catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException || cause instanceof StorageException) {
      forceRebuild(e);
    }
 else {
      throw e;
    }
  }
  return result;
}
