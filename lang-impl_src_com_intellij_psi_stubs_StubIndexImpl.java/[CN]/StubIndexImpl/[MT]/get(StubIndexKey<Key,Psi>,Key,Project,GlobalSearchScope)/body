{
  if (myNeedRebuild.getAndSet(false)) {
    StubUpdatingIndex.rebuildStubIndices();
  }
  FileBasedIndex.getInstance().ensureUpToDate(StubUpdatingIndex.INDEX_ID);
  final DirectoryIndex dirIndex=DirectoryIndex.getInstance(project);
  final PersistentFS fs=(PersistentFS)ManagingFS.getInstance();
  final PsiManager psiManager=PsiManager.getInstance(project);
  final List<Psi> result=new ArrayList<Psi>();
  final MyIndex<Key> index=(MyIndex<Key>)myIndices.get(indexKey);
  final Lock lock=index.getReadLock();
  lock.lock();
  try {
    ValueContainer<TIntArrayList> container;
    try {
      container=index.getData(key);
    }
 catch (    StorageException e) {
      LOG.info(e);
      lock.unlock();
      try {
        StubUpdatingIndex.rebuildStubIndices();
      }
  finally {
        lock.lock();
      }
      container=index.getData(key);
    }
    container.forEach(new ValueContainer.ContainerAction<TIntArrayList>(){
      public void perform(      final int id,      final TIntArrayList value){
        final VirtualFile file=IndexInfrastructure.findFileById(dirIndex,fs,id);
        if (file != null && (scope == null || scope.contains(file))) {
          final PsiFileImpl psiFile=(PsiFileImpl)psiManager.findFile(file);
          if (psiFile != null) {
            StubTree stubTree=psiFile.getStubTree();
            if (stubTree == null) {
              stubTree=StubTree.readFromVFile(file,project);
              if (stubTree != null) {
                final List<StubElement<?>> plained=stubTree.getPlainList();
                for (int i=0; i < value.size(); i++) {
                  final StubElement<?> stub=plained.get(value.get(i));
                  final ASTNode tree=psiFile.findTreeForStub(stubTree,stub);
                  result.add((Psi)tree.getPsi());
                }
              }
            }
 else {
              final List<StubElement<?>> plained=stubTree.getPlainList();
              for (int i=0; i < value.size(); i++) {
                result.add((Psi)plained.get(value.get(i)).getPsi());
              }
            }
          }
        }
      }
    }
);
  }
 catch (  StorageException e) {
    myNeedRebuild.set(true);
    LOG.info(e);
  }
catch (  RuntimeException e) {
    final Throwable cause=e.getCause();
    if (cause instanceof IOException || cause instanceof StorageException) {
      myNeedRebuild.set(true);
      LOG.info(e);
    }
    throw e;
  }
 finally {
    lock.unlock();
  }
  return result;
}
