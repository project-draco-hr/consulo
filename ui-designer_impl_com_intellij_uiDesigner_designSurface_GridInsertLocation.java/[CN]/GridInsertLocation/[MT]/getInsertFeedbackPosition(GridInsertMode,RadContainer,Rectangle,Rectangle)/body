{
  final RadAbstractGridLayoutManager manager=container.getGridLayoutManager();
  int[] vGridLines=manager.getVerticalGridLines(container);
  int[] hGridLines=manager.getHorizontalGridLines(container);
  Rectangle rc;
  int w=4;
switch (mode) {
case ColumnBefore:
    rc=new Rectangle(vGridLines[cellRect.x] - w,feedbackRect.y - INSERT_ARROW_SIZE,2 * w,feedbackRect.height + 2 * INSERT_ARROW_SIZE);
  if (cellRect.x > 0 && manager.isGapCell(container,false,cellRect.x - 1)) {
    rc.translate(-(vGridLines[cellRect.x] - vGridLines[cellRect.x - 1]) / 2,0);
  }
break;
case ColumnAfter:
rc=new Rectangle(vGridLines[cellRect.x + cellRect.width + 1] - w,feedbackRect.y - INSERT_ARROW_SIZE,2 * w,feedbackRect.height + 2 * INSERT_ARROW_SIZE);
if (cellRect.x < manager.getGridColumnCount(container) - 1 && manager.isGapCell(container,false,cellRect.x + 1)) {
rc.translate((vGridLines[cellRect.x + 2] - vGridLines[cellRect.x + 1]) / 2,0);
}
break;
case RowBefore:
rc=new Rectangle(feedbackRect.x - INSERT_ARROW_SIZE,hGridLines[cellRect.y] - w,feedbackRect.width + 2 * INSERT_ARROW_SIZE,2 * w);
if (cellRect.y > 0 && manager.isGapCell(container,true,cellRect.y - 1)) {
rc.translate(0,-(hGridLines[cellRect.y] - hGridLines[cellRect.y - 1]) / 2);
}
break;
case RowAfter:
rc=new Rectangle(feedbackRect.x - INSERT_ARROW_SIZE,hGridLines[cellRect.y + cellRect.height + 1] - w,feedbackRect.width + 2 * INSERT_ARROW_SIZE,2 * w);
if (cellRect.y < manager.getGridRowCount(container) - 1 && manager.isGapCell(container,true,cellRect.y + 1)) {
rc.translate(0,(hGridLines[cellRect.y + 2] - hGridLines[cellRect.y + 1]) / 2);
}
break;
default :
return feedbackRect;
}
return rc;
}
