{
  final int insertCol=getColumn();
  final int insertRow=getRow();
  Rectangle cellRect=getGridFeedbackRect(dragObject);
  if (cellRect == null) {
    feedbackLayer.removeFeedback();
    return;
  }
  FeedbackPainter painter=(myMode == GridInsertMode.ColumnBefore || myMode == GridInsertMode.ColumnAfter) ? VertInsertFeedbackPainter.INSTANCE : HorzInsertFeedbackPainter.INSTANCE;
  Rectangle rc;
  Rectangle rcFeedback=null;
  if (dragObject.getComponentCount() == 1 && myMode != GridInsertMode.InCell) {
    RadComponent component=getContainer().getLayoutManager().getComponentAtGrid(getContainer(),insertRow,insertCol);
    if (component != null) {
      Rectangle bounds=component.getBounds();
      int[] vGridLines=getContainer().getLayoutManager().getVerticalGridLines(getContainer());
      int[] hGridLines=getContainer().getLayoutManager().getHorizontalGridLines(getContainer());
      int cellWidth=vGridLines[insertCol + 1] - vGridLines[insertCol];
      int cellHeight=hGridLines[insertRow + 1] - hGridLines[insertRow];
      bounds.translate(-vGridLines[insertCol],-hGridLines[insertRow]);
      int spaceToRight=vGridLines[insertCol + 1] - vGridLines[insertCol] - (bounds.x + bounds.width);
      int spaceBelow=hGridLines[insertRow + 1] - hGridLines[insertRow] - (bounds.y + bounds.height);
      if (myMode == GridInsertMode.RowBefore && bounds.y > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,0,cellWidth,bounds.y);
      }
 else       if (myMode == GridInsertMode.RowAfter && spaceBelow > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,bounds.y + bounds.height,cellWidth,spaceBelow);
      }
 else       if (myMode == GridInsertMode.ColumnBefore && bounds.x > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(0,0,bounds.x,cellHeight);
      }
 else       if (myMode == GridInsertMode.ColumnAfter && spaceToRight > INSERT_RECT_MIN_SIZE) {
        rcFeedback=new Rectangle(bounds.x + bounds.width,0,spaceToRight,cellHeight);
      }
      if (rcFeedback != null) {
        rcFeedback.translate(vGridLines[insertCol],hGridLines[insertRow]);
        feedbackLayer.putFeedback(getContainer().getDelegee(),rcFeedback);
        return;
      }
    }
  }
  int w=4;
switch (myMode) {
case ColumnBefore:
    rc=new Rectangle(cellRect.x - w,cellRect.y - INSERT_ARROW_SIZE,2 * w,cellRect.height + 2 * INSERT_ARROW_SIZE);
  break;
case ColumnAfter:
rc=new Rectangle((int)cellRect.getMaxX() - w,(int)cellRect.getMinY() - INSERT_ARROW_SIZE,2 * w,(int)cellRect.getHeight() + 2 * INSERT_ARROW_SIZE);
break;
case RowBefore:
rc=new Rectangle((int)cellRect.getMinX() - INSERT_ARROW_SIZE,(int)cellRect.getMinY() - w,(int)cellRect.getWidth() + 2 * INSERT_ARROW_SIZE,2 * w);
break;
case RowAfter:
rc=new Rectangle((int)cellRect.getMinX() - INSERT_ARROW_SIZE,(int)cellRect.getMaxY() - w,(int)cellRect.getWidth() + 2 * INSERT_ARROW_SIZE,2 * w);
break;
default :
rc=cellRect;
painter=null;
}
feedbackLayer.putFeedback(getContainer().getDelegee(),rc,painter);
}
