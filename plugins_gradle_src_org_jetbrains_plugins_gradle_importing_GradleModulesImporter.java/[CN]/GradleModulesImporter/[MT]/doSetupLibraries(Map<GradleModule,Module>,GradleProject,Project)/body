{
  Application application=ApplicationManager.getApplication();
  application.assertWriteAccessAllowed();
  LibraryTable projectLibraryTable=ProjectLibraryTable.getInstance(intellijProject);
  if (projectLibraryTable == null) {
    GradleLog.LOG.warn("Can't resolve external dependencies of the target gradle project (" + intellijProject + "). Reason: project "+ "library table is undefined");
    return;
  }
  LibraryTable.ModifiableModel model=projectLibraryTable.getModifiableModel();
  try {
    for (    Library library : model.getLibraries()) {
      model.removeLibrary(library);
    }
  }
  finally {
    model.commit();
  }
  model=projectLibraryTable.getModifiableModel();
  List<ModifiableRootModel> modelsToCommit=new ArrayList<ModifiableRootModel>();
  Map<GradleLibrary,Library> libraryMappings=registerProjectLibraries(gradleProject,model);
  final GradleProjectEntityImportListener publisher=intellijProject.getMessageBus().syncPublisher(GradleProjectEntityImportListener.TOPIC);
  try {
    if (libraryMappings == null) {
      return;
    }
    for (    GradleLibrary library : libraryMappings.keySet()) {
      publisher.onImportStart(library);
    }
    modelsToCommit.addAll(configureModulesLibraryDependencies(moduleMappings,libraryMappings,gradleProject));
  }
  finally {
    model.commit();
    ProjectRootManager projectRootManager=ProjectRootManager.getInstance(intellijProject);
    ModifiableRootModel[] modelsAsArray=modelsToCommit.toArray(new ModifiableRootModel[modelsToCommit.size()]);
    projectRootManager.multiCommit(modelsAsArray);
    if (libraryMappings != null) {
      for (      GradleLibrary library : libraryMappings.keySet()) {
        publisher.onImportEnd(library);
      }
    }
  }
}
