{
  CallbackGenerator[] generators=CallbackInfo.getGenerators(callbackTypes);
  Map groups=new HashMap();
  final Map indexes=new HashMap();
  final Map originalModifiers=new HashMap();
  final Map positions=CollectionUtils.getIndexMap(methods);
  Iterator it1=methods.iterator();
  Iterator it2=(actualMethods != null) ? actualMethods.iterator() : null;
  while (it1.hasNext()) {
    MethodInfo method=(MethodInfo)it1.next();
    Method actualMethod=(it2 != null) ? (Method)it2.next() : null;
    int index=filter.accept(actualMethod);
    if (index >= callbackTypes.length) {
      throw new IllegalArgumentException("Callback filter returned an index that is too large: " + index);
    }
    originalModifiers.put(method,new Integer((actualMethod != null) ? actualMethod.getModifiers() : method.getModifiers()));
    indexes.put(method,new Integer(index));
    List group=(List)groups.get(generators[index]);
    if (group == null) {
      groups.put(generators[index],group=new ArrayList(methods.size()));
    }
    group.add(method);
  }
  Set seenGen=new HashSet();
  CodeEmitter se=ce.getStaticHook();
  se.new_instance(THREAD_LOCAL);
  se.dup();
  se.invoke_constructor(THREAD_LOCAL,CSTRUCT_NULL);
  se.putfield(THREAD_CALLBACKS_FIELD);
  final Object[] state=new Object[1];
  CallbackGenerator.Context context=new CallbackGenerator.Context(){
    public int getOriginalModifiers(    MethodInfo method){
      return ((Integer)originalModifiers.get(method)).intValue();
    }
    public int getIndex(    MethodInfo method){
      return ((Integer)indexes.get(method)).intValue();
    }
    public void emitCallback(    CodeEmitter e,    int index){
      emitCurrentCallback(e,index);
    }
    public Signature getImplSignature(    MethodInfo method){
      return rename(method.getSignature(),((Integer)positions.get(method)).intValue());
    }
    public CodeEmitter beginMethod(    ClassEmitter ce,    MethodInfo method){
      CodeEmitter e=EmitUtils.begin_method(ce,method);
      if (!interceptDuringConstruction && !TypeUtils.isAbstract(method.getModifiers())) {
        Label constructed=e.make_label();
        e.load_this();
        e.getfield(CONSTRUCTED_FIELD);
        e.if_jump(e.NE,constructed);
        e.load_this();
        e.load_args();
        e.super_invoke();
        e.return_value();
        e.mark(constructed);
      }
      return e;
    }
  }
;
  for (int i=0; i < callbackTypes.length; i++) {
    CallbackGenerator gen=generators[i];
    if (!seenGen.contains(gen)) {
      seenGen.add(gen);
      final List fmethods=(List)groups.get(gen);
      if (fmethods != null) {
        try {
          gen.generate(ce,context,fmethods);
          gen.generateStatic(se,context,fmethods);
        }
 catch (        RuntimeException x) {
          throw x;
        }
catch (        Exception x) {
          throw new CodeGenerationException(x);
        }
      }
    }
  }
  se.return_value();
  se.end_method();
}
