def copies(repo, c1, c2, ca, checkdirs=False):
    '\n    Find moves and copies between context c1 and c2\n    '
    if ((not c1) or (not c2) or (c1 == c2)):
        return ({}, {})
    if ((c2.node() is None) and (c1.node() == repo.dirstate.parents()[0])):
        return (repo.dirstate.copies(), {})
    limit = _findlimit(repo, c1.rev(), c2.rev())
    if (limit is None):
        return ({}, {})
    m1 = c1.manifest()
    m2 = c2.manifest()
    ma = ca.manifest()

    def makectx(f, n):
        if (len(n) != 20):
            if (c1.rev() is None):
                return c1.filectx(f)
            return c2.filectx(f)
        return repo.filectx(f, fileid=n)
    ctx = util.lrucachefunc(makectx)
    copy = {}
    fullcopy = {}
    diverge = {}

    def related(f1, f2, limit):
        if (f1 == f2):
            return f1
        (g1, g2) = (f1.ancestors(), f2.ancestors())
        try:
            (f1r, f2r) = (f1.rev(), f2.rev())
            if (f1r is None):
                f1 = g1.next()
            if (f2r is None):
                f2 = g2.next()
            while 1:
                (f1r, f2r) = (f1.rev(), f2.rev())
                if (f1r > f2r):
                    f1 = g1.next()
                elif (f2r > f1r):
                    f2 = g2.next()
                elif (f1 == f2):
                    return f1
                elif ((f1r == f2r) or (f1r < limit) or (f2r < limit)):
                    return False
        except StopIteration:
            return False

    def checkcopies(f, m1, m2):
        'check possible copies of f from m1 to m2'
        of = None
        seen = set([f])
        for oc in ctx(f, m1[f]).ancestors():
            ocr = oc.rev()
            of = oc.path()
            if (of in seen):
                if (ocr < limit):
                    break
                continue
            seen.add(of)
            fullcopy[f] = of
            if (of not in m2):
                continue
            if (m2[of] == ma.get(of)):
                break
            c2 = ctx(of, m2[of])
            cr = related(oc, c2, ca.rev())
            if (cr and ((of == f) or (of == c2.path()))):
                copy[f] = of
                of = None
                break
        if (of in ma):
            diverge.setdefault(of, []).append(f)
    repo.ui.debug(('  searching for copies back to rev %d\n' % limit))
    u1 = _nonoverlap(m1, m2, ma)
    u2 = _nonoverlap(m2, m1, ma)
    if u1:
        repo.ui.debug(('  unmatched files in local:\n   %s\n' % '\n   '.join(u1)))
    if u2:
        repo.ui.debug(('  unmatched files in other:\n   %s\n' % '\n   '.join(u2)))
    for f in u1:
        checkcopies(f, m1, m2)
    for f in u2:
        checkcopies(f, m2, m1)
    diverge2 = set()
    for (of, fl) in diverge.items():
        if (len(fl) == 1):
            del diverge[of]
        else:
            diverge2.update(fl)
    if fullcopy:
        repo.ui.debug('  all copies found (* = to merge, ! = divergent):\n')
        for f in fullcopy:
            note = ''
            if (f in copy):
                note += '*'
            if (f in diverge2):
                note += '!'
            repo.ui.debug(('   %s -> %s %s\n' % (f, fullcopy[f], note)))
    del diverge2
    if ((not fullcopy) or (not checkdirs)):
        return (copy, diverge)
    repo.ui.debug('  checking for directory renames\n')
    (d1, d2) = (_dirs(m1), _dirs(m2))
    invalid = set()
    dirmove = {}
    for (dst, src) in fullcopy.iteritems():
        (dsrc, ddst) = (_dirname(src), _dirname(dst))
        if (dsrc in invalid):
            continue
        elif ((dsrc in d1) and (ddst in d1)):
            invalid.add(dsrc)
        elif ((dsrc in d2) and (ddst in d2)):
            invalid.add(dsrc)
        elif ((dsrc in dirmove) and (dirmove[dsrc] != ddst)):
            invalid.add(dsrc)
        else:
            dirmove[(dsrc + '/')] = (ddst + '/')
    for i in invalid:
        if (i in dirmove):
            del dirmove[i]
    del d1, d2, invalid
    if (not dirmove):
        return (copy, diverge)
    for d in dirmove:
        repo.ui.debug(('  dir %s -> %s\n' % (d, dirmove[d])))
    for f in (u1 + u2):
        if (f not in fullcopy):
            for d in dirmove:
                if f.startswith(d):
                    df = (dirmove[d] + f[len(d):])
                    if (df not in copy):
                        copy[f] = df
                        repo.ui.debug(('  file %s -> %s\n' % (f, copy[f])))
                    break
    return (copy, diverge)
