{
  ArrayList<String> conflicts=new ArrayList<String>();
  GrMemberOwner owner=helper.getOwner();
  PsiMethod[] methods=ArrayUtil.mergeArrays(owner.getAllMethods(),new PsiMethod[]{method},PsiMethod.ARRAY_FACTORY);
  final Map<PsiMethod,List<PsiMethod>> map=DuplicatesUtil.factorDuplicates(methods,new TObjectHashingStrategy<PsiMethod>(){
    public int computeHashCode(    PsiMethod method){
      return method.getSignature(PsiSubstitutor.EMPTY).hashCode();
    }
    public boolean equals(    PsiMethod method1,    PsiMethod method2){
      return method1.getSignature(PsiSubstitutor.EMPTY).equals(method2.getSignature(PsiSubstitutor.EMPTY));
    }
  }
);
  List<PsiMethod> list=map.get(method);
  if (list == null)   return true;
  for (  PsiMethod psiMethod : list) {
    if (psiMethod != method) {
      PsiClass containingClass=psiMethod.getContainingClass();
      if (containingClass == null)       return true;
      String message=containingClass instanceof GroovyScriptClass ? GroovyRefactoringBundle.message("method.is.already.defined.in.script",GroovyRefactoringUtil.getMethodSignature(method),CommonRefactoringUtil.htmlEmphasize(containingClass.getQualifiedName())) : GroovyRefactoringBundle.message("method.is.already.defined.in.class",GroovyRefactoringUtil.getMethodSignature(method),CommonRefactoringUtil.htmlEmphasize(containingClass.getQualifiedName()));
      conflicts.add(message);
    }
  }
  return conflicts.size() <= 0 || reportConflicts(conflicts,helper.getProject());
}
