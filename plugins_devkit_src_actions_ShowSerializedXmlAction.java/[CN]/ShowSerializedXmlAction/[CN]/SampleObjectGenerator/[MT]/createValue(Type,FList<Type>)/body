{
  if (types.contains(type))   return null;
  FList<Type> processedTypes=types.prepend(type);
  final Class<?> valueClass=type instanceof Class ? (Class<Object>)type : (Class<Object>)((ParameterizedType)type).getRawType();
  if (String.class.isAssignableFrom(valueClass)) {
    return "value" + (myNum++);
  }
 else   if (byte.class.isAssignableFrom(valueClass) || Byte.class.isAssignableFrom(valueClass) || short.class.isAssignableFrom(valueClass)|| Short.class.isAssignableFrom(valueClass)|| int.class.isAssignableFrom(valueClass)|| Integer.class.isAssignableFrom(valueClass)|| long.class.isAssignableFrom(valueClass)|| Long.class.isAssignableFrom(valueClass)) {
    return myNum++ % 127;
  }
 else   if (double.class.isAssignableFrom(valueClass) || Double.class.isAssignableFrom(valueClass) || float.class.isAssignableFrom(valueClass)|| Float.class.isAssignableFrom(valueClass)) {
    return 0.5 + myNum++;
  }
 else   if (boolean.class.isAssignableFrom(valueClass) || Boolean.class.isAssignableFrom(valueClass)) {
    return (myNum++ % 2) == 0;
  }
 else   if (valueClass.isEnum()) {
    final Object[] constants=valueClass.getEnumConstants();
    return constants[(myNum++) % constants.length];
  }
 else   if (Collection.class.isAssignableFrom(valueClass) && type instanceof ParameterizedType) {
    return createCollection(valueClass,(ParameterizedType)type,processedTypes);
  }
 else   if (Map.class.isAssignableFrom(valueClass) && type instanceof ParameterizedType) {
    return createMap((ParameterizedType)type,processedTypes);
  }
 else   if (valueClass.isArray()) {
    return createArray(valueClass,processedTypes);
  }
 else   if (Element.class.isAssignableFrom(valueClass)) {
    return new Element("customElement" + (myNum++)).setAttribute("attribute","value" + (myNum++)).addContent(new Element("child" + (myNum++)));
  }
 else {
    return createObject(valueClass,processedTypes);
  }
}
