{
  if (updateStack.contains(mavenProject)) {
    MavenLog.LOG.info("Recursion detected in " + mavenProject.getFile());
    return;
  }
  updateStack.push(mavenProject);
  process.setText(ProjectBundle.message("maven.reading.pom",mavenProject.getPath()));
  process.setText2("");
  List<MavenProject> prevModules=getModules(mavenProject);
  Set<MavenProject> prevInheritors=new HashSet<MavenProject>();
  if (!isNew) {
    prevInheritors.addAll(findInheritors(mavenProject));
  }
  MavenProjectTimestamp timestamp=calculateTimestamp(mavenProject,explicitProfiles,generalSettings);
  boolean isChanged=force || !timestamp.equals(myTimestamps.get(mavenProject));
  MavenProjectChanges changes=force ? MavenProjectChanges.ALL : MavenProjectChanges.NONE;
  if (isChanged) {
    writeLock();
    try {
      if (!isNew) {
        clearIDMaps(mavenProject);
      }
    }
  finally {
      writeUnlock();
    }
    MavenId oldParentId=mavenProject.getParentId();
    changes=changes.mergedWith(mavenProject.read(generalSettings,explicitProfiles,reader,myProjectLocator));
    writeLock();
    try {
      myVirtualFileToProjectMapping.put(mavenProject.getFile(),mavenProject);
      fillIDMaps(mavenProject);
    }
  finally {
      writeUnlock();
    }
    if (!Comparing.equal(oldParentId,mavenProject.getParentId())) {
      timestamp=calculateTimestamp(mavenProject,explicitProfiles,generalSettings);
    }
    myTimestamps.put(mavenProject,timestamp);
  }
  boolean reconnected=isNew;
  if (isNew) {
    connect(aggregator,mavenProject);
  }
 else {
    reconnected=reconnect(aggregator,mavenProject);
  }
  if (isChanged || reconnected) {
    updateContext.update(mavenProject,changes);
  }
  List<VirtualFile> existingModuleFiles=mavenProject.getExistingModuleFiles();
  List<MavenProject> modulesToRemove=new ArrayList<MavenProject>();
  List<MavenProject> modulesToBecomeRoots=new ArrayList<MavenProject>();
  for (  MavenProject each : prevModules) {
    VirtualFile moduleFile=each.getFile();
    if (!existingModuleFiles.contains(moduleFile)) {
      if (isManagedFile(moduleFile)) {
        modulesToBecomeRoots.add(each);
      }
 else {
        modulesToRemove.add(each);
      }
    }
  }
  for (  MavenProject each : modulesToRemove) {
    removeModule(mavenProject,each);
    doDelete(mavenProject,each,updateContext);
    prevInheritors.removeAll(updateContext.deletedProjects);
  }
  for (  MavenProject each : modulesToBecomeRoots) {
    if (reconnect(null,each))     updateContext.update(each,MavenProjectChanges.NONE);
  }
  for (  VirtualFile each : existingModuleFiles) {
    MavenProject module=findProject(each);
    boolean isNewModule=module == null;
    if (isNewModule) {
      module=new MavenProject(each);
    }
 else {
      MavenProject currentAggregator=findAggregator(module);
      if (currentAggregator != null && currentAggregator != mavenProject) {
        MavenLog.LOG.info("Module " + each + " is already included into "+ mavenProject.getFile());
        continue;
      }
    }
    if (isChanged || isNewModule || recursive) {
      doUpdate(module,mavenProject,isNewModule,recursive,recursive ? force : false,explicitProfiles,updateContext,updateStack,reader,generalSettings,process);
    }
 else {
      if (reconnect(mavenProject,module)) {
        updateContext.update(module,MavenProjectChanges.NONE);
      }
    }
  }
  prevInheritors.addAll(findInheritors(mavenProject));
  for (  MavenProject each : prevInheritors) {
    doUpdate(each,findAggregator(each),false,false,false,explicitProfiles,updateContext,updateStack,reader,generalSettings,process);
  }
  updateStack.pop();
}
