{
  p.checkCanceled();
  p.setText(ProjectBundle.message("maven.reading",project.getPath()));
  p.setText2("");
  List<MavenProjectModel> prevModules=getModules(project);
  Set<MavenProjectModel> prevInheritors=isNew ? new HashSet<MavenProjectModel>() : findInheritors(project);
  if (!readFiles.contains(project.getFile())) {
    if (!isNew)     myMavenIdToProject.remove(project.getMavenId());
    project.read(embedder,myProfiles);
    myMavenIdToProject.put(project.getMavenId(),project);
    readFiles.add(project.getFile());
  }
  reconnect(aggregator,project);
  if (isNew) {
    fireAdded(project);
  }
 else {
    fireUpdated(project);
  }
  List<VirtualFile> existingModuleFiles=project.getExistingModuleFiles();
  List<MavenProjectModel> modulesToRemove=new ArrayList<MavenProjectModel>();
  for (  MavenProjectModel each : prevModules) {
    if (!existingModuleFiles.contains(each.getFile())) {
      modulesToRemove.add(each);
    }
  }
  for (  MavenProjectModel each : modulesToRemove) {
    removeModule(project,each);
    List<MavenProjectModel> removedProjects=new ArrayList<MavenProjectModel>();
    doRemove(project,each,removedProjects);
    prevInheritors.removeAll(removedProjects);
  }
  for (  VirtualFile each : existingModuleFiles) {
    MavenProjectModel child=findProject(each);
    boolean isNewChildProject=child == null;
    if (isNewChildProject) {
      child=new MavenProjectModel(each);
    }
 else {
      MavenProjectModel currentAggregator=findAggregator(child);
      if (currentAggregator != null && currentAggregator != project) {
        MavenLog.LOG.info("Module " + each + " is already included into "+ project.getFile());
        continue;
      }
    }
    if (isNewChildProject || force) {
      doUpdate(project,child,embedder,true,readFiles,p,force);
    }
 else {
      reconnect(project,child);
    }
  }
  prevInheritors.addAll(findInheritors(project));
  for (  MavenProjectModel each : prevInheritors) {
    doUpdate(findAggregator(each),each,embedder,false,readFiles,p,force);
  }
}
