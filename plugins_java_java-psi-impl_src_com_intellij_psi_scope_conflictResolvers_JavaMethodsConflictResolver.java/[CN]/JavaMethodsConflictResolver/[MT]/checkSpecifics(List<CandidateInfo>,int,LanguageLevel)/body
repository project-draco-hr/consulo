{
  final boolean applicable=applicabilityLevel > MethodCandidateInfo.ApplicabilityLevel.NOT_APPLICABLE;
  int conflictsCount=conflicts.size();
  if (applicable) {
    final CandidateInfo[] newConflictsArray=conflicts.toArray(new CandidateInfo[conflicts.size()]);
    for (int i=1; i < conflictsCount; i++) {
      final CandidateInfo method=newConflictsArray[i];
      for (int j=0; j < i; j++) {
        ProgressManager.checkCanceled();
        final CandidateInfo conflict=newConflictsArray[j];
        if (checkSameConflicts(method,conflict))         continue;
switch (isMoreSpecific(method,conflict,applicabilityLevel,languageLevel)) {
case FIRST:
          conflicts.remove(conflict);
        break;
case SECOND:
      conflicts.remove(method);
    break;
case NEITHER:
  break;
}
}
}
}
}
