{
  IndentData indent=calculateAlignIndent(context.alignment,context.targetBlock);
  if (indent == null) {
    return Result.TARGET_BLOCK_PROCESSED_NOT_ALIGNED;
  }
  WhiteSpace whiteSpace=context.targetBlock.getWhiteSpace();
  if (whiteSpace.containsLineFeeds()) {
    whiteSpace.setSpaces(indent.getSpaces(),indent.getIndentSpaces());
    return Result.TARGET_BLOCK_ALIGNED;
  }
  IndentData indentBeforeBlock=context.targetBlock.getNumberOfSymbolsBeforeBlock();
  int diff=indent.getTotalSpaces() - indentBeforeBlock.getTotalSpaces();
  if (diff == 0) {
    return Result.TARGET_BLOCK_ALIGNED;
  }
  if (diff > 0) {
    whiteSpace.setSpaces(whiteSpace.getSpaces() + diff,whiteSpace.getIndentSpaces());
    if (!whiteSpace.containsLineFeeds()) {
      whiteSpace.setForceSkipTabulationsUsage(true);
    }
    return Result.TARGET_BLOCK_ALIGNED;
  }
  if (!context.alignment.isAllowBackwardShift()) {
    return Result.TARGET_BLOCK_PROCESSED_NOT_ALIGNED;
  }
  LeafBlockWrapper offsetResponsibleBlock=context.alignment.getOffsetRespBlockBefore(context.targetBlock);
  if (offsetResponsibleBlock == null) {
    return Result.TARGET_BLOCK_PROCESSED_NOT_ALIGNED;
  }
  context.backwardAlignmentTarget=offsetResponsibleBlock;
  if (offsetResponsibleBlock.getWhiteSpace().isIsReadOnly()) {
    return Result.UNABLE_TO_ALIGN_BACKWARD_BLOCK;
  }
  if (!allowBackwardAlignment(context)) {
    return Result.UNABLE_TO_ALIGN_BACKWARD_BLOCK;
  }
  Set<LeafBlockWrapper> blocksCausedRealignment=context.backwardShiftedAlignedBlocks.get(offsetResponsibleBlock);
  if (blocksCausedRealignment != null && blocksCausedRealignment.contains(context.targetBlock)) {
    LOG.error(String.format("Formatting error - code block %s is set to be shifted right because of its alignment with " + "block %s more than once. I.e. moving the former block because of alignment algorithm causes " + "subsequent block to be shifted right as well - cyclic dependency",offsetResponsibleBlock.getTextRange(),context.targetBlock.getTextRange()));
    blocksCausedRealignment.add(context.targetBlock);
    return Result.UNABLE_TO_ALIGN_BACKWARD_BLOCK;
  }
  WhiteSpace previousWhiteSpace=offsetResponsibleBlock.getWhiteSpace();
  previousWhiteSpace.setSpaces(previousWhiteSpace.getSpaces() - diff,previousWhiteSpace.getIndentOffset());
  if (!previousWhiteSpace.containsLineFeeds()) {
    previousWhiteSpace.setForceSkipTabulationsUsage(true);
  }
  return Result.BACKWARD_BLOCK_ALIGNED;
}
