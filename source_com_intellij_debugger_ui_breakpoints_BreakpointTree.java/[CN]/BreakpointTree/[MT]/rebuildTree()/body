{
  final TreeStateSnapshot treeStateSnapshot=new TreeStateSnapshot(this);
  myRootNode.removeAllChildren();
  myDescriptorToNodeMap.clear();
  myDescriptorToNodeMap.put((TreeDescriptor)myRootNode.getUserObject(),myRootNode);
  for (Iterator<Breakpoint> it=myBreakpoints.iterator(); it.hasNext(); ) {
    final Breakpoint breakpoint=it.next();
    CheckedTreeNode node=createNode(new BreakpointDescriptor(breakpoint));
    node.setChecked(breakpoint.ENABLED);
    addNode(node);
  }
  final int count=myRootNode.getChildCount();
  final List<CheckedTreeNode> children=new ArrayList<CheckedTreeNode>();
  for (int idx=0; idx < count; idx++) {
    CheckedTreeNode child=(CheckedTreeNode)myRootNode.getChildAt(idx);
    if (!(child.getUserObject() instanceof PackageDescriptor)) {
      children.add(child);
      continue;
    }
    while (child.getUserObject() instanceof PackageDescriptor && child.getChildCount() <= 1) {
      child=(CheckedTreeNode)child.getChildAt(0);
    }
    if (!(child.getUserObject() instanceof PackageDescriptor)) {
      child=(CheckedTreeNode)child.getParent();
    }
    for (CheckedTreeNode childToRemove=(CheckedTreeNode)child.getParent(); !childToRemove.equals(myRootNode); childToRemove=(CheckedTreeNode)childToRemove.getParent()) {
      myDescriptorToNodeMap.remove(childToRemove.getUserObject());
    }
    children.add(child);
  }
  for (Iterator<CheckedTreeNode> it=children.iterator(); it.hasNext(); ) {
    it.next().removeFromParent();
  }
  myRootNode.removeAllChildren();
  for (Iterator<CheckedTreeNode> it=children.iterator(); it.hasNext(); ) {
    final CheckedTreeNode child=it.next();
    myRootNode.add(child);
  }
  ((DefaultTreeModel)getModel()).nodeStructureChanged(myRootNode);
  treeStateSnapshot.restore(this);
  expandPath(new TreePath(myRootNode));
}
