{
  final TextRange textRange=rootBlock.getTextRange();
  final int blockStartOffset=textRange.getStartOffset();
  myCurrentWhiteSpace.append(blockStartOffset,myModel);
  boolean isReadOnly=isReadOnly(textRange);
  final BlockWrapper info=new BlockWrapper(rootBlock,myCurrentWhiteSpace,myModel,myPreviousBlock,index,myResult,isReadOnly,textRange);
  myResult.put(rootBlock,info);
  final List<Block> subBlocks=rootBlock.getSubBlocks();
  if (subBlocks.isEmpty() || isReadOnly) {
    LOG.assertTrue(textRange.getLength() > 0);
    if (myPreviousBlock != null) {
      myPreviousBlock.setNextBlock(info);
    }
    if (myFirstTokenBlock == null) {
      myFirstTokenBlock=info;
    }
    if (currentWhiteSpaceIsRreadOnly()) {
      myCurrentWhiteSpace.setReadOnly();
    }
    myCurrentWhiteSpace=new WhiteSpace(textRange.getEndOffset(),textRange.getEndOffset(),0,0,false);
    myPreviousBlock=info;
  }
 else {
    Block previous=null;
    for (int i=0; i < subBlocks.size(); i++) {
      final Block block=subBlocks.get(i);
      if (previous != null) {
        myCurrentSpaceProperty=rootBlock.getSpaceProperty(previous,block);
      }
      buildFrom(block,i);
      previous=block;
    }
  }
}
