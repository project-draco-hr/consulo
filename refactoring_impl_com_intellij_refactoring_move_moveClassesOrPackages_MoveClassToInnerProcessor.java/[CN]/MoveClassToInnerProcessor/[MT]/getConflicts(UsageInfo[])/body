{
  List<String> conflicts=new ArrayList<String>();
  if (myTargetClass.findInnerClassByName(myClassToMove.getName(),false) != null) {
    conflicts.add(RefactoringBundle.message("move.to.inner.duplicate.inner.class",CommonRefactoringUtil.htmlEmphasize(myTargetClass.getQualifiedName()),CommonRefactoringUtil.htmlEmphasize(myClassToMove.getName())));
  }
  String classToMoveVisibility=VisibilityUtil.getVisibilityModifier(myClassToMove.getModifierList());
  String targetClassVisibility=VisibilityUtil.getVisibilityModifier(myTargetClass.getModifierList());
  boolean moveToOtherPackage=!Comparing.equal(mySourcePackage,myTargetPackage);
  if (moveToOtherPackage) {
    PsiElement[] elementsToMove=new PsiElement[]{myClassToMove};
    myClassToMove.accept(new PackageLocalsUsageCollector(elementsToMove,new PackageWrapper(myTargetPackage),conflicts));
  }
  ConflictsCollector collector=new ConflictsCollector(conflicts);
  if ((moveToOtherPackage && (classToMoveVisibility.equals(PsiModifier.PACKAGE_LOCAL) || targetClassVisibility.equals(PsiModifier.PACKAGE_LOCAL))) || targetClassVisibility.equals(PsiModifier.PRIVATE)) {
    detectInaccessibleClassUsages(usages,collector);
  }
  if (moveToOtherPackage) {
    detectInaccessibleMemberUsages(collector);
  }
  return conflicts;
}
