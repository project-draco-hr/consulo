{
  final String name=base.getModel().getFullName(element);
  if (name == null)   return false;
  final List<String> suspects=split(name,base);
  final List<Pair<String,Matcher>> patternsAndMatchers=ContainerUtil.map2List(split(qualifierPattern,base),new Function<String,Pair<String,Matcher>>(){
    public Pair<String,NameUtil.Matcher> fun(    String s){
      final String pattern=getNamePattern(base,s);
      final NameUtil.Matcher matcher=buildPatternMatcher(pattern);
      return new Pair<String,NameUtil.Matcher>(pattern,matcher);
    }
  }
);
  int matchPosition=0;
  try {
    patterns:     for (    Pair<String,NameUtil.Matcher> patternAndMatcher : patternsAndMatchers) {
      final String pattern=patternAndMatcher.first;
      final NameUtil.Matcher matcher=patternAndMatcher.second;
      if (pattern.length() > 0) {
        for (int j=matchPosition; j < suspects.size() - 1; j++) {
          String suspect=suspects.get(j);
          if (matches(base,pattern,matcher,suspect)) {
            matchPosition=j + 1;
            continue patterns;
          }
        }
        return false;
      }
    }
  }
 catch (  Exception e) {
    return false;
  }
  return true;
}
