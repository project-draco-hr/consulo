{
  final CvsTabbedWindow tabbedWindow=myIsQuietOperation ? null : openTabbedWindow(handler);
  final Runnable finish=new Runnable(){
    public void run(){
      try {
        myResult.addAllErrors(handler.getErrorsExceptAborted());
        myResult.addAllWarnings(handler.getWarnings());
        handler.runComplitingActivities();
        if (myProject != null) {
          showErrors(handler.getErrorsExceptAborted(),handler.getWarnings(),tabbedWindow);
        }
      }
  finally {
        try {
          if (myResult.finishedUnsuccessfully(true,handler)) {
            callback.executionFinished(false);
          }
 else {
            if (handler.getErrors().isEmpty())             callback.executionFinishedSuccessfully();
            callback.executionFinished(true);
          }
        }
  finally {
          if ((myProject != null) && (handler != CvsHandler.NULL)) {
            StatusBar statusBar=WindowManager.getInstance().getStatusBar(myProject);
            if (statusBar != null) {
              statusBar.setInfo(getStatusMessage(handler));
            }
          }
        }
      }
    }
  }
;
  final Runnable cvsAction=new Runnable(){
    public void run(){
      try {
        if (handler == CvsHandler.NULL)         return;
        setText(CvsBundle.message("progress.text.preparing.for.login"));
        handler.beforeLogin();
        if (myResult.finishedUnsuccessfully(false,handler))         return;
        setText(CvsBundle.message("progress.text.login"));
        setCancelText(handler);
        login(handler);
        if (myResult.finishedUnsuccessfully(true,handler))         return;
        setText(CvsBundle.message("progress.text.preparing.for.action",handler.getTitle()));
        handler.run(myExecutor);
        if (myResult.finishedUnsuccessfully(true,handler))         return;
      }
 catch (      ProcessCanceledException ex) {
        myResult.setIsCanceled();
      }
 finally {
        callback.executeInProgressAfterAction(myExecutor);
      }
    }
  }
;
  if (doNotShowProgress()) {
    cvsAction.run();
    myExecutor.runInDispatchThread(finish);
  }
 else {
    PerformInBackgroundOption backgroundOption=handler.getBackgroundOption(myProject);
    if (backgroundOption != null) {
      Task.Backgroundable task=new Task.Backgroundable(myProject,handler.getTitle(),handler.canBeCanceled(),backgroundOption){
        public void run(        @NotNull final ProgressIndicator indicator){
          cvsAction.run();
        }
        @Override public void onSuccess(){
          finish.run();
        }
      }
;
      ProgressManager.getInstance().run(task);
    }
 else {
      if (ProgressManager.getInstance().runProcessWithProgressSynchronously(cvsAction,handler.getTitle(),handler.canBeCanceled(),myProject)) {
        finish.run();
      }
    }
  }
}
