{
  if (repo == null) {
    return Collections.emptySet();
  }
  HgCommandExecutor executor=new HgCommandExecutor(myProject,null);
  executor.setSilent(true);
  List<String> options=new LinkedList<String>();
  if (myIncludeAdded) {
    options.add("--added");
  }
  if (myIncludeModified) {
    options.add("--modified");
  }
  if (myIncludeRemoved) {
    options.add("--removed");
  }
  if (myIncludeDeleted) {
    options.add("--deleted");
  }
  if (myIncludeUnknown) {
    options.add("--unknown");
  }
  if (myIncludeIgnored) {
    options.add("--ignored");
  }
  if (myIncludeCopySource) {
    options.add("--copies");
  }
  if (myBaseRevision != null && !myBaseRevision.getRevision().isEmpty()) {
    options.add("--rev");
    options.add(myBaseRevision.getChangeset().isEmpty() ? myBaseRevision.getRevision() : myBaseRevision.getChangeset());
    if (myTargetRevision != null) {
      options.add("--rev");
      options.add(myTargetRevision.getChangeset());
    }
  }
  final Set<HgChange> changes=new HashSet<HgChange>();
  if (paths != null) {
    final List<List<String>> chunked=VcsFileUtil.chunkPaths(repo,paths);
    for (    List<String> chunk : chunked) {
      List<String> args=new ArrayList<String>();
      args.addAll(options);
      args.addAll(chunk);
      HgCommandResult result=executor.executeInCurrentThread(repo,"status",args);
      changes.addAll(parseChangesFromResult(repo,result,args));
    }
  }
 else {
    HgCommandResult result=executor.executeInCurrentThread(repo,"status",options);
    changes.addAll(parseChangesFromResult(repo,result,options));
  }
  return changes;
}
