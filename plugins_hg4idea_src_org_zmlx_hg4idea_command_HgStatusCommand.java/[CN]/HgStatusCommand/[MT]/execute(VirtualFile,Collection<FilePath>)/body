{
  if (repo == null) {
    return Collections.emptySet();
  }
  HgCommandExecutor executor=new HgCommandExecutor(project);
  executor.setSilent(true);
  List<String> options=new LinkedList<String>();
  if (includeAdded) {
    options.add("--added");
  }
  if (includeModified) {
    options.add("--modified");
  }
  if (includeRemoved) {
    options.add("--removed");
  }
  if (includeDeleted) {
    options.add("--deleted");
  }
  if (includeUnknown) {
    options.add("--unknown");
  }
  if (includeIgnored) {
    options.add("--ignored");
  }
  if (includeCopySource) {
    options.add("--copies");
  }
  if (baseRevision != null) {
    options.add("--rev");
    options.add(baseRevision.getChangeset().equals("") ? baseRevision.getRevision() : baseRevision.getChangeset());
    if (targetRevision != null) {
      options.add("--rev");
      options.add(targetRevision.getChangeset());
    }
  }
  final Set<HgChange> changes=new HashSet<HgChange>();
  if (paths != null) {
    final List<List<String>> chunked=VcsFileUtil.chunkPaths(repo,paths);
    for (    List<String> chunk : chunked) {
      List<String> args=new ArrayList<String>();
      args.addAll(options);
      args.addAll(chunk);
      HgCommandResult result=executor.executeInCurrentThread(repo,"status",args);
      changes.addAll(parseChangesFromResult(repo,result));
    }
  }
 else {
    HgCommandResult result=executor.executeInCurrentThread(repo,"status",options);
    changes.addAll(parseChangesFromResult(repo,result));
  }
  return changes;
}
