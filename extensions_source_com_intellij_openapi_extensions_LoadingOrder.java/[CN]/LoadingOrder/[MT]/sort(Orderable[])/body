{
  final Map<String,Orderable> map=new HashMap<String,Orderable>();
  for (  final Orderable orderable : orderables) {
    final String id=orderable.getOrderId();
    if (StringUtil.isNotEmpty(id)) {
      map.put(id,orderable);
    }
  }
  DFSTBuilder<Orderable> builder=new DFSTBuilder<Orderable>(new GraphGenerator<Orderable>(new CachingSemiGraph<Orderable>(new GraphGenerator.SemiGraph<Orderable>(){
    public Collection<Orderable> getNodes(){
      final ArrayList<Orderable> list=new ArrayList<Orderable>(Arrays.asList(orderables));
      Collections.reverse(list);
      return list;
    }
    public Iterator<Orderable> getIn(    final Orderable n){
      final LoadingOrder order=n.getOrder();
      Set<Orderable> predecessors=new LinkedHashSet<Orderable>();
      for (      final String id : order.myAfter) {
        final Orderable orderable=map.get(id);
        if (orderable != null) {
          predecessors.add(orderable);
        }
      }
      String id=n.getOrderId();
      for (      final Orderable orderable : orderables) {
        final LoadingOrder hisOrder=orderable.getOrder();
        if (StringUtil.isNotEmpty(id) && hisOrder.myBefore.contains(id) || order.myLast && !hisOrder.myLast || hisOrder.myFirst && !order.myFirst) {
          predecessors.add(orderable);
        }
      }
      return predecessors.iterator();
    }
  }
)));
  if (!builder.isAcyclic()) {
    final Pair<Orderable,Orderable> dependency=builder.getCircularDependency();
    throw new SortingException("Could not satisfy sorting requirements",new Element[]{dependency.first.getDescribingElement(),dependency.second.getDescribingElement()});
  }
  Arrays.sort(orderables,builder.comparator());
}
