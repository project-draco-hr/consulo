{
  final PsiElement myPsiElement=startElement;
  if (editor == null || !CodeInsightUtilBase.prepareFileForWrite(myPsiElement.getContainingFile()))   return;
  if (myPsiElement instanceof PsiEnumConstant) {
    FeatureUsageTracker.getInstance().triggerFeatureUsed(ProductivityFeatureNames.CODEASSISTS_OVERRIDE_IMPLEMENT);
    final TreeMap<MethodSignature,CandidateInfo> result=new TreeMap<MethodSignature,CandidateInfo>(new OverrideImplementUtil.MethodSignatureComparator());
    final HashMap<MethodSignature,PsiMethod> abstracts=new HashMap<MethodSignature,PsiMethod>();
    for (    PsiMethod method : ((PsiEnumConstant)myPsiElement).getContainingClass().getMethods()) {
      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {
        abstracts.put(method.getHierarchicalMethodSignature(),method);
      }
    }
    final HashMap<MethodSignature,PsiMethod> finals=new HashMap<MethodSignature,PsiMethod>();
    final HashMap<MethodSignature,PsiMethod> concretes=new HashMap<MethodSignature,PsiMethod>();
    OverrideImplementUtil.collectMethodsToImplement(null,abstracts,finals,concretes,result);
    final MemberChooser<PsiMethodMember> chooser=OverrideImplementUtil.showOverrideImplementChooser(editor,myPsiElement,true,result.values(),Collections.<CandidateInfo>emptyList());
    if (chooser == null)     return;
    final List<PsiMethodMember> selectedElements=chooser.getSelectedElements();
    if (selectedElements == null || selectedElements.isEmpty())     return;
    new WriteCommandAction(project,file){
      protected void run(      final Result result) throws Throwable {
        final PsiClass psiClass=ImplementAbstractMethodHandler.addClassInitializer((PsiEnumConstant)myPsiElement);
        OverrideImplementUtil.overrideOrImplementMethodsInRightPlace(editor,psiClass,selectedElements,chooser.isCopyJavadoc(),chooser.isInsertOverrideAnnotation());
      }
    }
.execute();
  }
 else {
    OverrideImplementUtil.chooseAndImplementMethods(project,editor,(PsiClass)myPsiElement);
  }
}
