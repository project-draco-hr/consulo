{
  if (CreateFromUsageUtils.isValidReference(myReferenceExpression,true))   return;
  final Project project=myReferenceExpression.getProject();
  PsiType[] expectedTypes=CreateFromUsageUtils.guessType(myReferenceExpression,false);
  PsiType type=expectedTypes[0];
  String varName=myReferenceExpression.getReferenceName();
  PsiMethod method=PsiTreeUtil.getParentOfType(myReferenceExpression,PsiMethod.class);
  LOG.assertTrue(method != null);
  method=IntroduceParameterHandler.chooseEnclosingMethod(method);
  if (method == null)   return;
  method=SuperMethodWarningUtil.checkSuperMethod(method,RefactoringBundle.message("to.refactor"));
  if (method == null)   return;
  List<ParameterInfoImpl> parameterInfos=new ArrayList<ParameterInfoImpl>(Arrays.asList(ParameterInfoImpl.fromMethod(method)));
  ParameterInfoImpl parameterInfo=new ParameterInfoImpl(-1,varName,type,PsiTypesUtil.getDefaultValueOfType(type),true);
  parameterInfos.add(parameterInfo);
  if (ApplicationManager.getApplication().isUnitTestMode()) {
    ParameterInfoImpl[] array=parameterInfos.toArray(new ParameterInfoImpl[parameterInfos.size()]);
    @Modifier String modifier=PsiUtil.getAccessModifier(PsiUtil.getAccessLevel(method.getModifierList()));
    ChangeSignatureProcessor processor=new ChangeSignatureProcessor(project,method,false,modifier,method.getName(),method.getReturnType(),array);
    processor.run();
  }
 else {
    ChangeSignatureDialog dialog=new ChangeSignatureDialog(project,method,false,myReferenceExpression);
    dialog.setParameterInfos(parameterInfos);
    dialog.show();
  }
}
