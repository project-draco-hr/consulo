{
  List<Pair<File,GroovyDslExecutor>> result=ourStandardScripts;
  if (result != null) {
    return result;
  }
  final Semaphore semaphore=new Semaphore();
  semaphore.down();
  ourPool.execute(new Runnable(){
    @SuppressWarnings("AssignmentToStaticFieldFromInstanceMethod") @Override public void run(){
      if (ourStandardScripts != null) {
        return;
      }
      try {
        Set<File> scriptFolders=new LinkedHashSet<File>();
        for (        GroovyFrameworkConfigNotification extension : GroovyFrameworkConfigNotification.EP_NAME.getExtensions()) {
          File jarPath=new File(PathUtil.getJarPathForClass(extension.getClass()));
          if (jarPath.isFile()) {
            jarPath=jarPath.getParentFile();
          }
          scriptFolders.add(new File(jarPath,"standardDsls"));
        }
        List<Pair<File,GroovyDslExecutor>> executors=new ArrayList<Pair<File,GroovyDslExecutor>>();
        for (        File file : scriptFolders) {
          if (file.exists()) {
            for (            File child : file.listFiles()) {
              final String fileName=child.getName();
              if (fileName.endsWith(".gdsl")) {
                try {
                  final String text=new String(FileUtil.loadFileText(child));
                  executors.add(Pair.create(child,new GroovyDslExecutor(text,fileName)));
                }
 catch (                IOException e) {
                  LOG.error(e);
                }
              }
            }
          }
        }
        ourStandardScripts=executors;
      }
 catch (      OutOfMemoryError e) {
        stopGdsl=true;
        throw e;
      }
catch (      NoClassDefFoundError e) {
        stopGdsl=true;
        throw e;
      }
 finally {
        semaphore.up();
      }
    }
  }
);
  while (ourStandardScripts == null && !stopGdsl && !semaphore.waitFor(20)) {
    ProgressManager.checkCanceled();
  }
  if (stopGdsl) {
    return Collections.emptyList();
  }
  return ourStandardScripts;
}
