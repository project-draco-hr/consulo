{
  if (files.isEmpty()) {
    return ExitCode.FINISHED;
  }
  final ProjectPaths paths=new ProjectPaths(context.getScope().getProject());
  final Collection<File> classpath=paths.getClasspath(getClasspathKind(context),chunk);
  final Collection<File> platformPaths=collectPlatformClasspath(context,chunk);
  final Map<File,Set<File>> outs=buildOutputDirectoriesMap(context,chunk);
  final List<String> options=getCompilationOptions(context,chunk);
  final int ERROR=0, WARNING=1;
  final int[] statistics=new int[]{0,0};
  final boolean compilationOk=myJavacCompiler.compile(options,files,classpath,platformPaths,outs,new EmbeddedJavac.OutputConsumer(){
    public void outputLineAvailable(    String line){
      context.processMessage(new CompilerMessage(JAVAC_COMPILER_NAME,line));
    }
    public void report(    Diagnostic<? extends JavaFileObject> diagnostic){
      context.processMessage(new CompilerMessage(JAVAC_COMPILER_NAME,diagnostic.getKind().name() + "/" + diagnostic.getMessage(Locale.US)));
switch (diagnostic.getKind()) {
case ERROR:
        statistics[ERROR]++;
      break;
case MANDATORY_WARNING:
case WARNING:
    statistics[WARNING]++;
  break;
}
}
}
);
if (!compilationOk || statistics[ERROR] > 0) {
throw new ProjectBuildException("Compilation failed: errors: " + statistics[ERROR] + "; warnings: "+ statistics[WARNING]);
}
return ExitCode.FINISHED;
}
