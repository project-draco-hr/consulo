{
  final PsiParameter[] parameters=targetMethod.getParameterList().getParameters();
  List<ParameterInfo> result=new ArrayList<ParameterInfo>();
  if (expressions.length < parameters.length) {
    int ei=0;
    int pi=0;
    while (ei < expressions.length && pi < parameters.length) {
      PsiExpression expression=expressions[ei];
      final PsiParameter parameter=parameters[pi];
      final PsiType paramType=substitutor.substitute(parameter.getType());
      if (TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression)) {
        result.add(new ParameterInfo(pi,parameter.getName(),PsiUtil.convertAnonymousToBaseType(paramType)));
        pi++;
        ei++;
      }
 else {
        pi++;
      }
    }
    if (result.size() != expressions.length)     return null;
  }
 else   if (expressions.length > parameters.length) {
    int ei=0;
    int pi=0;
    Set<String> existingNames=new HashSet<String>();
    for (int j=0; j < parameters.length; j++) {
      PsiParameter parameter=parameters[j];
      existingNames.add(parameter.getName());
    }
    while (ei < expressions.length || pi < parameters.length) {
      PsiExpression expression=ei < expressions.length ? expressions[ei] : null;
      final PsiParameter parameter=pi < parameters.length ? parameters[pi] : null;
      PsiType paramType=parameter == null ? null : substitutor.substitute(parameter.getType());
      final boolean parameterAssignable=paramType != null && (expression == null || TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression));
      if (parameterAssignable) {
        result.add(new ParameterInfo(pi,parameter.getName(),paramType));
        pi++;
        ei++;
      }
 else       if (expression != null) {
        PsiType exprType=RefactoringUtil.getTypeByExpression(expression);
        if (exprType == null)         return null;
        final CodeStyleManager codeStyleManager=CodeStyleManager.getInstance(expression.getProject());
        String name=suggestUniqueParameterName(codeStyleManager,expression,exprType,existingNames);
        result.add(new ParameterInfo(-1,name,exprType,expression.getText()));
        ei++;
      }
    }
    if (result.size() != expressions.length)     return null;
  }
 else {
    for (int i=0; i < parameters.length; i++) {
      PsiParameter parameter=parameters[i];
      PsiExpression expression=expressions[i];
      final PsiType paramType=substitutor.substitute(parameter.getType());
      if (TypeConversionUtil.areTypesAssignmentCompatible(paramType,expression)) {
        result.add(new ParameterInfo(i,parameter.getName(),paramType));
      }
 else {
        PsiType exprType=RefactoringUtil.getTypeByExpression(expression);
        if (exprType == null)         return null;
        result.add(new ParameterInfo(i,parameter.getName(),exprType));
      }
    }
    boolean isSilly=true;
    for (int i=0; i < result.size(); i++) {
      PsiParameter parameter=parameters[i];
      final PsiType paramType=substitutor.substitute(parameter.getType());
      ParameterInfo parameterInfo=result.get(i);
      String typeText=parameterInfo.getTypeText();
      if (!paramType.equalsToText(typeText)) {
        isSilly=false;
        break;
      }
    }
    if (isSilly)     return null;
  }
  return result.toArray(new ParameterInfo[result.size()]);
}
