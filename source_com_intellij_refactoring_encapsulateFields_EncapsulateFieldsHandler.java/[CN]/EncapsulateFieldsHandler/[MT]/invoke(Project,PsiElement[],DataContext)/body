{
  PsiClass aClass=null;
  final HashSet preselectedFields=new HashSet();
  if (elements.length == 1) {
    if (elements[0] instanceof PsiClass) {
      aClass=(PsiClass)elements[0];
    }
 else     if (elements[0] instanceof PsiField) {
      PsiField field=(PsiField)elements[0];
      aClass=field.getContainingClass();
      preselectedFields.add(field);
    }
 else {
      return;
    }
  }
 else {
    for (int idx=0; idx < elements.length; idx++) {
      PsiElement element=elements[idx];
      if (!(element instanceof PsiField)) {
        return;
      }
      PsiField field=(PsiField)element;
      if (aClass == null) {
        aClass=field.getContainingClass();
        preselectedFields.add(field);
      }
 else {
        if (aClass.equals(field.getContainingClass())) {
          preselectedFields.add(field);
        }
 else {
          String message="Cannot perform the refactoring.\nFields to be refactored should belong to the same class.";
          RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.ENCAPSULATE_FIELDS,project);
          return;
        }
      }
    }
  }
  LOG.assertTrue(aClass != null);
  if (aClass.isInterface()) {
    String message=REFACTORING_NAME + " refactoring cannot be applied to interface";
    RefactoringMessageUtil.showErrorMessage(REFACTORING_NAME,message,HelpID.ENCAPSULATE_FIELDS,project);
    return;
  }
  if (!aClass.isWritable()) {
    if (!RefactoringMessageUtil.checkReadOnlyStatus(project,aClass))     return;
  }
  EncapsulateFieldsDialog dialog=new EncapsulateFieldsDialog(project,aClass,preselectedFields);
  dialog.show();
}
