{
  document.putUserData(TEMP_TREE_IN_DOCUMENT_KEY,null);
  TextBlock textBlock=getTextBlock(document,file);
  if (textBlock.isEmpty())   return false;
  ((DocumentImpl)document).normalizeRangeMarkers();
  myIsCommitInProgress=true;
  try {
    myTreeElementBeingReparsedSoItWontBeCollected=((PsiFileImpl)file).calcTreeElement();
    if (textBlock.isEmpty())     return false;
    textBlock.lock();
    final CharSequence chars=document.getCharsSequence();
    final Boolean data=document.getUserData(BlockSupport.DO_NOT_REPARSE_INCREMENTALLY);
    if (data != null) {
      document.putUserData(BlockSupport.DO_NOT_REPARSE_INCREMENTALLY,null);
      file.putUserData(BlockSupport.DO_NOT_REPARSE_INCREMENTALLY,data);
    }
    final String oldPsiText=ApplicationManagerEx.getApplicationEx().isInternal() && !ApplicationManagerEx.getApplicationEx().isUnitTestMode() ? myTreeElementBeingReparsedSoItWontBeCollected.getText() : null;
    int startOffset;
    int endOffset;
    int lengthShift;
    if (file.getViewProvider().supportsIncrementalReparse(file.getLanguage())) {
      startOffset=textBlock.getStartOffset();
      int psiEndOffset=textBlock.getPsiEndOffset();
      endOffset=psiEndOffset;
      lengthShift=textBlock.getTextEndOffset() - psiEndOffset;
    }
 else {
      startOffset=0;
      endOffset=document.getTextLength();
      lengthShift=document.getTextLength() - myTreeElementBeingReparsedSoItWontBeCollected.getTextLength();
    }
    assertBeforeCommit(document,file,textBlock,chars,oldPsiText);
    myBlockSupport.reparseRange(file,startOffset,endOffset,lengthShift,chars);
    assertAfterCommit(document,file,oldPsiText);
  }
  finally {
    textBlock.unlock();
    textBlock.clear();
    myTreeElementBeingReparsedSoItWontBeCollected=null;
    myIsCommitInProgress=false;
    if (mySmartPointerManager != null) {
      SmartPointerManagerImpl.synchronizePointers(file);
    }
  }
  return true;
}
