{
  return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){
    public Boolean compute(){
synchronized (VcsDirtyScopeImpl.this) {
        if (myProject.isDisposed())         return Boolean.FALSE;
        if (myVcsManager.getVcsFor(path) != myVcs) {
          return Boolean.FALSE;
        }
        final VirtualFile vcsRoot=myVcsManager.getVcsRootFor(path);
        if (vcsRoot != null) {
          for (          VirtualFile contentRoot : myAffectedContentRoots) {
            if (VfsUtil.isAncestor(contentRoot,vcsRoot,false)) {
              THashSet<FilePath> dirsByRoot=myDirtyDirectoriesRecursively.get(contentRoot);
              if (dirsByRoot != null) {
                for (                FilePath filePath : dirsByRoot) {
                  if (path.isUnder(filePath,false))                   return Boolean.TRUE;
                }
              }
              break;
            }
          }
        }
        if (myDirtyFiles.size() > 0) {
          FilePath parent;
          VirtualFile vParent=path.getVirtualFileParent();
          if (vParent != null && vParent.isValid()) {
            parent=new FilePathImpl(vParent);
          }
 else {
            parent=FilePathImpl.create(path.getIOFile().getParentFile());
          }
          if (myDirtyFiles.contains(parent) || myDirtyFiles.contains(path))           return Boolean.TRUE;
        }
        return Boolean.FALSE;
      }
    }
  }
).booleanValue();
}
