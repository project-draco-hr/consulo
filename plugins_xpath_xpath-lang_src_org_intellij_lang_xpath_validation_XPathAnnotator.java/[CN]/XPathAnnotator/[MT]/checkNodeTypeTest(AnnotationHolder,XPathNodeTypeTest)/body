{
  final NodeType nodeType=test.getNodeType();
  if (nodeType == null) {
    return;
  }
  final XPathExpression[] arguments=test.getArgumentList();
  if (test.getXPathVersion() == XPathVersion.V2) {
switch (nodeType) {
case NODE:
case TEXT:
case COMMENT:
      markExceedingArguments(holder,arguments,0);
    break;
case ELEMENT:
case ATTRIBUTE:
  checkKindTestArguments(holder,test,true,0,2);
break;
case SCHEMA_ELEMENT:
case SCHEMA_ATTRIBUTE:
checkKindTestArguments(holder,test,false,1,1);
break;
case DOCUMENT_NODE:
if (arguments.length >= 1) {
markExceedingArguments(holder,arguments,1);
final XPathNodeTypeTest argument=findNodeType(arguments[0]);
if (argument != null) {
final NodeType type=argument.getNodeType();
if (type == NodeType.ELEMENT || type == NodeType.SCHEMA_ELEMENT) {
return;
}
}
holder.createErrorAnnotation(arguments[0],"element() or schema-element() expected");
}
break;
case PROCESSING_INSTRUCTION:
if (arguments.length >= 1) {
markExceedingArguments(holder,arguments,1);
if (arguments[0] instanceof XPathString) {
break;
}
 else {
final PrefixedName argument=findQName(arguments[0]);
if (argument != null) {
if (argument.getPrefix() == null && !"*".equals(argument.getLocalName())) {
break;
}
}
}
holder.createErrorAnnotation(arguments[0],"String literal or NCName expected");
}
break;
}
}
 else {
if (arguments.length == 0) {
return;
}
if (test.getNodeType() == NodeType.PROCESSING_INSTRUCTION && arguments.length == 1) {
if (!(arguments[0] instanceof XPathString)) {
holder.createErrorAnnotation(arguments[0],"String literal expected");
}
return;
}
holder.createErrorAnnotation(test,"Invalid number of arguments for node type test '" + nodeType.getType() + "'");
}
}
