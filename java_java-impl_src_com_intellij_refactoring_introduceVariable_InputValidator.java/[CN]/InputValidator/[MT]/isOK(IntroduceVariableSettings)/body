{
  String name=settings.getEnteredName();
  final PsiElement anchor;
  final boolean replaceAllOccurrences=settings.isReplaceAllOccurrences();
  if (replaceAllOccurrences) {
    anchor=myAnchorStatementIfAll;
  }
 else {
    anchor=myAnchorStatement;
  }
  final PsiElement scope=anchor.getParent();
  if (scope == null)   return true;
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  final HashSet<PsiVariable> reportedVariables=new HashSet<PsiVariable>();
  JavaUnresolvableLocalCollisionDetector.CollidingVariableVisitor visitor=new JavaUnresolvableLocalCollisionDetector.CollidingVariableVisitor(){
    public void visitCollidingElement(    PsiVariable collidingVariable){
      if (collidingVariable instanceof PsiField)       return;
      if (!reportedVariables.contains(collidingVariable)) {
        reportedVariables.add(collidingVariable);
        String message=RefactoringBundle.message("introduced.variable.will.conflict.with.0",RefactoringUIUtil.getDescription(collidingVariable,true));
        conflicts.putValue(collidingVariable,message);
      }
    }
  }
;
  JavaUnresolvableLocalCollisionDetector.visitLocalsCollisions(anchor,name,scope,anchor,visitor);
  if (replaceAllOccurrences) {
    final PsiExpression[] occurences=myOccurenceManager.getOccurences();
    for (    PsiExpression occurence : occurences) {
      IntroduceVariableBase.checkInLoopCondition(occurence,conflicts);
    }
  }
 else {
    IntroduceVariableBase.checkInLoopCondition(myOccurenceManager.getMainOccurence(),conflicts);
  }
  if (conflicts.size() > 0) {
    return myIntroduceVariableBase.reportConflicts(conflicts,myProject,settings);
  }
 else {
    return true;
  }
}
