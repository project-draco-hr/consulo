{
  final Cache oldCache=myDependencyCache.getCache();
  if (!ClsUtil.isAnnotation(oldCache.getFlags(annotationQName))) {
    return;
  }
  if (!hasRetentionPolicyChanged(annotationQName,oldCache,myDependencyCache.getNewClassesCache(),myDependencyCache.getSymbolTable())) {
    return;
  }
  final CacheCorruptedException[] _ex=new CacheCorruptedException[]{null};
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        final String qName=myDependencyCache.resolve(annotationQName);
        PsiClass[] classes=JavaPsiFacade.getInstance(myProject).findClasses(qName.replace('$','.'),GlobalSearchScope.allScope(myProject));
        for (        final PsiClass aClass : classes) {
          if (!aClass.isAnnotationType()) {
            continue;
          }
          final Collection<PsiReference> references=mySearcher.findReferences(aClass,true);
          for (          PsiReference reference : references) {
            final PsiClass ownerClass=getOwnerClass(reference.getElement());
            if (ownerClass != null && !ownerClass.equals(aClass)) {
              int qualifiedName=myDependencyCache.getSymbolTable().getId(ownerClass.getQualifiedName());
              if (myDependencyCache.markClass(qualifiedName,false)) {
                if (LOG.isDebugEnabled()) {
                  LOG.debug("Marked dependent class " + myDependencyCache.resolve(qualifiedName) + "; reason: annotation's retention policy changed from SOURCE to CLASS or RUNTIME "+ myDependencyCache.resolve(annotationQName));
                }
              }
            }
          }
        }
      }
 catch (      CacheCorruptedException e) {
        _ex[0]=e;
      }
catch (      ProcessCanceledException e) {
      }
    }
  }
);
  if (_ex[0] != null) {
    throw _ex[0];
  }
}
