{
  final Set<Method> methods=getStaticMethods();
  final StringBuilder sb=new StringBuilder();
  final THashMap<Class,Collection<Class>> classes=new THashMap<Class,Collection<Class>>();
  final THashSet<Class> missingClasses=new THashSet<Class>();
  classes.put(Object.class,missingClasses);
  for (  Method method : methods) {
    for (Class<?> type=method.getReturnType(); type != null && ElementPattern.class.isAssignableFrom(type); type=type.getSuperclass()) {
      final Class<?> enclosingClass=type.getEnclosingClass();
      if (enclosingClass != null) {
        Collection<Class> list=classes.get(enclosingClass);
        if (list == null) {
          list=new THashSet<Class>();
          classes.put(enclosingClass,list);
        }
        list.add(type);
      }
 else       if (!classes.containsKey(type)) {
        classes.put(type,null);
      }
    }
  }
  for (  Class aClass : classes.keySet()) {
    if (aClass == Object.class)     continue;
    printClass(aClass,classes,sb);
  }
  for (  Method method : methods) {
    printMethodDeclaration(method,sb,classes);
  }
  for (  Class aClass : missingClasses) {
    sb.append("class ").append(aClass.getSimpleName());
    final Class superclass=aClass.getSuperclass();
    if (missingClasses.contains(superclass)) {
      sb.append(" extends ").append(superclass.getSimpleName());
    }
    sb.append("{}\n");
  }
  return sb.toString();
}
