{
  final boolean[] changes1=new boolean[myOriginalLengths[0]];
  final boolean[] changes2=new boolean[myOriginalLengths[1]];
  Arrays.fill(changes1,true);
  Arrays.fill(changes2,true);
  paths.decodePath(new LCSBuilder(){
    private int x=myOldIndecies[0].length - 1;
    private int y=myOldIndecies[1].length - 1;
    private int originalX=myOriginalLengths[0] - 1;
    private int originalY=myOriginalLengths[1] - 1;
    public void addChange(    int first,    int second){
      x-=first;
      y-=second;
      originalX=markChanged(changes1,originalX,myOldIndecies[0],x);
      originalY=markChanged(changes2,originalY,myOldIndecies[1],y);
    }
    public void addEqual(    int length){
      for (int i=length; i > 0; i--) {
        originalX=markChanged(changes1,originalX,myOldIndecies[0],x);
        originalY=markChanged(changes2,originalY,myOldIndecies[1],y);
        x--;
        y--;
        changes1[originalX]=false;
        changes2[originalY]=false;
        originalX--;
        originalY--;
      }
    }
  }
);
  int x=0;
  int y=0;
  while (x < changes1.length && y < changes2.length) {
    int startX=x;
    while (x < changes1.length && y < changes2.length && !changes1[x] && !changes2[y]) {
      x++;
      y++;
    }
    if (x > startX)     builder.addEqual(x - startX);
    int dx=0;
    int dy=0;
    while (x < changes1.length && changes1[x]) {
      dx++;
      x++;
    }
    while (y < changes2.length && changes2[y]) {
      dy++;
      y++;
    }
    if (dx != 0 || dy != 0)     builder.addChange(dx,dy);
  }
  if (x != changes1.length || y != changes2.length)   builder.addChange(changes1.length - x,changes2.length - y);
}
