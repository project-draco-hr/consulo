{
  final XmlTag sourceElement=se.getSourceElement();
  for (  final XmlAttribute attr : sourceElement.getAttributes()) {
    @NonNls final String name=attr.getName();
    if (name.startsWith("xmlns"))     continue;
    final AntAttributeType type=def.getAttributeType(name);
    final PsiElement attrName=attr.getFirstChild();
    if (attrName != null) {
      if (type == null) {
        if (!isSuccessorOfUndefinedElement(se)) {
          holder.createErrorAnnotation(attrName,AntBundle.message("attribute.is.not.allowed.here",name));
        }
      }
 else {
        final String attrValue=attr.getValue();
        if (type == AntAttributeType.INTEGER) {
          try {
            Integer.parseInt(se.computeAttributeValue(attrValue));
          }
 catch (          NumberFormatException e) {
            holder.createErrorAnnotation(attrName,AntBundle.message("integer.attribute.has.invalid.value",name));
          }
        }
 else         if (type == AntAttributeType.STRING) {
          if (attrValue != null && AntProperty.TSTAMP_PATTERN_ATTRIBUTE_NAME.equalsIgnoreCase(name)) {
            final PsiElement parent=se.getParent();
            if (parent instanceof AntProperty && ((AntProperty)parent).isTstamp()) {
              try {
                new SimpleDateFormat(attrValue);
              }
 catch (              IllegalArgumentException e) {
                holder.createErrorAnnotation(attr.getValueElement(),e.getMessage());
              }
            }
          }
        }
      }
    }
  }
}
