{
  if (myBaseProfile != null) {
    myBaseProfile.initInspectionTools(project);
  }
  final List<InspectionToolWrapper> tools;
  try {
    tools=createTools(project);
  }
 catch (  ProcessCanceledException ignored) {
    return false;
  }
  final Map<String,List<String>> dependencies=new HashMap<String,List<String>>();
  for (  InspectionToolWrapper toolWrapper : tools) {
    final String shortName=toolWrapper.getShortName();
    HighlightDisplayKey key=HighlightDisplayKey.find(shortName);
    if (key == null) {
      final InspectionEP extension=toolWrapper.getExtension();
      Computable<String> computable=extension == null ? new Computable.PredefinedValueComputable<String>(toolWrapper.getDisplayName()) : new Computable<String>(){
        @Override public String compute(){
          return extension.getDisplayName();
        }
      }
;
      if (toolWrapper instanceof LocalInspectionToolWrapper) {
        key=HighlightDisplayKey.register(shortName,computable,((LocalInspectionToolWrapper)toolWrapper).getID(),((LocalInspectionToolWrapper)toolWrapper).getAlternativeID());
      }
 else {
        key=HighlightDisplayKey.register(shortName,computable);
      }
    }
    LOG.assertTrue(key != null,shortName + " ; number of initialized tools: " + myTools.size());
    HighlightDisplayLevel level=myBaseProfile != null ? myBaseProfile.getErrorLevel(key,project) : toolWrapper.getDefaultLevel();
    boolean enabled=myBaseProfile != null ? myBaseProfile.isToolEnabled(key) : toolWrapper.isEnabledByDefault();
    final ToolsImpl toolsList=new ToolsImpl(toolWrapper,level,!myLockedProfile && enabled,enabled);
    final Element element=myUninstalledInspectionsSettings.remove(shortName);
    try {
      if (element != null) {
        toolsList.readExternal(element,this,dependencies);
      }
 else       if (!myUninstalledInspectionsSettings.containsKey(InspectionElementsMerger.getMergedMarkerName(shortName))) {
        final InspectionElementsMerger merger=getMergers().get(shortName);
        if (merger != null) {
          final Element merged=merger.merge(myUninstalledInspectionsSettings);
          if (merged != null) {
            toolsList.readExternal(merged,this,dependencies);
          }
        }
      }
    }
 catch (    InvalidDataException e) {
      LOG.error("Can't read settings for " + toolWrapper,e);
    }
    myTools.put(toolWrapper.getShortName(),toolsList);
  }
  final GraphGenerator<String> graphGenerator=GraphGenerator.create(CachingSemiGraph.create(new GraphGenerator.SemiGraph<String>(){
    @Override public Collection<String> getNodes(){
      return dependencies.keySet();
    }
    @Override public Iterator<String> getIn(    String n){
      return dependencies.get(n).iterator();
    }
  }
));
  DFSTBuilder<String> builder=new DFSTBuilder<String>(graphGenerator);
  if (builder.isAcyclic()) {
    final List<String> scopes=builder.getSortedNodes();
    myScopesOrder=ArrayUtil.toStringArray(scopes);
  }
  if (mySource != null) {
    copyToolsConfigurations(mySource,project);
  }
  return true;
}
