{
  setConflict(conflictString);
  this.conflictStringWithoutConflictMarker=conflictString;
  this.lastModified=null;
  this.conflict=false;
  this.timeStampMatchesFile=false;
  if (conflictString == null || conflictString.equals(DUMMY_TIMESTAMP) || conflictString.equals(MERGE_TIMESTAMP) || conflictString.equals(DUMMY_TIMESTAMP_NEW_ENTRY)) {
    return;
  }
  int parseStartIndex=0;
  final int conflictIndex=conflictStringWithoutConflictMarker.indexOf(HAD_CONFLICTS);
  if (conflictIndex >= 0) {
    conflict=true;
    parseStartIndex=conflictIndex + 1;
  }
  final int timeMatchIndex=conflictStringWithoutConflictMarker.indexOf(TIMESTAMP_MATCHES_FILE);
  if (timeMatchIndex >= 0) {
    timeStampMatchesFile=true;
    parseStartIndex=Math.max(parseStartIndex,timeMatchIndex + 1);
  }
  if (parseStartIndex > 0) {
    conflictStringWithoutConflictMarker=conflictStringWithoutConflictMarker.substring(parseStartIndex);
  }
  if (conflictStringWithoutConflictMarker.length() == 0) {
    conflictStringWithoutConflictMarker=null;
    return;
  }
  if (conflictStringWithoutConflictMarker.startsWith(INITIAL_PREFIX)) {
    return;
  }
  try {
    this.lastModified=getLastModifiedDateFormatter().parse(conflictStringWithoutConflictMarker);
  }
 catch (  ParseException ex) {
    lastModified=null;
    System.err.println("[Entry] can't parse conflict '" + conflictStringWithoutConflictMarker + "'");
  }
}
