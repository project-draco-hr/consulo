{
  final List<VcsException> exceptions=new LinkedList<VcsException>();
  final Collection<Change> removedChanges=(Collection<Change>)parametersHolder.fun(HgVcs.getInstance(myProject));
  for (  final Map.Entry<VirtualFile,List<Change>> entry : groupChangesByRepository(changes).entrySet()) {
    final VirtualFile repo=entry.getKey();
    final HgCommitCommand command=new HgCommitCommand(myProject,repo,preparedComment);
    final Set<HgFile> selectedFiles=new THashSet<HgFile>();
    for (    Change c : entry.getValue()) {
      if (c.getFileStatus() == FileStatus.DELETED_FROM_FS) {
        if (removedChanges == null || !removedChanges.contains(c)) {
          continue;
        }
      }
      final FilePath filepath=(c.getAfterRevision() == null ? c.getBeforeRevision().getFile() : c.getAfterRevision().getFile());
      selectedFiles.add(new HgFile(repo,filepath));
    }
    if (isMergeCommit(repo)) {
      final Set<HgFile> changedFilesNotInCommit=getChangedFilesNotInCommit(repo,selectedFiles);
      if (!changedFilesNotInCommit.isEmpty()) {
        final StringBuilder filesNotIncludedString=new StringBuilder();
        for (        HgFile hgFile : changedFilesNotInCommit) {
          filesNotIncludedString.append("<li>");
          filesNotIncludedString.append(hgFile.getRelativePath());
          filesNotIncludedString.append("</li>");
        }
        if (!mayCommitEverything(filesNotIncludedString.toString())) {
          return exceptions;
        }
      }
    }
 else {
      if (selectedFiles.isEmpty()) {
        return exceptions;
      }
      command.setFiles(selectedFiles);
    }
    try {
      command.execute();
    }
 catch (    HgCommandException e) {
      exceptions.add(new VcsException(e));
    }
catch (    VcsException e) {
      exceptions.add(e);
    }
  }
  return exceptions;
}
