{
  return new Iterable<PsiClass>(){
    public Iterator<PsiClass> iterator(){
      return new Iterator<PsiClass>(){
        int i=0;
        Set<PsiClass> set=new HashSet<PsiClass>();
        PsiClass current=psiClass;
        public boolean hasNext(){
          if (i < current.getSuperTypes().length)           return true;
          if (set.contains(current))           set.remove(current);
          final Iterator<PsiClass> classIterator=set.iterator();
          if (classIterator.hasNext()) {
            current=classIterator.next();
          }
 else           return false;
          i=0;
          return current.getSuperTypes().length != 0 || hasNext();
        }
        public PsiClass next(){
          final PsiClassType superType;
          PsiClass superClass;
          superType=current.getSuperTypes()[i++];
          superClass=superType.resolve();
          if (superClass == null)           return null;
          if (!set.contains(superClass))           set.add(superClass);
          return superClass;
        }
        public void remove(){
          throw new IllegalStateException("cannot.be.called");
        }
      }
;
    }
  }
;
}
