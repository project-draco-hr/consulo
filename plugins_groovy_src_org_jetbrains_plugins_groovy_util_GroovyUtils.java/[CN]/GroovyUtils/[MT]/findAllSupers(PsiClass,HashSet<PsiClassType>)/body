{
  return new Iterable<PsiClass>(){
    public Iterator<PsiClass> iterator(){
      return new Iterator<PsiClass>(){
        int i=0;
        final PsiClassType[] superTypes=psiClass.getSuperTypes();
        public boolean hasNext(){
          return i < superTypes.length;
        }
        public PsiClass next(){
          final PsiClassType classType=superTypes[i++];
          final PsiClass aClass=classType.resolve();
          if (aClass == null)           return null;
          if (visitedSupers.contains(classType)) {
            i++;
            final Iterator<PsiClass> iterator=findAllSupers(aClass,visitedSupers).iterator();
            if (iterator.hasNext()) {
              return iterator.next();
            }
 else             return null;
          }
          visitedSupers.add(classType);
          final Iterator<PsiClass> iterator=findAllSupers(aClass,visitedSupers).iterator();
          if (iterator.hasNext()) {
            return iterator.next();
          }
 else           return aClass;
        }
        public void remove(){
          throw new IllegalStateException("cannot.be.called");
        }
      }
;
    }
  }
;
}
