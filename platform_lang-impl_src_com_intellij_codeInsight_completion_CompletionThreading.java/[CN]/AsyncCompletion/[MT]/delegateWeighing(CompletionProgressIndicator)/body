{
  final LinkedBlockingQueue<Computable<Boolean>> queue=new LinkedBlockingQueue<Computable<Boolean>>();
class WeighItems implements Runnable {
    @Override public void run(){
      try {
        while (true) {
          Computable<Boolean> next=queue.poll(30,TimeUnit.MILLISECONDS);
          if (next != null && !next.compute()) {
            return;
          }
          indicator.checkCanceled();
        }
      }
 catch (      InterruptedException e) {
        LOG.error(e);
      }
    }
  }
  final Future<?> future=startThread(ProgressWrapper.wrap(indicator),new WeighItems());
  return new WeighingDelegate(){
    @Override public void waitFor(){
      queue.offer(new Computable.PredefinedValueComputable<Boolean>(false));
      try {
        future.get();
      }
 catch (      InterruptedException e) {
        LOG.error(e);
      }
catch (      ExecutionException e) {
        LOG.error(e);
      }
    }
    @Override public void consume(    final CompletionResult result){
      queue.offer(new Computable<Boolean>(){
        @Override public Boolean compute(){
          indicator.addItem(result);
          return true;
        }
      }
);
    }
  }
;
}
