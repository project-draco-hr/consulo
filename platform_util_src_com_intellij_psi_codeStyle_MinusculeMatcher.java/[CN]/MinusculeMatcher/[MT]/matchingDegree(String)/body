{
  Iterable<TextRange> iterable=matchingFragments(name);
  if (iterable == null)   return Integer.MIN_VALUE;
  int fragmentCount=0;
  int matchingCase=0;
  int p=-1;
  TextRange first=null;
  int integral=0;
  int humpIndex=0;
  int nextHumpStart=NameUtil.nextWord(name,0);
  for (  TextRange range : iterable) {
    if (first == null) {
      first=range;
    }
    for (int i=range.getStartOffset(); i < range.getEndOffset(); i++) {
      while (nextHumpStart < i) {
        nextHumpStart=NameUtil.nextWord(name,nextHumpStart);
        humpIndex++;
      }
      integral+=humpIndex;
      char c=name.charAt(i);
      p=StringUtil.indexOf(myPattern,c,p + 1,myPattern.length,false);
      if (p < 0) {
        break;
      }
      if (isUpperCase[p] || i == range.getStartOffset()) {
        matchingCase+=c == myPattern[p] ? 1 : 0;
      }
    }
    fragmentCount++;
  }
  if (first == null) {
    return 0;
  }
  int skipCount=CharArrayUtil.shiftForward(myPattern,0," *");
  int commonStart=0;
  while (commonStart < name.length() && commonStart + skipCount < myPattern.length && name.charAt(commonStart) == myPattern[commonStart + skipCount]) {
    commonStart++;
  }
  int startIndex=first.getStartOffset();
  boolean prefixMatching=isStartMatch(name,startIndex);
  boolean middleWordStart=!prefixMatching && startIndex > 0 && NameUtil.isWordStart(name,startIndex) && !NameUtil.isWordStart(name,startIndex - 1);
  return -fragmentCount + matchingCase * 20 + commonStart * 30 - startIndex + (prefixMatching ? 2 : middleWordStart ? 1 : 0) * 1000 - integral;
}
