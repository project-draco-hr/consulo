{
  if (!isFirstCharMatching(name,nameIndex,patternIndex)) {
    return null;
  }
  int minFragment=isPatternChar(patternIndex - 1,'*') && Character.isLetterOrDigit(name.charAt(nameIndex)) && !NameUtil.isWordStart(name,nameIndex) ? 2 : 1;
  int i=1;
  boolean ignoreCase=myOptions != NameUtil.MatchingCaseSensitivity.ALL;
  while (nameIndex + i < name.length() && patternIndex + i < myPattern.length && charEquals(myPattern[patternIndex + i],patternIndex + i,name.charAt(nameIndex + i),ignoreCase)) {
    if (isUpperCase[patternIndex + i]) {
      if (i < minFragment) {
        return null;
      }
      if (myPattern[patternIndex + i] != name.charAt(nameIndex + i)) {
        int nextWordStart=indexOfWordStart(name,patternIndex + i,nameIndex + i,isAsciiName);
        FList<TextRange> ranges=matchWildcards(name,patternIndex + i,nextWordStart,isAsciiName,matchingState);
        if (ranges != null) {
          return prependRange(ranges,nameIndex,i);
        }
        if (myHasHumps && i > 1 && isUpperCase[patternIndex + i - 1] && isUpperCase[patternIndex + i - 2]) {
          return null;
        }
      }
    }
    i++;
  }
  if (patternIndex + i >= myPattern.length) {
    return FList.<TextRange>emptyList().prepend(TextRange.from(nameIndex,i));
  }
  while (i >= minFragment) {
    FList<TextRange> ranges=isWildcard(patternIndex + i) ? matchWildcards(name,patternIndex + i,nameIndex + i,isAsciiName,matchingState) : matchSkippingWords(name,patternIndex + i,nameIndex + i,false,isAsciiName,matchingState);
    if (ranges != null) {
      return prependRange(ranges,nameIndex,i);
    }
    i--;
  }
  return null;
}
