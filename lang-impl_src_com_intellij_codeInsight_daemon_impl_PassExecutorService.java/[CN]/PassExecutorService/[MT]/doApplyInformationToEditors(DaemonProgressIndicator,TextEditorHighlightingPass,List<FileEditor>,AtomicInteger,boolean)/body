{
  if (isDisposed() || myProject.isDisposed()) {
    updateProgress.cancel();
  }
  if (updateProgress.isCanceled()) {
    log(updateProgress,pass," is canceled during apply, sorry");
    return;
  }
  boolean applied=false;
  for (  final FileEditor fileEditor : fileEditors) {
    LOG.assertTrue(fileEditor != null);
    try {
      if (testMode || fileEditor.getComponent().isDisplayable()) {
        if (!applied) {
          applied=true;
          log(updateProgress,pass," Applied");
          pass.applyInformationToEditor();
        }
        afterApplyInformationToEditor(pass,fileEditor,updateProgress);
        if (pass.isRunIntentionPassAfter() && fileEditor instanceof TextEditor && !updateProgress.isCanceled()) {
          Editor editor=((TextEditor)fileEditor).getEditor();
          ShowIntentionsPass ip=new ShowIntentionsPass(myProject,editor,-1);
          ip.setId(nextPassId.incrementAndGet());
          threadsToStartCountdown.incrementAndGet();
          submit(new ScheduledPass(fileEditors,ip,updateProgress,threadsToStartCountdown,Job.DEFAULT_PRIORITY));
        }
      }
    }
 catch (    RuntimeException e) {
      log(updateProgress,pass,"Error " + e);
      throw e;
    }
  }
  if (threadsToStartCountdown.decrementAndGet() == 0) {
    log(updateProgress,pass,"Stopping ");
    updateProgress.stopIfRunning();
  }
 else {
    log(updateProgress,pass,"Finished but there are passes in the queue: " + threadsToStartCountdown.get());
  }
}
