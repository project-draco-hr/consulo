{
  if (i >= kids.size()) {
    async.setRejected();
    return;
  }
  final AbstractTreeNode eachKid=kids.get(i);
  final boolean[] nodeWasCollapsed={true};
  final DefaultMutableTreeNode nodeForElement=getNodeForElement(eachKid);
  if (nodeForElement != null) {
    nodeWasCollapsed[0]=getTree().isCollapsed(new TreePath(nodeForElement.getPath()));
  }
  if (nonStopCondition.value(eachKid)) {
    expandPathTo(file,eachKid,element,nonStopCondition,indicator,virtualSelectTarget).doWhenDone(new AsyncResult.Handler<AbstractTreeNode>(){
      @Override public void run(      AbstractTreeNode abstractTreeNode){
        indicator.checkCanceled();
        async.setDone(abstractTreeNode);
      }
    }
).doWhenRejected(new Runnable(){
      @Override public void run(){
        indicator.checkCanceled();
        if (nodeWasCollapsed[0] && virtualSelectTarget == null) {
          collapseChildren(eachKid,null);
        }
        expandChild(kids,i + 1,nonStopCondition,file,element,async,indicator,virtualSelectTarget);
      }
    }
);
  }
 else {
    async.setRejected();
  }
}
