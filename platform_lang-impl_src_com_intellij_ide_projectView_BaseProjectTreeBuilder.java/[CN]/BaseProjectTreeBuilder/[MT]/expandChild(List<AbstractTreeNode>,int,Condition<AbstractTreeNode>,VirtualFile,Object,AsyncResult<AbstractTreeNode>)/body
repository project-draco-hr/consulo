{
  if (i >= kids.size()) {
    async.setRejected();
    return;
  }
  final AbstractTreeNode eachKid=kids.get(i);
  final boolean[] nodeWasCollapsed=new boolean[]{true};
  final DefaultMutableTreeNode nodeForElement=getNodeForElement(eachKid);
  if (nodeForElement != null) {
    nodeWasCollapsed[0]=getTree().isCollapsed(new TreePath(nodeForElement.getPath()));
  }
  if (nonStopCondition.value(eachKid)) {
    expandPathTo(file,eachKid,element,nonStopCondition).doWhenDone(new AsyncResult.Handler<AbstractTreeNode>(){
      public void run(      AbstractTreeNode abstractTreeNode){
        async.setDone(abstractTreeNode);
      }
    }
).doWhenRejected(new Runnable(){
      public void run(){
        if (nodeWasCollapsed[0]) {
          collapseChildren(eachKid,null);
        }
        expandChild(kids,i + 1,nonStopCondition,file,element,async);
      }
    }
);
  }
 else {
    async.setRejected();
  }
}
