{
  boolean includeLibs=includeLibraries || showAll.get();
  int clsCounter=0;
  final int maxCount=includeLibraries ? 5 : MAX_CLASSES;
  if (myClasses == null) {
    myClasses=myClassModel.getNames(false);
  }
  List<MatchResult> matches=collectResults(pattern,includeLibs ? myClassModel.getNames(true) : myClasses,myClassModel);
  final List<Object> classes=new ArrayList<Object>();
  for (  MatchResult matchResult : matches) {
    if (clsCounter > maxCount)     break;
    Object[] objects=myClassModel.getElementsByName(matchResult.elementName,includeLibs,pattern);
    for (    Object object : objects) {
      myProgressIndicator.checkCanceled();
      if (!myListModel.contains(object)) {
        if (object instanceof PsiElement) {
          VirtualFile file=PsiUtilCore.getVirtualFile((PsiElement)object);
          if (file != null) {
            if (myAlreadyAddedFiles.contains(file)) {
              continue;
            }
 else {
              myAlreadyAddedFiles.add(file);
            }
          }
        }
        classes.add(object);
        clsCounter++;
        if (clsCounter > maxCount)         break;
      }
    }
  }
  myProgressIndicator.checkCanceled();
  if (classes.size() > 0) {
    UIUtil.invokeLaterIfNeeded(new Runnable(){
      @Override public void run(){
        if (!myProgressIndicator.isCanceled()) {
          myTitleIndexes.classes=myListModel.size();
          for (          Object cls : classes) {
            myListModel.addElement(cls);
          }
          myMoreClassesIndex=classes.size() >= maxCount ? myListModel.size() - 1 : -1;
        }
      }
    }
);
  }
 else {
    if (!includeLibs) {
      buildClasses(pattern,true);
    }
  }
}
