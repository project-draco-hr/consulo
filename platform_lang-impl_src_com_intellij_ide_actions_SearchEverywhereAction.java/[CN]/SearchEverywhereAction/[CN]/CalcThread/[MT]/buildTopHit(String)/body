{
  final List<Object> elements=new ArrayList<Object>();
  HistoryItem history=myHistoryItem;
  if (history != null) {
    final HistoryType type=parseHistoryType(history.type);
    if (type != null) {
switch (type) {
case CLASS:
        break;
case FILE:
      final VirtualFile file=VirtualFileManager.getInstance().findFileByUrl(history.fqn);
    if (file != null) {
      elements.add(file);
    }
  break;
case SYMBOL:
break;
case SETTING:
break;
case ACTION:
final AnAction action=ActionManager.getInstance().getAction(history.fqn);
if (action != null) {
elements.add(action);
myAlreadyAddedActions.add(action);
}
break;
}
}
}
final Consumer<Object> consumer=new Consumer<Object>(){
@Override public void consume(Object o){
if (isSetting(o) || isVirtualFile(o) || isActionValue(o)|| o instanceof PsiElement) {
if (o instanceof AnAction && myAlreadyAddedActions.contains(o)) {
return;
}
elements.add(o);
}
}
}
;
final ActionManager actionManager=ActionManager.getInstance();
final List<String> actions=AbbreviationManager.getInstance().findActions(pattern);
for (String actionId : actions) {
consumer.consume(actionManager.getAction(actionId));
}
for (SearchTopHitProvider provider : SearchTopHitProvider.EP_NAME.getExtensions()) {
check();
provider.consumeTopHits(pattern,consumer);
}
if (elements.size() > 0) {
UIUtil.invokeLaterIfNeeded(new Runnable(){
@Override public void run(){
if (!myProgressIndicator.isCanceled()) {
myTitleIndexes.topHit=myListModel.size();
for (Object element : elements) {
myListModel.addElement(element);
}
}
}
}
);
}
}
