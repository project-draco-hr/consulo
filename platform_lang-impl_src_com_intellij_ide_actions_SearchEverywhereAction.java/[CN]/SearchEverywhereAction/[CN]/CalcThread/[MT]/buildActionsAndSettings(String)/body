{
  final Set<AnAction> actions=new HashSet<AnAction>();
  final Set<Object> settings=new HashSet<Object>();
  final MinusculeMatcher matcher=new MinusculeMatcher("*" + pattern,NameUtil.MatchingCaseSensitivity.NONE);
  if (myActions == null) {
    myActions=myActionModel.getNames(true);
  }
  List<MatchResult> matches=collectResults(pattern,myActions,myActionModel);
  for (  MatchResult o : matches) {
    myProgressIndicator.checkCanceled();
    Object[] objects=myActionModel.getElementsByName(o.elementName,true,pattern);
    for (    Object object : objects) {
      myProgressIndicator.checkCanceled();
      if (isSetting(object) && settings.size() < MAX_SETTINGS) {
        if (matcher.matches(getSettingText((OptionDescription)object))) {
          settings.add(object);
        }
      }
 else       if (!isToolWindowAction(object) && isActionValue(object) && actions.size() < MAX_ACTIONS) {
        actions.add((AnAction)((Map.Entry)object).getKey());
      }
    }
  }
  myProgressIndicator.checkCanceled();
  UIUtil.invokeLaterIfNeeded(new Runnable(){
    @Override public void run(){
      if (myProgressIndicator.isCanceled())       return;
      if (actions.size() > 0) {
        myTitleIndexes.actions=myListModel.size();
        for (        Object action : actions) {
          myListModel.addElement(action);
        }
      }
      myMoreActionsIndex=actions.size() >= MAX_ACTIONS ? myListModel.size() - 1 : -1;
      if (settings.size() > 0) {
        myTitleIndexes.settings=myListModel.size();
        for (        Object setting : settings) {
          myListModel.addElement(setting);
        }
      }
      myMoreSettingsIndex=settings.size() >= MAX_SETTINGS ? myListModel.size() - 1 : -1;
    }
  }
);
}
