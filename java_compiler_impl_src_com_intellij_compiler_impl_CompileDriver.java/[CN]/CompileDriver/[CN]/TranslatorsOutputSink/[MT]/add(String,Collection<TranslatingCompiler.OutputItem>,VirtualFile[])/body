{
  for (  TranslatingCompiler.OutputItem item : items) {
    final VirtualFile file=item.getSourceFile();
    if (file != null) {
      myCompiledSources.add(file);
    }
  }
  final TranslatingCompiler compiler=myCompilers[myCurrentCompilerIdx];
  if (compiler instanceof IntermediateOutputCompiler) {
    final LocalFileSystem lfs=LocalFileSystem.getInstance();
    final List<VirtualFile> outputs=new ArrayList<VirtualFile>();
    for (    TranslatingCompiler.OutputItem item : items) {
      final VirtualFile vFile=lfs.findFileByPath(item.getOutputPath());
      if (vFile != null) {
        outputs.add(vFile);
      }
    }
    myContext.markGenerated(outputs);
  }
  final int nextCompilerIdx=myCurrentCompilerIdx + 1;
  try {
    if (nextCompilerIdx < myCompilers.length) {
      final Map<String,Collection<TranslatingCompiler.OutputItem>> updateNow=new java.util.HashMap<String,Collection<TranslatingCompiler.OutputItem>>();
      for (      Map.Entry<String,Collection<TranslatingCompiler.OutputItem>> entry : myPostponedItems.entrySet()) {
        final String outputDir=entry.getKey();
        final Collection<TranslatingCompiler.OutputItem> postponed=entry.getValue();
        for (Iterator<TranslatingCompiler.OutputItem> it=postponed.iterator(); it.hasNext(); ) {
          TranslatingCompiler.OutputItem item=it.next();
          boolean shouldPostpone=false;
          for (int idx=nextCompilerIdx; idx < myCompilers.length; idx++) {
            if (shouldPostpone=myCompilers[idx].isCompilableFile(item.getSourceFile(),myContext)) {
              break;
            }
          }
          if (!shouldPostpone) {
            it.remove();
            addItemToMap(updateNow,outputDir,item);
          }
        }
      }
      for (      TranslatingCompiler.OutputItem item : items) {
        boolean shouldPostpone=false;
        for (int idx=nextCompilerIdx; idx < myCompilers.length; idx++) {
          if (shouldPostpone=myCompilers[idx].isCompilableFile(item.getSourceFile(),myContext)) {
            break;
          }
        }
        if (shouldPostpone) {
          addItemToMap(myPostponedItems,outputRoot,item);
        }
 else {
          addItemToMap(updateNow,outputRoot,item);
        }
      }
      if (updateNow.size() == 1) {
        final Map.Entry<String,Collection<TranslatingCompiler.OutputItem>> entry=updateNow.entrySet().iterator().next();
        final String outputDir=entry.getKey();
        final Collection<TranslatingCompiler.OutputItem> itemsToUpdate=entry.getValue();
        TranslatingCompilerFilesMonitor.getInstance().update(myContext,outputDir,itemsToUpdate,filesToRecompile);
      }
 else {
        for (        Map.Entry<String,Collection<TranslatingCompiler.OutputItem>> entry : updateNow.entrySet()) {
          final String outputDir=entry.getKey();
          final Collection<TranslatingCompiler.OutputItem> itemsToUpdate=entry.getValue();
          TranslatingCompilerFilesMonitor.getInstance().update(myContext,outputDir,itemsToUpdate,VirtualFile.EMPTY_ARRAY);
        }
        if (filesToRecompile.length > 0) {
          TranslatingCompilerFilesMonitor.getInstance().update(myContext,null,Collections.<TranslatingCompiler.OutputItem>emptyList(),filesToRecompile);
        }
      }
    }
 else {
      TranslatingCompilerFilesMonitor.getInstance().update(myContext,outputRoot,items,filesToRecompile);
    }
  }
 catch (  IOException e) {
    LOG.info(e);
    myContext.requestRebuildNextTime(e.getMessage());
  }
}
