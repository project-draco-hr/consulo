{
  ExitStatus status=ExitStatus.ERRORS;
  boolean wereExceptions=false;
  final long vfsTimestamp=((PersistentFS)ManagingFS.getInstance()).getCreationTimestamp();
  try {
    if (checkCachesVersion) {
      checkCachesVersion(compileContext,vfsTimestamp);
      if (compileContext.isRebuildRequested()) {
        return;
      }
    }
    writeStatus(new CompileStatus(CompilerConfigurationImpl.DEPENDENCY_FORMAT_VERSION,true,vfsTimestamp),compileContext);
    if (compileContext.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
      return;
    }
    myAllOutputDirectories=getAllOutputDirectories(compileContext);
    status=doCompile(compileContext,isRebuild,forceCompile,false);
  }
 catch (  Throwable ex) {
    if (ApplicationManager.getApplication().isUnitTestMode())     throw new RuntimeException(ex);
    wereExceptions=true;
    final PluginId pluginId=IdeErrorsDialog.findPluginId(ex);
    final StringBuffer message=new StringBuffer();
    message.append("Internal error");
    if (pluginId != null) {
      message.append(" (Plugin: ").append(pluginId).append(")");
    }
    message.append(": ").append(ex.getMessage());
    compileContext.addMessage(CompilerMessageCategory.ERROR,message.toString(),null,-1,-1);
    if (pluginId != null) {
      throw new PluginException(ex,pluginId);
    }
    throw new RuntimeException(ex);
  }
 finally {
    dropDependencyCache(compileContext);
    final ExitStatus _status=status;
    if (compileContext.isRebuildRequested()) {
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        public void run(){
          final CompilerMessageImpl msg=new CompilerMessageImpl(myProject,CompilerMessageCategory.INFORMATION,compileContext.getRebuildReason());
          doRebuild(callback,msg,false,compileContext.getCompileScope());
        }
      }
,ModalityState.NON_MODAL);
    }
 else {
      final long duration=System.currentTimeMillis() - compileContext.getStartCompilationStamp();
      if (!myProject.isDisposed()) {
        writeStatus(new CompileStatus(CompilerConfigurationImpl.DEPENDENCY_FORMAT_VERSION,wereExceptions,vfsTimestamp),compileContext);
      }
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        public void run(){
          if (myProject.isDisposed())           return;
          final int errorCount=compileContext.getMessageCount(CompilerMessageCategory.ERROR);
          final int warningCount=compileContext.getMessageCount(CompilerMessageCategory.WARNING);
          final String statusMessage=createStatusMessage(_status,warningCount,errorCount);
          final MessageType messageType=errorCount > 0 ? MessageType.ERROR : warningCount > 0 ? MessageType.WARNING : MessageType.INFO;
          if (duration > ONE_MINUTE_MS) {
            ToolWindowManager.getInstance(myProject).notifyByBalloon(ToolWindowId.MESSAGES_WINDOW,messageType,statusMessage);
          }
 else {
            String logMessage=statusMessage;
            if (_status == ExitStatus.UP_TO_DATE) {
              logMessage="Compilation: all files are up to date";
            }
            NOTIFICATION_GROUP.createNotification(logMessage,messageType.toNotificationType()).notify(myProject);
          }
          if (_status != ExitStatus.UP_TO_DATE && compileContext.getMessageCount(null) > 0) {
            compileContext.addMessage(CompilerMessageCategory.INFORMATION,statusMessage,null,-1,-1);
          }
          if (callback != null) {
            callback.finished(_status == ExitStatus.CANCELLED,errorCount,warningCount,compileContext);
          }
        }
      }
,ModalityState.NON_MODAL);
    }
  }
}
