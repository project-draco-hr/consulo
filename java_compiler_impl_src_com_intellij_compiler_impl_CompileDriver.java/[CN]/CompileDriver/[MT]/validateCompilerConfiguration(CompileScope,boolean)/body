{
  final Module[] scopeModules=scope.getAffectedModules();
  final List<String> modulesWithoutOutputPathSpecified=new ArrayList<String>();
  boolean isProjectCompilePathSpecified=true;
  final List<String> modulesWithoutJdkAssigned=new ArrayList<String>();
  final Set<File> nonExistingOutputPaths=new HashSet<File>();
  final CompilerConfiguration config=CompilerConfiguration.getInstance(myProject);
  for (  final Module module : scopeModules) {
    final boolean hasSources=hasSources(module,false);
    final boolean hasTestSources=hasSources(module,true);
    if (!hasSources && !hasTestSources) {
      continue;
    }
    final Sdk jdk=ModuleRootManager.getInstance(module).getSdk();
    if (jdk == null) {
      modulesWithoutJdkAssigned.add(module.getName());
    }
    final String outputPath=getModuleOutputPath(module,false);
    final String testsOutputPath=getModuleOutputPath(module,true);
    if (outputPath == null && testsOutputPath == null) {
      modulesWithoutOutputPathSpecified.add(module.getName());
    }
 else {
      if (outputPath != null) {
        final File file=new File(outputPath.replace('/',File.separatorChar));
        if (!file.exists()) {
          nonExistingOutputPaths.add(file);
        }
      }
 else {
        if (hasSources) {
          modulesWithoutOutputPathSpecified.add(module.getName());
        }
      }
      if (testsOutputPath != null) {
        final File f=new File(testsOutputPath.replace('/',File.separatorChar));
        if (!f.exists()) {
          nonExistingOutputPaths.add(f);
        }
      }
 else {
        if (hasTestSources) {
          modulesWithoutOutputPathSpecified.add(module.getName());
        }
      }
      if (config.isAnnotationProcessorsEnabled() && !config.getExcludedModules().contains(module)) {
        final String path=CompilerPaths.getAnnotationProcessorsGenerationPath(module);
        if (path == null) {
          if (CompilerProjectExtension.getInstance(module.getProject()).getCompilerOutputUrl() == null) {
            isProjectCompilePathSpecified=false;
          }
 else {
            modulesWithoutOutputPathSpecified.add(module.getName());
          }
        }
 else {
          final File file=new File(path);
          if (!file.exists()) {
            nonExistingOutputPaths.add(file);
          }
        }
      }
    }
  }
  if (!modulesWithoutJdkAssigned.isEmpty()) {
    showNotSpecifiedError("error.jdk.not.specified",modulesWithoutJdkAssigned,ProjectBundle.message("modules.classpath.title"));
    return false;
  }
  if (!isProjectCompilePathSpecified) {
    final String message=CompilerBundle.message("error.project.output.not.specified");
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      LOG.error(message);
    }
    Messages.showMessageDialog(myProject,message,CommonBundle.getErrorTitle(),Messages.getErrorIcon());
    ProjectSettingsService.getInstance(myProject).openProjectSettings();
    return false;
  }
  if (!modulesWithoutOutputPathSpecified.isEmpty()) {
    showNotSpecifiedError("error.output.not.specified",modulesWithoutOutputPathSpecified,CommonContentEntriesEditor.NAME);
    return false;
  }
  if (!nonExistingOutputPaths.isEmpty()) {
    for (    File file : nonExistingOutputPaths) {
      final boolean succeeded=file.mkdirs();
      if (!succeeded) {
        if (file.exists()) {
          continue;
        }
        Messages.showMessageDialog(myProject,CompilerBundle.message("error.failed.to.create.directory",file.getPath()),CommonBundle.getErrorTitle(),Messages.getErrorIcon());
        return false;
      }
    }
    final Boolean refreshSuccess=ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>(){
      public Boolean compute(){
        LocalFileSystem.getInstance().refreshIoFiles(nonExistingOutputPaths);
        for (        File file : nonExistingOutputPaths) {
          if (LocalFileSystem.getInstance().findFileByIoFile(file) == null) {
            return Boolean.FALSE;
          }
        }
        return Boolean.TRUE;
      }
    }
);
    if (!refreshSuccess.booleanValue()) {
      return false;
    }
    dropScopesCaches();
  }
  if (checkOutputAndSourceIntersection) {
    if (myShouldClearOutputDirectory) {
      if (!validateOutputAndSourcePathsIntersection()) {
        return false;
      }
    }
  }
  final List<Chunk<Module>> chunks=ModuleCompilerUtil.getSortedModuleChunks(myProject,Arrays.asList(scopeModules));
  for (  final Chunk<Module> chunk : chunks) {
    final Set<Module> chunkModules=chunk.getNodes();
    if (chunkModules.size() <= 1) {
      continue;
    }
    if (config.isAnnotationProcessorsEnabled()) {
      final Set<Module> excluded=config.getExcludedModules();
      for (      Module chunkModule : chunkModules) {
        if (!excluded.contains(chunkModule)) {
          showCyclesNotSupportedForAnnotationProcessors(chunkModules.toArray(new Module[chunkModules.size()]));
          return false;
        }
      }
    }
    Sdk jdk=null;
    LanguageLevel languageLevel=null;
    for (    final Module module : chunkModules) {
      final Sdk moduleJdk=ModuleRootManager.getInstance(module).getSdk();
      if (jdk == null) {
        jdk=moduleJdk;
      }
 else {
        if (!jdk.equals(moduleJdk)) {
          showCyclicModulesHaveDifferentJdksError(chunkModules.toArray(new Module[chunkModules.size()]));
          return false;
        }
      }
      LanguageLevel moduleLanguageLevel=LanguageLevelUtil.getEffectiveLanguageLevel(module);
      if (languageLevel == null) {
        languageLevel=moduleLanguageLevel;
      }
 else {
        if (!languageLevel.equals(moduleLanguageLevel)) {
          showCyclicModulesHaveDifferentLanguageLevel(chunkModules.toArray(new Module[chunkModules.size()]));
          return false;
        }
      }
    }
  }
  final Compiler[] allCompilers=CompilerManager.getInstance(myProject).getCompilers(Compiler.class);
  for (  Compiler compiler : allCompilers) {
    if (!compiler.validateConfiguration(scope)) {
      return false;
    }
  }
  return true;
}
