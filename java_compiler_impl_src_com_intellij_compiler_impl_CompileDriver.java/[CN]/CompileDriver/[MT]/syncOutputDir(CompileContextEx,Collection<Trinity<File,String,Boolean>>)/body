{
  final DependencyCache dependencyCache=context.getDependencyCache();
  final boolean isTestMode=ApplicationManager.getApplication().isUnitTestMode();
  final List<File> filesToRefresh=new ArrayList<File>();
  final boolean[] wereFilesDeleted={false};
  CompilerUtil.runInContext(context,CompilerBundle.message("progress.synchronizing.output.directory"),new ThrowableRunnable<CacheCorruptedException>(){
    public void run() throws CacheCorruptedException {
      final long start=System.currentTimeMillis();
      try {
        for (        final Trinity<File,String,Boolean> trinity : toDelete) {
          final File outputPath=trinity.getFirst();
          context.getProgressIndicator().checkCanceled();
          context.getProgressIndicator().setText2(outputPath.getPath());
          filesToRefresh.add(outputPath);
          if (isTestMode) {
            LOG.assertTrue(outputPath.exists());
          }
          if (!deleteFile(outputPath)) {
            if (isTestMode && outputPath.exists()) {
              LOG.error("Was not able to delete output file: " + outputPath.getPath());
            }
            continue;
          }
          wereFilesDeleted[0]=true;
          final String className=trinity.getSecond();
          if (className != null) {
            final int id=dependencyCache.getSymbolTable().getId(className);
            dependencyCache.addTraverseRoot(id);
            final boolean sourcePresent=trinity.getThird().booleanValue();
            if (!sourcePresent) {
              dependencyCache.markSourceRemoved(id);
            }
          }
          if (isTestMode) {
            CompilerManagerImpl.addDeletedPath(outputPath.getPath());
          }
        }
      }
  finally {
        CompilerUtil.logDuration("Sync output directory",System.currentTimeMillis() - start);
        CompilerUtil.refreshIOFiles(filesToRefresh);
      }
    }
  }
);
  return wereFilesDeleted[0];
}
