{
  if (LOG.isDebugEnabled()) {
    LOG.debug("isUpToDate operation started");
  }
  if (!useOutOfProcessBuild()) {
    scope=addAdditionalRoots(scope,ALL_EXCEPT_SOURCE_PROCESSING);
  }
 else {
    final Application app=ApplicationManager.getApplication();
    if (!app.isUnitTestMode()) {
      final boolean isDispatchThread=app.isDispatchThread();
      LOG.assertTrue(!isDispatchThread,"Calling isUpToDate() from Event Dispatch Thread may cause deadlocks");
      if (isDispatchThread) {
        return false;
      }
    }
  }
  final CompilerTask task=new CompilerTask(myProject,"Classes up-to-date check",true,false);
  final DependencyCache cache=useOutOfProcessBuild() ? null : createDependencyCache();
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,task,scope,cache,true,false);
  if (!useOutOfProcessBuild()) {
    checkCachesVersion(compileContext,ManagingFS.getInstance().getCreationTimestamp());
    if (compileContext.isRebuildRequested()) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Rebuild requested, up-to-date=false");
      }
      return false;
    }
    for (    Map.Entry<Pair<IntermediateOutputCompiler,Module>,Pair<VirtualFile,VirtualFile>> entry : myGenerationCompilerModuleToOutputDirMap.entrySet()) {
      final Pair<VirtualFile,VirtualFile> outputs=entry.getValue();
      final Pair<IntermediateOutputCompiler,Module> key=entry.getKey();
      final Module module=key.getSecond();
      compileContext.assignModule(outputs.getFirst(),module,false,key.getFirst());
      compileContext.assignModule(outputs.getSecond(),module,true,key.getFirst());
    }
  }
  final Ref<ExitStatus> result=new Ref<ExitStatus>();
  final Runnable compileWork;
  if (useOutOfProcessBuild()) {
    compileWork=new Runnable(){
      public void run(){
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        if (indicator.isCanceled() || myProject.isDisposed()) {
          return;
        }
        try {
          final Collection<String> paths=CompileScopeUtil.fetchFiles(compileContext);
          List<TargetTypeBuildScope> scopes=new ArrayList<TargetTypeBuildScope>();
          if (paths.isEmpty()) {
            if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) {
              CompileScopeUtil.addScopesForModules(Arrays.asList(compileContext.getCompileScope().getAffectedModules()),scopes);
            }
 else {
              scopes.addAll(CmdlineProtoUtil.createAllModulesScopes());
            }
            for (            BuildTargetScopeProvider provider : BuildTargetScopeProvider.EP_NAME.getExtensions()) {
              scopes=CompileScopeUtil.mergeScopes(scopes,provider.getBuildTargetScopes(compileContext.getCompileScope(),myCompilerFilter,myProject));
            }
          }
          final RequestFuture future=compileInExternalProcess(compileContext,scopes,paths,true);
          if (future != null) {
            while (!future.waitFor(200L,TimeUnit.MILLISECONDS)) {
              if (indicator.isCanceled()) {
                future.cancel(false);
              }
            }
          }
        }
 catch (        Throwable e) {
          LOG.error(e);
        }
 finally {
          result.set(COMPILE_SERVER_BUILD_STATUS.get(compileContext));
          CompilerCacheManager.getInstance(myProject).flushCaches();
        }
      }
    }
;
  }
 else {
    compileWork=new Runnable(){
      public void run(){
        try {
          myAllOutputDirectories=getAllOutputDirectories(compileContext);
          result.set(doCompile(compileContext,false,false,true));
        }
  finally {
          CompilerCacheManager.getInstance(myProject).flushCaches();
        }
      }
    }
;
  }
  task.start(compileWork,null);
  if (LOG.isDebugEnabled()) {
    LOG.debug("isUpToDate operation finished");
  }
  return ExitStatus.UP_TO_DATE.equals(result.get());
}
