{
  try {
    if (isRebuild) {
      deleteAll(context);
    }
 else     if (forceCompile) {
      if (myShouldClearOutputDirectory) {
        clearAffectedOutputPathsIfPossible(context);
      }
    }
    if (context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
      if (LOG.isDebugEnabled()) {
        logErrorMessages(context);
      }
      return ExitStatus.ERRORS;
    }
    if (!onlyCheckStatus) {
      if (!executeCompileTasks(context,true)) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Compilation cancelled");
        }
        return ExitStatus.CANCELLED;
      }
    }
    if (context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
      if (LOG.isDebugEnabled()) {
        logErrorMessages(context);
      }
      return ExitStatus.ERRORS;
    }
    boolean needRecalcOutputDirs=false;
    if (Registry.is(PROP_PERFORM_INITIAL_REFRESH) || !myInitialRefreshPerformed) {
      myInitialRefreshPerformed=true;
      final long refreshStart=System.currentTimeMillis();
      final VirtualFile[] all=context.getAllOutputDirectories();
      final ProgressIndicator progressIndicator=context.getProgressIndicator();
      final int totalCount=all.length + myGenerationCompilerModuleToOutputDirMap.size() * 2;
      final CountDownLatch latch=new CountDownLatch(totalCount);
      final Runnable decCount=new Runnable(){
        public void run(){
          latch.countDown();
          progressIndicator.setFraction(((double)(totalCount - latch.getCount())) / totalCount);
        }
      }
;
      progressIndicator.pushState();
      progressIndicator.setText("Inspecting output directories...");
      final boolean asyncMode=!ApplicationManager.getApplication().isDispatchThread();
      try {
        for (        VirtualFile output : all) {
          if (output.isValid()) {
            walkChildren(output,context);
          }
 else {
            needRecalcOutputDirs=true;
            final File file=new File(output.getPath());
            if (!file.exists()) {
              final boolean created=file.mkdirs();
              if (!created) {
                context.addMessage(CompilerMessageCategory.ERROR,"Failed to create output directory " + file.getPath(),null,0,0);
                return ExitStatus.ERRORS;
              }
            }
            output=LocalFileSystem.getInstance().refreshAndFindFileByIoFile(file);
            if (output == null) {
              context.addMessage(CompilerMessageCategory.ERROR,"Failed to locate output directory " + file.getPath(),null,0,0);
              return ExitStatus.ERRORS;
            }
          }
          output.refresh(asyncMode,true,decCount);
        }
        for (        Pair<IntermediateOutputCompiler,Module> pair : myGenerationCompilerModuleToOutputDirMap.keySet()) {
          final Pair<VirtualFile,VirtualFile> generated=myGenerationCompilerModuleToOutputDirMap.get(pair);
          walkChildren(generated.getFirst(),context);
          generated.getFirst().refresh(asyncMode,true,decCount);
          walkChildren(generated.getSecond(),context);
          generated.getSecond().refresh(asyncMode,true,decCount);
        }
        try {
          while (latch.getCount() > 0) {
            latch.await(500,TimeUnit.MILLISECONDS);
            if (progressIndicator.isCanceled()) {
              return ExitStatus.CANCELLED;
            }
          }
        }
 catch (        InterruptedException e) {
          LOG.info(e);
        }
      }
  finally {
        progressIndicator.popState();
      }
      final long initialRefreshTime=System.currentTimeMillis() - refreshStart;
      CompilerUtil.logDuration("Initial VFS refresh",initialRefreshTime);
      CompilerUtil.ourRefreshTime+=initialRefreshTime;
    }
    final Semaphore semaphore=new Semaphore();
    semaphore.down();
    DumbService.getInstance(myProject).runWhenSmart(new Runnable(){
      public void run(){
        semaphore.up();
      }
    }
);
    while (!semaphore.waitFor(500)) {
      if (context.getProgressIndicator().isCanceled()) {
        return ExitStatus.CANCELLED;
      }
    }
    if (needRecalcOutputDirs) {
      context.recalculateOutputDirs();
    }
    boolean didSomething=false;
    final CompilerManager compilerManager=CompilerManager.getInstance(myProject);
    try {
      didSomething|=generateSources(compilerManager,context,forceCompile,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,SourceInstrumentingCompiler.class,FILE_PROCESSING_COMPILER_ADAPTER_FACTORY,forceCompile,true,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,SourceProcessingCompiler.class,FILE_PROCESSING_COMPILER_ADAPTER_FACTORY,forceCompile,true,onlyCheckStatus);
      final CompileScope intermediateSources=attachIntermediateOutputDirectories(new CompositeScope(CompileScope.EMPTY_ARRAY){
        @NotNull public Module[] getAffectedModules(){
          return context.getCompileScope().getAffectedModules();
        }
      }
,SOURCE_PROCESSING_ONLY);
      context.addScope(intermediateSources);
      didSomething|=translate(context,compilerManager,forceCompile,isRebuild,trackDependencies,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,ClassInstrumentingCompiler.class,FILE_PROCESSING_COMPILER_ADAPTER_FACTORY,isRebuild,false,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,ClassPostProcessingCompiler.class,FILE_PROCESSING_COMPILER_ADAPTER_FACTORY,isRebuild,false,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,PackagingCompiler.class,FILE_PACKAGING_COMPILER_ADAPTER_FACTORY,isRebuild,false,onlyCheckStatus);
      didSomething|=invokeFileProcessingCompilers(compilerManager,context,Validator.class,FILE_PROCESSING_COMPILER_ADAPTER_FACTORY,forceCompile,true,onlyCheckStatus);
    }
 catch (    ExitException e) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(e);
        logErrorMessages(context);
      }
      return e.getExitStatus();
    }
 finally {
      dropDependencyCache(context);
      final VirtualFile[] allOutputDirs=context.getAllOutputDirectories();
      if (didSomething && GENERATE_CLASSPATH_INDEX) {
        CompilerUtil.runInContext(context,"Generating classpath index...",new ThrowableRunnable<RuntimeException>(){
          public void run(){
            int count=0;
            for (            VirtualFile file : allOutputDirs) {
              context.getProgressIndicator().setFraction((double)++count / allOutputDirs.length);
              createClasspathIndex(file);
            }
          }
        }
);
      }
      if (!context.getProgressIndicator().isCanceled() && context.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
        RefreshQueue.getInstance().refresh(true,true,new Runnable(){
          public void run(){
            CompilerDirectoryTimestamp.updateTimestamp(Arrays.asList(allOutputDirs));
          }
        }
,allOutputDirs);
      }
    }
    if (!onlyCheckStatus) {
      if (!executeCompileTasks(context,false)) {
        return ExitStatus.CANCELLED;
      }
    }
    if (context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
      if (LOG.isDebugEnabled()) {
        logErrorMessages(context);
      }
      return ExitStatus.ERRORS;
    }
    if (!didSomething) {
      return ExitStatus.UP_TO_DATE;
    }
    return ExitStatus.SUCCESS;
  }
 catch (  ProcessCanceledException e) {
    return ExitStatus.CANCELLED;
  }
}
