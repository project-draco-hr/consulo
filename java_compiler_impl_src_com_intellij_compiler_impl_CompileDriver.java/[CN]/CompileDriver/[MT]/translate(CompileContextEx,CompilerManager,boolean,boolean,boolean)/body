{
  boolean didSomething=false;
  final TranslatingCompiler[] translators=compilerManager.getCompilers(TranslatingCompiler.class,myCompilerFilter);
  final List<Chunk<Module>> sortedChunks=Collections.unmodifiableList(ApplicationManager.getApplication().runReadAction(new Computable<List<Chunk<Module>>>(){
    public List<Chunk<Module>> compute(){
      final ModuleManager moduleManager=ModuleManager.getInstance(myProject);
      return ModuleCompilerUtil.getSortedModuleChunks(myProject,Arrays.asList(moduleManager.getModules()));
    }
  }
));
  final DumbService dumbService=DumbService.getInstance(myProject);
  try {
    final Set<Module> processedModules=new HashSet<Module>();
    VirtualFile[] snapshot=null;
    final Map<Chunk<Module>,Collection<VirtualFile>> chunkMap=new HashMap<Chunk<Module>,Collection<VirtualFile>>();
    int total=0;
    int processed=0;
    for (    final Chunk<Module> currentChunk : sortedChunks) {
      final TranslatorsOutputSink sink=new TranslatorsOutputSink(context,translators);
      final Set<FileType> generatedTypes=new HashSet<FileType>();
      Collection<VirtualFile> chunkFiles=chunkMap.get(currentChunk);
      final Set<VirtualFile> filesToRecompile=new HashSet<VirtualFile>();
      final Set<VirtualFile> allDependent=new HashSet<VirtualFile>();
      try {
        int round=0;
        boolean compiledSomethingForThisChunk=false;
        Collection<VirtualFile> dependentFiles=Collections.emptyList();
        final Function<Pair<int[],Set<VirtualFile>>,Pair<int[],Set<VirtualFile>>> dependencyFilter=new DependentClassesCumulativeFilter();
        do {
          generatedTypes.clear();
          for (int currentCompiler=0, translatorsLength=translators.length; currentCompiler < translatorsLength; currentCompiler++) {
            sink.setCurrentCompilerIndex(currentCompiler);
            final TranslatingCompiler compiler=translators[currentCompiler];
            if (context.getProgressIndicator().isCanceled()) {
              throw new ExitException(ExitStatus.CANCELLED);
            }
            dumbService.waitForSmartMode();
            if (snapshot == null || ContainerUtil.intersects(generatedTypes,compilerManager.getRegisteredInputTypes(compiler))) {
              snapshot=ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile[]>(){
                public VirtualFile[] compute(){
                  return context.getCompileScope().getFiles(null,true);
                }
              }
);
              recalculateChunkToFilesMap(context,sortedChunks,snapshot,chunkMap);
              chunkFiles=chunkMap.get(currentChunk);
              total=snapshot.length * translatorsLength;
            }
            final CompileContextEx _context;
            if (compiler instanceof IntermediateOutputCompiler) {
              final IntermediateOutputCompiler _compiler=(IntermediateOutputCompiler)compiler;
              _context=new CompileContextExProxy(context){
                public VirtualFile getModuleOutputDirectory(                final Module module){
                  return getGenerationOutputDir(_compiler,module,false);
                }
                public VirtualFile getModuleOutputDirectoryForTests(                final Module module){
                  return getGenerationOutputDir(_compiler,module,true);
                }
              }
;
            }
 else {
              _context=context;
            }
            final boolean compiledSomething=compileSources(_context,currentChunk,compiler,chunkFiles,round == 0 ? forceCompile : true,isRebuild,onlyCheckStatus,sink);
            processed+=chunkFiles.size();
            _context.getProgressIndicator().setFraction(((double)processed) / total);
            if (compiledSomething) {
              generatedTypes.addAll(compilerManager.getRegisteredOutputTypes(compiler));
            }
            didSomething|=compiledSomething;
            compiledSomethingForThisChunk|=didSomething;
            if (_context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
              break;
            }
          }
          final boolean hasUnprocessedTraverseRoots=context.getDependencyCache().hasUnprocessedTraverseRoots();
          if (!isRebuild && (compiledSomethingForThisChunk || hasUnprocessedTraverseRoots)) {
            final Set<VirtualFile> compiledWithErrors=CacheUtils.getFilesCompiledWithErrors(context);
            filesToRecompile.removeAll(sink.getCompiledSources());
            filesToRecompile.addAll(compiledWithErrors);
            dependentFiles=CacheUtils.findDependentFiles(context,compiledWithErrors,dependencyFilter);
            if (!processedModules.isEmpty()) {
              for (Iterator<VirtualFile> it=dependentFiles.iterator(); it.hasNext(); ) {
                final VirtualFile next=it.next();
                final Module module=context.getModuleByFile(next);
                if (module != null && processedModules.contains(module)) {
                  it.remove();
                }
              }
            }
            if (ourDebugMode) {
              if (!dependentFiles.isEmpty()) {
                for (                VirtualFile dependentFile : dependentFiles) {
                  System.out.println("FOUND TO RECOMPILE: " + dependentFile.getPresentableUrl());
                }
              }
 else {
                System.out.println("NO FILES TO RECOMPILE");
              }
            }
            if (!dependentFiles.isEmpty()) {
              filesToRecompile.addAll(dependentFiles);
              allDependent.addAll(dependentFiles);
              if (context.getProgressIndicator().isCanceled() || context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
                break;
              }
              final List<VirtualFile> filesInScope=getFilesInScope(context,currentChunk,dependentFiles);
              if (filesInScope.isEmpty()) {
                break;
              }
              context.getDependencyCache().clearTraverseRoots();
              chunkFiles=filesInScope;
              total+=chunkFiles.size() * translators.length;
            }
            didSomething|=(hasUnprocessedTraverseRoots != context.getDependencyCache().hasUnprocessedTraverseRoots());
          }
          round++;
        }
 while (!dependentFiles.isEmpty() && context.getMessageCount(CompilerMessageCategory.ERROR) == 0);
        if (CompilerConfiguration.MAKE_ENABLED) {
          if (!context.getProgressIndicator().isCanceled()) {
            final ProgressIndicator indicator=context.getProgressIndicator();
            final DependencyCache cache=context.getDependencyCache();
            indicator.pushState();
            indicator.setText(CompilerBundle.message("progress.updating.caches"));
            indicator.setText2("");
            cache.update();
            indicator.setText(CompilerBundle.message("progress.saving.caches"));
            cache.resetState();
            processedModules.addAll(currentChunk.getNodes());
            indicator.popState();
          }
        }
        if (context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
          throw new ExitException(ExitStatus.ERRORS);
        }
      }
 catch (      CacheCorruptedException e) {
        LOG.info(e);
        context.requestRebuildNextTime(e.getMessage());
      }
 finally {
        final int errorCount=context.getMessageCount(CompilerMessageCategory.ERROR);
        if (errorCount != 0) {
          filesToRecompile.addAll(allDependent);
        }
        if (filesToRecompile.size() > 0) {
          sink.add(null,Collections.<TranslatingCompiler.OutputItem>emptyList(),VfsUtil.toVirtualFileArray(filesToRecompile));
        }
        if (errorCount == 0) {
          sink.flushPostponedItems();
        }
      }
    }
  }
 catch (  ProcessCanceledException e) {
    ProgressManager.getInstance().executeNonCancelableSection(new Runnable(){
      public void run(){
        try {
          final Collection<VirtualFile> deps=CacheUtils.findDependentFiles(context,Collections.<VirtualFile>emptySet(),null);
          if (deps.size() > 0) {
            TranslatingCompilerFilesMonitor.getInstance().update(context,null,Collections.<TranslatingCompiler.OutputItem>emptyList(),VfsUtil.toVirtualFileArray(deps));
          }
        }
 catch (        IOException ignored) {
          LOG.info(ignored);
        }
catch (        CacheCorruptedException ignored) {
          LOG.info(ignored);
        }
catch (        ExitException e1) {
          LOG.info(e1);
        }
      }
    }
);
    throw e;
  }
 finally {
    dropDependencyCache(context);
    if (didSomething) {
      TranslatingCompilerFilesMonitor.getInstance().updateOutputRootsLayout(myProject);
    }
  }
  return didSomething;
}
