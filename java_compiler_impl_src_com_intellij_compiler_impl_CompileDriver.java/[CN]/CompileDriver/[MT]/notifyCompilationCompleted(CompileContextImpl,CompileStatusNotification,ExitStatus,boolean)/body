{
  final long duration=System.currentTimeMillis() - compileContext.getStartCompilationStamp();
  if (refreshOutputRoots) {
    final Set<File> outputs=new HashSet<File>();
    final Module[] affectedModules=compileContext.getCompileScope().getAffectedModules();
    for (    final String path : CompilerPathsEx.getOutputPaths(affectedModules)) {
      outputs.add(new File(path));
    }
    final LocalFileSystem lfs=LocalFileSystem.getInstance();
    if (!outputs.isEmpty()) {
      final ProgressIndicator indicator=compileContext.getProgressIndicator();
      indicator.setText("Synchronizing output directories...");
      lfs.refreshIoFiles(outputs,false,false,null);
      indicator.setText("");
    }
    if (compileContext.isAnnotationProcessorsEnabled()) {
      final Set<VirtualFile> genSourceRoots=new HashSet<VirtualFile>();
      final CompilerConfiguration config=CompilerConfiguration.getInstance(myProject);
      for (      Module module : affectedModules) {
        if (config.getAnnotationProcessingConfiguration(module).isEnabled()) {
          final String path=CompilerPaths.getAnnotationProcessorsGenerationPath(module);
          if (path != null) {
            final File genPath=new File(path);
            final VirtualFile vFile=lfs.findFileByIoFile(genPath);
            if (vFile != null && ModuleRootManager.getInstance(module).getFileIndex().isInSourceContent(vFile)) {
              genSourceRoots.add(vFile);
            }
          }
        }
      }
      if (!genSourceRoots.isEmpty()) {
        lfs.refreshFiles(genSourceRoots,true,true,null);
      }
    }
  }
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      int errorCount=0;
      int warningCount=0;
      try {
        errorCount=compileContext.getMessageCount(CompilerMessageCategory.ERROR);
        warningCount=compileContext.getMessageCount(CompilerMessageCategory.WARNING);
        if (!myProject.isDisposed()) {
          final String statusMessage=createStatusMessage(_status,warningCount,errorCount,duration);
          final MessageType messageType=errorCount > 0 ? MessageType.ERROR : warningCount > 0 ? MessageType.WARNING : MessageType.INFO;
          if (duration > ONE_MINUTE_MS) {
            ToolWindowManager.getInstance(myProject).notifyByBalloon(ToolWindowId.MESSAGES_WINDOW,messageType,statusMessage);
          }
          CompilerManager.NOTIFICATION_GROUP.createNotification(statusMessage,messageType).notify(myProject);
          if (_status != ExitStatus.UP_TO_DATE && compileContext.getMessageCount(null) > 0) {
            compileContext.addMessage(CompilerMessageCategory.INFORMATION,statusMessage,null,-1,-1);
          }
        }
      }
  finally {
        if (callback != null) {
          callback.finished(_status == ExitStatus.CANCELLED,errorCount,warningCount,compileContext);
        }
      }
    }
  }
);
  return duration;
}
