{
  boolean didSomething=false;
  final TranslatingCompiler[] translators=compilerManager.getCompilers(TranslatingCompiler.class,myCompilerFilter);
  final Set<FileType> generatedTypes=new HashSet<FileType>();
  VirtualFile[] snapshot=null;
  final TranslatorsOutputSink sink=new TranslatorsOutputSink(context,translators);
  try {
    for (int currentCompiler=0, translatorsLength=translators.length; currentCompiler < translatorsLength; currentCompiler++) {
      sink.setCurrentCompilerIndex(currentCompiler);
      final TranslatingCompiler translator=translators[currentCompiler];
      if (context.getProgressIndicator().isCanceled()) {
        throw new ExitException(ExitStatus.CANCELLED);
      }
      DumbService.getInstance(myProject).waitForSmartMode();
      if (snapshot == null || ContainerUtil.intersects(generatedTypes,compilerManager.getRegisteredInputTypes(translator))) {
        snapshot=ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile[]>(){
          public VirtualFile[] compute(){
            return context.getCompileScope().getFiles(null,true);
          }
        }
);
      }
      final CompileContextEx _context;
      if (translator instanceof IntermediateOutputCompiler) {
        final IntermediateOutputCompiler _translator=(IntermediateOutputCompiler)translator;
        _context=new CompileContextExProxy(context){
          public VirtualFile getModuleOutputDirectory(          final Module module){
            return getGenerationOutputDir(_translator,module,false);
          }
          public VirtualFile getModuleOutputDirectoryForTests(          final Module module){
            return getGenerationOutputDir(_translator,module,true);
          }
        }
;
      }
 else {
        _context=context;
      }
      final boolean compiledSomething=compileSources(_context,translators,currentCompiler,snapshot,forceCompile,isRebuild,trackDependencies,onlyCheckStatus,sink);
      if (compiledSomething) {
        generatedTypes.addAll(compilerManager.getRegisteredOutputTypes(translator));
      }
      if (_context.getMessageCount(CompilerMessageCategory.ERROR) > 0) {
        throw new ExitException(ExitStatus.ERRORS);
      }
      didSomething|=compiledSomething;
    }
  }
  finally {
    if (context.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
      sink.flushPostponedItems();
    }
    dropDependencyCache(context);
  }
  return didSomething;
}
