{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final boolean useExtProcessBuild=useOutOfProcessBuild();
  final String contentName=forceCompile ? CompilerBundle.message("compiler.content.name.compile") : CompilerBundle.message("compiler.content.name.make");
  final boolean compileInBackground=true;
  final CompilerTask compileTask=new CompilerTask(myProject,compileInBackground,contentName,ApplicationManager.getApplication().isUnitTestMode());
  StatusBar.Info.set("",myProject,"Compiler");
  if (useExtProcessBuild && BuildManager.getInstance().rescanRequired(myProject)) {
    myProject.save();
  }
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  FileDocumentManager.getInstance().saveAllDocuments();
  final DependencyCache dependencyCache=useExtProcessBuild ? null : createDependencyCache();
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,compileTask,scope,dependencyCache,!isRebuild && !forceCompile,isRebuild);
  if (!useExtProcessBuild) {
    for (    Map.Entry<Pair<IntermediateOutputCompiler,Module>,Pair<VirtualFile,VirtualFile>> entry : myGenerationCompilerModuleToOutputDirMap.entrySet()) {
      final Pair<VirtualFile,VirtualFile> outputs=entry.getValue();
      final Pair<IntermediateOutputCompiler,Module> key=entry.getKey();
      final Module module=key.getSecond();
      compileContext.assignModule(outputs.getFirst(),module,false,key.getFirst());
      compileContext.assignModule(outputs.getSecond(),module,true,key.getFirst());
    }
    attachAnnotationProcessorsOutputDirectories(compileContext);
  }
  final Runnable compileWork;
  if (useExtProcessBuild) {
    compileWork=new Runnable(){
      public void run(){
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        if (indicator.isCanceled() || myProject.isDisposed()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        try {
          LOG.info("COMPILATION STARTED (BUILD PROCESS)");
          if (message != null) {
            compileContext.addMessage(message);
          }
          if (!executeCompileTasks(compileContext,true)) {
            COMPILE_SERVER_BUILD_STATUS.set(compileContext,ExitStatus.CANCELLED);
            return;
          }
          final Collection<String> paths=fetchFiles(compileContext);
          final List<Module> modules=paths.isEmpty() && !isRebuild && !allProjectModulesAffected(compileContext) ? Arrays.asList(compileContext.getCompileScope().getAffectedModules()) : Collections.<Module>emptyList();
          final Set<Artifact> artifacts=ArtifactCompileScope.getArtifactsToBuild(myProject,compileContext.getCompileScope(),true);
          final RequestFuture future=compileInExternalProcess(compileContext,modules,artifacts,paths,callback);
          if (future != null) {
            while (!future.waitFor(200L,TimeUnit.MILLISECONDS)) {
              if (indicator.isCanceled()) {
                future.cancel(false);
              }
            }
            if (!executeCompileTasks(compileContext,false)) {
              COMPILE_SERVER_BUILD_STATUS.set(compileContext,ExitStatus.CANCELLED);
              return;
            }
          }
        }
 catch (        Throwable e) {
          LOG.error(e);
        }
 finally {
          final long duration=notifyCompilationCompleted(compileContext,callback,COMPILE_SERVER_BUILD_STATUS.get(compileContext));
          CompilerUtil.logDuration("\tCOMPILATION FINISHED (BUILD PROCESS); Errors: " + compileContext.getMessageCount(CompilerMessageCategory.ERROR) + "; warnings: "+ compileContext.getMessageCount(CompilerMessageCategory.WARNING),duration);
          CompilerCacheManager.getInstance(myProject).flushCaches();
          if (ApplicationManager.getApplication().isUnitTestMode()) {
            final Set<File> outputs=new HashSet<File>();
            for (            final String path : CompilerPathsEx.getOutputPaths(ModuleManager.getInstance(myProject).getModules())) {
              outputs.add(new File(path));
            }
            CompilerUtil.refreshIOFiles(outputs);
          }
        }
      }
    }
;
  }
 else {
    compileWork=new Runnable(){
      public void run(){
        if (compileContext.getProgressIndicator().isCanceled()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        try {
          if (myProject.isDisposed()) {
            return;
          }
          LOG.info("COMPILATION STARTED");
          if (message != null) {
            compileContext.addMessage(message);
          }
          TranslatingCompilerFilesMonitor.getInstance().ensureInitializationCompleted(myProject,compileContext.getProgressIndicator());
          doCompile(compileContext,isRebuild,forceCompile,callback,checkCachesVersion);
        }
  finally {
          CompilerCacheManager.getInstance(myProject).flushCaches();
          FileUtil.delete(CompilerPaths.getRebuildMarkerFile(myProject));
        }
      }
    }
;
  }
  compileTask.start(compileWork,new Runnable(){
    public void run(){
      if (isRebuild) {
        final int rv=Messages.showOkCancelDialog(myProject,"You are about to rebuild the whole project.\nRun 'Make Project' instead?","Confirm Project Rebuild","Make","Rebuild",Messages.getQuestionIcon());
        if (rv == 0) {
          startup(scope,false,false,callback,null,checkCachesVersion);
          return;
        }
      }
      startup(scope,isRebuild,forceCompile,callback,message,checkCachesVersion);
    }
  }
);
}
