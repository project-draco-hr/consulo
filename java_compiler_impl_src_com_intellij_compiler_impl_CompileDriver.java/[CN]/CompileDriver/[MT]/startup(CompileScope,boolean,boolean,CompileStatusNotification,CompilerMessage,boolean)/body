{
  ApplicationManager.getApplication().assertIsDispatchThread();
  final boolean useServer=useCompileServer();
  final String contentName=forceCompile ? CompilerBundle.message("compiler.content.name.compile") : CompilerBundle.message("compiler.content.name.make");
  final boolean compileInBackground=useServer ? true : CompilerWorkspaceConfiguration.getInstance(myProject).COMPILE_IN_BACKGROUND;
  final CompilerTask compileTask=new CompilerTask(myProject,compileInBackground,contentName,ApplicationManager.getApplication().isUnitTestMode());
  StatusBar.Info.set("",myProject,"Compiler");
  PsiDocumentManager.getInstance(myProject).commitAllDocuments();
  FileDocumentManager.getInstance().saveAllDocuments();
  final DependencyCache dependencyCache=useServer ? null : createDependencyCache();
  final CompileContextImpl compileContext=new CompileContextImpl(myProject,compileTask,scope,dependencyCache,!isRebuild && !forceCompile,isRebuild);
  compileContext.putUserData(COMPILATION_START_TIMESTAMP,LocalTimeCounter.currentTime());
  if (!useServer) {
    for (    Map.Entry<Pair<IntermediateOutputCompiler,Module>,Pair<VirtualFile,VirtualFile>> entry : myGenerationCompilerModuleToOutputDirMap.entrySet()) {
      final Pair<VirtualFile,VirtualFile> outputs=entry.getValue();
      final Pair<IntermediateOutputCompiler,Module> key=entry.getKey();
      final Module module=key.getSecond();
      compileContext.assignModule(outputs.getFirst(),module,false,key.getFirst());
      compileContext.assignModule(outputs.getSecond(),module,true,key.getFirst());
    }
    attachAnnotationProcessorsOutputDirectories(compileContext);
  }
  final Runnable compileWork;
  if (useServer) {
    compileWork=new Runnable(){
      public void run(){
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        if (indicator.isCanceled()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        long start=System.currentTimeMillis();
        try {
          if (myProject.isDisposed()) {
            return;
          }
          LOG.info("COMPILATION STARTED (COMPILE SERVER)");
          if (message != null) {
            compileContext.addMessage(message);
          }
          final Collection<String> paths=fetchFiles(compileContext);
          final List<Module> modules=paths.isEmpty() ? Arrays.asList(compileContext.getCompileScope().getAffectedModules()) : Collections.<Module>emptyList();
          final Set<Artifact> artifacts=ArtifactCompileScope.getArtifactsToBuild(myProject,compileContext.getCompileScope(),true);
          final RequestFuture future=compileOnServer(compileContext,modules,artifacts,paths,callback);
          if (future != null) {
            while (!future.waitFor(200L,TimeUnit.MILLISECONDS)) {
              if (indicator.isCanceled()) {
                future.cancel(false);
              }
            }
          }
 else {
            callback.finished(false,compileContext.getMessageCount(CompilerMessageCategory.ERROR),compileContext.getMessageCount(CompilerMessageCategory.WARNING),compileContext);
          }
        }
 catch (        Exception e) {
          LOG.error(e);
          callback.finished(false,compileContext.getMessageCount(CompilerMessageCategory.ERROR),compileContext.getMessageCount(CompilerMessageCategory.WARNING),compileContext);
        }
 finally {
          final long finish=System.currentTimeMillis();
          CompilerUtil.logDuration("\tCOMPILATION FINISHED (COMPILE SERVER); Errors: " + compileContext.getMessageCount(CompilerMessageCategory.ERROR) + "; warnings: "+ compileContext.getMessageCount(CompilerMessageCategory.WARNING),finish - start);
          CompilerCacheManager.getInstance(myProject).flushCaches();
          final Set<File> outputs=new HashSet<File>();
          for (          final String path : CompilerPathsEx.getOutputPaths(ModuleManager.getInstance(myProject).getModules())) {
            outputs.add(new File(path));
          }
          CompilerUtil.refreshIOFiles(outputs);
        }
      }
    }
;
  }
 else {
    compileWork=new Runnable(){
      public void run(){
        if (compileContext.getProgressIndicator().isCanceled()) {
          if (callback != null) {
            callback.finished(true,0,0,compileContext);
          }
          return;
        }
        long start=System.currentTimeMillis();
        try {
          if (myProject.isDisposed()) {
            return;
          }
          LOG.info("COMPILATION STARTED");
          if (message != null) {
            compileContext.addMessage(message);
          }
          TranslatingCompilerFilesMonitor.getInstance().ensureInitializationCompleted(myProject,compileContext.getProgressIndicator());
          doCompile(compileContext,isRebuild,forceCompile,callback,checkCachesVersion);
        }
  finally {
          final long finish=System.currentTimeMillis();
          CompilerUtil.logDuration("\tCOMPILATION FINISHED; Errors: " + compileContext.getMessageCount(CompilerMessageCategory.ERROR) + "; warnings: "+ compileContext.getMessageCount(CompilerMessageCategory.WARNING),finish - start);
          CompilerCacheManager.getInstance(myProject).flushCaches();
          FileUtil.delete(CompilerPaths.getRebuildMarkerFile(myProject));
        }
      }
    }
;
  }
  compileTask.start(compileWork,new Runnable(){
    public void run(){
      if (isRebuild) {
        final int rv=Messages.showOkCancelDialog(myProject,"You are about to rebuild the whole project.\nRun 'Make Project' instead?","Confirm Project Rebuild","Make","Rebuild",Messages.getQuestionIcon());
        if (rv == 0) {
          startup(scope,false,false,callback,null,checkCachesVersion);
          return;
        }
      }
      startup(scope,isRebuild,forceCompile,callback,message,checkCachesVersion);
    }
  }
);
}
