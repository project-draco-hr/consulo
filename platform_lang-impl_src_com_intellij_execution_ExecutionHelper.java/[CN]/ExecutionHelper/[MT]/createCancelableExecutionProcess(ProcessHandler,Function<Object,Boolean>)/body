{
  return new Runnable(){
    private ProgressIndicator myProgressIndicator;
    private final Semaphore mySemaphore=new Semaphore();
    private final Runnable myWaitThread=new Runnable(){
      public void run(){
        try {
          processHandler.waitFor();
        }
  finally {
          mySemaphore.up();
        }
      }
    }
;
    private final Runnable myCancelListener=new Runnable(){
      public void run(){
        for (; ; ) {
          if ((myProgressIndicator != null && (myProgressIndicator.isCanceled() || !myProgressIndicator.isRunning())) || (cancelableFun != null && cancelableFun.fun(null).booleanValue()) || processHandler.isProcessTerminated()) {
            if (!processHandler.isProcessTerminated()) {
              try {
                processHandler.destroyProcess();
              }
  finally {
                mySemaphore.up();
              }
            }
            break;
          }
          try {
synchronized (this) {
              wait(1000);
            }
          }
 catch (          InterruptedException e) {
          }
        }
      }
    }
;
    public void run(){
      myProgressIndicator=ProgressManager.getInstance().getProgressIndicator();
      if (myProgressIndicator != null && StringUtil.isEmpty(myProgressIndicator.getText())) {
        myProgressIndicator.setText("Please wait");
      }
      LOG.assertTrue(myProgressIndicator != null || cancelableFun != null,"Cancelable process must have an opportunity to be canceled!");
      mySemaphore.down();
      ApplicationManager.getApplication().executeOnPooledThread(myWaitThread);
      ApplicationManager.getApplication().executeOnPooledThread(myCancelListener);
      mySemaphore.waitFor();
    }
  }
;
}
