{
  UsageInfo[] usagesIn=refUsages.get();
  MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  if (!mySettings.generateDelegate()) {
    GroovyIntroduceParameterUtil.detectAccessibilityConflicts(mySettings.getExpression(),usagesIn,conflicts,mySettings.replaceFieldsWithGetters() != IntroduceParameterRefactoring.REPLACE_FIELDS_WITH_GETTERS_NONE,myProject);
  }
  final GrMethod toReplaceIn=(GrMethod)mySettings.getToReplaceIn();
  if (mySettings.getExpression() != null && !toReplaceIn.hasModifierProperty(PsiModifier.PRIVATE)) {
    final AnySupers anySupers=new AnySupers();
    mySettings.getExpression().accept(anySupers);
    if (anySupers.isResult()) {
      for (      UsageInfo usageInfo : usagesIn) {
        if (!(usageInfo.getElement() instanceof PsiMethod) && !(usageInfo instanceof InternalUsageInfo)) {
          if (!PsiTreeUtil.isAncestor(toReplaceIn.getContainingClass(),usageInfo.getElement(),false)) {
            conflicts.putValue(mySettings.getExpression(),RefactoringBundle.message("parameter.initializer.contains.0.but.not.all.calls.to.method.are.in.its.class",CommonRefactoringUtil.htmlEmphasize(PsiKeyword.SUPER)));
            break;
          }
        }
      }
    }
  }
  for (  IntroduceParameterMethodUsagesProcessor processor : IntroduceParameterMethodUsagesProcessor.EP_NAME.getExtensions()) {
    processor.findConflicts(this,refUsages.get(),conflicts);
  }
  return showConflicts(conflicts,usagesIn);
}
