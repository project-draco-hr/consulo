{
  myMockery=new JUnit4Mockery();
  myEditor=myMockery.mock(EditorEx.class);
  myDocument=myMockery.mock(DocumentEx.class);
  myStorage=new SoftWrapsStorage();
  mySoftWrapModel=myMockery.mock(SoftWrapModelEx.class);
  myFoldingModel=myMockery.mock(FoldingModelEx.class);
  final EditorSettings settings=myMockery.mock(EditorSettings.class);
  final Project project=myMockery.mock(Project.class);
  final SoftWrapPainter painter=myMockery.mock(SoftWrapPainter.class);
  myMockery.checking(new Expectations(){
{
      allowing(myEditor).getDocument();
      will(returnValue(myDocument));
      allowing(myDocument).getLineCount();
      will(new CustomAction("getLineCount()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myLineRanges.size();
        }
      }
);
      allowing(myDocument).getLineNumber(with(any(int.class)));
      will(new CustomAction("getLineNumber()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineNumber((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineStartOffset(with(any(int.class)));
      will(new CustomAction("getLineStart()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineStartOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myDocument).getLineEndOffset(with(any(int.class)));
      will(new CustomAction("getLineEnd()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getLineEndOffset((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).getSettings();
      will(returnValue(settings));
      allowing(settings).isUseSoftWraps();
      will(returnValue(true));
      allowing(settings).getTabSize(project);
      will(returnValue(TAB_SIZE));
      allowing(settings).isWhitespacesShown();
      will(returnValue(true));
      allowing(myEditor).getProject();
      will(returnValue(project));
      allowing(myEditor).getSoftWrapModel();
      will(returnValue(mySoftWrapModel));
      allowing(mySoftWrapModel).getSoftWrap(with(any(int.class)));
      will(new CustomAction("getSoftWrap"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getSoftWrap((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).getFoldingModel();
      will(returnValue(myFoldingModel));
      allowing(myFoldingModel).isFoldingEnabled();
      returnValue(true);
      allowing(myFoldingModel).setFoldingEnabled(with(any(boolean.class)));
      allowing(myFoldingModel).isOffsetCollapsed(with(any(int.class)));
      will(new CustomAction("isOffsetCollapsed()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myFoldedOffsets.contains((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myFoldingModel).getCollapsedRegionAtOffset(with(any(int.class)));
      will(new CustomAction("getCollapsedRegionAtOffset()"){
        @Nullable @Override public Object invoke(        Invocation invocation) throws Throwable {
          return getCollapsedFoldRegion((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myFoldingModel).fetchTopLevel();
      will(new CustomAction("fetchTopLevel()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return myFoldRegions.toArray(new FoldRegion[myFoldRegions.size()]);
        }
      }
);
      allowing(myEditor).logicalToVisualPosition(with(any(LogicalPosition.class)));
      will(new CustomAction("logical2visual()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return logicalToVisual((LogicalPosition)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).logicalPositionToOffset(with(any(LogicalPosition.class)));
      will(new CustomAction("logical2offset()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return logicalToOffset((LogicalPosition)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).offsetToLogicalPosition(with(any(int.class)));
      will(new CustomAction("offset2logical()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return offsetToLogical((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(myEditor).offsetToLogicalPosition(with(any(int.class)),with(equal(false)));
      will(new CustomAction("offset2logical()"){
        @Override public Object invoke(        Invocation invocation) throws Throwable {
          return offsetToSoftWrapUnawareLogical((Integer)invocation.getParameter(0));
        }
      }
);
      allowing(painter).getMinDrawingWidth(SoftWrapDrawingType.AFTER_SOFT_WRAP);
      will(returnValue(SOFT_WRAP_DRAWING_WIDTH));
    }
  }
);
  myRepresentationHelper=new MockEditorTextRepresentationHelper(SPACE_SIZE,TAB_SIZE);
  myMapper=new CachingSoftWrapDataMapper(myEditor,myStorage,myRepresentationHelper);
}
