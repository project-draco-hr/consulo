{
  log(updateProgress,null,"---------------------------------------------");
  final AtomicInteger threadsToStartCountdown=new AtomicInteger(0);
  int id=1;
  Map<Pair<Document,Integer>,ScheduledPass> toBeSubmitted=new THashMap<Pair<Document,Integer>,ScheduledPass>(passesMap.size());
  Map<Document,List<FileEditor>> documentToEditor=new HashMap<Document,List<FileEditor>>();
  Map<Document,List<TextEditorHighlightingPass>> textPasses=new HashMap<Document,List<TextEditorHighlightingPass>>(passesMap.size());
  for (  FileEditor fileEditor : passesMap.keySet()) {
    Document document=null;
    if (fileEditor instanceof TextEditor) {
      Editor editor=((TextEditor)fileEditor).getEditor();
      document=editor.getDocument();
    }
    HighlightingPass[] passes=passesMap.get(fileEditor);
    for (int i=0; i < passes.length; i++) {
      final HighlightingPass pass=passes[i];
      TextEditorHighlightingPass textEditorHighlightingPass;
      if (pass instanceof TextEditorHighlightingPass) {
        textEditorHighlightingPass=(TextEditorHighlightingPass)pass;
      }
 else {
        textEditorHighlightingPass=new TextEditorHighlightingPass(myProject,document){
          public void doCollectInformation(          ProgressIndicator progress){
            pass.collectInformation(progress);
          }
          public void doApplyInformationToEditor(){
            pass.applyInformationToEditor();
          }
        }
;
        textEditorHighlightingPass.setId(id++);
        if (i > 0) {
          textEditorHighlightingPass.setCompletionPredecessorIds(new int[]{i - 1});
        }
      }
      document=textEditorHighlightingPass.getDocument();
      List<TextEditorHighlightingPass> textPassesForDocument=textPasses.get(document);
      if (textPassesForDocument == null) {
        textPassesForDocument=new SmartList<TextEditorHighlightingPass>();
        textPasses.put(document,textPassesForDocument);
      }
      textPassesForDocument.add(textEditorHighlightingPass);
      List<FileEditor> editors=documentToEditor.get(document);
      if (editors == null) {
        editors=new SmartList<FileEditor>();
        documentToEditor.put(document,editors);
      }
      if (!editors.contains(fileEditor))       editors.add(fileEditor);
    }
    threadsToStartCountdown.addAndGet(passes.length);
  }
  List<ScheduledPass> freePasses=new ArrayList<ScheduledPass>(documentToEditor.size());
  for (  Document document : documentToEditor.keySet()) {
    List<FileEditor> fileEditors=documentToEditor.get(document);
    List<TextEditorHighlightingPass> passes=textPasses.get(document);
    Collections.sort(passes,new Comparator<TextEditorHighlightingPass>(){
      public int compare(      final TextEditorHighlightingPass o1,      final TextEditorHighlightingPass o2){
        return o1.getId() - o2.getId();
      }
    }
);
    int passId=-1;
    TextEditorHighlightingPass currentPass=null;
    for (int i=0; i <= passes.size(); i++) {
      int newId=-1;
      if (i < passes.size()) {
        currentPass=passes.get(i);
        newId=currentPass.getId();
      }
      if (newId != passId) {
        createScheduledPass(fileEditors,currentPass,toBeSubmitted,passes,freePasses,updateProgress,threadsToStartCountdown,jobPriority);
        passId=newId;
      }
    }
  }
  for (  ScheduledPass freePass : freePasses) {
    submit(freePass);
  }
}
