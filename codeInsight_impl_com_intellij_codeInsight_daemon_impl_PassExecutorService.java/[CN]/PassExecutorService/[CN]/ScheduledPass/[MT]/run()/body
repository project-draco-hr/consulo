{
  log(myUpdateProgress,"Started ",myPass);
  Thread.currentThread().setName("Highlighting pass " + myPass);
  if (myUpdateProgress.isCanceled())   return;
  for (  ScheduledPass successor : mySuccessorsOnSubmit) {
    int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
    if (predecessorsToRun == 0) {
      submit(successor);
    }
  }
  ((ProgressManagerImpl)ProgressManager.getInstance()).executeProcessUnderProgress(new Runnable(){
    public void run(){
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        public void run(){
          try {
            long modificationCount=PsiManager.getInstance(myProject).getModificationTracker().getModificationCount();
            if (myUpdateProgress.isCanceled() || myModificationCount != modificationCount) {
              throw new ProcessCanceledException();
            }
            myPass.doCollectInformation(myUpdateProgress);
          }
 catch (          ProcessCanceledException e) {
            log(myUpdateProgress,"Canceled ",myPass);
            cancelAll();
          }
        }
      }
);
    }
  }
,myUpdateProgress);
  if (!myUpdateProgress.isCanceled()) {
    for (    ScheduledPass successor : mySuccessorsOnCompletion) {
      int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
      if (predecessorsToRun == 0) {
        submit(successor);
      }
    }
    applyInformationToEditor(this);
  }
  if (!myUpdateProgress.isCanceled()) {
    int toexec=myThreadsToStartCountdown.decrementAndGet();
    LOG.assertTrue(toexec >= 0);
    if (toexec == 0) {
      log(myUpdateProgress,"Stopping ",myPass);
      myUpdateProgress.stopIfRunning();
    }
 else {
      log(myUpdateProgress,"Pass ",myPass," finished but there are",toexec," passes in the queue");
    }
  }
  log(myUpdateProgress,"Finished ",myPass);
}
