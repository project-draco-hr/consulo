{
  try {
    Thread.currentThread().setName("Highlighting pass " + myPass);
    ((ProgressManagerImpl)ProgressManager.getInstance()).progressMe(myUpdateProgress);
    if (myUpdateProgress.isCanceled())     return;
    LOG.debug(myPass + " started at " + System.currentTimeMillis());
    for (    ScheduledPass successor : mySuccessorsOnSubmit) {
      int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
      if (predecessorsToRun == 0) {
        submit(successor);
      }
    }
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        try {
          if (myUpdateProgress.isCanceled()) {
            throw new ProcessCanceledException();
          }
          myPass.doCollectInformation(myUpdateProgress);
        }
 catch (        ProcessCanceledException e) {
          LOG.debug(myPass + " canceled");
        }
      }
    }
);
    LOG.debug(myPass + " finished at " + System.currentTimeMillis());
    if (!myUpdateProgress.isCanceled()) {
      for (      ScheduledPass successor : mySuccessorsOnCompletion) {
        int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
        if (predecessorsToRun == 0) {
          submit(successor);
        }
      }
      applyInformationToEditor(this);
    }
    mySubmittedPasses.remove(this);
    int toexec=myThreadsToExecuteCountdown.decrementAndGet();
    if (toexec == 0) {
      LOG.debug("Stopping");
      myUpdateProgress.cancel();
      myUpdateProgress.stop();
    }
 else {
      LOG.debug("Pass " + myPass + " finished but there is the pass in the queue: "+ mySubmittedPasses.keySet().iterator().next().myPass+ "; toexec="+ toexec);
    }
  }
 catch (  Throwable e) {
    LOG.error(e);
  }
}
