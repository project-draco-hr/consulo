{
  info("Started " + myPass,myUpdateProgress);
  Thread.currentThread().setName("Highlighting pass " + myPass);
  if (myUpdateProgress.isCanceled())   return;
  ((ProgressManagerImpl)ProgressManager.getInstance()).progressMe(myUpdateProgress);
  for (  ScheduledPass successor : mySuccessorsOnSubmit) {
    int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
    if (predecessorsToRun == 0) {
      submit(successor);
    }
  }
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        if (myUpdateProgress.isCanceled()) {
          throw new ProcessCanceledException();
        }
        myPass.doCollectInformation(myUpdateProgress);
      }
 catch (      ProcessCanceledException e) {
        info("Canceled " + myPass,myUpdateProgress);
      }
    }
  }
);
  if (!myUpdateProgress.isCanceled()) {
    for (    ScheduledPass successor : mySuccessorsOnCompletion) {
      int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
      if (predecessorsToRun == 0) {
        submit(successor);
      }
    }
    applyInformationToEditor(this);
  }
  mySubmittedPasses.remove(this);
  if (myUpdateProgress == myDaemonCodeAnalyzer.getUpdateProgress()) {
    int toexec=myThreadsToExecuteCountdown.decrementAndGet();
    if (toexec == 0) {
      LOG.debug("Stopping");
      myUpdateProgress.stop();
    }
 else {
    }
  }
  info("Finished " + myPass,myUpdateProgress);
}
