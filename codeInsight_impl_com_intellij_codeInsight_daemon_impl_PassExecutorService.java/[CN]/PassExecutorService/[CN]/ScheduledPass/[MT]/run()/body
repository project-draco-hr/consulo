{
  log(myUpdateProgress,myPass,"Started ");
  if (myUpdateProgress.isCanceled())   return;
  for (  ScheduledPass successor : mySuccessorsOnSubmit) {
    int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
    if (predecessorsToRun == 0) {
      submit(successor);
    }
  }
  ((ProgressManagerImpl)ProgressManager.getInstance()).executeProcessUnderProgress(new Runnable(){
    public void run(){
      ApplicationManager.getApplication().runReadAction(new Runnable(){
        public void run(){
          try {
            if (myUpdateProgress.isCanceled()) {
              throw new ProcessCanceledException();
            }
            myPass.collectInformation(myUpdateProgress);
          }
 catch (          ProcessCanceledException e) {
            log(myUpdateProgress,myPass,"Canceled ");
          }
catch (          RuntimeException e) {
            LOG.error(e);
            throw e;
          }
catch (          Error e) {
            LOG.error(e);
            throw e;
          }
        }
      }
);
    }
  }
,myUpdateProgress);
  boolean hasMoreWorkTodo=myThreadsToStartCountdown.decrementAndGet() != 0;
  if (!myUpdateProgress.isCanceled()) {
    for (    ScheduledPass successor : mySuccessorsOnCompletion) {
      int predecessorsToRun=successor.myRunningPredecessorsCount.decrementAndGet();
      if (predecessorsToRun == 0) {
        submit(successor);
      }
    }
    applyInformationToEditors(hasMoreWorkTodo);
  }
  if (!myUpdateProgress.isCanceled()) {
    if (!hasMoreWorkTodo) {
      log(myUpdateProgress,myPass,"Stopping ");
      myUpdateProgress.stopIfRunning();
    }
 else {
      log(myUpdateProgress,myPass,"Pass finished but there are passes in the queue");
    }
  }
  log(myUpdateProgress,myPass,"Finished ");
}
