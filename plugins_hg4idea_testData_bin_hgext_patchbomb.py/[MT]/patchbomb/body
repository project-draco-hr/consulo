def patchbomb(ui, repo, *revs, **opts):
    'send changesets by email\n\n    By default, diffs are sent in the format generated by hg export,\n    one per message. The series starts with a "[PATCH 0 of N]"\n    introduction, which describes the series as a whole.\n\n    Each patch email has a Subject line of "[PATCH M of N] ...", using\n    the first line of the changeset description as the subject text.\n    The message contains two or three parts. First, the changeset\n    description. Next, (optionally) if the diffstat program is\n    installed and -d/--diffstat is used, the result of running\n    diffstat on the patch. Finally, the patch itself, as generated by\n    "hg export".\n\n    By default the patch is included as text in the email body for\n    easy reviewing. Using the -a/--attach option will instead create\n    an attachment for the patch. With -i/--inline an inline attachment\n    will be created.\n\n    With -o/--outgoing, emails will be generated for patches not found\n    in the destination repository (or only those which are ancestors\n    of the specified revisions if any are provided)\n\n    With -b/--bundle, changesets are selected as for --outgoing, but a\n    single email containing a binary Mercurial bundle as an attachment\n    will be sent.\n\n    Examples::\n\n      hg email -r 3000          # send patch 3000 only\n      hg email -r 3000 -r 3001  # send patches 3000 and 3001\n      hg email -r 3000:3005     # send patches 3000 through 3005\n      hg email 3000             # send patch 3000 (deprecated)\n\n      hg email -o               # send all patches not in default\n      hg email -o DEST          # send all patches not in DEST\n      hg email -o -r 3000       # send all ancestors of 3000 not in default\n      hg email -o -r 3000 DEST  # send all ancestors of 3000 not in DEST\n\n      hg email -b               # send bundle of all patches not in default\n      hg email -b DEST          # send bundle of all patches not in DEST\n      hg email -b -r 3000       # bundle of all ancestors of 3000 not in default\n      hg email -b -r 3000 DEST  # bundle of all ancestors of 3000 not in DEST\n\n    Before using this command, you will need to enable email in your\n    hgrc. See the [email] section in hgrc(5) for details.\n    '
    _charsets = mail._charsets(ui)

    def outgoing(dest, revs):
        'Return the revisions present locally but not in dest'
        dest = ui.expandpath((dest or 'default-push'), (dest or 'default'))
        (dest, branches) = hg.parseurl(dest)
        (revs, checkout) = hg.addbranchrevs(repo, repo, branches, revs)
        if revs:
            revs = [repo.lookup(rev) for rev in revs]
        other = hg.repository(cmdutil.remoteui(repo, opts), dest)
        ui.status((_('comparing with %s\n') % dest))
        o = repo.findoutgoing(other)
        if (not o):
            ui.status(_('no changes found\n'))
            return []
        o = repo.changelog.nodesbetween(o, revs)[0]
        return [str(repo.changelog.rev(r)) for r in o]

    def getpatches(revs):
        for r in cmdutil.revrange(repo, revs):
            output = cStringIO.StringIO()
            patch.export(repo, [r], fp=output, opts=patch.diffopts(ui, opts))
            yield output.getvalue().split('\n')

    def getbundle(dest):
        tmpdir = tempfile.mkdtemp(prefix='hg-email-bundle-')
        tmpfn = os.path.join(tmpdir, 'bundle')
        try:
            commands.bundle(ui, repo, tmpfn, dest, **opts)
            return open(tmpfn, 'rb').read()
        finally:
            try:
                os.unlink(tmpfn)
            except:
                pass
            os.rmdir(tmpdir)
    if (not (opts.get('test') or opts.get('mbox'))):
        mail.validateconfig(ui)
    if (not (revs or opts.get('rev') or opts.get('outgoing') or opts.get('bundle') or opts.get('patches'))):
        raise util.Abort(_('specify at least one changeset with -r or -o'))
    if (opts.get('outgoing') and opts.get('bundle')):
        raise util.Abort(_('--outgoing mode always on with --bundle; do not re-specify --outgoing'))
    if (opts.get('outgoing') or opts.get('bundle')):
        if (len(revs) > 1):
            raise util.Abort(_('too many destinations'))
        dest = ((revs and revs[0]) or None)
        revs = []
    if opts.get('rev'):
        if revs:
            raise util.Abort(_('use only one form to specify the revision'))
        revs = opts.get('rev')
    if opts.get('outgoing'):
        revs = outgoing(dest, opts.get('rev'))
    if opts.get('bundle'):
        opts['revs'] = revs
    if opts.get('date'):
        start_time = util.parsedate(opts.get('date'))
    else:
        start_time = util.makedate()

    def genmsgid(id):
        return ('<%s.%s@%s>' % (id[:20], int(start_time[0]), socket.getfqdn()))

    def getdescription(body, sender):
        if opts.get('desc'):
            body = open(opts.get('desc')).read()
        else:
            ui.write(_('\nWrite the introductory message for the patch series.\n\n'))
            body = ui.edit(body, sender)
        return body

    def getpatchmsgs(patches, patchnames=None):
        jumbo = []
        msgs = []
        ui.write((_('This patch series consists of %d patches.\n\n') % len(patches)))
        name = None
        for (i, p) in enumerate(patches):
            jumbo.extend(p)
            if patchnames:
                name = patchnames[i]
            msg = makepatch(ui, repo, p, opts, _charsets, (i + 1), len(patches), name)
            msgs.append(msg)
        if ((len(patches) > 1) or opts.get('intro')):
            tlen = len(str(len(patches)))
            flag = ' '.join(opts.get('flag'))
            if flag:
                subj = ('[PATCH %0*d of %d %s]' % (tlen, 0, len(patches), flag))
            else:
                subj = ('[PATCH %0*d of %d]' % (tlen, 0, len(patches)))
            subj += (' ' + (opts.get('subject') or prompt(ui, 'Subject: ', rest=subj)))
            body = ''
            if opts.get('diffstat'):
                d = cdiffstat(ui, _('Final summary:\n'), jumbo)
                if d:
                    body = ('\n' + d)
            body = getdescription(body, sender)
            msg = mail.mimeencode(ui, body, _charsets, opts.get('test'))
            msg['Subject'] = mail.headencode(ui, subj, _charsets, opts.get('test'))
            msgs.insert(0, (msg, subj))
        return msgs

    def getbundlemsgs(bundle):
        subj = (opts.get('subject') or prompt(ui, 'Subject:', 'A bundle for your repository'))
        body = getdescription('', sender)
        msg = email.MIMEMultipart.MIMEMultipart()
        if body:
            msg.attach(mail.mimeencode(ui, body, _charsets, opts.get('test')))
        datapart = email.MIMEBase.MIMEBase('application', 'x-mercurial-bundle')
        datapart.set_payload(bundle)
        bundlename = ('%s.hg' % opts.get('bundlename', 'bundle'))
        datapart.add_header('Content-Disposition', 'attachment', filename=bundlename)
        email.Encoders.encode_base64(datapart)
        msg.attach(datapart)
        msg['Subject'] = mail.headencode(ui, subj, _charsets, opts.get('test'))
        return [(msg, subj)]
    sender = (opts.get('from') or ui.config('email', 'from') or ui.config('patchbomb', 'from') or prompt(ui, 'From', ui.username()))
    patches = opts.get('patches')
    if patches:
        msgs = getpatchmsgs(patches, opts.get('patchnames'))
    elif opts.get('bundle'):
        msgs = getbundlemsgs(getbundle(dest))
    else:
        msgs = getpatchmsgs(list(getpatches(revs)))

    def getaddrs(opt, prpt=None, default=None):
        if opts.get(opt):
            return mail.addrlistencode(ui, opts.get(opt), _charsets, opts.get('test'))
        addrs = (ui.config('email', opt) or ui.config('patchbomb', opt) or '')
        if ((not addrs) and prpt):
            addrs = prompt(ui, prpt, default)
        return mail.addrlistencode(ui, [addrs], _charsets, opts.get('test'))
    to = getaddrs('to', 'To')
    cc = getaddrs('cc', 'Cc', '')
    bcc = getaddrs('bcc')
    ui.write('\n')
    parent = (opts.get('in_reply_to') or None)
    if (parent is not None):
        if (not parent.startswith('<')):
            parent = ('<' + parent)
        if (not parent.endswith('>')):
            parent += '>'
    first = True
    sender_addr = email.Utils.parseaddr(sender)[1]
    sender = mail.addressencode(ui, sender, _charsets, opts.get('test'))
    sendmail = None
    for (m, subj) in msgs:
        try:
            m['Message-Id'] = genmsgid(m['X-Mercurial-Node'])
        except TypeError:
            m['Message-Id'] = genmsgid('patchbomb')
        if parent:
            m['In-Reply-To'] = parent
            m['References'] = parent
        if first:
            parent = m['Message-Id']
            first = False
        m['User-Agent'] = ('Mercurial-patchbomb/%s' % util.version())
        m['Date'] = email.Utils.formatdate(start_time[0], localtime=True)
        start_time = ((start_time[0] + 1), start_time[1])
        m['From'] = sender
        m['To'] = ', '.join(to)
        if cc:
            m['Cc'] = ', '.join(cc)
        if bcc:
            m['Bcc'] = ', '.join(bcc)
        if opts.get('test'):
            ui.status(_('Displaying '), subj, ' ...\n')
            ui.flush()
            if ('PAGER' in os.environ):
                fp = util.popen(os.environ['PAGER'], 'w')
            else:
                fp = ui
            generator = email.Generator.Generator(fp, mangle_from_=False)
            try:
                generator.flatten(m, 0)
                fp.write('\n')
            except IOError as inst:
                if (inst.errno != errno.EPIPE):
                    raise
            if (fp is not ui):
                fp.close()
        elif opts.get('mbox'):
            ui.status(_('Writing '), subj, ' ...\n')
            fp = open(opts.get('mbox'), ((('In-Reply-To' in m) and 'ab+') or 'wb+'))
            generator = email.Generator.Generator(fp, mangle_from_=True)
            date = time.strftime('%a %b %d %H:%M:%S %Y', time.localtime(start_time[0]))
            fp.write(('From %s %s\n' % (sender_addr, date)))
            generator.flatten(m, 0)
            fp.write('\n\n')
            fp.close()
        else:
            if (not sendmail):
                sendmail = mail.connect(ui)
            ui.status(_('Sending '), subj, ' ...\n')
            del m['Bcc']
            fp = cStringIO.StringIO()
            generator = email.Generator.Generator(fp, mangle_from_=False)
            generator.flatten(m, 0)
            sendmail(sender, ((to + bcc) + cc), fp.getvalue())
