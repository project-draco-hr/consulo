{
  PsiBuilder.Marker bbm=builder.mark();
  IElementType balancedTokens;
  IElementType myBracket=null;
  if (ParserUtils.getToken(builder,mLPAREN)) {
    myBracket=mLPAREN;
  }
  if (ParserUtils.getToken(builder,mLCURLY)) {
    myBracket=mLCURLY;
  }
  if (ParserUtils.getToken(builder,mGSTRING_SINGLE_BEGIN)) {
    myBracket=mGSTRING_SINGLE_BEGIN;
  }
  if (myBracket == null) {
    bbm.rollbackTo();
    builder.error(GroovyBundle.message("lbrack.or.lparen.or.lcurly.or.string_ctor_start.expected"));
    return false;
  }
  balancedTokens=BalancedTokens.parse(builder);
  if (WRONGWAY.equals(balancedTokens)) {
    bbm.rollbackTo();
    return false;
  }
  if (ParserUtils.getToken(builder,mRPAREN) && !mRPAREN.equals(Pairs.pairElementsMap.get(myBracket)) || ParserUtils.getToken(builder,mRBRACK) && !mRBRACK.equals(Pairs.pairElementsMap.get(myBracket)) || ParserUtils.getToken(builder,mRCURLY) && !mRCURLY.equals(Pairs.pairElementsMap.get(myBracket)) || ParserUtils.getToken(builder,mGSTRING_SINGLE_END) && !mGSTRING_SINGLE_END.equals(Pairs.pairElementsMap.get(myBracket))) {
    bbm.rollbackTo();
    return false;
  }
 else {
    bbm.done(BALANCED_BRACKETS);
    return true;
  }
}
