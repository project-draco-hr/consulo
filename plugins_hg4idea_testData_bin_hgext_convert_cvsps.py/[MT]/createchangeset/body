def createchangeset(ui, log, fuzz=60, mergefrom=None, mergeto=None):
    'Convert log into changesets.'
    ui.status(_('creating changesets\n'))
    log.sort(key=(lambda x: (x.comment, x.author, x.branch, x.date)))
    changesets = []
    files = set()
    c = None
    for (i, e) in enumerate(log):
        if (not (c and (e.comment == c.comment) and (e.author == c.author) and (e.branch == c.branch) and ((not hasattr(e, 'branchpoints')) or (not hasattr(c, 'branchpoints')) or (e.branchpoints == c.branchpoints)) and ((c.date[0] + c.date[1]) <= (e.date[0] + e.date[1]) <= ((c.date[0] + c.date[1]) + fuzz)) and (e.file not in files))):
            c = changeset(comment=e.comment, author=e.author, branch=e.branch, date=e.date, entries=[], mergepoint=getattr(e, 'mergepoint', None), branchpoints=getattr(e, 'branchpoints', set()))
            changesets.append(c)
            files = set()
            if ((len(changesets) % 100) == 0):
                t = ('%d %s' % (len(changesets), repr(e.comment)[1:(-1)]))
                ui.status((util.ellipsis(t, 80) + '\n'))
        c.entries.append(e)
        files.add(e.file)
        c.date = e.date
    for c in changesets:
        c.synthetic = ((len(c.entries) == 1) and c.entries[0].synthetic)
    for c in changesets:

        def pathcompare(l, r):
            'Mimic cvsps sorting order'
            l = l.split('/')
            r = r.split('/')
            nl = len(l)
            nr = len(r)
            n = min(nl, nr)
            for i in range(n):
                if (((i + 1) == nl) and (nl < nr)):
                    return (-1)
                elif (((i + 1) == nr) and (nl > nr)):
                    return (+ 1)
                elif (l[i] < r[i]):
                    return (-1)
                elif (l[i] > r[i]):
                    return (+ 1)
            return 0

        def entitycompare(l, r):
            return pathcompare(l.file, r.file)
        c.entries.sort(entitycompare)

    def cscmp(l, r):
        d = (sum(l.date) - sum(r.date))
        if d:
            return d
        le = {}
        for e in l.entries:
            le[e.rcs] = e.revision
        re = {}
        for e in r.entries:
            re[e.rcs] = e.revision
        d = 0
        for e in l.entries:
            if (re.get(e.rcs, None) == e.parent):
                assert (not d)
                d = 1
                break
        for e in r.entries:
            if (le.get(e.rcs, None) == e.parent):
                assert (not d)
                d = (-1)
                break
        return d
    changesets.sort(cscmp)
    globaltags = {}
    for c in changesets:
        for e in c.entries:
            for tag in e.tags:
                globaltags[tag] = c
    for c in changesets:
        tags = set()
        for e in c.entries:
            tags.update(e.tags)
        c.tags = sorted((tag for tag in tags if (globaltags[tag] is c)))
    if (mergeto is None):
        mergeto = '{{mergetobranch ([-\\w]+)}}'
    if mergeto:
        mergeto = re.compile(mergeto)
    if (mergefrom is None):
        mergefrom = '{{mergefrombranch ([-\\w]+)}}'
    if mergefrom:
        mergefrom = re.compile(mergefrom)
    versions = {}
    branches = {}
    n = len(changesets)
    i = 0
    while (i < n):
        c = changesets[i]
        for f in c.entries:
            versions[(f.rcs, f.revision)] = i
        p = None
        if (c.branch in branches):
            p = branches[c.branch]
        else:
            for candidate in xrange(i):
                if (c.branch not in changesets[candidate].branchpoints):
                    if (p is not None):
                        break
                    continue
                p = candidate
        c.parents = []
        if (p is not None):
            p = changesets[p]
            while p.synthetic:
                assert (len(p.parents) <= 1), _('synthetic changeset cannot have multiple parents')
                if p.parents:
                    p = p.parents[0]
                else:
                    p = None
                    break
            if (p is not None):
                c.parents.append(p)
        if c.mergepoint:
            if (c.mergepoint == 'HEAD'):
                c.mergepoint = None
            c.parents.append(changesets[branches[c.mergepoint]])
        if mergefrom:
            m = mergefrom.search(c.comment)
            if m:
                m = m.group(1)
                if (m == 'HEAD'):
                    m = None
                try:
                    candidate = changesets[branches[m]]
                except KeyError:
                    ui.warn((_('warning: CVS commit message references non-existent branch %r:\n%s\n') % (m, c.comment)))
                if ((m in branches) and (c.branch != m) and (not candidate.synthetic)):
                    c.parents.append(candidate)
        if mergeto:
            m = mergeto.search(c.comment)
            if m:
                try:
                    m = m.group(1)
                    if (m == 'HEAD'):
                        m = None
                except:
                    m = None
                if ((m in branches) and (c.branch != m)):
                    cc = changeset(author=c.author, branch=m, date=c.date, comment=('convert-repo: CVS merge from branch %s' % c.branch), entries=[], tags=[], parents=[changesets[branches[m]], c])
                    changesets.insert((i + 1), cc)
                    branches[m] = (i + 1)
                    n += 1
                    i += 2
                    continue
        branches[c.branch] = i
        i += 1
    i = 0
    while (i < len(changesets)):
        if changesets[i].synthetic:
            del changesets[i]
        else:
            i += 1
    for (i, c) in enumerate(changesets):
        c.id = (i + 1)
    ui.status((_('%d changeset entries\n') % len(changesets)))
    hook.hook(ui, None, 'cvschangesets', True, changesets=changesets)
    return changesets
