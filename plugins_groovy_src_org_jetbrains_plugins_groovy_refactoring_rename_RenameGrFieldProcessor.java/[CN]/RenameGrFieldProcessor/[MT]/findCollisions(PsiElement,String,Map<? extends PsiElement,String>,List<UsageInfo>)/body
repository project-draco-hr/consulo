{
  List<UsageInfo> collisions=new ArrayList<UsageInfo>();
  for (  UsageInfo info : result) {
    if (!(info instanceof MoveRenameUsageInfo))     continue;
    final PsiElement infoElement=info.getElement();
    final PsiElement referencedElement=((MoveRenameUsageInfo)info).getReferencedElement();
    if (infoElement instanceof GrReferenceExpression && (referencedElement instanceof GrField || ((GrReferenceExpression)infoElement).advancedResolve().isInvokedOnProperty()) && infoElement.getParent() instanceof GrCall) {
      final PsiType[] argTypes=PsiUtil.getArgumentTypes(infoElement,false);
      final PsiMethod resolved=ResolveUtil.resolveExistingElement(((GrReferenceExpression)infoElement),new MethodResolverProcessor(newName,((GroovyPsiElement)infoElement),false,null,argTypes,((GrReferenceExpression)infoElement).getTypeArguments()),PsiMethod.class);
      if (resolved != null) {
        collisions.add(new UnresolvableCollisionUsageInfo(resolved,infoElement){
          @Override public String getDescription(){
            return GroovyRefactoringBundle.message("usage.will.be.overriden.by.method",infoElement.getParent().getText(),PsiFormatUtil.formatMethod(resolved,PsiSubstitutor.EMPTY,PsiFormatUtil.SHOW_NAME,PsiFormatUtil.SHOW_TYPE));
          }
        }
);
      }
    }
  }
  result.addAll(collisions);
  super.findCollisions(element,newName,allRenames,result);
}
