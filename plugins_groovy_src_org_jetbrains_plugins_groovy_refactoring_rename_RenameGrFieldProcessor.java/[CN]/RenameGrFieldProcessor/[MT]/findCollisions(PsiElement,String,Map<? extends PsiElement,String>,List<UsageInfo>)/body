{
  List<UsageInfo> collisions=new ArrayList<UsageInfo>();
  for (  UsageInfo info : result) {
    if (!(info instanceof MoveRenameUsageInfo))     continue;
    final PsiElement infoElement=info.getElement();
    final PsiElement referencedElement=((MoveRenameUsageInfo)info).getReferencedElement();
    if (!(infoElement instanceof GrReferenceExpression))     continue;
    final GrReferenceExpression refExpr=(GrReferenceExpression)infoElement;
    if (!(referencedElement instanceof GrField || refExpr.advancedResolve().isInvokedOnProperty()))     continue;
    if (!(refExpr.getParent() instanceof GrCall))     continue;
    final PsiType[] argTypes=PsiUtil.getArgumentTypes(refExpr,false);
    final PsiType[] typeArguments=refExpr.getTypeArguments();
    final MethodResolverProcessor processor=new MethodResolverProcessor(newName,refExpr,false,null,argTypes,typeArguments);
    final PsiMethod resolved=ResolveUtil.resolveExistingElement(refExpr,processor,PsiMethod.class);
    if (resolved == null)     continue;
    collisions.add(new UnresolvableCollisionUsageInfo(resolved,refExpr){
      @Override public String getDescription(){
        return GroovyRefactoringBundle.message("usage.will.be.overriden.by.method",refExpr.getParent().getText(),PsiFormatUtil.formatMethod(resolved,PsiSubstitutor.EMPTY,PsiFormatUtilBase.SHOW_NAME,PsiFormatUtilBase.SHOW_TYPE));
      }
    }
);
  }
  result.addAll(collisions);
  super.findCollisions(element,newName,allRenames,result);
}
