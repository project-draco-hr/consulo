{
  final DataHolder dataHolder;
  final ProjectLevelVcsManager vcsManager=ProjectLevelVcsManager.getInstance(myProject);
  if (!vcsManager.hasActiveVcss())   return;
  final VcsInvalidated invalidated=myDirtyScopeManager.retrieveScopes();
  if (checkScopeIsEmpty(invalidated))   return;
  final boolean wasEverythingDirty=invalidated.isEverythingDirty();
  final List<VcsDirtyScope> scopes=invalidated.getScopes();
  try {
    checkIfDisposed();
synchronized (myDataLock) {
      dataHolder=new DataHolder((FileHolderComposite)myComposite.copy(),myWorker.copy(),wasEverythingDirty);
      myModifier.enterUpdate();
      if (wasEverythingDirty) {
        myUpdateException=null;
        myAdditionalInfo=null;
      }
    }
    final String scopeInString=(!LOG.isDebugEnabled()) ? "" : StringUtil.join(scopes,new Function<VcsDirtyScope,String>(){
      @Override public String fun(      VcsDirtyScope scope){
        return scope.toString();
      }
    }
,"->\n");
    debugLogging("refresh procedure started, everything = " + wasEverythingDirty + " dirty scope: "+ scopeInString);
    dataHolder.notifyStart();
    myChangesViewManager.scheduleRefresh();
    myUpdateChangesProgressIndicator=createProgressIndicator();
    iterateScopes(dataHolder,scopes,wasEverythingDirty);
    final boolean takeChanges=(myUpdateException == null);
    if (takeChanges) {
      updateIgnoredFiles(dataHolder.getComposite());
    }
    clearCurrentRevisionsCache(invalidated);
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
synchronized (myDataLock) {
          dataHolder.notifyEnd();
          myModifier.finishUpdate(dataHolder.getChangeListWorker());
          if (takeChanges) {
            final ChangeListWorker oldWorker=myWorker;
            myWorker=dataHolder.getChangeListWorker();
            myWorker.onAfterWorkerSwitch(oldWorker);
            myModifier.setWorker(myWorker);
            debugLogging("refresh procedure finished, unversioned size: " + dataHolder.getComposite().getVFHolder(FileHolder.HolderType.UNVERSIONED).getSize() + "\n changes: "+ myWorker);
            final boolean statusChanged=!myComposite.equals(dataHolder.getComposite());
            myComposite=dataHolder.getComposite();
            if (statusChanged) {
              myDelayedNotificator.getProxyDispatcher().unchangedFileStatusChanged();
            }
          }
          myShowLocalChangesInvalidated=false;
        }
      }
    }
);
    for (    VcsDirtyScope scope : scopes) {
      scope.iterateExistingInsideScope(new Processor<VirtualFile>(){
        @Override public boolean process(        VirtualFile file){
          file.putUserData(LastUnchangedContentTracker.VCS_INVALID_FILE_STATUS,null);
          return true;
        }
      }
);
    }
    myChangesViewManager.scheduleRefresh();
  }
 catch (  DisposedException e) {
  }
catch (  ProcessCanceledException e) {
  }
catch (  RuntimeInterruptedException ignore) {
  }
catch (  Exception ex) {
    LOG.error(ex);
  }
catch (  AssertionError ex) {
    LOG.error(ex);
  }
 finally {
    myDirtyScopeManager.changesProcessed();
synchronized (myDataLock) {
      myDelayedNotificator.getProxyDispatcher().changeListUpdateDone();
      myChangesViewManager.scheduleRefresh();
    }
  }
}
