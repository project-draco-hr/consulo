{
  final List<VcsException> exceptions=new ArrayList<>();
  final Set<VirtualFile> allProcessedFiles=new HashSet<>();
  ChangesUtil.processVirtualFilesByVcs(myProject,files,new ChangesUtil.PerVcsProcessor<VirtualFile>(){
    @Override public void process(    final AbstractVcs vcs,    final List<VirtualFile> items){
      final CheckinEnvironment environment=vcs.getCheckinEnvironment();
      if (environment != null) {
        final Set<VirtualFile> descendants=getUnversionedDescendantsRecursively(items,statusChecker);
        Set<VirtualFile> parents=vcs.areDirectoriesVersionedItems() ? getUnversionedParents(items,statusChecker) : Collections.<VirtualFile>emptySet();
        final List<VcsException> result=ContainerUtil.newArrayList();
        ProgressManager.getInstance().run(new Task.Modal(myProject,"Adding files to VCS...",true){
          @Override public void run(          @NotNull ProgressIndicator indicator){
            indicator.setIndeterminate(true);
            List<VcsException> exs=environment.scheduleUnversionedFilesForAddition(ContainerUtil.newArrayList(descendants));
            if (exs != null) {
              ContainerUtil.addAll(result,exs);
            }
          }
        }
);
        allProcessedFiles.addAll(descendants);
        allProcessedFiles.addAll(parents);
        exceptions.addAll(result);
      }
    }
  }
);
  if (!exceptions.isEmpty()) {
    StringBuilder message=new StringBuilder(VcsBundle.message("error.adding.files.prompt"));
    for (    VcsException ex : exceptions) {
      message.append("\n").append(ex.getMessage());
    }
    Messages.showErrorDialog(myProject,message.toString(),VcsBundle.message("error.adding.files.title"));
  }
  for (  VirtualFile file : allProcessedFiles) {
    myFileStatusManager.fileStatusChanged(file);
  }
  VcsDirtyScopeManager.getInstance(myProject).filesDirty(allProcessedFiles,null);
  final Ref<List<Change>> foundChanges=Ref.create();
  final boolean moveRequired=!list.isDefault();
  boolean syncUpdateRequired=changesConsumer != null;
  if (moveRequired || syncUpdateRequired) {
    InvokeAfterUpdateMode updateMode=syncUpdateRequired ? InvokeAfterUpdateMode.SYNCHRONOUS_CANCELLABLE : InvokeAfterUpdateMode.BACKGROUND_NOT_CANCELLABLE_NOT_AWT;
    invokeAfterUpdate(new Runnable(){
      @Override public void run(){
        ApplicationManager.getApplication().runReadAction(new Runnable(){
          @Override public void run(){
synchronized (myDataLock) {
              List<Change> newChanges=findChanges(allProcessedFiles);
              foundChanges.set(newChanges);
              if (moveRequired && !newChanges.isEmpty()) {
                moveChangesTo(list,newChanges.toArray(new Change[newChanges.size()]));
              }
            }
          }
        }
);
        myChangesViewManager.scheduleRefresh();
      }
    }
,updateMode,VcsBundle.message("change.lists.manager.add.unversioned"),null);
    if (changesConsumer != null) {
      changesConsumer.consume(foundChanges.get());
    }
  }
 else {
    myChangesViewManager.scheduleRefresh();
  }
  return exceptions;
}
