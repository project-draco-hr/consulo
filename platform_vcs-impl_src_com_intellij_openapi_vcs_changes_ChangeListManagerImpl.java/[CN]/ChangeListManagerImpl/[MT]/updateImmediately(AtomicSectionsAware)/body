{
  final DataHolder dataHolder;
  final ProjectLevelVcsManager vcsManager=ProjectLevelVcsManager.getInstance(myProject);
  if (!vcsManager.hasActiveVcss())   return;
  final VcsDirtyScopeManagerImpl dirtyScopeManager=getVcsManager();
  if (dirtyScopeManager == null)   return;
  final VcsInvalidated invalidated=dirtyScopeManager.retrieveScopes();
  if (invalidated == null || invalidated.isEmpty()) {
    if (invalidated != null && invalidated.isEmpty() && invalidated.isEverythingDirty()) {
      VcsDirtyScopeManager.getInstance(myProject).markEverythingDirty();
    }
    return;
  }
  final boolean wasEverythingDirty=invalidated.isEverythingDirty();
  final List<VcsDirtyScope> scopes=invalidated.getScopes();
  if (!wasEverythingDirty) {
    filterOutIgnoredFiles(scopes);
    if (scopes.isEmpty()) {
      return;
    }
  }
  try {
    checkIfDisposed();
synchronized (myDataLock) {
      dataHolder=new DataHolder((FileHolderComposite)myComposite.copy(),myWorker.copy(),wasEverythingDirty);
      myModifier.enterUpdate();
      if (wasEverythingDirty) {
        myUpdateException=null;
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("refresh procedure started, everything = " + wasEverythingDirty);
      }
    }
    dataHolder.notifyStart();
    myChangesViewManager.scheduleRefresh();
    final ChangeListManagerGate gate=dataHolder.getChangeListWorker().createSelfGate();
    final UpdatingChangeListBuilder builder=new UpdatingChangeListBuilder(dataHolder.getChangeListWorker(),dataHolder.getComposite(),myUpdater.getIsStoppedGetter(),myIgnoredIdeaLevel,gate);
    myUpdateChangesProgressIndicator=createProgressIndicator(atomicSectionsAware);
    for (    final VcsDirtyScope scope : scopes) {
      atomicSectionsAware.checkShouldExit();
      final AbstractVcs vcs=scope.getVcs();
      if (vcs == null)       continue;
      final VcsModifiableDirtyScope adjustedScope=vcs.adjustDirtyScope((VcsModifiableDirtyScope)scope);
      myChangesViewManager.updateProgressText(VcsBundle.message("changes.update.progress.message",vcs.getDisplayName()),false);
      dataHolder.notifyStartProcessingChanges(adjustedScope);
      actualUpdate(builder,adjustedScope,vcs,dataHolder,gate);
      if (myUpdateException != null)       break;
    }
    final boolean takeChanges=(myUpdateException == null);
    if (takeChanges) {
      updateIgnoredFiles(dataHolder.getComposite());
    }
synchronized (myDataLock) {
      dataHolder.notifyEnd();
      myModifier.exitUpdate();
      myModifier.apply(dataHolder.getChangeListWorker());
      myModifier.clearQueue();
      if (takeChanges) {
        clearCurrentRevisionsCache(invalidated);
        myWorker=dataHolder.getChangeListWorker();
        myModifier.setWorker(myWorker);
        if (LOG.isDebugEnabled()) {
          LOG.debug("refresh procedure finished, size: " + dataHolder.getComposite().getVFHolder(FileHolder.HolderType.UNVERSIONED).getSize());
        }
        final boolean statusChanged=!myComposite.equals(dataHolder.getComposite());
        myComposite=dataHolder.getComposite();
        if (statusChanged) {
          myDelayedNotificator.getProxyDispatcher().unchangedFileStatusChanged();
        }
      }
      myShowLocalChangesInvalidated=false;
    }
    myChangesViewManager.scheduleRefresh();
  }
 catch (  DisposedException e) {
  }
catch (  ProcessCanceledException e) {
  }
catch (  RuntimeInterruptedException ignore) {
  }
catch (  Exception ex) {
    LOG.error(ex);
  }
catch (  AssertionError ex) {
    LOG.error(ex);
  }
 finally {
    dirtyScopeManager.changesProcessed();
synchronized (myDataLock) {
      myDelayedNotificator.getProxyDispatcher().changeListUpdateDone();
      myChangesViewManager.scheduleRefresh();
    }
  }
}
