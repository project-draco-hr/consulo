{
  if (!saveDialogState())   return;
  saveComments(true);
  final CommitSession session=commitExecutor.createCommitSession(myCommitContext);
  if (session == CommitSession.VCS_COMMIT) {
    doOKAction();
    return;
  }
  boolean isOK=true;
  if (SessionDialog.createConfigurationUI(session,getIncludedChanges(),getCommitMessage()) != null) {
    DialogWrapper sessionDialog=new SessionDialog(commitExecutor.getActionText(),getProject(),session,getIncludedChanges(),getCommitMessage());
    sessionDialog.show();
    isOK=sessionDialog.isOK();
  }
  if (isOK) {
    final DefaultListCleaner defaultListCleaner=new DefaultListCleaner();
    runBeforeCommitHandlers(new Runnable(){
      public void run(){
        try {
          final boolean completed=ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
            public void run(){
              session.execute(getIncludedChanges(),getCommitMessage());
            }
          }
,commitExecutor.getActionText(),true,getProject());
          if (completed) {
            for (            CheckinHandler handler : myHandlers) {
              handler.checkinSuccessful();
            }
            defaultListCleaner.clean();
            close(OK_EXIT_CODE);
          }
 else {
            session.executionCanceled();
          }
        }
 catch (        Throwable e) {
          Messages.showErrorDialog(VcsBundle.message("error.executing.commit",commitExecutor.getActionText(),e.getLocalizedMessage()),commitExecutor.getActionText());
          for (          CheckinHandler handler : myHandlers) {
            handler.checkinFailed(Arrays.asList(new VcsException(e)));
          }
        }
      }
    }
,commitExecutor);
  }
 else {
    session.executionCanceled();
  }
}
