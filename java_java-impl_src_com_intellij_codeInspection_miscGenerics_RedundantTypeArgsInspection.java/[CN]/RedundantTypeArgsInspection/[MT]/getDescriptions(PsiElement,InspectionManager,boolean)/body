{
  final List<ProblemDescriptor> problems=new ArrayList<ProblemDescriptor>();
  place.accept(new JavaRecursiveElementWalkingVisitor(){
    @Override public void visitMethodCallExpression(    PsiMethodCallExpression expression){
      final PsiType[] typeArguments=expression.getTypeArguments();
      if (typeArguments.length > 0) {
        checkCallExpression(expression.getMethodExpression(),typeArguments,expression,inspectionManager,problems);
      }
    }
    @Override public void visitNewExpression(    PsiNewExpression expression){
      final PsiType[] typeArguments=expression.getTypeArguments();
      if (typeArguments.length > 0) {
        final PsiJavaCodeReferenceElement classReference=expression.getClassReference();
        if (classReference != null) {
          checkCallExpression(classReference,typeArguments,expression,inspectionManager,problems);
        }
      }
    }
    private void checkCallExpression(    final PsiJavaCodeReferenceElement reference,    final PsiType[] typeArguments,    PsiCallExpression expression,    final InspectionManager inspectionManager,    final List<ProblemDescriptor> problems){
      PsiExpressionList argumentList=expression.getArgumentList();
      if (argumentList == null)       return;
      final JavaResolveResult resolveResult=reference.advancedResolve(false);
      final PsiElement element=resolveResult.getElement();
      if (element instanceof PsiMethod && resolveResult.isValidResult()) {
        PsiMethod method=(PsiMethod)element;
        final PsiTypeParameter[] typeParameters=method.getTypeParameters();
        if (typeParameters.length == typeArguments.length) {
          final PsiParameter[] parameters=method.getParameterList().getParameters();
          PsiResolveHelper resolveHelper=JavaPsiFacade.getInstance(expression.getProject()).getResolveHelper();
          for (int i=0; i < typeParameters.length; i++) {
            PsiTypeParameter typeParameter=typeParameters[i];
            final PsiType inferedType=resolveHelper.inferTypeForMethodTypeParameter(typeParameter,parameters,argumentList.getExpressions(),resolveResult.getSubstitutor(),expression,false);
            if (!typeArguments[i].equals(inferedType))             return;
          }
          final PsiCallExpression copy=(PsiCallExpression)expression.copy();
          try {
            copy.getTypeArgumentList().delete();
            if (copy.resolveMethod() != element)             return;
          }
 catch (          IncorrectOperationException e) {
            LOG.error(e);
            return;
          }
          final ProblemDescriptor descriptor=inspectionManager.createProblemDescriptor(expression.getTypeArgumentList(),InspectionsBundle.message("inspection.redundant.type.problem.descriptor"),myQuickFixAction,ProblemHighlightType.LIKE_UNUSED_SYMBOL,false);
          problems.add(descriptor);
        }
      }
    }
  }
);
  if (problems.isEmpty())   return null;
  return problems.toArray(new ProblemDescriptor[problems.size()]);
}
