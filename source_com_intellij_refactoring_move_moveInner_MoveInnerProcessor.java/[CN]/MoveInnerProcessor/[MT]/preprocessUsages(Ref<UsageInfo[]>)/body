{
  final ArrayList<String> conflicts=new ArrayList<String>();
class Visitor extends PsiRecursiveElementVisitor {
    private final HashMap<PsiElement,HashSet<PsiElement>> reported=new HashMap<PsiElement,HashSet<PsiElement>>();
    public void visitReferenceExpression(    PsiReferenceExpression expression){
      visitReferenceElement(expression);
    }
    public void visitReferenceElement(    PsiJavaCodeReferenceElement reference){
      PsiElement resolved=reference.resolve();
      final boolean isInInnerClass;
      final PsiManager manager=myOuterClass.getManager();
      if (resolved instanceof PsiField) {
        isInInnerClass=manager.areElementsEquivalent(((PsiField)resolved).getContainingClass(),myInnerClass);
      }
 else       if (resolved instanceof PsiMethod) {
        isInInnerClass=manager.areElementsEquivalent(((PsiMethod)resolved).getContainingClass(),myInnerClass);
      }
 else {
        isInInnerClass=false;
      }
      if (isInInnerClass && becomesInaccessible(((PsiModifierListOwner)resolved))) {
        final PsiElement container=ConflictsUtil.getContainer(reference);
        HashSet<PsiElement> containerSet=reported.get(resolved);
        if (containerSet == null) {
          containerSet=new HashSet<PsiElement>();
          reported.put(resolved,containerSet);
        }
        if (!containerSet.contains(container)) {
          containerSet.add(container);
          String message=ConflictsUtil.getDescription(resolved,true) + " will become inaccessible from " + ConflictsUtil.getDescription(container,true)+ ".";
          conflicts.add(message);
        }
      }
    }
    private boolean becomesInaccessible(    PsiModifierListOwner element){
      final String visibilityModifier=VisibilityUtil.getVisibilityModifier(element.getModifierList());
      if (PsiModifier.PRIVATE.equals(visibilityModifier))       return true;
      if (PsiModifier.PUBLIC.equals(visibilityModifier))       return false;
      final PsiFile containingFile=myOuterClass.getContainingFile();
      if (myTargetContainer instanceof PsiPackage) {
        return !isInPackage(containingFile,(PsiPackage)myTargetContainer);
      }
 else {
        PsiFile targetFile=myTargetContainer.getContainingFile();
        if (targetFile != null) {
          final PsiDirectory containingDirectory=targetFile.getContainingDirectory();
          if (containingDirectory != null) {
            final PsiPackage targetPackage=containingDirectory.getPackage();
            return isInPackage(containingFile,targetPackage);
          }
        }
      }
      return false;
    }
    public void visitClass(    PsiClass aClass){
      if (aClass == myInnerClass)       return;
      super.visitClass(aClass);
    }
  }
  myOuterClass.accept(new Visitor());
  return showConflicts(conflicts);
}
