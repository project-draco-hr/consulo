def hybridencode(path):
    "encodes path with a length limit\n\n    Encodes all paths that begin with 'data/', according to the following.\n\n    Default encoding (reversible):\n\n    Encodes all uppercase letters 'X' as '_x'. All reserved or illegal\n    characters are encoded as '~xx', where xx is the two digit hex code\n    of the character (see encodefilename).\n    Relevant path components consisting of Windows reserved filenames are\n    masked by encoding the third character ('aux' -> 'au~78', see auxencode).\n\n    Hashed encoding (not reversible):\n\n    If the default-encoded path is longer than MAX_PATH_LEN_IN_HGSTORE, a\n    non-reversible hybrid hashing of the path is done instead.\n    This encoding uses up to DIR_PREFIX_LEN characters of all directory\n    levels of the lowerencoded path, but not more levels than can fit into\n    _MAX_SHORTENED_DIRS_LEN.\n    Then follows the filler followed by the sha digest of the full path.\n    The filler is the beginning of the basename of the lowerencoded path\n    (the basename is everything after the last path separator). The filler\n    is as long as possible, filling in characters from the basename until\n    the encoded path has MAX_PATH_LEN_IN_HGSTORE characters (or all chars\n    of the basename have been taken).\n    The extension (e.g. '.i' or '.d') is preserved.\n\n    The string 'data/' at the beginning is replaced with 'dh/', if the hashed\n    encoding was used.\n    "
    if (not path.startswith('data/')):
        return path
    path = encodedir(path)
    ndpath = path[len('data/'):]
    res = ('data/' + auxencode(encodefilename(ndpath)))
    if (len(res) > MAX_PATH_LEN_IN_HGSTORE):
        digest = _sha(path).hexdigest()
        aep = auxencode(lowerencode(ndpath))
        (_root, ext) = os.path.splitext(aep)
        parts = aep.split('/')
        basename = parts[(-1)]
        sdirs = []
        for p in parts[:(-1)]:
            d = p[:DIR_PREFIX_LEN]
            if (d[(-1)] in '. '):
                d = (d[:(-1)] + '_')
            t = (('/'.join(sdirs) + '/') + d)
            if (len(t) > _MAX_SHORTENED_DIRS_LEN):
                break
            sdirs.append(d)
        dirs = '/'.join(sdirs)
        if (len(dirs) > 0):
            dirs += '/'
        res = ((('dh/' + dirs) + digest) + ext)
        space_left = (MAX_PATH_LEN_IN_HGSTORE - len(res))
        if (space_left > 0):
            filler = basename[:space_left]
            res = (((('dh/' + dirs) + filler) + digest) + ext)
    return res
