{
  if (!CodeInsightUtil.prepareFileForWrite(file))   return;
  final PsiMethod method=SuperMethodWarningUtil.checkSuperMethod(myTargetMethod,RefactoringBundle.message("to.refactor"));
  if (method == null)   return;
  if (!CodeInsightUtil.prepareFileForWrite(method.getContainingFile()))   return;
  final FindUsagesOptions options=new FindUsagesOptions(project);
  options.isImplementingMethods=true;
  options.isMethodsUsages=true;
  options.isOverridingMethods=true;
  options.isUsages=true;
  options.isSearchForTextOccurences=false;
  final Ref<Integer> usagesFound=new Ref<Integer>(Integer.valueOf(0));
  Runnable runnable=new Runnable(){
    public void run(){
      Processor<UsageInfo> processor=new Processor<UsageInfo>(){
        public boolean process(        final UsageInfo t){
          usagesFound.set(Integer.valueOf(usagesFound.get().intValue() + 1));
          return false;
        }
      }
;
      FindUsagesUtil.processUsages(method,processor,options);
    }
  }
;
  String progressTitle=QuickFixBundle.message("searching.for.usages.progress.title");
  if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable,progressTitle,true,project))   return;
  if (usagesFound.get().intValue() <= 1) {
    ChangeSignatureProcessor processor=new ChangeSignatureProcessor(project,method,false,null,method.getName(),method.getReturnType(),myNewParametersInfo);
    processor.run();
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      public void run(){
        UndoManager.getInstance(file.getProject()).markDocumentForUndo(file);
      }
    }
);
  }
 else {
    List<ParameterInfo> parameterInfos=Arrays.asList(myNewParametersInfo);
    ChangeSignatureDialog dialog=new ChangeSignatureDialog(project,method,false);
    dialog.setParameterInfos(parameterInfos);
    dialog.show();
  }
}
