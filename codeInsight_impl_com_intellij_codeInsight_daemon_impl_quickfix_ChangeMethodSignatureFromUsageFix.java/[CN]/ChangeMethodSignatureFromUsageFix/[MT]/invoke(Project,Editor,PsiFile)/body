{
  if (!CodeInsightUtil.prepareFileForWrite(file))   return;
  final PsiMethod method=SuperMethodWarningUtil.checkSuperMethod(myTargetMethod,RefactoringBundle.message("to.refactor"));
  if (method == null)   return;
  if (!CodeInsightUtil.prepareFileForWrite(method.getContainingFile()))   return;
  final FindUsagesOptions options=new FindUsagesOptions(project);
  options.isImplementingMethods=true;
  options.isMethodsUsages=true;
  options.isOverridingMethods=true;
  options.isUsages=true;
  options.isSearchForTextOccurences=false;
  final int[] usagesFound=new int[1];
  Runnable runnable=new Runnable(){
    public void run(){
      Processor<UsageInfo> processor=new Processor<UsageInfo>(){
        public boolean process(        final UsageInfo t){
          return ++usagesFound[0] < 2;
        }
      }
;
      FindUsagesUtil.processUsages(method,processor,options);
    }
  }
;
  String progressTitle=QuickFixBundle.message("searching.for.usages.progress.title");
  if (!ProgressManager.getInstance().runProcessWithProgressSynchronously(runnable,progressTitle,true,project))   return;
  myNewParametersInfo=getNewParametersInfo(myExpressions,myTargetMethod,mySubstitutor);
  if (usagesFound[0] <= 1) {
    ChangeSignatureProcessor processor=new ChangeSignatureProcessor(project,method,false,null,method.getName(),method.getReturnType(),myNewParametersInfo){
      @NotNull protected UsageInfo[] findUsages(){
        return myChangeSingleUsageSignature ? super.findUsages() : UsageInfo.EMPTY_ARRAY;
      }
    }
;
    processor.run();
    ApplicationManager.getApplication().runWriteAction(new Runnable(){
      public void run(){
        UndoManager.getInstance(file.getProject()).markDocumentForUndo(file);
      }
    }
);
  }
 else {
    List<ParameterInfo> parameterInfos=Arrays.asList(myNewParametersInfo);
    ChangeSignatureDialog dialog=new ChangeSignatureDialog(project,method,false);
    dialog.setParameterInfos(parameterInfos);
    dialog.show();
  }
}
