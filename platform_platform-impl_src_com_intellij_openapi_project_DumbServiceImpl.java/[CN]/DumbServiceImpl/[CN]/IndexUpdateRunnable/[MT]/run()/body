{
  if (myProject.isDisposed()) {
    return;
  }
  ProgressManager.getInstance().run(new Task.Backgroundable(myProject,IdeBundle.message("progress.indexing"),false){
    private final ArrayBlockingQueue<Ref<CacheUpdateRunner>> myActionQueue=new ArrayBlockingQueue<Ref<CacheUpdateRunner>>(1);
    public void run(    @NotNull final ProgressIndicator indicator){
      if (indicator instanceof ProgressIndicatorEx) {
        ((ProgressIndicatorEx)indicator).addStateDelegate(new ProgressIndicatorBase(){
          double lastFraction;
          @Override public void setFraction(          final double fraction){
            if (fraction - lastFraction < 0.01d)             return;
            lastFraction=fraction;
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              public void run(){
                AppIcon.getInstance().setProgress("indexUpdate",AppIconScheme.Progress.INDEXING,fraction,true);
              }
            }
);
          }
          @Override public void finish(          @NotNull TaskInfo task){
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              public void run(){
                AppIcon appIcon=AppIcon.getInstance();
                if (appIcon.hideProgress("indexUpdate")) {
                  appIcon.requestAttention(false);
                  appIcon.setOkBadge(true);
                }
              }
            }
);
          }
        }
);
      }
      final ProgressIndicator proxy=new DelegatingProgressIndicator(indicator){
        @Override public void setFraction(        double fraction){
          super.setFraction((myProcessedItems + fraction * myCurrentBaseTotal) / myTotalItems);
        }
      }
;
      final ShutDownTracker shutdownTracker=ShutDownTracker.getInstance();
      final Thread self=Thread.currentThread();
      try {
        HeavyProcessLatch.INSTANCE.processStarted();
        shutdownTracker.registerStopperThread(self);
        runAction(proxy,myAction);
      }
  finally {
        shutdownTracker.unregisterStopperThread(self);
        HeavyProcessLatch.INSTANCE.processFinished();
      }
    }
    private void runAction(    ProgressIndicator indicator,    CacheUpdateRunner updateRunner){
      do {
        int count=0;
        try {
          indicator.setIndeterminate(true);
          indicator.setText(IdeBundle.message("progress.indexing.scanning"));
          count=updateRunner.queryNeededFiles(indicator);
          myCurrentBaseTotal=count;
          myTotalItems+=count;
          indicator.setIndeterminate(false);
          indicator.setText(IdeBundle.message("progress.indexing.updating"));
          if (count > 0) {
            updateRunner.processFiles(indicator,true);
          }
          updateRunner.updatingDone();
        }
  finally {
          myProcessedItems+=count;
          UIUtil.invokeLaterIfNeeded(new DumbAwareRunnable(){
            public void run(){
              if (myUpdatesQueue.isEmpty()) {
                myActionQueue.offer(NULL_ACTION);
                updateFinished();
              }
 else {
                final IndexUpdateRunnable nextUpdateRunnable=myUpdatesQueue.pullFirst();
                if (!myActionQueue.offer(new Ref<CacheUpdateRunner>(nextUpdateRunnable.myAction))) {
                  LOG.error("Action queue rejected next updateRunnable!");
                  nextUpdateRunnable.run();
                }
              }
            }
          }
);
          try {
            Ref<CacheUpdateRunner> ref;
            do {
              ref=myActionQueue.poll(500,TimeUnit.MILLISECONDS);
              updateRunner=ref != null ? ref.get() : null;
              if (myProject.isDisposed()) {
                break;
              }
            }
 while (ref == null);
          }
 catch (          InterruptedException ignored) {
            LOG.info(ignored);
            break;
          }
        }
      }
 while (updateRunner != null);
      myActionQueue.offer(NULL_ACTION);
    }
  }
);
}
