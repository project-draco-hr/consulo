{
  if (myProject.isDisposed()) {
    return;
  }
  ProgressManager.getInstance().run(new Task.Backgroundable(myProject,IdeBundle.message("progress.indexing"),false){
    private final BlockingQueue<Ref<CacheUpdateRunner>> myActionQueue=new LinkedBlockingQueue<Ref<CacheUpdateRunner>>();
    public void run(    @NotNull final ProgressIndicator indicator){
      if (indicator instanceof ProgressIndicatorEx) {
        ((ProgressIndicatorEx)indicator).addStateDelegate(new ProgressIndicatorBase(){
          double lastFraction;
          @Override public void setFraction(          final double fraction){
            if (fraction - lastFraction < 0.01d)             return;
            lastFraction=fraction;
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              public void run(){
                AppIcon.getInstance().setProgress(myProject,"indexUpdate",AppIconScheme.Progress.INDEXING,fraction,true);
              }
            }
);
          }
          @Override public void finish(          @NotNull TaskInfo task){
            UIUtil.invokeLaterIfNeeded(new Runnable(){
              public void run(){
                AppIcon appIcon=AppIcon.getInstance();
                if (appIcon.hideProgress(myProject,"indexUpdate")) {
                  appIcon.requestAttention(myProject,false);
                  appIcon.setOkBadge(myProject,true);
                }
              }
            }
);
          }
        }
);
      }
      final ProgressIndicator proxy=new DelegatingProgressIndicator(indicator){
        @Override public void setFraction(        double fraction){
          super.setFraction((myProcessedItems + fraction * myCurrentBaseTotal) / myTotalItems);
        }
      }
;
      final ShutDownTracker shutdownTracker=ShutDownTracker.getInstance();
      final Thread self=Thread.currentThread();
      try {
        HeavyProcessLatch.INSTANCE.processStarted();
        shutdownTracker.registerStopperThread(self);
        runAction(proxy,myAction);
      }
  finally {
        shutdownTracker.unregisterStopperThread(self);
        HeavyProcessLatch.INSTANCE.processFinished();
      }
    }
    private void runAction(    ProgressIndicator indicator,    CacheUpdateRunner updateRunner){
      do {
        int count=0;
        try {
          indicator.setIndeterminate(true);
          indicator.setText(IdeBundle.message("progress.indexing.scanning"));
          count=updateRunner.queryNeededFiles(indicator);
          myCurrentBaseTotal=count;
          myTotalItems+=count;
          indicator.setIndeterminate(false);
          indicator.setText(IdeBundle.message("progress.indexing.updating"));
          if (count > 0) {
            updateRunner.processFiles(indicator,true);
          }
          updateRunner.updatingDone();
        }
  finally {
          myProcessedItems+=count;
          if (LOG.isDebugEnabled()) {
            LOG.debug("Scheduling checkNextUpdateFromQueue");
          }
          UIUtil.invokeLaterIfNeeded(new DumbAwareRunnable(){
            public void run(){
              checkNextUpdateFromQueue();
            }
          }
);
          Ref<CacheUpdateRunner> ref=null;
          do {
            try {
              ref=myActionQueue.poll(500,TimeUnit.MILLISECONDS);
            }
 catch (            InterruptedException e) {
              LOG.info(e);
            }
            updateRunner=ref != null ? ref.get() : null;
            if (myProject.isDisposed()) {
              break;
            }
          }
 while (ref == null);
        }
      }
 while (updateRunner != null);
    }
    private void checkNextUpdateFromQueue(){
      if (LOG.isDebugEnabled()) {
        LOG.debug("Inside checkNextUpdateFromQueue");
      }
      IndexUpdateRunnable nextUpdateRunnable=null;
      try {
        nextUpdateRunnable=myUpdatesQueue.isEmpty() ? null : myUpdatesQueue.pullFirst();
        if (nextUpdateRunnable == null) {
          myActionQueue.offer(NULL_ACTION);
        }
 else {
          myActionQueue.offer(new Ref<CacheUpdateRunner>(nextUpdateRunnable.myAction));
        }
      }
 catch (      Throwable e) {
        myActionQueue.offer(NULL_ACTION);
        LOG.info(e);
      }
 finally {
        if (nextUpdateRunnable == null) {
          updateFinished();
        }
      }
    }
  }
);
}
