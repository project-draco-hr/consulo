{
  if (pattern.length() == 0 || pattern.equals("*")) {
    pattern="^(.*)$";
  }
 else {
    boolean hasPackage=pattern.indexOf(".") != -1;
    pattern=pattern.replace(".","/");
    pattern=pattern.replaceAll("\\*","[^/]*?");
    if (!hasPackage)     pattern=".*?/" + pattern;
    pattern="^(" + pattern + ")$";
  }
  Pattern p;
  try {
    p=Pattern.compile(pattern,Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
  }
 catch (  PatternSyntaxException e) {
    return Collections.emptyList();
  }
  Map<String,MavenClassSearchResult> result=new HashMap<String,MavenClassSearchResult>();
  for (  ArtifactInfo each : infos) {
    if (each.classNames == null)     continue;
    Matcher matcher=p.matcher(each.classNames);
    while (matcher.find()) {
      String classFQName=matcher.group();
      classFQName=classFQName.replace("/",".");
      String key=makeKey(classFQName,each);
      MavenClassSearchResult classResult=result.get(key);
      if (classResult == null) {
        classResult=new MavenClassSearchResult();
        int pos=classFQName.lastIndexOf(".");
        if (pos == -1) {
          classResult.packageName="default package";
          classResult.className=classFQName;
        }
 else {
          classResult.packageName=classFQName.substring(0,pos);
          classResult.className=classFQName.substring(pos + 1);
        }
        result.put(key,classResult);
      }
      classResult.versions.add(each);
      if (result.size() > maxResult)       break;
    }
  }
  return result.values();
}
