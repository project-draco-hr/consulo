{
  final SoftReference<Set<OuterLanguageElement>> outerElements=myOuterLanguageElements.get(lang);
  if (outerElements == null || outerElements.get() == null)   return;
  final Set<OuterLanguageElement> languageElements=outerElements.get();
  final Iterator<OuterLanguageElement> iterator=languageElements.iterator();
  final List<OuterLanguageElement> toRemove=new ArrayList<OuterLanguageElement>();
  OuterLanguageElement prev=null;
  while (iterator.hasNext()) {
    final OuterLanguageElement outer=iterator.next();
    if (outer == null) {
      iterator.remove();
      continue;
    }
    if (prev != null && prev.getFollowingText() == null && outer.getTextRange().getStartOffset() == prev.getTextRange().getEndOffset()) {
      final CompositeElement prevParent=prev.getTreeParent();
      final JspWhileStatement outerWhile=PsiTreeUtil.getParentOfType(outer,JspWhileStatement.class);
      if (prevParent != null && prevParent.getElementType() == JspElementType.JSP_TEMPLATE_EXPRESSION || outerWhile != null) {
        final JspWhileStatement prevWhile=PsiTreeUtil.getParentOfType(prev,JspWhileStatement.class);
        if (prevWhile == null || prevWhile == outerWhile || prevWhile.getStartOffset() != prev.getStartOffset()) {
          toRemove.add(prev);
          prev=mergeOuterLanguageElements(outer,prev);
        }
 else {
          prev=outer;
        }
      }
 else {
        toRemove.add(outer);
        prev=mergeOuterLanguageElements(prev,outer);
      }
    }
 else {
      prev=outer;
    }
  }
  languageElements.removeAll(toRemove);
}
