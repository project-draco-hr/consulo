{
  for (  Map.Entry<Language,PsiFile> entry : myRoots.entrySet()) {
    final PsiFile psiFile=entry.getValue();
    final Language updatedLanguage=entry.getKey();
    if (languagesToSkip.contains(updatedLanguage))     continue;
    SoftReference<Set<OuterLanguageElement>> outerSet=myOuterLanguageElements.get(psiFile);
    if (outerSet == null) {
      continue;
    }
    try {
      myRootsInUpdate.add(psiFile);
      Set<OuterLanguageElement> languageElements=outerSet.get();
      if (languageElements == null) {
        psiFile.accept(new PsiElementVisitor(){
          public void visitReferenceExpression(          PsiReferenceExpression expression){
          }
          public void visitElement(          PsiElement element){
            if (element instanceof OuterLanguageElement) {
              registerOuterLanguageElement((OuterLanguageElement)element,psiFile);
            }
 else {
              element.acceptChildren(this);
            }
          }
        }
);
        outerSet=myOuterLanguageElements.get(psiFile);
        languageElements=outerSet.get();
      }
      Iterator<OuterLanguageElement> iterator=languageElements.iterator();
      while (iterator.hasNext()) {
        final OuterLanguageElement outerElement=iterator.next();
        final FileElement file=TreeUtil.getFileElement(outerElement);
        if (file == null || file.getPsi() != psiFile) {
          iterator.remove();
        }
      }
      XmlText prevText=null;
      int outerCount=0;
      iterator=languageElements.iterator();
      while (iterator.hasNext()) {
        final OuterLanguageElement outerElement=iterator.next();
        final XmlText nextText=outerElement.getFollowingText();
        final TextRange textRange=new TextRange(prevText != null ? prevText.getTextRange().getEndOffset() : outerCount != 0 ? outerElement.getTextRange().getStartOffset() : 0,nextText != null ? nextText.getTextRange().getStartOffset() : iterator.hasNext() ? outerElement.getTextRange().getEndOffset() : getContents().length());
        if (!textRange.equals(outerElement.getTextRange())) {
          outerElement.setRange(textRange);
        }
        prevText=nextText;
        ++outerCount;
      }
    }
  finally {
      myRootsInUpdate.remove(psiFile);
      checkConsistensy(psiFile);
    }
  }
}
