{
  final Ref<Boolean> result=new Ref<Boolean>();
  PsiClass aClass=ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>(){
    public PsiClass compute(){
      PsiClass aClass=constructor.getContainingClass();
      if (aClass == null) {
        result.set(true);
        return null;
      }
      if (aClass.isEnum()) {
        PsiField[] fields=aClass.getFields();
        for (        PsiField field : fields) {
          if (field instanceof PsiEnumConstant) {
            PsiReference reference=field.getReference();
            if (reference != null && reference.isReferenceTo(constructor)) {
              if (!processor.process(reference)) {
                result.set(false);
                return null;
              }
            }
          }
        }
      }
      return aClass;
    }
  }
);
  if (!result.isNull())   return result.get();
  Processor<PsiReference> processor1=new ReadActionProcessor<PsiReference>(){
    public boolean processInReadAction(    final PsiReference reference){
      PsiElement parent=reference.getElement().getParent();
      if (parent instanceof PsiAnonymousClass) {
        parent=parent.getParent();
      }
      if (parent instanceof PsiNewExpression) {
        PsiMethod constructor1=((PsiNewExpression)parent).resolveConstructor();
        if (constructor1 != null) {
          if (isStrictSignatureSearch) {
            if (myManager.areElementsEquivalent(constructor,constructor1)) {
              return processor.process(reference);
            }
          }
 else {
            if (myManager.areElementsEquivalent(constructor.getContainingClass(),constructor1.getContainingClass())) {
              return processor.process(reference);
            }
          }
        }
      }
      return true;
    }
  }
;
  if (!ReferencesSearch.search(aClass,searchScope,ignoreAccessScope).forEach(processor1))   return false;
  if (!processConstructorReferencesViaSuperOrThis(processor,aClass,constructor,searchScope,isStrictSignatureSearch,PsiKeyword.THIS)) {
    return false;
  }
  Processor<PsiClass> processor2=new Processor<PsiClass>(){
    public boolean process(    PsiClass inheritor){
      return processConstructorReferencesViaSuperOrThis(processor,inheritor,constructor,searchScope,isStrictSignatureSearch,PsiKeyword.SUPER);
    }
  }
;
  return ClassInheritorsSearch.search(aClass,searchScope,false).forEach(processor2);
}
