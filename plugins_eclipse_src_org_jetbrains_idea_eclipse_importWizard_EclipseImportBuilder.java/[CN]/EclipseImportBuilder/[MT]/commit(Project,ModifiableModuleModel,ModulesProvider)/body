{
  final Collection<String> unknownLibraries=new TreeSet<String>();
  final Collection<String> unknownJdks=new TreeSet<String>();
  final Set<String> refsToModules=new HashSet<String>();
  final List<Module> result=new ArrayList<Module>();
  try {
    final ModifiableModuleModel moduleModel=model != null ? model : ModuleManager.getInstance(project).getModifiableModel();
    final ModifiableRootModel[] rootModels=new ModifiableRootModel[getParameters().projectsToConvert.size()];
    int idx=0;
    final Set<String> usedVariables=new HashSet<String>();
    for (    String path : getParameters().projectsToConvert) {
      String modulesDirectory=getParameters().converterOptions.commonModulesDirectory;
      if (modulesDirectory == null) {
        modulesDirectory=path;
      }
      final Module module=moduleModel.newModule(modulesDirectory + "/" + EclipseProjectFinder.findProjectName(path)+ IdeaXml.IML_EXT,StdModuleTypes.JAVA);
      result.add(module);
      final ModifiableRootModel rootModel=ModuleRootManager.getInstance(module).getModifiableModel();
      rootModels[idx++]=rootModel;
      final File classpathFile=new File(path,EclipseXml.DOT_CLASSPATH_EXT);
      final EclipseClasspathReader classpathReader=new EclipseClasspathReader(path,project);
      classpathReader.init(rootModel);
      if (classpathFile.exists()) {
        final Element classpathElement=JDOMUtil.loadDocument(classpathFile).getRootElement();
        classpathReader.readClasspath(rootModel,unknownLibraries,unknownJdks,usedVariables,refsToModules,getParameters().converterOptions.testPattern,classpathElement);
      }
      ClasspathStorage.setStorageType(module,getParameters().linkConverted ? EclipseClasspathStorageProvider.ID : ClasspathStorage.DEFAULT_STORAGE);
      if (model != null) {
        ApplicationManager.getApplication().runWriteAction(new Runnable(){
          public void run(){
            rootModel.commit();
          }
        }
);
      }
    }
    if (model == null) {
      ApplicationManager.getApplication().runWriteAction(new Runnable(){
        public void run(){
          ProjectRootManagerEx.getInstanceEx(project).multiCommit(moduleModel,rootModels);
        }
      }
);
    }
  }
 catch (  Exception e) {
    LOG.error(e);
  }
  createEclipseLibrary(project,unknownLibraries,IdeaXml.ECLIPSE_LIBRARY);
  StringBuffer message=new StringBuffer();
  if (!unknownLibraries.isEmpty()) {
    message.append(EclipseBundle.message("eclipse.import.warning.undefinded.libraries"));
    for (    String name : unknownLibraries) {
      message.append("\n").append(name);
    }
  }
  if (!unknownJdks.isEmpty()) {
    if (message.length() > 0) {
      message.append("\nand jdks");
    }
 else {
      message.append("Imported project refers to unknown jdks");
    }
    for (    String unknownJdk : unknownJdks) {
      message.append("\n").append(unknownJdk);
    }
  }
  refsToModules.removeAll(getParameters().existingModuleNames);
  for (  String path : getParameters().projectsToConvert) {
    final String projectName=EclipseClasspathReader.getLastPathComponent(FileUtil.toSystemIndependentName(path));
    if (projectName != null) {
      refsToModules.remove(projectName);
      getParameters().existingModuleNames.add(projectName);
    }
  }
  if (!refsToModules.isEmpty()) {
    if (message.length() > 0)     message.append("\n");
    message.append("Unknown modules detected");
    for (    String module : refsToModules) {
      message.append("\n").append(module);
    }
  }
  if (message.length() > 0) {
    Messages.showErrorDialog(project,message.toString(),getTitle());
  }
  return result;
}
