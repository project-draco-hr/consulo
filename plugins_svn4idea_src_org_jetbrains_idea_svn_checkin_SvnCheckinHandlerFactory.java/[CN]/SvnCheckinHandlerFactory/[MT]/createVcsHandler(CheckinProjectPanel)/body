{
  final Project project=panel.getProject();
  final Collection<VirtualFile> commitRoots=panel.getRoots();
  return new CheckinHandler(){
    private Collection<Change> myChanges=panel.getSelectedChanges();
    @Override public RefreshableOnComponent getBeforeCheckinConfigurationPanel(){
      return null;
    }
    @Override public ReturnResult beforeCheckin(    @Nullable CommitExecutor executor,    PairConsumer<Object,Object> additionalDataConsumer){
      if (executor instanceof LocalCommitExecutor)       return ReturnResult.COMMIT;
      final SvnVcs vcs=SvnVcs.getInstance(project);
      final Map<String,Integer> copiesInfo=splitIntoCopies(vcs,myChanges);
      final List<String> repoUrls=new ArrayList<String>();
      for (      Map.Entry<String,Integer> entry : copiesInfo.entrySet()) {
        if (entry.getValue() == 3) {
          repoUrls.add(entry.getKey());
        }
      }
      if (!repoUrls.isEmpty()) {
        final String join=StringUtil.join(repoUrls.toArray(new String[repoUrls.size()]),",\n");
        final int isOk=Messages.showOkCancelDialog(project,SvnBundle.message("checkin.different.formats.involved",repoUrls.size() > 1 ? 1 : 0,join),"Subversion: Commit Will Split",Messages.getWarningIcon());
        if (Messages.OK == isOk) {
          return ReturnResult.COMMIT;
        }
        return ReturnResult.CANCEL;
      }
      return ReturnResult.COMMIT;
    }
    @Override public void includedChangesChanged(){
      myChanges=panel.getSelectedChanges();
    }
    @Override public void checkinSuccessful(){
      if (SvnConfiguration.getInstance(project).isAutoUpdateAfterCommit()) {
        final VirtualFile[] roots=ProjectLevelVcsManager.getInstance(project).getRootsUnderVcs(SvnVcs.getInstance(project));
        final List<FilePath> paths=new ArrayList<FilePath>();
        for (int i=0; i < roots.length; i++) {
          VirtualFile root=roots[i];
          boolean take=false;
          for (          VirtualFile commitRoot : commitRoots) {
            if (VfsUtil.isAncestor(root,commitRoot,false)) {
              take=true;
              break;
            }
          }
          if (!take)           continue;
          paths.add(new FilePathImpl(root));
        }
        if (paths.isEmpty())         return;
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          @Override public void run(){
            final JComponent frame=WindowManager.getInstance().getIdeFrame(project).getComponent();
            final AutoSvnUpdater updater=new AutoSvnUpdater(project,paths.toArray(new FilePath[paths.size()]));
            updater.getTemplatePresentation().setText(ActionInfo.UPDATE.getActionName());
            updater.actionPerformed(new AnActionEvent(null,DataManager.getInstance().getDataContext(frame),ActionPlaces.UNKNOWN,updater.getTemplatePresentation(),ActionManager.getInstance(),0));
          }
        }
,ModalityState.NON_MODAL);
      }
    }
  }
;
}
