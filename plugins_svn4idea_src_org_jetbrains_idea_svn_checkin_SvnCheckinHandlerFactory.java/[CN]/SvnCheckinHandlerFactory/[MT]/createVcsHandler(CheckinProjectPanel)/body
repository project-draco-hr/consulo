{
  final Project project=panel.getProject();
  final Collection<VirtualFile> commitRoots=panel.getRoots();
  return new CheckinHandler(){
    private Collection<Change> myChanges=panel.getSelectedChanges();
    @Override public RefreshableOnComponent getBeforeCheckinConfigurationPanel(){
      return null;
    }
    @Override public ReturnResult beforeCheckin(    @Nullable CommitExecutor executor,    PairConsumer<Object,Object> additionalDataConsumer){
      if (executor instanceof LocalCommitExecutor)       return ReturnResult.COMMIT;
      final SvnVcs vcs=SvnVcs.getInstance(project);
      final Map<String,Integer> copiesInfo=splitIntoCopies(vcs,myChanges);
      final List<String> repoUrls=new ArrayList<String>();
      for (      Map.Entry<String,Integer> entry : copiesInfo.entrySet()) {
        if (entry.getValue() == 3) {
          repoUrls.add(entry.getKey());
        }
      }
      if (!repoUrls.isEmpty()) {
        final String join=StringUtil.join(repoUrls.toArray(new String[repoUrls.size()]),",\n");
        final int isOk=Messages.showOkCancelDialog(project,SvnBundle.message("checkin.different.formats.involved",repoUrls.size() > 1 ? 1 : 0,join),"Subversion: Commit Will Split",Messages.getWarningIcon());
        if (Messages.OK == isOk) {
          return ReturnResult.COMMIT;
        }
      }
      return ReturnResult.CANCEL;
    }
    @Override public void includedChangesChanged(){
      myChanges=panel.getSelectedChanges();
    }
    @Override public void checkinSuccessful(){
      forceRefreshAdministrative(project);
      if (SvnConfiguration.getInstance(project).isAutoUpdateAfterCommit()) {
        final VirtualFile[] roots=ProjectLevelVcsManager.getInstance(project).getRootsUnderVcs(SvnVcs.getInstance(project));
        final List<FilePath> paths=new ArrayList<FilePath>();
        for (int i=0; i < roots.length; i++) {
          VirtualFile root=roots[i];
          boolean take=false;
          for (          VirtualFile commitRoot : commitRoots) {
            if (VfsUtil.isAncestor(root,commitRoot,false)) {
              take=true;
              break;
            }
          }
          if (!take)           continue;
          paths.add(new FilePathImpl(root));
        }
        if (paths.isEmpty())         return;
        ApplicationManager.getApplication().invokeLater(new Runnable(){
          @Override public void run(){
            final JComponent frame=WindowManager.getInstance().getIdeFrame(project).getComponent();
            final AutoSvnUpdater updater=new AutoSvnUpdater(project,paths.toArray(new FilePath[paths.size()]));
            updater.getTemplatePresentation().setText(ActionInfo.UPDATE.getActionName());
            updater.actionPerformed(new AnActionEvent(null,DataManager.getInstance().getDataContext(frame),ActionPlaces.UNKNOWN,updater.getTemplatePresentation(),ActionManager.getInstance(),0));
          }
        }
,ModalityState.NON_MODAL);
      }
    }
    private void forceRefreshAdministrative(    Project project){
      final SvnVcs vcs=SvnVcs.getInstance(project);
      final SvnFileUrlMapping mapping=vcs.getSvnFileUrlMapping();
      final List<FilePath> paths=ChangesUtil.getPaths(myChanges);
      final SvnEntriesFileListener listener=vcs.getEntriesFileListener();
      ApplicationManager.getApplication().invokeLater(new Runnable(){
        @Override public void run(){
          for (          FilePath path : paths) {
            VirtualFile vf=path.getVirtualFile();
            if (vf == null) {
              path.hardRefresh();
              vf=path.getVirtualFile();
            }
            if (vf != null) {
              listener.fileRevisionProbablyChanged(vf);
            }
          }
        }
      }
,ModalityState.NON_MODAL);
      final ProjectLevelVcsManager vcsManager=ProjectLevelVcsManager.getInstance(project);
      final Map<File,File> less17=new HashMap<File,File>();
      final Map<VirtualFile,VirtualFile> exactly17=new HashMap<VirtualFile,VirtualFile>();
      for (      FilePath path : paths) {
        if (!vcs.equals(vcsManager.getVcsFor(path)))         continue;
        final RootUrlInfo root=mapping.getWcRootForFilePath(path.getIOFile());
        if (root == null)         continue;
        final WorkingCopyFormat format=root.getFormat();
        if (WorkingCopyFormat.ONE_DOT_SEVEN.equals(format)) {
          if (!exactly17.containsKey(root.getVirtualFile())) {
            final VirtualFile admin=root.getVirtualFile().findChild(SvnUtil.SVN_ADMIN_DIR_NAME);
            if (admin != null) {
              final VirtualFile wc_db=admin.findChild(SvnUtil.WC_DB_FILE_NAME);
              if (wc_db != null) {
                exactly17.put(root.getVirtualFile(),wc_db);
              }
            }
          }
        }
 else {
          final File parentOfAdmin=path.isDirectory() ? path.getIOFile() : (path.getParentPath() == null ? null : path.getParentPath().getIOFile());
          if (parentOfAdmin != null && !less17.containsKey(parentOfAdmin)) {
            final File entries=new File(parentOfAdmin,SvnUtil.SVN_ADMIN_DIR_NAME + File.separator + SvnUtil.ENTRIES_FILE_NAME);
            less17.put(parentOfAdmin,entries);
          }
        }
      }
      for (      VirtualFile file : exactly17.values()) {
        if (file != null) {
          file.refresh(false,false);
        }
      }
      final LocalFileSystem lfs=LocalFileSystem.getInstance();
      for (      File file : less17.values()) {
        lfs.refreshAndFindFileByIoFile(file);
      }
    }
  }
;
}
