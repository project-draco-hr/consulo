{
  final PsiClass containingClass=member.getContainingClass();
  if (member instanceof PsiMethod && ((PsiMethod)member).isConstructor()) {
    return RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("constructor.cannot.be.made.static"));
  }
  if (member.getContainingClass() == null) {
    return RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("this.member.does.not.seem.to.belong.to.any.class"));
  }
  if (member.hasModifierProperty(PsiModifier.STATIC)) {
    return RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("member.is.already.static"));
  }
  if (member instanceof PsiMethod && member.hasModifierProperty(PsiModifier.ABSTRACT)) {
    return RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("cannot.make.abstract.method.static"));
  }
  if (containingClass.getContainingClass() != null && !containingClass.hasModifierProperty(PsiModifier.STATIC)) {
    return RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("inner.classes.cannot.have.static.members"));
  }
  return null;
}
