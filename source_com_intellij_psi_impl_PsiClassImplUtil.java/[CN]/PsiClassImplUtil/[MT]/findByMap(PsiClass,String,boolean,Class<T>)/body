{
  if (name == null)   return emptyArrayByType(type);
  if (!checkBases) {
    Object[] members=null;
    if (type.isAssignableFrom(PsiMethod.class)) {
      members=aClass.getMethods();
    }
 else     if (type.isAssignableFrom(PsiClass.class)) {
      members=aClass.getInnerClasses();
    }
 else     if (type.isAssignableFrom(PsiField.class)) {
      members=aClass.getFields();
    }
    if (members == null)     return emptyArrayByType(type);
    List<T> list=new ArrayList<T>();
    for (int i=0; i < members.length; i++) {
      final T method=(T)members[i];
      if (name.equals(method.getName()))       list.add(method);
    }
    return list.toArray(emptyArrayByType(type));
  }
 else {
    final Map<String,List<Pair<T,PsiSubstitutor>>> allMethodsMap=getMap(aClass,type);
    final List<Pair<T,PsiSubstitutor>> list=allMethodsMap.get(name);
    if (list == null)     return emptyArrayByType(type);
    final List<T> ret=new ArrayList<T>();
    final Iterator<Pair<T,PsiSubstitutor>> iterator=list.iterator();
    while (iterator.hasNext()) {
      final Pair<T,PsiSubstitutor> info=iterator.next();
      ret.add(info.getFirst());
    }
    return ret.toArray(emptyArrayByType(type));
  }
}
