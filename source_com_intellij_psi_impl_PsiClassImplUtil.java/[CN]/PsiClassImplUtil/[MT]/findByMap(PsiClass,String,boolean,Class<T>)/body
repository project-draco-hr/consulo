{
  if (name == null)   return Collections.emptyList();
  if (!checkBases) {
    T[] members=null;
    if (ReflectionCache.isAssignable(type,PsiMethod.class)) {
      members=(T[])aClass.getMethods();
    }
 else     if (ReflectionCache.isAssignable(type,PsiClass.class)) {
      members=(T[])aClass.getInnerClasses();
    }
 else     if (ReflectionCache.isAssignable(type,PsiField.class)) {
      members=(T[])aClass.getFields();
    }
    if (members == null)     return Collections.emptyList();
    List<T> list=new ArrayList<T>();
    for (    T member : members) {
      if (name.equals(member.getName()))       list.add(member);
    }
    return list;
  }
 else {
    final Map<String,List<Pair<T,PsiSubstitutor>>> allMethodsMap=getMap(aClass,type);
    final List<Pair<T,PsiSubstitutor>> list=allMethodsMap.get(name);
    if (list == null)     return Collections.emptyList();
    final List<T> ret=new ArrayList<T>();
    for (    final Pair<T,PsiSubstitutor> info : list) {
      ret.add(info.getFirst());
    }
    return ret;
  }
}
