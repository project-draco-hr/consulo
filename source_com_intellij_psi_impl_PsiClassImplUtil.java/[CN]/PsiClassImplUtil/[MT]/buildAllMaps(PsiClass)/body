{
  final List<Pair<PsiClass,PsiSubstitutor>> classes=new ArrayList<Pair<PsiClass,PsiSubstitutor>>();
  final List<Pair<PsiField,PsiSubstitutor>> fields=new ArrayList<Pair<PsiField,PsiSubstitutor>>();
  final List<Pair<PsiMethod,PsiSubstitutor>> methods=new ArrayList<Pair<PsiMethod,PsiSubstitutor>>();
  FilterScopeProcessor<MethodCandidateInfo> processor=new FilterScopeProcessor<MethodCandidateInfo>(new OrFilter(new ClassFilter(PsiMethod.class),new ClassFilter(PsiField.class),new ClassFilter(PsiClass.class))){
    protected void add(    PsiElement element,    PsiSubstitutor substitutor){
      if (element instanceof PsiMethod) {
        methods.add(new Pair<PsiMethod,PsiSubstitutor>((PsiMethod)element,substitutor));
      }
 else       if (element instanceof PsiField) {
        fields.add(new Pair<PsiField,PsiSubstitutor>((PsiField)element,substitutor));
      }
 else       if (element instanceof PsiClass) {
        classes.add(new Pair<PsiClass,PsiSubstitutor>((PsiClass)element,substitutor));
      }
    }
  }
;
  processDeclarationsInClassNotCached(psiClass,processor,PsiSubstitutor.EMPTY,new THashSet<PsiClass>(),null,psiClass,false);
  Map<Class<? extends PsiMember>,Map<String,List>> result=new HashMap<Class<? extends PsiMember>,Map<String,List>>(3);
  result.put(PsiClass.class,generateMapByList(classes));
  result.put(PsiMethod.class,generateMapByList(methods));
  result.put(PsiField.class,generateMapByList(fields));
  psiClass.putUserData(NAME_MAPS_BUILT_FLAG,Boolean.TRUE);
  return result;
}
