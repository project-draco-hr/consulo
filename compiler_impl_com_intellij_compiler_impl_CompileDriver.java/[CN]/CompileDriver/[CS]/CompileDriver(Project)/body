{
  myProject=project;
  myCachesDirectoryPath=CompilerPaths.getCacheStoreDirectory(myProject).getPath().replace('/',File.separatorChar);
  myShouldClearOutputDirectory=CompilerWorkspaceConfiguration.getInstance(myProject).CLEAR_OUTPUT_DIRECTORY;
  myGenerationCompilerModuleToOutputDirMap=new com.intellij.util.containers.HashMap<Pair<Compiler,Module>,VirtualFile>();
  final GeneratingCompiler[] compilers=CompilerManager.getInstance(myProject).getCompilers(GeneratingCompiler.class);
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    public void run(){
      final Module[] allModules=ModuleManager.getInstance(myProject).getModules();
      for (      GeneratingCompiler compiler : compilers) {
        for (        final Module module : allModules) {
          final String path=getGenerationOutputPath(compiler,module);
          final File file=new File(path);
          final VirtualFile vFile;
          if (file.mkdirs()) {
            vFile=LocalFileSystem.getInstance().refreshAndFindFileByIoFile(file);
          }
 else {
            vFile=LocalFileSystem.getInstance().findFileByPath(path);
          }
          Pair<Compiler,Module> pair=new Pair<Compiler,Module>(compiler,module);
          myGenerationCompilerModuleToOutputDirMap.put(pair,vFile);
        }
      }
    }
  }
);
  myProjectRootManager=ProjectRootManager.getInstance(myProject);
  myProcessingCompilerAdapterFactory=new FileProcessingCompilerAdapterFactory(){
    public FileProcessingCompilerAdapter create(    CompileContext context,    FileProcessingCompiler compiler){
      return new FileProcessingCompilerAdapter(context,compiler);
    }
  }
;
  myPackagingCompilerAdapterFactory=new FileProcessingCompilerAdapterFactory(){
    public FileProcessingCompilerAdapter create(    CompileContext context,    FileProcessingCompiler compiler){
      return new PackagingCompilerAdapter(context,(PackagingCompiler)compiler);
    }
  }
;
  myProjectCompileScope=new ProjectCompileScope(myProject);
}
