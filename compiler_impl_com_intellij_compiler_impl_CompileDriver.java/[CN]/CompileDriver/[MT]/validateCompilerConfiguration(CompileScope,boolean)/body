{
  final Module[] scopeModules=scope.getAffectedModules();
  final List<String> modulesWithoutOutputPathSpecified=new ArrayList<String>();
  final List<String> modulesWithoutJdkAssigned=new ArrayList<String>();
  final Set<File> nonExistingOutputPaths=new HashSet<File>();
  for (  final Module module : scopeModules) {
    final boolean hasSources=hasSources(module,false);
    final boolean hasTestSources=hasSources(module,true);
    if (!hasSources && !hasTestSources) {
      continue;
    }
    final ProjectJdk jdk=ModuleRootManager.getInstance(module).getJdk();
    if (jdk == null) {
      modulesWithoutJdkAssigned.add(module.getName());
    }
    final String outputPath=getModuleOutputPath(module,false);
    final String testsOutputPath=getModuleOutputPath(module,true);
    if (outputPath == null && testsOutputPath == null) {
      modulesWithoutOutputPathSpecified.add(module.getName());
    }
 else {
      if (outputPath != null) {
        final File file=new File(outputPath.replace('/',File.separatorChar));
        if (!file.exists()) {
          nonExistingOutputPaths.add(file);
        }
      }
 else {
        if (hasSources) {
          modulesWithoutOutputPathSpecified.add(module.getName());
        }
      }
      if (testsOutputPath != null) {
        final File f=new File(testsOutputPath.replace('/',File.separatorChar));
        if (!f.exists()) {
          nonExistingOutputPaths.add(f);
        }
      }
 else {
        if (hasTestSources) {
          modulesWithoutOutputPathSpecified.add(module.getName());
        }
      }
    }
  }
  if (!modulesWithoutJdkAssigned.isEmpty()) {
    showNotSpecifiedError("error.jdk.not.specified",modulesWithoutJdkAssigned,ClasspathEditor.NAME);
    return false;
  }
  if (!modulesWithoutOutputPathSpecified.isEmpty()) {
    showNotSpecifiedError("error.output.not.specified",modulesWithoutOutputPathSpecified,ContentEntriesEditor.NAME);
    return false;
  }
  if (!nonExistingOutputPaths.isEmpty()) {
    for (    File file : nonExistingOutputPaths) {
      final boolean succeeded=file.mkdirs();
      if (!succeeded) {
        Messages.showMessageDialog(myProject,CompilerBundle.message("error.failed.to.create.directory",file.getPath()),CommonBundle.getErrorTitle(),Messages.getErrorIcon());
        return false;
      }
    }
    final Boolean refreshSuccess=ApplicationManager.getApplication().runWriteAction(new Computable<Boolean>(){
      public Boolean compute(){
        LocalFileSystem.getInstance().refreshIoFiles(nonExistingOutputPaths);
        for (        File file : nonExistingOutputPaths) {
          if (LocalFileSystem.getInstance().findFileByIoFile(file) == null) {
            return Boolean.FALSE;
          }
        }
        return Boolean.TRUE;
      }
    }
);
    if (!refreshSuccess.booleanValue()) {
      return false;
    }
    dropScopesCaches();
  }
  if (checkOutputAndSourceIntersection) {
    if (myShouldClearOutputDirectory) {
      if (!validateOutputAndSourcePathsIntersection()) {
        return false;
      }
    }
  }
  final List<Chunk<Module>> chunks=ModuleCompilerUtil.getSortedModuleChunks(myProject,scopeModules);
  for (  final Chunk<Module> chunk : chunks) {
    final Set<Module> chunkModules=chunk.getNodes();
    if (chunkModules.size() <= 1) {
      continue;
    }
    ProjectJdk jdk=null;
    LanguageLevel languageLevel=null;
    for (    final Module module : chunkModules) {
      final ProjectJdk moduleJdk=ModuleRootManager.getInstance(module).getJdk();
      if (jdk == null) {
        jdk=moduleJdk;
      }
 else {
        if (!jdk.equals(moduleJdk)) {
          showCyclicModulesHaveDifferentJdksError(chunkModules.toArray(new Module[chunkModules.size()]));
          return false;
        }
      }
      LanguageLevel moduleLanguageLevel=module.getEffectiveLanguageLevel();
      if (languageLevel == null) {
        languageLevel=moduleLanguageLevel;
      }
 else {
        if (!languageLevel.equals(moduleLanguageLevel)) {
          showCyclicModulesHaveDifferentLanguageLevel(chunkModules.toArray(new Module[chunkModules.size()]));
          return false;
        }
      }
    }
  }
  final Compiler[] allCompilers=CompilerManager.getInstance(myProject).getCompilers(Compiler.class);
  for (  Compiler compiler : allCompilers) {
    if (!compiler.validateConfiguration(scope)) {
      return false;
    }
  }
  return true;
}
