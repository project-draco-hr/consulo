{
  final List<String> toRemove=new ArrayList<String>();
  final CompileScope scope=context.getCompileScope();
  for (Iterator<String> it=cache.getOutputUrlsIterator(); it.hasNext(); ) {
    final String outputPath=it.next();
    final String sourceUrl=cache.getSourceUrl(outputPath);
    final VirtualFile sourceFile=snapshot.getFileByUrl(sourceUrl);
    boolean needRecompile=false;
    boolean shouldDelete;
    String reason;
    if (myOutputFilesOnDisk.contains(outputPath)) {
      if (sourceFile == null) {
        shouldDelete=scope.belongs(sourceUrl);
        reason="source file not found; [scope.belongs(sourceUrl)] = " + shouldDelete;
      }
 else {
        if (toCompile.contains(sourceFile)) {
          shouldDelete=!FileUtil.pathsEqual(outputPath,VirtualFileManager.extractPath(sourceUrl));
          reason="source file found, is about to be compiled; shouldDelete= " + shouldDelete + " ("+ outputPath+ ") != "+ VirtualFileManager.extractPath(sourceUrl);
        }
 else {
          final String currentOutputDir=getModuleOutputDirForFile(context,sourceFile);
          if (currentOutputDir != null) {
            final String className=cache.getClassName(outputPath);
            final boolean pathsEqual=className == null || currentOutputDir.regionMatches(!SystemInfo.isFileSystemCaseSensitive,0,outputPath,0,outputPath.length() - className.length() - ".class".length()- 1);
            if (pathsEqual) {
              shouldDelete=false;
              reason="source file found, current output dir!=null; shouldDelete=false: className=" + className;
            }
 else {
              shouldDelete=true;
              needRecompile=true;
              reason="source file found, current output dir!=null; shouldDelete=true: className=" + className;
            }
          }
 else {
            shouldDelete=true;
            reason="source file found, current output dir==null";
          }
        }
      }
    }
 else {
      needRecompile=true;
      shouldDelete=true;
      reason="myOutputFileOnDisk does not contain the output path";
    }
    LOG.info("OutputPath \"" + outputPath + "\"; SHOULD_DELETE="+ shouldDelete+ "; REASON: "+ reason);
    if (shouldDelete) {
      toDelete.add(outputPath);
    }
    if (needRecompile) {
      if (sourceFile != null && scope.belongs(sourceUrl)) {
        if (!compilerConfiguration.isExcludedFromCompilation(sourceFile)) {
          toCompile.add(sourceFile);
          toRemove.add(outputPath);
        }
      }
    }
    if (sourceFile == null) {
      urlsWithSourceRemoved.add(outputPath);
    }
  }
  for (  final String aToRemove : toRemove) {
    cache.remove(aToRemove);
  }
}
