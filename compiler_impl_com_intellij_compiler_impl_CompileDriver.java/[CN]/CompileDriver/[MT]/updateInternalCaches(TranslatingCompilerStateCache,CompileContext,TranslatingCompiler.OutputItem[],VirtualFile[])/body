{
  final IOException[] ex=new IOException[]{null};
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    public void run(){
      try {
        context.getProgressIndicator().setText(CompilerBundle.message("progress.updating.caches"));
        final FileTypeManager typeManager=FileTypeManager.getInstance();
        if (LOG.isDebugEnabled()) {
          LOG.debug("Updating internal caches: successfully compiled " + successfullyCompiled.length + " files; toRecompile: "+ filesToRecompile.length+ " files");
        }
        for (        final TranslatingCompiler.OutputItem item : successfullyCompiled) {
          final String outputPath=item.getOutputPath();
          final VirtualFile sourceFile=item.getSourceFile();
          final String className;
          if (outputPath != null && StdFileTypes.JAVA.equals(typeManager.getFileTypeByFile(sourceFile))) {
            final String outputDir=item.getOutputRootDirectory();
            if (outputDir != null) {
              if (!FileUtil.startsWith(outputPath,outputDir)) {
                LOG.error(outputPath + " does not start with " + outputDir);
              }
              className=MakeUtil.relativeClassPathToQName(outputPath.substring(outputDir.length(),outputPath.length()),'/');
            }
 else {
              className=null;
            }
          }
 else {
            className=null;
          }
          if (LOG.isDebugEnabled()) {
            LOG.debug("Putting: [outputPath, className, sourceFile] = [" + outputPath + ";"+ className+ ";"+ sourceFile.getPresentableUrl()+ "]");
          }
          cache.update(outputPath,className,sourceFile);
        }
        for (        VirtualFile aFilesToRecompile : filesToRecompile) {
          cache.markAsModified(aFilesToRecompile);
        }
      }
 catch (      IOException e) {
        ex[0]=e;
      }
    }
  }
);
  if (ex[0] != null) {
    throw ex[0];
  }
}
