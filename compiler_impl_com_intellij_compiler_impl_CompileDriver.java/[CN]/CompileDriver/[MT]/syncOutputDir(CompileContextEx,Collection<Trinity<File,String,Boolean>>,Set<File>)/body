{
  final int total=toDelete.size();
  final DependencyCache dependencyCache=context.getDependencyCache();
  final boolean isTestMode=ApplicationManager.getApplication().isUnitTestMode();
  final List<File> filesToRefresh=new ArrayList<File>();
  try {
    final boolean[] wereFilesDeleted={false};
    runInContext(context,CompilerBundle.message("progress.synchronizing.output.directory"),new ThrowableRunnable<CacheCorruptedException>(){
      public void run() throws CacheCorruptedException {
        int current=0;
        for (        final Trinity<File,String,Boolean> trinity : toDelete) {
          context.getProgressIndicator().setFraction((double)++current / total);
          context.getProgressIndicator().checkCanceled();
          final File outputPath=trinity.getFirst();
          filesToRefresh.add(outputPath);
          if (deleteFile(outputPath)) {
            wereFilesDeleted[0]=true;
            final String className=trinity.getSecond();
            if (className != null) {
              final int id=dependencyCache.getSymbolTable().getId(className);
              dependencyCache.addTraverseRoot(id);
              final boolean sourcePresent=trinity.getThird().booleanValue();
              if (!sourcePresent) {
                dependencyCache.markSourceRemoved(id);
              }
            }
            if (isTestMode) {
              CompilerManagerImpl.addDeletedPath(outputPath.getPath());
            }
          }
        }
        runInContext(context,"Pruning empty directories...",new ThrowableRunnable<RuntimeException>(){
          public void run() throws RuntimeException {
            pruneEmptyDirectories(context.getProgressIndicator(),outputDirectories);
          }
        }
);
      }
    }
);
    return wereFilesDeleted[0];
  }
  finally {
    CompilerUtil.refreshIOFiles(filesToRefresh);
  }
}
