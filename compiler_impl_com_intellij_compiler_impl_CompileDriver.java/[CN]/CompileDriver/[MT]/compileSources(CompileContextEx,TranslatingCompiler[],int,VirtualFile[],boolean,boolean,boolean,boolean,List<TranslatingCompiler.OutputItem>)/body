{
  final TranslatingCompiler compiler=compilers[currentCompiler];
  final Set<VirtualFile> toCompile=new HashSet<VirtualFile>();
  final List<Trinity<File,String,Boolean>> toDelete=new ArrayList<Trinity<File,String,Boolean>>();
  context.getProgressIndicator().pushState();
  final boolean[] wereFilesDeleted=new boolean[]{false};
  try {
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        TranslatingCompilerFilesMonitor.getInstance().collectFiles(context,compiler,Arrays.asList(sources).iterator(),forceCompile,isRebuild,toCompile,toDelete);
        if (trackDependencies && !toCompile.isEmpty()) {
          final FileTypeManager fileTypeManager=FileTypeManager.getInstance();
          final PsiManager psiManager=PsiManager.getInstance(myProject);
          final VirtualFile[] filesToCompile=toCompile.toArray(new VirtualFile[toCompile.size()]);
          for (          final VirtualFile file : filesToCompile) {
            if (fileTypeManager.getFileTypeByFile(file) == StdFileTypes.JAVA) {
              final PsiFile psiFile=psiManager.findFile(file);
              if (psiFile != null) {
                addDependentFiles(psiFile,toCompile,compiler,context);
              }
            }
          }
        }
      }
    }
);
    if (onlyCheckStatus) {
      if (toDelete.isEmpty() && toCompile.isEmpty()) {
        return false;
      }
      if (LOG.isDebugEnabled()) {
        if (!toDelete.isEmpty()) {
          LOG.debug("Found items to delete, compiler " + compiler.getDescription());
        }
        if (!toCompile.isEmpty()) {
          LOG.debug("Found items to compile, compiler " + compiler.getDescription());
        }
      }
      throw new ExitException(ExitStatus.CANCELLED);
    }
    if (!toDelete.isEmpty()) {
      try {
        wereFilesDeleted[0]=syncOutputDir(context,toDelete);
      }
 catch (      CacheCorruptedException e) {
        LOG.info(e);
        context.requestRebuildNextTime(e.getMessage());
      }
    }
    if ((wereFilesDeleted[0] || !toCompile.isEmpty()) && context.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
      final TranslatingCompiler.ExitStatus exitStatus=compiler.compile(context,toCompile.toArray(new VirtualFile[toCompile.size()]));
      final TranslatingCompiler.OutputItem[] successfullyCompiled=exitStatus.getSuccessfullyCompiled();
      if (compiler instanceof IntermediateOutputCompiler) {
        final LocalFileSystem lfs=LocalFileSystem.getInstance();
        final List<VirtualFile> outputs=new ArrayList<VirtualFile>();
        for (        TranslatingCompiler.OutputItem item : successfullyCompiled) {
          final VirtualFile vFile=lfs.findFileByPath(item.getOutputPath());
          if (vFile != null) {
            outputs.add(vFile);
          }
        }
        context.markGenerated(outputs);
      }
      TranslatingCompiler.OutputItem[] toUpdate=successfullyCompiled;
      final int nextCompiler=currentCompiler + 1;
      if (nextCompiler < compilers.length) {
        boolean changes=false;
        final List<TranslatingCompiler.OutputItem> updateNow=new ArrayList<TranslatingCompiler.OutputItem>(successfullyCompiled.length);
        for (Iterator<TranslatingCompiler.OutputItem> it=postponed.iterator(); it.hasNext(); ) {
          TranslatingCompiler.OutputItem item=it.next();
          boolean shouldPostpone=false;
          for (int idx=nextCompiler; idx < compilers.length; idx++) {
            if (shouldPostpone=compilers[idx].isCompilableFile(item.getSourceFile(),context)) {
              break;
            }
          }
          if (!shouldPostpone) {
            it.remove();
            updateNow.add(item);
            changes=true;
          }
        }
        for (        TranslatingCompiler.OutputItem item : successfullyCompiled) {
          boolean shouldPostpone=false;
          for (int idx=nextCompiler; idx < compilers.length; idx++) {
            if (shouldPostpone=compilers[idx].isCompilableFile(item.getSourceFile(),context)) {
              break;
            }
          }
          if (shouldPostpone) {
            postponed.add(item);
            changes=true;
          }
 else {
            updateNow.add(item);
          }
        }
        if (changes) {
          toUpdate=updateNow.toArray(new TranslatingCompiler.OutputItem[updateNow.size()]);
        }
      }
      TranslatingCompilerFilesMonitor.getInstance().update(context,toUpdate,exitStatus.getFilesToRecompile());
    }
  }
 catch (  IOException e) {
    LOG.info(e);
    context.requestRebuildNextTime(e.getMessage());
    throw new ExitException(ExitStatus.ERRORS);
  }
 finally {
    context.getProgressIndicator().popState();
  }
  return !toCompile.isEmpty() || wereFilesDeleted[0];
}
