{
  final CompilerConfiguration compilerConfiguration=CompilerConfiguration.getInstance(myProject);
  context.getProgressIndicator().pushState();
  final boolean[] wereFilesDeleted=new boolean[]{false};
  final Set<VirtualFile> toCompile=new HashSet<VirtualFile>();
  try {
    final TranslatingCompilerStateCache cache=getTranslatingCompilerCache(compiler);
    final Set<String> toDelete=new HashSet<String>();
    final Set<String> urlsWithSourceRemoved=new HashSet<String>();
    final IOException[] ex=new IOException[]{null};
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        try {
          findOutOfDateFiles(compiler,forceCompile,cache,toCompile,context,snapshot);
          if (trackDependencies && !toCompile.isEmpty()) {
            final FileTypeManager fileTypeManager=FileTypeManager.getInstance();
            final PsiManager psiManager=PsiManager.getInstance(myProject);
            final VirtualFile[] filesToCompile=toCompile.toArray(new VirtualFile[toCompile.size()]);
            Set<String> sourcesWithOutputRemoved=getSourcesWithOutputRemoved(cache);
            for (            final VirtualFile file : filesToCompile) {
              if (fileTypeManager.getFileTypeByFile(file) == StdFileTypes.JAVA) {
                final PsiFile psiFile=psiManager.findFile(file);
                if (psiFile != null) {
                  addDependentFiles(psiFile,toCompile,cache,sourcesWithOutputRemoved,compiler,context);
                }
              }
            }
          }
          if (!isRebuild) {
            final ProgressIndicator progressIndicator=context.getProgressIndicator();
            progressIndicator.pushState();
            progressIndicator.setText(CompilerBundle.message("progress.searching.for.files.to.delete"));
            findFilesToDelete(compiler,snapshot,urlsWithSourceRemoved,cache,toCompile,context,toDelete,compilerConfiguration);
            progressIndicator.popState();
          }
        }
 catch (        IOException e) {
          ex[0]=e;
        }
      }
    }
);
    if (ex[0] != null) {
      throw ex[0];
    }
    if (onlyCheckStatus) {
      if (toDelete.isEmpty() && toCompile.isEmpty()) {
        return false;
      }
      if (LOG.isDebugEnabled()) {
        if (!toDelete.isEmpty()) {
          LOG.debug("Found items to delete, compiler " + compiler.getDescription());
        }
        if (!toCompile.isEmpty()) {
          LOG.debug("Found items to compile, compiler " + compiler.getDescription());
        }
      }
      throw new ExitException(ExitStatus.CANCELLED);
    }
    if (!toDelete.isEmpty()) {
      try {
        wereFilesDeleted[0]=syncOutputDir(urlsWithSourceRemoved,context,toDelete,cache,outputDirectories);
      }
 catch (      CacheCorruptedException e) {
        LOG.info(e);
        context.requestRebuildNextTime(e.getMessage());
      }
    }
    if (wereFilesDeleted[0] && !toDelete.isEmpty()) {
      CompilerUtil.refreshPaths(toDelete.toArray(new String[toDelete.size()]));
    }
    if ((wereFilesDeleted[0] || !toCompile.isEmpty()) && context.getMessageCount(CompilerMessageCategory.ERROR) == 0) {
      final TranslatingCompiler.ExitStatus exitStatus=compiler.compile(context,toCompile.toArray(new VirtualFile[toCompile.size()]));
      updateInternalCaches(cache,context,exitStatus.getSuccessfullyCompiled(),exitStatus.getFilesToRecompile());
    }
  }
 catch (  IOException e) {
    LOG.info(e);
    context.requestRebuildNextTime(e.getMessage());
    throw new ExitException(ExitStatus.ERRORS);
  }
  return !toCompile.isEmpty() || wereFilesDeleted[0];
}
