{
  final GeneratingCompiler.GenerationItem[] allItems=compiler.getGenerationItems(context);
  final List<GeneratingCompiler.GenerationItem> toGenerate=new ArrayList<GeneratingCompiler.GenerationItem>();
  final List<File> filesToRefresh=new ArrayList<File>();
  final List<File> generatedFiles=new ArrayList<File>();
  final List<Module> affectedModules=new ArrayList<Module>();
  try {
    final StateCache<ValidityState> cache=getGeneratingCompilerCache(compiler);
    final Set<String> pathsToRemove=new HashSet<String>(cache.getUrls());
    final Map<GeneratingCompiler.GenerationItem,String> itemToOutputPathMap=new HashMap<GeneratingCompiler.GenerationItem,String>();
    final IOException[] ex=new IOException[]{null};
    ApplicationManager.getApplication().runReadAction(new Runnable(){
      public void run(){
        for (        final GeneratingCompiler.GenerationItem item : allItems) {
          final Module itemModule=item.getModule();
          final String outputDirPath=CompilerPaths.getGenerationOutputPath(compiler,itemModule,item.isTestSource());
          final String outputPath=outputDirPath + "/" + item.getPath();
          itemToOutputPathMap.put(item,outputPath);
          try {
            final ValidityState savedState=cache.getState(outputPath);
            if (forceGenerate || savedState == null || !savedState.equalsTo(item.getValidityState())) {
              final String outputPathUrl=VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL,outputPath);
              if (context.getCompileScope().belongs(outputPathUrl)) {
                toGenerate.add(item);
              }
 else {
                pathsToRemove.remove(outputPath);
              }
            }
 else {
              pathsToRemove.remove(outputPath);
            }
          }
 catch (          IOException e) {
            ex[0]=e;
          }
        }
      }
    }
);
    if (ex[0] != null) {
      throw ex[0];
    }
    if (onlyCheckStatus) {
      if (toGenerate.isEmpty() && pathsToRemove.isEmpty()) {
        return false;
      }
      if (LOG.isDebugEnabled()) {
        if (!toGenerate.isEmpty()) {
          LOG.debug("Found items to generate, compiler " + compiler.getDescription());
        }
        if (!pathsToRemove.isEmpty()) {
          LOG.debug("Found paths to remove, compiler " + compiler.getDescription());
        }
      }
      throw new ExitException(ExitStatus.CANCELLED);
    }
    if (!pathsToRemove.isEmpty()) {
      context.getProgressIndicator().pushState();
      context.getProgressIndicator().setText(CompilerBundle.message("progress.synchronizing.output.directory"));
      for (      final String path : pathsToRemove) {
        final File file=new File(path);
        final boolean deleted=deleteFile(file);
        if (deleted) {
          cache.remove(path);
          filesToRefresh.add(file);
        }
      }
      context.getProgressIndicator().popState();
    }
    Map<Module,Set<GeneratingCompiler.GenerationItem>> moduleToItemMap=buildModuleToGenerationItemMap(toGenerate.toArray(new GeneratingCompiler.GenerationItem[toGenerate.size()]));
    List<Module> modules=new ArrayList<Module>(moduleToItemMap.size());
    for (    final Module module : moduleToItemMap.keySet()) {
      modules.add(module);
    }
    ModuleCompilerUtil.sortModules(myProject,modules);
    for (    final Module module : modules) {
      context.getProgressIndicator().pushState();
      try {
        final Set<GeneratingCompiler.GenerationItem> items=moduleToItemMap.get(module);
        if (items != null && !items.isEmpty()) {
          final GeneratingCompiler.GenerationItem[][] productionAndTestItems=splitGenerationItems(items);
          boolean moduleAffected=false;
          for (          GeneratingCompiler.GenerationItem[] _items : productionAndTestItems) {
            if (_items.length > 0) {
              final VirtualFile outputDir=getGenerationOutputDir(compiler,module,_items[0].isTestSource());
              final GeneratingCompiler.GenerationItem[] successfullyGenerated=compiler.generate(context,_items,outputDir);
              context.getProgressIndicator().setText(CompilerBundle.message("progress.updating.caches"));
              if (successfullyGenerated.length > 0) {
                moduleAffected=true;
              }
              for (              final GeneratingCompiler.GenerationItem item : successfullyGenerated) {
                final String fullOutputPath=itemToOutputPathMap.get(item);
                cache.update(fullOutputPath,item.getValidityState());
                final File file=new File(fullOutputPath);
                filesToRefresh.add(file);
                generatedFiles.add(file);
              }
            }
          }
          if (moduleAffected) {
            affectedModules.add(module);
          }
        }
      }
  finally {
        context.getProgressIndicator().popState();
      }
    }
  }
 catch (  IOException e) {
    LOG.info(e);
    context.requestRebuildNextTime(e.getMessage());
    throw new ExitException(ExitStatus.ERRORS);
  }
 finally {
    context.getProgressIndicator().pushState();
    CompilerUtil.refreshIOFiles(filesToRefresh);
    if (!generatedFiles.isEmpty()) {
      List<VirtualFile> vFiles=ApplicationManager.getApplication().runReadAction(new Computable<List<VirtualFile>>(){
        public List<VirtualFile> compute(){
          final ArrayList<VirtualFile> vFiles=new ArrayList<VirtualFile>(generatedFiles.size());
          for (          File generatedFile : generatedFiles) {
            final VirtualFile vFile=LocalFileSystem.getInstance().findFileByIoFile(generatedFile);
            if (vFile != null) {
              vFiles.add(vFile);
            }
          }
          return vFiles;
        }
      }
);
      if (forceGenerate) {
        context.addScope(new FileSetCompileScope(vFiles.toArray(new VirtualFile[vFiles.size()]),affectedModules.toArray(new Module[affectedModules.size()])));
      }
      context.markGenerated(vFiles);
    }
  }
  return !toGenerate.isEmpty() || !filesToRefresh.isEmpty();
}
