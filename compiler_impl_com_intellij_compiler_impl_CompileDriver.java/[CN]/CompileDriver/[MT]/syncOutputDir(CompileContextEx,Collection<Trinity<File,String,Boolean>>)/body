{
  final int total=toDelete.size();
  final DependencyCache dependencyCache=context.getDependencyCache();
  final boolean isTestMode=ApplicationManager.getApplication().isUnitTestMode();
  final List<File> filesToRefresh=new ArrayList<File>();
  final boolean[] wereFilesDeleted={false};
  runInContext(context,CompilerBundle.message("progress.synchronizing.output.directory"),new ThrowableRunnable<CacheCorruptedException>(){
    public void run() throws CacheCorruptedException {
      try {
        int current=0;
        for (        final Trinity<File,String,Boolean> trinity : toDelete) {
          final File outputPath=trinity.getFirst();
          context.getProgressIndicator().checkCanceled();
          context.getProgressIndicator().setFraction((double)++current / total);
          context.getProgressIndicator().setText2(outputPath.getPath());
          filesToRefresh.add(outputPath);
          if (!deleteFile(outputPath)) {
            continue;
          }
          wereFilesDeleted[0]=true;
          final String className=trinity.getSecond();
          if (className != null) {
            final int id=dependencyCache.getSymbolTable().getId(className);
            dependencyCache.addTraverseRoot(id);
            final boolean sourcePresent=trinity.getThird().booleanValue();
            if (!sourcePresent) {
              dependencyCache.markSourceRemoved(id);
            }
          }
          if (isTestMode) {
            CompilerManagerImpl.addDeletedPath(outputPath.getPath());
          }
        }
      }
  finally {
        CompilerUtil.refreshIOFilesInterruptibly(context,filesToRefresh,null);
      }
    }
  }
);
  return wereFilesDeleted[0];
}
