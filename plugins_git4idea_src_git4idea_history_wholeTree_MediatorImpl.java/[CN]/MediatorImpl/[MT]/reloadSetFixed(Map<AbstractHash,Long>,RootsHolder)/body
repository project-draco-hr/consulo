{
  myTicket.increment();
  final List<AbstractHash> hash=new ArrayList<AbstractHash>(starred.keySet());
  Collections.sort(hash,new Comparator<AbstractHash>(){
    @Override public int compare(    AbstractHash o1,    AbstractHash o2){
      return Comparing.compare(starred.get(o2),starred.get(o1));
    }
  }
);
  final boolean multipleRoots=rootsHolder.multipleRoots();
  final List<CommitI> filtered=new ArrayList<CommitI>();
  final List<AbstractHash> missing=new ArrayList<AbstractHash>();
  int cInHashes=0;
  final int count=myTableWrapper.myTableModel.getRowCount();
  for (int i=0; i < count && hash.size() > cInHashes; i++) {
    final CommitI at=myTableWrapper.myTableModel.getCommitAt(i);
    if (at.holdsDecoration())     continue;
    final AbstractHash obj=hash.get(cInHashes);
    if (at.getHash().equals(obj)) {
      final Commit commit=new Commit(at.getHash().getString(),at.getTime(),at.getAuthorIdx());
      if (multipleRoots) {
        filtered.add(new MultipleRepositoryCommitDecorator(commit,at.selectRepository(SelectorList.getInstance())));
      }
 else {
        filtered.add(commit);
      }
      ++cInHashes;
    }
 else     if (starred.get(obj) > at.getTime()) {
      missing.add(obj);
      ++cInHashes;
    }
  }
  for (; cInHashes < hash.size(); ++cInHashes) {
    missing.add(hash.get(cInHashes));
  }
  myTableWrapper.reset(false,true);
  myController.reset();
  myHaveRestrictingFilters=true;
  if (!filtered.isEmpty()) {
    myTableWrapper.appendResult(myTicket.copy(),filtered,Collections.<List<AbstractHash>>emptyList());
  }
  if (!missing.isEmpty()) {
    final GitLogFilters filters=new GitLogFilters(null,null,null,null,ObjectsConvertor.convert(missing,new Convertor<AbstractHash,String>(){
      @Override public String convert(      AbstractHash o){
        return o.getString();
      }
    }
));
    filters.setUseOnlyHashes(true);
    myLoader.loadSkeleton(myTicket.copy(),rootsHolder,Collections.<String>emptyList(),filters,myController,false);
  }
 else {
    myUIRefresh.finished();
    myTableWrapper.finished();
  }
}
