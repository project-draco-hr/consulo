{
  final CompileScope scope=compileContext.getCompileScope();
  final Collection<String> paths=CompileScopeUtil.fetchFiles(compileContext);
  List<TargetTypeBuildScope> scopes=new ArrayList<TargetTypeBuildScope>();
  final boolean forceBuild=!compileContext.isMake();
  if (!compileContext.isRebuild() && !CompileScopeUtil.allProjectModulesAffected(compileContext)) {
    CompileScopeUtil.addScopesForModules(Arrays.asList(scope.getAffectedModules()),scopes,forceBuild);
  }
 else {
    scopes.addAll(CmdlineProtoUtil.createAllModulesScopes(forceBuild));
  }
  if (paths.isEmpty()) {
    for (    BuildTargetScopeProvider provider : BuildTargetScopeProvider.EP_NAME.getExtensions()) {
      scopes=CompileScopeUtil.mergeScopes(scopes,provider.getBuildTargetScopes(scope,myCompilerFilter,myProject,forceBuild));
    }
  }
  final Map<String,String> builderParams;
  if (onlyCheckUpToDate) {
    builderParams=Collections.emptyMap();
  }
 else {
    final Map<Key,Object> exported=scope.exportUserData();
    if (!exported.isEmpty()) {
      builderParams=new HashMap<String,String>();
      for (      Map.Entry<Key,Object> entry : exported.entrySet()) {
        final String _key=entry.getKey().toString();
        final String _value=entry.getValue().toString();
        builderParams.put(_key,_value);
      }
    }
 else {
      builderParams=Collections.emptyMap();
    }
  }
  final MessageBus messageBus=myProject.getMessageBus();
  final MultiMap<String,Artifact> outputToArtifact=ArtifactCompilerUtil.containsArtifacts(scopes) ? ArtifactCompilerUtil.createOutputToArtifactMap(myProject) : null;
  final BuildManager buildManager=BuildManager.getInstance();
  buildManager.cancelAutoMakeTasks(myProject);
  return buildManager.scheduleBuild(myProject,compileContext.isRebuild(),compileContext.isMake(),onlyCheckUpToDate,scopes,paths,builderParams,new DefaultMessageHandler(myProject){
    @Override public void buildStarted(    UUID sessionId){
    }
    @Override public void sessionTerminated(    final UUID sessionId){
      if (compileContext.shouldUpdateProblemsView()) {
        final ProblemsView view=ProblemsViewImpl.SERVICE.getInstance(myProject);
        view.clearProgress();
        view.clearOldMessages(compileContext.getCompileScope(),compileContext.getSessionId());
      }
    }
    @Override public void handleFailure(    UUID sessionId,    CmdlineRemoteProto.Message.Failure failure){
      compileContext.addMessage(CompilerMessageCategory.ERROR,failure.hasDescription() ? failure.getDescription() : "",null,-1,-1);
      final String trace=failure.hasStacktrace() ? failure.getStacktrace() : null;
      if (trace != null) {
        LOG.info(trace);
      }
      compileContext.putUserData(COMPILE_SERVER_BUILD_STATUS,ExitStatus.ERRORS);
    }
    @Override protected void handleCompileMessage(    UUID sessionId,    CmdlineRemoteProto.Message.BuilderMessage.CompileMessage message){
      final CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind kind=message.getKind();
      final String messageText=message.getText();
      if (kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.PROGRESS) {
        final ProgressIndicator indicator=compileContext.getProgressIndicator();
        indicator.setText(messageText);
        if (message.hasDone()) {
          indicator.setFraction(message.getDone());
        }
      }
 else {
        final CompilerMessageCategory category=kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.ERROR ? CompilerMessageCategory.ERROR : kind == CmdlineRemoteProto.Message.BuilderMessage.CompileMessage.Kind.WARNING ? CompilerMessageCategory.WARNING : CompilerMessageCategory.INFORMATION;
        String sourceFilePath=message.hasSourceFilePath() ? message.getSourceFilePath() : null;
        if (sourceFilePath != null) {
          sourceFilePath=FileUtil.toSystemIndependentName(sourceFilePath);
        }
        final long line=message.hasLine() ? message.getLine() : -1;
        final long column=message.hasColumn() ? message.getColumn() : -1;
        final String srcUrl=sourceFilePath != null ? VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL,sourceFilePath) : null;
        compileContext.addMessage(category,messageText,srcUrl,(int)line,(int)column);
      }
    }
    @Override protected void handleBuildEvent(    UUID sessionId,    CmdlineRemoteProto.Message.BuilderMessage.BuildEvent event){
      final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Type eventType=event.getEventType();
switch (eventType) {
case FILES_GENERATED:
        final List<CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.GeneratedFile> generated=event.getGeneratedFilesList();
      final CompilationStatusListener publisher=messageBus.syncPublisher(CompilerTopics.COMPILATION_STATUS);
    Set<String> writtenArtifactOutputPaths=outputToArtifact != null ? new THashSet<String>(FileUtil.PATH_HASHING_STRATEGY) : null;
  for (  CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.GeneratedFile generatedFile : generated) {
    final String root=FileUtil.toSystemIndependentName(generatedFile.getOutputRoot());
    final String relativePath=FileUtil.toSystemIndependentName(generatedFile.getRelativePath());
    publisher.fileGenerated(root,relativePath);
    if (outputToArtifact != null) {
      Collection<Artifact> artifacts=outputToArtifact.get(root);
      if (!artifacts.isEmpty()) {
        for (        Artifact artifact : artifacts) {
          ArtifactsCompiler.addChangedArtifact(compileContext,artifact);
        }
        writtenArtifactOutputPaths.add(FileUtil.toSystemDependentName(DeploymentUtil.appendToPath(root,relativePath)));
      }
    }
  }
if (writtenArtifactOutputPaths != null && !writtenArtifactOutputPaths.isEmpty()) {
  ArtifactsCompiler.addWrittenPaths(compileContext,writtenArtifactOutputPaths);
}
break;
case BUILD_COMPLETED:
ExitStatus status=ExitStatus.SUCCESS;
if (event.hasCompletionStatus()) {
final CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.Status completionStatus=event.getCompletionStatus();
switch (completionStatus) {
case CANCELED:
status=ExitStatus.CANCELLED;
break;
case ERRORS:
status=ExitStatus.ERRORS;
break;
case SUCCESS:
status=ExitStatus.SUCCESS;
break;
case UP_TO_DATE:
status=ExitStatus.UP_TO_DATE;
break;
}
}
compileContext.putUserDataIfAbsent(COMPILE_SERVER_BUILD_STATUS,status);
break;
case CUSTOM_BUILDER_MESSAGE:
if (event.hasCustomBuilderMessage()) {
CmdlineRemoteProto.Message.BuilderMessage.BuildEvent.CustomBuilderMessage message=event.getCustomBuilderMessage();
messageBus.syncPublisher(CustomBuilderMessageHandler.TOPIC).messageReceived(message.getBuilderId(),message.getMessageType(),message.getMessageText());
}
break;
}
}
}
);
}
