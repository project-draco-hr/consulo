{
  final HashMap<PsiMethod,HashSet<PsiMethod>> constructorsToSubConstructors=new HashMap<PsiMethod,HashSet<PsiMethod>>();
  for (  PsiMethod constructor : constructors) {
    final HashSet<PsiMethod> referencingSubConstructors=new HashSet<PsiMethod>();
    constructorsToSubConstructors.put(constructor,referencingSubConstructors);
    if (constructor != null) {
      final PsiReference[] references=myManager.getSearchHelper().findReferences(constructor,new LocalSearchScope(mySourceClass),false);
      for (      PsiReference reference : references) {
        final PsiElement element=reference.getElement();
        if (element != null && "super".equals(element.getText())) {
          PsiMethod parentMethod=PsiTreeUtil.getParentOfType(element,PsiMethod.class);
          if (parentMethod != null && parentMethod.isConstructor()) {
            referencingSubConstructors.add(parentMethod);
          }
        }
      }
    }
    if (constructor == null || constructor.getParameterList().getParametersCount() == 0) {
      RefactoringUtil.visitImplicitSuperConstructorUsages(mySourceClass,new RefactoringUtil.ImplicitConstructorUsageVisitor(){
        public void visitConstructor(        PsiMethod constructor,        PsiMethod baseConstructor){
          referencingSubConstructors.add(constructor);
        }
        public void visitClassWithoutConstructors(        PsiClass aClass){
        }
      }
,myTargetSuperClass);
    }
  }
  return constructorsToSubConstructors;
}
