{
  if (things.isEmpty()) {
    return true;
  }
  if (things.size() == 1) {
    T t=things.get(0);
    return thingProcessor.process(t);
  }
  final Job<String> job=new JobImpl<String>(Job.DEFAULT_PRIORITY,failFastOnAcquireReadAction);
  final int chunkSize=Math.max(1,things.size() / JobSchedulerImpl.CORES_COUNT / 100);
  for (int i=0; i < things.size(); i+=chunkSize) {
    final int finalI=i;
    job.addTask(new Runnable(){
      public void run(){
        try {
          for (int k=finalI; k < finalI + chunkSize && k < things.size(); k++) {
            T thing=things.get(k);
            if (!thingProcessor.process(thing)) {
              job.cancel();
              break;
            }
          }
        }
 catch (        ProcessCanceledException e) {
          job.cancel();
          throw e;
        }
      }
    }
);
  }
  try {
    job.scheduleAndWaitForResults();
  }
 catch (  RuntimeException e) {
    job.cancel();
    throw e;
  }
catch (  Throwable throwable) {
    job.cancel();
    LOG.error(throwable);
  }
  return !job.isCanceled();
}
