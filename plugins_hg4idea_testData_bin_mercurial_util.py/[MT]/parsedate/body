def parsedate(date, formats=None, defaults=None):
    'parse a localized date/time string and return a (unixtime, offset) tuple.\n\n    The date may be a "unixtime offset" string or in one of the specified\n    formats. If the date already is a (unixtime, offset) tuple, it is returned.\n    '
    if (not date):
        return (0, 0)
    if (isinstance(date, tuple) and (len(date) == 2)):
        return date
    if (not formats):
        formats = defaultdateformats
    date = date.strip()
    try:
        (when, offset) = map(int, date.split(' '))
    except ValueError:
        if (not defaults):
            defaults = {}
        now = makedate()
        for part in 'd mb yY HI M S'.split():
            if (part not in defaults):
                if (part[0] in 'HMS'):
                    defaults[part] = '00'
                else:
                    defaults[part] = datestr(now, ('%' + part[0]))
        for format in formats:
            try:
                (when, offset) = strdate(date, format, defaults)
            except (ValueError, OverflowError):
                pass
            else:
                break
        else:
            raise Abort((_('invalid date: %r ') % date))
    if (abs(when) > 2147483647):
        raise Abort((_('date exceeds 32 bits: %d') % when))
    if ((offset < (-50400)) or (offset > 43200)):
        raise Abort((_('impossible time zone offset: %d') % offset))
    return (when, offset)
