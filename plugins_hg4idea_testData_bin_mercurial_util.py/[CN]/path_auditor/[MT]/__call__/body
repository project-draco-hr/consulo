def __call__(self, path):
    if (path in self.audited):
        return
    normpath = os.path.normcase(path)
    parts = splitpath(normpath)
    if (os.path.splitdrive(path)[0] or (parts[0].lower() in ('.hg', '.hg.', '')) or (os.pardir in parts)):
        raise Abort((_('path contains illegal component: %s') % path))
    if ('.hg' in path.lower()):
        lparts = [p.lower() for p in parts]
        for p in ('.hg', '.hg.'):
            if (p in lparts[1:]):
                pos = lparts.index(p)
                base = os.path.join(*parts[:pos])
                raise Abort((_('path %r is inside repo %r') % (path, base)))

    def check(prefix):
        curpath = os.path.join(self.root, prefix)
        try:
            st = os.lstat(curpath)
        except OSError as err:
            if (err.errno not in (errno.ENOENT, errno.ENOTDIR, errno.EINVAL)):
                raise
        else:
            if stat.S_ISLNK(st.st_mode):
                raise Abort((_('path %r traverses symbolic link %r') % (path, prefix)))
            elif (stat.S_ISDIR(st.st_mode) and os.path.isdir(os.path.join(curpath, '.hg'))):
                raise Abort((_('path %r is inside repo %r') % (path, prefix)))
    parts.pop()
    prefixes = []
    while parts:
        prefix = os.sep.join(parts)
        if (prefix in self.auditeddir):
            break
        check(prefix)
        prefixes.append(prefix)
        parts.pop()
    self.audited.add(path)
    self.auditeddir.update(prefixes)
