{
  final PsiClassType superType=getSuperType(myClass);
  LOG.assertTrue(superType != null);
  List<PsiElement> elementsToDelete=new ArrayList<PsiElement>();
  List<PsiNewExpression> newExpressions=new ArrayList<PsiNewExpression>();
  for (  UsageInfo info : usages) {
    final PsiElement element=info.getElement();
    if (element instanceof PsiNewExpression) {
      newExpressions.add((PsiNewExpression)element);
    }
 else     if (element.getParent() instanceof PsiNewExpression) {
      newExpressions.add((PsiNewExpression)element.getParent());
    }
 else {
      PsiImportStatement statement=PsiTreeUtil.getParentOfType(element,PsiImportStatement.class);
      if (statement != null && !myInlineThisOnly) {
        elementsToDelete.add(statement);
      }
 else {
        PsiTypeElement typeElement=PsiTreeUtil.getParentOfType(element,PsiTypeElement.class);
        if (typeElement != null) {
          replaceWithSuperType(typeElement,superType);
        }
      }
    }
  }
  Collections.sort(newExpressions,PsiUtil.BY_POSITION);
  for (  PsiNewExpression newExpression : newExpressions) {
    replaceNewOrType(newExpression,superType);
  }
  for (  PsiElement element : elementsToDelete) {
    try {
      if (element.isValid()) {
        element.delete();
      }
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
  }
  if (!myInlineThisOnly) {
    try {
      myClass.delete();
    }
 catch (    IncorrectOperationException e) {
      LOG.error(e);
    }
  }
}
