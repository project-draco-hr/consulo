def dorecord(ui, repo, commitfunc, *pats, **opts):
    if (not ui.interactive()):
        raise util.Abort(_('running non-interactively, use commit instead'))

    def recordfunc(ui, repo, message, match, opts):
        "This is generic record driver.\n\n        Its job is to interactively filter local changes, and accordingly\n        prepare working dir into a state, where the job can be delegated to\n        non-interactive commit command such as 'commit' or 'qrefresh'.\n\n        After the actual job is done by non-interactive command, working dir\n        state is restored to original.\n\n        In the end we'll record intresting changes, and everything else will be\n        left in place, so the user can continue his work.\n        "
        changes = repo.status(match=match)[:3]
        diffopts = mdiff.diffopts(git=True, nodates=True)
        chunks = patch.diff(repo, changes=changes, opts=diffopts)
        fp = cStringIO.StringIO()
        fp.write(''.join(chunks))
        fp.seek(0)
        chunks = filterpatch(ui, parsepatch(fp))
        del fp
        contenders = set()
        for h in chunks:
            try:
                contenders.update(set(h.files()))
            except AttributeError:
                pass
        changed = ((changes[0] + changes[1]) + changes[2])
        newfiles = [f for f in changed if (f in contenders)]
        if (not newfiles):
            ui.status(_('no changes to record\n'))
            return 0
        modified = set(changes[0])
        backups = {}
        backupdir = repo.join('record-backups')
        try:
            os.mkdir(backupdir)
        except OSError as err:
            if (err.errno != errno.EEXIST):
                raise
        try:
            for f in newfiles:
                if (f not in modified):
                    continue
                (fd, tmpname) = tempfile.mkstemp(prefix=(f.replace('/', '_') + '.'), dir=backupdir)
                os.close(fd)
                ui.debug(('backup %r as %r\n' % (f, tmpname)))
                util.copyfile(repo.wjoin(f), tmpname)
                backups[f] = tmpname
            fp = cStringIO.StringIO()
            for c in chunks:
                if (c.filename() in backups):
                    c.write(fp)
            dopatch = fp.tell()
            fp.seek(0)
            if backups:
                hg.revert(repo, repo.dirstate.parents()[0], backups.has_key)
            if dopatch:
                try:
                    ui.debug('applying patch\n')
                    ui.debug(fp.getvalue())
                    pfiles = {}
                    patch.internalpatch(fp, ui, 1, repo.root, files=pfiles, eolmode=None)
                    patch.updatedir(ui, repo, pfiles)
                except patch.PatchError as err:
                    s = str(err)
                    if s:
                        raise util.Abort(s)
                    else:
                        raise util.Abort(_('patch failed to apply'))
            del fp
            cwd = os.getcwd()
            os.chdir(repo.root)
            try:
                commitfunc(ui, repo, *newfiles, **opts)
            finally:
                os.chdir(cwd)
            return 0
        finally:
            try:
                for (realname, tmpname) in backups.iteritems():
                    ui.debug(('restoring %r to %r\n' % (tmpname, realname)))
                    util.copyfile(tmpname, repo.wjoin(realname))
                    os.unlink(tmpname)
                os.rmdir(backupdir)
            except OSError:
                pass
    return cmdutil.commit(ui, repo, recordfunc, pats, opts)
