def filterpatch(ui, chunks):
    'Interactively filter patch chunks into applied-only chunks'
    chunks = list(chunks)
    chunks.reverse()
    seen = set()

    def consumefile():
        "fetch next portion from chunks until a 'header' is seen\n        NB: header == new-file mark\n        "
        consumed = []
        while chunks:
            if isinstance(chunks[(-1)], header):
                break
            else:
                consumed.append(chunks.pop())
        return consumed
    resp_all = [None]
    resp_file = [None]
    applied = {}

    def prompt(query):
        'prompt query, and process base inputs\n\n        - y/n for the rest of file\n        - y/n for the rest\n        - ? (help)\n        - q (quit)\n\n        Returns True/False and sets reps_all and resp_file as\n        appropriate.\n        '
        if (resp_all[0] is not None):
            return resp_all[0]
        if (resp_file[0] is not None):
            return resp_file[0]
        while True:
            resps = _('[Ynsfdaq?]')
            choices = (_('&Yes, record this change'), _('&No, skip this change'), _('&Skip remaining changes to this file'), _('Record remaining changes to this &file'), _('&Done, skip remaining changes and files'), _('Record &all changes to all remaining files'), _('&Quit, recording no changes'), _('&?'))
            r = ui.promptchoice(('%s %s' % (query, resps)), choices)
            if (r == 7):
                doc = gettext(record.__doc__)
                c = doc.find(_('y - record this change'))
                for l in doc[c:].splitlines():
                    if l:
                        ui.write(l.strip(), '\n')
                continue
            elif (r == 0):
                ret = True
            elif (r == 1):
                ret = False
            elif (r == 2):
                ret = resp_file[0] = False
            elif (r == 3):
                ret = resp_file[0] = True
            elif (r == 4):
                ret = resp_all[0] = False
            elif (r == 5):
                ret = resp_all[0] = True
            elif (r == 6):
                raise util.Abort(_('user quit'))
            return ret
    (pos, total) = (0, (len(chunks) - 1))
    while chunks:
        pos = ((total - len(chunks)) + 1)
        chunk = chunks.pop()
        if isinstance(chunk, header):
            resp_file = [None]
            fixoffset = 0
            hdr = ''.join(chunk.header)
            if (hdr in seen):
                consumefile()
                continue
            seen.add(hdr)
            if (resp_all[0] is None):
                chunk.pretty(ui)
            r = prompt((_('examine changes to %s?') % _(' and ').join(map(repr, chunk.files()))))
            if r:
                applied[chunk.filename()] = [chunk]
                if chunk.allhunks():
                    applied[chunk.filename()] += consumefile()
            else:
                consumefile()
        else:
            if ((resp_file[0] is None) and (resp_all[0] is None)):
                chunk.pretty(ui)
            r = (((total == 1) and prompt((_('record this change to %r?') % chunk.filename()))) or prompt((_('record change %d/%d to %r?') % (pos, total, chunk.filename()))))
            if r:
                if fixoffset:
                    chunk = copy.copy(chunk)
                    chunk.toline += fixoffset
                applied[chunk.filename()].append(chunk)
            else:
                fixoffset += (chunk.removed - chunk.added)
    return reduce(operator.add, [h for h in applied.itervalues() if (h[0].special() or (len(h) > 1))], [])
