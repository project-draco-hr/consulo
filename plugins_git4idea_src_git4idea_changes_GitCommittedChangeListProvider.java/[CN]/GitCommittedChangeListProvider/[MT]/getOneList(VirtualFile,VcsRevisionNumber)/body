{
  final FilePathImpl filePath=new FilePathImpl(file);
  final List<GitCommit> gitCommits=GitHistoryUtils.commitsDetails(myProject,filePath,new SymbolicRefs(),Collections.singletonList(number.asString()));
  if (gitCommits == null || gitCommits.size() != 1)   return null;
  final GitCommit gitCommit=gitCommits.get(0);
  final CommittedChangeList commit=new CommittedChangeListImpl(gitCommit.getDescription() + " (" + gitCommit.getShortHash().getString()+ ")",gitCommit.getDescription(),gitCommit.getCommitter(),GitChangeUtils.longForSHAHash(gitCommit.getHash().getValue()),gitCommit.getDate(),gitCommit.getChanges());
  final Collection<Change> changes=commit.getChanges();
  if (changes.size() == 1) {
    return new Pair<CommittedChangeList,FilePath>(commit,changes.iterator().next().getAfterRevision().getFile());
  }
  for (  Change change : changes) {
    if (change.getAfterRevision() != null && filePath.getIOFile().equals(change.getAfterRevision().getFile().getIOFile())) {
      return new Pair<CommittedChangeList,FilePath>(commit,filePath);
    }
  }
  final String afterTime="--after=" + GitUtil.gitTime(gitCommit.getDate());
  final List<VcsFileRevision> history=GitHistoryUtils.history(myProject,filePath,null,afterTime);
  if (history.isEmpty()) {
    return new Pair<CommittedChangeList,FilePath>(commit,filePath);
  }
  return new Pair<CommittedChangeList,FilePath>(commit,((GitFileRevision)history.get(history.size() - 1)).getPath());
}
