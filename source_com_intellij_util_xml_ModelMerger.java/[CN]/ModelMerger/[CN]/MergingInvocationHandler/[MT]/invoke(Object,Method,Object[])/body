{
  if (Object.class.equals(method.getDeclaringClass())) {
    @NonNls String methodName=method.getName();
    if ("toString".equals(methodName)) {
      return "Merger: " + Arrays.asList(myImplementations);
    }
    if ("hashCode".equals(methodName)) {
      return System.identityHashCode(proxy);
    }
    if ("equals".equals(methodName)) {
      return proxy == args[0];
    }
    return null;
  }
  if (MergedObject.class.equals(method.getDeclaringClass())) {
    return findImplementation((Class<Object>)args[0]);
  }
  final Class returnType=method.getReturnType();
  if (Collection.class.isAssignableFrom(returnType)) {
    return getMergedImplementations(method,args,DomUtil.getRawType(DomUtil.extractCollectionElementType(method.getGenericReturnType())));
  }
  if (GenericValue.class.isAssignableFrom(returnType)) {
    return new MergedGenericValue(method,args);
  }
  if (void.class == returnType) {
    for (    final T t : myImplementations) {
      method.invoke(t,args);
    }
    return null;
  }
  List<Object> results=getMergedImplementations(method,args,method.getReturnType());
  return results.isEmpty() ? null : results.get(0);
}
