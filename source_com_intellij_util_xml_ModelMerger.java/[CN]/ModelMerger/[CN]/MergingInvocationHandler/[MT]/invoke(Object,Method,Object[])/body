{
  if (Object.class.equals(method.getDeclaringClass())) {
    @NonNls String methodName=method.getName();
    if ("toString".equals(methodName)) {
      return "Merger: " + Arrays.asList(myImplementations);
    }
    if ("hashCode".equals(methodName)) {
      return System.identityHashCode(proxy);
    }
    if ("equals".equals(methodName)) {
      return proxy == args[0];
    }
    return null;
  }
  final Class returnType=method.getReturnType();
  if (Collection.class.isAssignableFrom(returnType)) {
    return getMergedImplementations(method,args,DomUtil.getRawType(DomUtil.extractCollectionElementType(method.getGenericReturnType())));
  }
  if (GenericValue.class.isAssignableFrom(returnType)) {
    return new ReadOnlyGenericValue(){
      private GenericValue findGenericValue(){
        for (        final T t : myImplementations) {
          try {
            GenericValue genericValue=(GenericValue)method.invoke(t,args);
            if (genericValue != null) {
              final Object value=genericValue.getValue();
              if (value != null) {
                return genericValue;
              }
            }
          }
 catch (          IllegalAccessException e) {
            LOG.error(e);
          }
catch (          InvocationTargetException e) {
            LOG.error(e);
          }
        }
        return null;
      }
      public Object getValue(){
        final GenericValue genericValue=findGenericValue();
        return genericValue != null ? genericValue.getValue() : null;
      }
      public String getStringValue(){
        final GenericValue genericValue=findGenericValue();
        return genericValue != null ? genericValue.getStringValue() : super.getStringValue();
      }
    }
;
  }
  if (void.class == returnType) {
    for (    final T t : myImplementations) {
      method.invoke(t,args);
    }
    return null;
  }
  List<Object> results=getMergedImplementations(method,args,method.getReturnType());
  return results.isEmpty() ? null : results.get(0);
}
