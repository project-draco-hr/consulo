{
  if (myDialog.getFieldsVisibility() != null) {
    for (int i=0; i < myFields.length; i++) {
      setNewFieldVisibility(myFields[i]);
    }
  }
  myNameToGetter=new com.intellij.util.containers.HashMap<String,PsiMethod>();
  myNameToSetter=new com.intellij.util.containers.HashMap<String,PsiMethod>();
  for (int i=0; i < myFields.length; i++) {
    PsiField field=myFields[i];
    if (myDialog.isToEncapsulateGet()) {
      PsiMethod[] prototypes=myDialog.getGetterPrototypes();
      addOrChangeAccessor(prototypes[i],myNameToGetter);
    }
    if (myDialog.isToEncapsulateSet() && !field.hasModifierProperty(PsiModifier.FINAL)) {
      PsiMethod[] prototypes=myDialog.getSetterPrototypes();
      addOrChangeAccessor(prototypes[i],myNameToSetter);
    }
  }
  HashSet<PsiElement> allFiles=new HashSet<PsiElement>();
  HashMap<PsiElement,MyUsageInfo> treeSkeletonMap=new com.intellij.util.containers.HashMap<PsiElement,MyUsageInfo>();
  for (int i=0; i < usages.length; i++) {
    MyUsageInfo usage=(MyUsageInfo)usages[i];
    if (!usage.getElement().isValid())     continue;
    PsiElement element=usage.getElement();
    treeSkeletonMap.put(element,usage);
    while (!(element instanceof PsiFile)) {
      element=element.getParent();
      if (!treeSkeletonMap.containsKey(element)) {
        treeSkeletonMap.put(element,null);
      }
    }
    allFiles.add(element);
  }
  for (Iterator<PsiElement> iterator=allFiles.iterator(); iterator.hasNext(); ) {
    PsiFile file=(PsiFile)iterator.next();
    processSubtree(file,treeSkeletonMap);
  }
}
