{
  final Set<Key> allKeys=new HashSet<Key>(oldData.size() + newData.size());
  allKeys.addAll(oldData.keySet());
  allKeys.addAll(newData.keySet());
  if (allKeys.size() > 0) {
    final Lock writeLock=getWriteLock();
    for (    Key key : allKeys) {
      writeLock.lock();
      try {
        if (oldData.containsKey(key)) {
          final Value oldValue=oldData.get(key);
          if (CachesBasedRefSearcher.DEBUG && !Comparing.equal(oldValue,newData.get(key))) {
            System.out.println("MapReduceIndex.updateWithMap: inputId=" + inputId + "; REMOVE key='"+ key+ "'; value="+ oldValue);
          }
          myStorage.removeValue(key,inputId,oldValue);
        }
        if (newData.containsKey(key)) {
          final Value newValue=newData.get(key);
          if (CachesBasedRefSearcher.DEBUG && !Comparing.equal(oldData.get(key),newValue)) {
            System.out.println("MapReduceIndex.updateWithMap: inputId=" + inputId + "; ADD key='"+ key+ "'; value="+ newValue);
          }
          myStorage.addValue(key,inputId,newValue);
        }
        if (CachesBasedRefSearcher.DEBUG) {
          System.out.println("MapReduceIndex.updateWithMap");
          System.out.println("inputId = " + inputId);
          final ValueContainer<Value> container=myStorage.read(key);
          container.forEach(new ValueContainer.ContainerAction<Value>(){
            public void perform(            final int id,            final Value value){
              System.out.println("id = " + id + "; value = "+ value);
            }
          }
);
        }
      }
  finally {
        writeLock.unlock();
      }
    }
    scheduleFlush();
  }
}
