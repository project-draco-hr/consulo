{
  LOG.assertTrue(!PsiDocumentManager.getInstance(project).hasUncommitedDocuments());
  PsiMethod method;
  if (expr != null) {
    method=Util.getContainingMethod(expr);
  }
 else {
    method=Util.getContainingMethod(localVar);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + expr);
  }
  if (expr == null && localVar == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.block.should.represent.an.expression"));
    showErrorMessage(project,message,editor);
    return false;
  }
  if (localVar != null) {
    final PsiElement parent=localVar.getParent();
    if (!(parent instanceof PsiDeclarationStatement)) {
      String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("error.wrong.caret.position.local.or.expression.name"));
      showErrorMessage(project,message,editor);
      return false;
    }
  }
  if (method == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("is.not.supported.in.the.current.context",REFACTORING_NAME));
    showErrorMessage(project,message,editor);
    return false;
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,method))   return false;
  final PsiType typeByExpression=invokedOnDeclaration ? null : RefactoringUtil.getTypeByExpressionWithExpectedType(expr);
  if (!invokedOnDeclaration && typeByExpression == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("type.of.the.selected.expression.cannot.be.determined"));
    showErrorMessage(project,message,editor);
    return false;
  }
  if (!invokedOnDeclaration && PsiType.VOID.equals(typeByExpression)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    showErrorMessage(project,message,editor);
    return false;
  }
  final List<PsiMethod> validEnclosingMethods=getEnclosingMethods(method);
  if (validEnclosingMethods.isEmpty()) {
    return false;
  }
  final Introducer introducer=new Introducer(project,expr,localVar,editor);
  final boolean unitTestMode=ApplicationManager.getApplication().isUnitTestMode();
  if (validEnclosingMethods.size() == 1 || unitTestMode) {
    final PsiMethod methodToIntroduceParameterTo=validEnclosingMethods.get(0);
    if (methodToIntroduceParameterTo.findDeepestSuperMethod() == null || unitTestMode) {
      introducer.introduceParameter(methodToIntroduceParameterTo,methodToIntroduceParameterTo);
      return true;
    }
  }
  chooseMethodToIntroduceParameter(editor,validEnclosingMethods,introducer);
  return true;
}
