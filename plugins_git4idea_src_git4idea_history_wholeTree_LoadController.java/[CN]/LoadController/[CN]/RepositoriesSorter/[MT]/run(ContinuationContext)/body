{
  final Map<VirtualFile,SymbolicRefs> map=new HashMap<VirtualFile,SymbolicRefs>();
  for (  ByRootLoader shortLoader : myShortLoaders) {
    final VirtualFile root=shortLoader.getRootHolder().getRoot();
    final SymbolicRefs refs=shortLoader.initSymbRefs();
    map.put(root,refs);
    try {
      final GitRepository repositoryForRoot=GitRepositoryManager.getInstance(myProject).getRepositoryForRoot(root);
      if (repositoryForRoot == null)       continue;
      final String currentRevisionName=repositoryForRoot.getCurrentRevision();
      final Pair<String,Long> pair=mySortOrder.get(root);
      if (pair != null && pair.getFirst() != null && pair.getFirst().equals(currentRevisionName)) {
        continue;
      }
      final VcsRevisionNumber currentRevision=GitHistoryUtils.getCurrentRevision(myProject,new FilePathImpl(root),null);
      if (currentRevision != null) {
        mySortOrder.put(root,new Pair<String,Long>(currentRevisionName,((GitRevisionNumber)currentRevision).getTimestamp().getTime()));
        continue;
      }
      mySortOrder.put(root,new Pair<String,Long>(currentRevisionName,Long.MAX_VALUE));
    }
 catch (    VcsException e) {
      LOG.info(e);
    }
  }
  for (  LoaderAndRefresher<CommitHashPlusParents> simpleLoader : mySimpleLoaders) {
    simpleLoader.setSymbolicRefs(map.get(simpleLoader.getRoot()));
  }
  Collections.sort(myShortLoaders,new Comparator<ByRootLoader>(){
    @Override public int compare(    ByRootLoader rl1,    ByRootLoader rl2){
      final Pair<String,Long> pair1=mySortOrder.get(rl1.getRootHolder().getRoot());
      final Pair<String,Long> pair2=mySortOrder.get(rl2.getRootHolder().getRoot());
      final Long l1=pair1 == null ? null : pair1.getSecond();
      final Long l2=pair2 == null ? null : pair2.getSecond();
      return Comparing.compare(l2,l1);
    }
  }
);
  Collections.sort(mySimpleLoaders,new Comparator<LoaderAndRefresher<CommitHashPlusParents>>(){
    @Override public int compare(    LoaderAndRefresher<CommitHashPlusParents> lr1,    LoaderAndRefresher<CommitHashPlusParents> lr2){
      final Pair<String,Long> pair1=mySortOrder.get(lr1.getRoot());
      final Pair<String,Long> pair2=mySortOrder.get(lr2.getRoot());
      final Long l1=pair1 == null ? null : pair1.getSecond();
      final Long l2=pair2 == null ? null : pair2.getSecond();
      return Comparing.compare(l2,l1);
    }
  }
);
  myPreviousAlgorithm=new LoadAlgorithm(myProject,mySimpleLoaders,myShortLoaders,myContinuation,myGitCommitsSequentially);
  myPreviousAlgorithm.fillContinuation();
}
