{
  if (myPreviousAlgorithm != null) {
    myPreviousAlgorithm.stop();
  }
  final List<LoaderAndRefresher<CommitHashPlusParents>> list=new ArrayList<LoaderAndRefresher<CommitHashPlusParents>>();
  final List<ByRootLoader> shortLoaders=new ArrayList<ByRootLoader>();
  final List<VirtualFile> roots=rootsHolder.getRoots();
  int i=0;
  for (  VirtualFile root : roots) {
    final LoaderAndRefresherImpl.MyRootHolder rootHolder=roots.size() == 1 ? new LoaderAndRefresherImpl.OneRootHolder(root) : new LoaderAndRefresherImpl.ManyCaseHolder(i,rootsHolder);
    filters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
      @Override public void consume(      final List<ChangesFilter.Filter> filters){
        final LoaderAndRefresherImpl loaderAndRefresher=new LoaderAndRefresherImpl(ticket,filters,myMediator,startingPoints,myDetailsCache,myProject,rootHolder,myUsersIndex,loadGrowthController.getId());
        list.add(loaderAndRefresher);
      }
    }
,true);
    shortLoaders.add(new ByRootLoader(myProject,rootHolder,myMediator,myDetailsCache,ticket,myUsersIndex,filters,startingPoints));
    ++i;
  }
  myUsersComponent.acceptUpdate(myUsersIndex.getKeys());
  if (myPreviousAlgorithm != null) {
    final Continuation oldContinuation=myPreviousAlgorithm.getContinuation();
    oldContinuation.cancelCurrent();
    oldContinuation.clearQueue();
  }
  final Continuation continuation=Continuation.createFragmented(myProject,true);
  myPreviousAlgorithm=new LoadAlgorithm(myProject,list,shortLoaders,continuation);
  myPreviousAlgorithm.fillContinuation();
  continuation.resume();
}
