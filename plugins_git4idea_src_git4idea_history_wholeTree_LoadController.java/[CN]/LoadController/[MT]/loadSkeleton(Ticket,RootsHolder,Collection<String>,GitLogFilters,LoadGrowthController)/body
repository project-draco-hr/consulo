{
  if (myPreviousAlgorithm != null) {
    myPreviousAlgorithm.stop();
  }
  final List<LoaderAndRefresher<CommitHashPlusParents>> list=new ArrayList<LoaderAndRefresher<CommitHashPlusParents>>();
  final List<ByRootLoader> shortLoaders=new ArrayList<ByRootLoader>();
  final List<VirtualFile> roots=rootsHolder.getRoots();
  int i=0;
  final boolean topoOrder=filters.isEmpty() ? GitLogSettings.getInstance(myProject).isTopoOrder() : false;
  for (  VirtualFile root : roots) {
    final LoaderAndRefresherImpl.MyRootHolder rootHolder=roots.size() == 1 ? new LoaderAndRefresherImpl.OneRootHolder(root) : new LoaderAndRefresherImpl.ManyCaseHolder(i,rootsHolder);
    final boolean haveStructureFilter=filters.haveStructureFilter();
    if (haveStructureFilter && !filters.haveStructuresForRoot(root)) {
      ++i;
      continue;
    }
    filters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
      @Override public void consume(      final List<ChangesFilter.Filter> filters){
        final LoaderAndRefresherImpl loaderAndRefresher=new LoaderAndRefresherImpl(ticket,filters,myMediator,startingPoints,myDetailsCache,myProject,rootHolder,myUsersIndex,loadGrowthController.getId(),haveStructureFilter,topoOrder);
        list.add(loaderAndRefresher);
      }
    }
,true,root);
    shortLoaders.add(new ByRootLoader(myProject,rootHolder,myMediator,myDetailsCache,ticket,myUsersIndex,filters,startingPoints));
    ++i;
  }
  myUsersComponent.acceptUpdate(myUsersIndex.getKeys());
  if (myPreviousAlgorithm != null) {
    final Continuation oldContinuation=myPreviousAlgorithm.getContinuation();
    oldContinuation.cancelCurrent();
    oldContinuation.clearQueue();
  }
  final Continuation continuation=Continuation.createFragmented(myProject,true);
  continuation.add(Arrays.<TaskDescriptor>asList(new RepositoriesSorter(list,shortLoaders,continuation)));
  continuation.resume();
}
