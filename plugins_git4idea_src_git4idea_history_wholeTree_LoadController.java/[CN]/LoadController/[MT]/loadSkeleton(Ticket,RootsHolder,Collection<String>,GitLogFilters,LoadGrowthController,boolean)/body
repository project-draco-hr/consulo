{
  if (myPreviousAlgorithm != null) {
    myPreviousAlgorithm.stop();
  }
  final List<LoaderAndRefresher<CommitHashPlusParents>> list=new ArrayList<LoaderAndRefresher<CommitHashPlusParents>>();
  final List<ByRootLoader> shortLoaders=new ArrayList<ByRootLoader>();
  final List<VirtualFile> roots=rootsHolder.getRoots();
  int i=0;
  for (  VirtualFile root : roots) {
    final LoaderAndRefresherImpl.MyRootHolder rootHolder=roots.size() == 1 ? new LoaderAndRefresherImpl.OneRootHolder(root) : new LoaderAndRefresherImpl.ManyCaseHolder(i,rootsHolder);
    if (!gitLogFilters.isUseOnlyHashes()) {
      final boolean haveStructureFilter=gitLogFilters.haveStructureFilter();
      if (haveStructureFilter && !gitLogFilters.haveStructuresForRoot(root)) {
        ++i;
        continue;
      }
      gitLogFilters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
        @Override public void consume(        final List<ChangesFilter.Filter> filters){
          final LoaderAndRefresherImpl loaderAndRefresher=new LoaderAndRefresherImpl(ticket,filters,myMediator,startingPoints,myDetailsCache,myProject,rootHolder,myUsersIndex,loadGrowthController.getId(),haveStructureFilter,topoOrder,gitLogFilters.haveDisordering());
          list.add(loaderAndRefresher);
        }
      }
,true,root);
    }
    shortLoaders.add(new ByRootLoader(myProject,rootHolder,myMediator,myDetailsCache,ticket,myUsersIndex,gitLogFilters,startingPoints));
    ++i;
  }
  myUsersComponent.acceptUpdate(myUsersIndex.getKeys());
  if (myPreviousAlgorithm != null) {
    final Continuation oldContinuation=myPreviousAlgorithm.getContinuation();
    oldContinuation.cancelCurrent();
    oldContinuation.clearQueue();
  }
  final RepositoriesSorter sorter=new RepositoriesSorter(list,shortLoaders);
  final Runnable runnable=new Runnable(){
    @Override public void run(){
      final Continuation continuation=Continuation.createForCurrentProgress(myProject,true,"Load git log data");
      sorter.setContinuation(continuation);
      continuation.add(Arrays.<TaskDescriptor>asList(sorter));
      continuation.resume();
    }
  }
;
  loadUnderProgress(runnable);
}
