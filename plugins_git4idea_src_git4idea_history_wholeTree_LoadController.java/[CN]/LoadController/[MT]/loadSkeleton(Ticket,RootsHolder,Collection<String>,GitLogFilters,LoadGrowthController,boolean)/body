{
  if (myPreviousAlgorithm != null) {
    myPreviousAlgorithm.stop();
  }
  final List<LoaderAndRefresher<CommitHashPlusParents>> list=new ArrayList<LoaderAndRefresher<CommitHashPlusParents>>();
  final List<ByRootLoader> shortLoaders=new ArrayList<ByRootLoader>();
  final List<VirtualFile> roots=rootsHolder.getRoots();
  int i=0;
  for (  VirtualFile root : roots) {
    final LoaderAndRefresherImpl.MyRootHolder rootHolder=roots.size() == 1 ? new LoaderAndRefresherImpl.OneRootHolder(root) : new LoaderAndRefresherImpl.ManyCaseHolder(i,rootsHolder);
    if (!filters.isUseOnlyHashes()) {
      final boolean haveStructureFilter=filters.haveStructureFilter();
      if (haveStructureFilter && !filters.haveStructuresForRoot(root)) {
        ++i;
        continue;
      }
      filters.callConsumer(new Consumer<List<ChangesFilter.Filter>>(){
        @Override public void consume(        final List<ChangesFilter.Filter> filters){
          final LoaderAndRefresherImpl loaderAndRefresher=new LoaderAndRefresherImpl(ticket,filters,myMediator,startingPoints,myDetailsCache,myProject,rootHolder,myUsersIndex,loadGrowthController.getId(),haveStructureFilter,topoOrder);
          list.add(loaderAndRefresher);
        }
      }
,true,root);
    }
    shortLoaders.add(new ByRootLoader(myProject,rootHolder,myMediator,myDetailsCache,ticket,myUsersIndex,filters,startingPoints));
    ++i;
  }
  myUsersComponent.acceptUpdate(myUsersIndex.getKeys());
  if (myPreviousAlgorithm != null) {
    final Continuation oldContinuation=myPreviousAlgorithm.getContinuation();
    oldContinuation.cancelCurrent();
    oldContinuation.clearQueue();
  }
  final Continuation continuation=Continuation.createFragmented(myProject,true);
  continuation.add(Arrays.<TaskDescriptor>asList(new RepositoriesSorter(list,shortLoaders,continuation)));
  continuation.resume();
}
