def __init__(self, root, cwd, patterns, include=[], exclude=[], default='glob', exact=False):
    "build an object to match a set of file patterns\n\n        arguments:\n        root - the canonical root of the tree you're matching against\n        cwd - the current working directory, if relevant\n        patterns - patterns to find\n        include - patterns to include\n        exclude - patterns to exclude\n        default - if a pattern in names has no explicit type, assume this one\n        exact - patterns are actually literals\n\n        a pattern is one of:\n        'glob:<glob>' - a glob relative to cwd\n        're:<regexp>' - a regular expression\n        'path:<path>' - a path relative to canonroot\n        'relglob:<glob>' - an unrooted glob (*.c matches C files in all dirs)\n        'relpath:<path>' - a path relative to cwd\n        'relre:<regexp>' - a regexp that needn't match the start of a name\n        '<something>' - a pattern of the specified default type\n        "
    self._root = root
    self._cwd = cwd
    self._files = []
    self._anypats = bool((include or exclude))
    if include:
        im = _buildmatch(_normalize(include, 'glob', root, cwd), '(?:/|$)')
    if exclude:
        em = _buildmatch(_normalize(exclude, 'glob', root, cwd), '(?:/|$)')
    if exact:
        self._files = patterns
        pm = self.exact
    elif patterns:
        pats = _normalize(patterns, default, root, cwd)
        self._files = _roots(pats)
        self._anypats = (self._anypats or _anypats(pats))
        pm = _buildmatch(pats, '$')
    if (patterns or exact):
        if include:
            if exclude:
                m = (lambda f: (im(f) and (not em(f)) and pm(f)))
            else:
                m = (lambda f: (im(f) and pm(f)))
        elif exclude:
            m = (lambda f: ((not em(f)) and pm(f)))
        else:
            m = pm
    elif include:
        if exclude:
            m = (lambda f: (im(f) and (not em(f))))
        else:
            m = im
    elif exclude:
        m = (lambda f: (not em(f)))
    else:
        m = (lambda f: True)
    self.matchfn = m
    self._fmap = set(self._files)
