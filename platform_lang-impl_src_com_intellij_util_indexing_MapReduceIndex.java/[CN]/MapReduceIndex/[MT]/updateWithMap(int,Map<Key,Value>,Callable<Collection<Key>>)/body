{
  getWriteLock().lock();
  try {
    try {
      for (      Key key : oldKeysGetter.call()) {
        myStorage.removeAllValues(key,inputId);
      }
    }
 catch (    Exception e) {
      throw new StorageException(e);
    }
    if (newData instanceof THashMap) {
      final Ref<StorageException> exceptionRef=new Ref<StorageException>();
      final boolean b=((THashMap<Key,Value>)newData).forEachEntry(new TObjectObjectProcedure<Key,Value>(){
        @Override public boolean execute(        Key key,        Value value){
          try {
            myStorage.addValue(key,inputId,value);
          }
 catch (          StorageException ex) {
            exceptionRef.set(ex);
            return false;
          }
          return true;
        }
      }
);
      if (!b)       throw exceptionRef.get();
    }
 else {
      for (      Map.Entry<Key,Value> entry : newData.entrySet()) {
        myStorage.addValue(entry.getKey(),inputId,entry.getValue());
      }
    }
    if (myInputsIndex != null) {
      try {
        final Set<Key> newKeys=newData.keySet();
        if (newKeys.size() > 0) {
          myInputsIndex.put(inputId,newKeys);
        }
 else {
          myInputsIndex.remove(inputId);
        }
      }
 catch (      IOException e) {
        throw new StorageException(e);
      }
    }
  }
  finally {
    getWriteLock().unlock();
  }
}
