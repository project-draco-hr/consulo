{
  final boolean weProcessPhysicalContent=content == null || (content instanceof UserDataHolder && FileBasedIndexImpl.ourPhysicalContentKey.get((UserDataHolder)content,Boolean.FALSE));
  Map<Key,Value> data=null;
  boolean havePersistentData=false;
  Integer hashId=null;
  boolean skippedReadingPersistentDataButMayHaveIt=false;
  if (myContents != null && weProcessPhysicalContent && content != null) {
    try {
      FileContent fileContent=(FileContent)content;
      hashId=getHashOfContent(fileContent);
      if (doReadSavedPersistentData) {
        if (!myContents.isBusyReading() || DebugAssertions.EXTRA_SANITY_CHECKS) {
          ByteSequence bytes=myContents.get(hashId);
          if (bytes != null) {
            data=deserializeSavedPersistentData(bytes);
            havePersistentData=true;
            if (DebugAssertions.EXTRA_SANITY_CHECKS) {
              Map<Key,Value> contentData=myIndexer.map(content);
              boolean sameValueForSavedIndexedResultAndCurrentOne=contentData.equals(data);
              if (!sameValueForSavedIndexedResultAndCurrentOne) {
                DebugAssertions.error("Unexpected difference in indexing of %s by index %s, file type %s, charset %s\ndiff %s\nprevious indexed info %s",fileContent.getFile(),myIndexId,fileContent.getFileType().getName(),((FileContentImpl)fileContent).getCharset(),buildDiff(data,contentData),myIndexingTrace.get(hashId));
              }
            }
          }
        }
 else {
          skippedReadingPersistentDataButMayHaveIt=true;
        }
      }
 else {
        havePersistentData=myContents.containsMapping(hashId);
      }
    }
 catch (    IOException ex) {
      throw new RuntimeException(ex);
    }
  }
  if (data == null)   data=content != null ? myIndexer.map(content) : Collections.<Key,Value>emptyMap();
  if (hashId != null && !havePersistentData) {
    boolean saved=savePersistentData(data,hashId,skippedReadingPersistentDataButMayHaveIt);
    if (DebugAssertions.EXTRA_SANITY_CHECKS) {
      if (saved) {
        FileContent fileContent=(FileContent)content;
        try {
          myIndexingTrace.put(hashId,((FileContentImpl)fileContent).getCharset() + "," + fileContent.getFileType().getName()+ ","+ fileContent.getFile().getPath()+ ","+ ExceptionUtil.getThrowableText(new Throwable()));
        }
 catch (        IOException ex) {
          LOG.error(ex);
        }
      }
    }
  }
  ProgressManager.checkCanceled();
  UpdateData<Key,Value> optimizedUpdateData=null;
  final NotNullComputable<Collection<Key>> oldKeysGetter;
  final int savedInputId;
  if (myHasSnapshotMapping) {
    try {
      final NotNullComputable<Collection<Key>> keysForGivenInputId=new NotNullComputable<Collection<Key>>(){
        @NotNull @Override public Collection<Key> compute(){
          try {
            Integer currentHashId=myInputsSnapshotMapping.get(inputId);
            Collection<Key> currentKeys;
            if (currentHashId != null) {
              ByteSequence byteSequence=myContents.get(currentHashId);
              currentKeys=byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList();
            }
 else {
              currentKeys=Collections.emptyList();
            }
            return currentKeys;
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
;
      if (weProcessPhysicalContent) {
        if (content instanceof FileContent) {
          savedInputId=getHashOfContent((FileContent)content);
        }
 else {
          savedInputId=NULL_MAPPING;
        }
        oldKeysGetter=keysForGivenInputId;
        if (MapDiffUpdateData.ourDiffUpdateEnabled) {
          final Map<Key,Value> newValue=data;
          optimizedUpdateData=new MapDiffUpdateData<Key,Value>(myIndexId){
            @Override protected Map<Key,Value> getNewValue(){
              return newValue;
            }
            @Override protected Map<Key,Value> getCurrentValue() throws IOException {
              Integer currentHashId=myInputsSnapshotMapping.get(inputId);
              Map<Key,Value> currentValue;
              if (currentHashId != null) {
                ByteSequence byteSequence=myContents.get(currentHashId);
                currentValue=byteSequence != null ? deserializeSavedPersistentData(byteSequence) : Collections.<Key,Value>emptyMap();
              }
 else {
                currentValue=Collections.emptyMap();
              }
              return currentValue;
            }
            @Override public void save(            int inputId) throws IOException {
              myInputsSnapshotMapping.put(inputId,savedInputId);
            }
          }
;
        }
      }
 else {
        oldKeysGetter=new NotNullComputable<Collection<Key>>(){
          @NotNull @Override public Collection<Key> compute(){
            try {
              Collection<Key> oldKeys=myInputsIndex.get(inputId);
              if (oldKeys == null) {
                return keysForGivenInputId.compute();
              }
              return oldKeys;
            }
 catch (            IOException e) {
              throw new RuntimeException(e);
            }
          }
        }
;
        savedInputId=NULL_MAPPING;
      }
    }
 catch (    IOException ex) {
      throw new RuntimeException(ex);
    }
  }
 else {
    oldKeysGetter=new NotNullComputable<Collection<Key>>(){
      @NotNull @Override public Collection<Key> compute(){
        try {
          Collection<Key> oldKeys=myInputsIndex.get(inputId);
          return oldKeys == null ? Collections.<Key>emptyList() : oldKeys;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    savedInputId=inputId;
  }
  final UpdateData<Key,Value> updateData=optimizedUpdateData != null ? optimizedUpdateData : new SimpleUpdateData(myIndexId,savedInputId,data,oldKeysGetter);
  return new Computable<Boolean>(){
    @Override public Boolean compute(){
      final Ref<StorageException> exRef=new Ref<StorageException>(null);
      ProgressManager.getInstance().executeNonCancelableSection(new Runnable(){
        @Override public void run(){
          try {
            updateWithMap(inputId,updateData);
          }
 catch (          StorageException ex) {
            exRef.set(ex);
          }
        }
      }
);
      StorageException nestedException=exRef.get();
      if (nestedException != null) {
        LOG.info("Exception during updateWithMap:" + nestedException);
        FileBasedIndex.getInstance().requestRebuild(myIndexId,nestedException);
        return Boolean.FALSE;
      }
      return Boolean.TRUE;
    }
  }
;
}
