{
  final boolean weProcessPhysicalContent=content == null || (content instanceof UserDataHolder && FileBasedIndexImpl.ourPhysicalContentKey.get((UserDataHolder)content,Boolean.FALSE));
  Map<Key,Value> data=null;
  boolean havePersistentData=false;
  Integer hashId=null;
  boolean skippedReadingPersistentDataButMayHaveIt=false;
  if (myContents != null && weProcessPhysicalContent && content != null) {
    try {
      hashId=getHashOfContent((FileContent)content);
      if (doReadSavedPersistentData) {
        if (!myContents.isBusyReading()) {
          ByteSequence bytes=myContents.get(hashId);
          if (bytes != null) {
            data=deserializeSavedPersistentData(bytes);
            havePersistentData=true;
          }
        }
 else {
          skippedReadingPersistentDataButMayHaveIt=true;
        }
      }
 else {
        havePersistentData=myContents.containsMapping(hashId);
      }
    }
 catch (    IOException ex) {
      throw new RuntimeException(ex);
    }
  }
  if (data == null)   data=content != null ? myIndexer.map(content) : Collections.<Key,Value>emptyMap();
  if (hashId != null && !havePersistentData) {
    savePersistentData(data,hashId,skippedReadingPersistentDataButMayHaveIt);
  }
  ProgressManager.checkCanceled();
  final NotNullComputable<Collection<Key>> oldKeysGetter;
  final int savedInputId;
  if (myHasSnapshotMapping && weProcessPhysicalContent) {
    try {
      oldKeysGetter=new NotNullComputable<Collection<Key>>(){
        @NotNull @Override public Collection<Key> compute(){
          try {
            Integer currentHashId=myInputsSnapshotMapping.get(inputId);
            Collection<Key> currentKeys;
            if (currentHashId != null) {
              ByteSequence byteSequence=myContents.get(currentHashId);
              currentKeys=byteSequence != null ? deserializeSavedPersistentData(byteSequence).keySet() : Collections.<Key>emptyList();
            }
 else {
              currentKeys=Collections.emptyList();
            }
            return currentKeys;
          }
 catch (          IOException e) {
            throw new RuntimeException(e);
          }
        }
      }
;
      if (content instanceof FileContent) {
        savedInputId=getHashOfContent((FileContent)content);
      }
 else {
        savedInputId=NULL_MAPPING;
      }
    }
 catch (    IOException ex) {
      throw new RuntimeException(ex);
    }
  }
 else {
    oldKeysGetter=new NotNullComputable<Collection<Key>>(){
      @NotNull @Override public Collection<Key> compute(){
        try {
          Collection<Key> oldKeys=myInputsIndex.get(inputId);
          return oldKeys == null ? Collections.<Key>emptyList() : oldKeys;
        }
 catch (        IOException e) {
          throw new RuntimeException(e);
        }
      }
    }
;
    savedInputId=inputId;
  }
  final Map<Key,Value> finalData=data;
  return new Computable<Boolean>(){
    @Override public Boolean compute(){
      final Ref<StorageException> exRef=new Ref<StorageException>(null);
      ProgressManager.getInstance().executeNonCancelableSection(new Runnable(){
        @Override public void run(){
          try {
            updateWithMap(inputId,savedInputId,finalData,oldKeysGetter);
          }
 catch (          StorageException ex) {
            exRef.set(ex);
          }
        }
      }
);
      if (exRef.get() != null) {
        LOG.info(exRef.get());
        FileBasedIndex.getInstance().requestRebuild(myIndexId);
        return Boolean.FALSE;
      }
      return Boolean.TRUE;
    }
  }
;
}
