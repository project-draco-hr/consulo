{
  final Map<Key,Value> data=content != null ? myIndexer.map(content) : Collections.<Key,Value>emptyMap();
  ProgressManager.checkCanceled();
  return new Computable<Boolean>(){
    @Override public Boolean compute(){
      final Ref<StorageException> exRef=new Ref<StorageException>(null);
      ProgressManager.getInstance().executeNonCancelableSection(new Runnable(){
        @Override public void run(){
          try {
            updateWithMap(inputId,data,new Callable<Collection<Key>>(){
              @Override public Collection<Key> call() throws Exception {
                if (myInputsIndex == null) {
                  return new SmartList<Key>((Key)(Integer)inputId);
                }
                final Collection<Key> oldKeys=myInputsIndex.get(inputId);
                return oldKeys == null ? Collections.<Key>emptyList() : oldKeys;
              }
            }
);
          }
 catch (          StorageException ex) {
            exRef.set(ex);
          }
        }
      }
);
      if (exRef.get() != null) {
        LOG.info(exRef.get());
        FileBasedIndex.getInstance().requestRebuild(myIndexId);
        return Boolean.FALSE;
      }
 else {
        return Boolean.TRUE;
      }
    }
  }
;
}
