{
  if (!refMethod.isBodyEmpty())   return null;
  if (refMethod.isConstructor())   return null;
  for (Iterator<RefMethod> iterator=refMethod.getSuperMethods().iterator(); iterator.hasNext(); ) {
    RefMethod refSuper=iterator.next();
    if (checkMethod(refSuper) != null)     return null;
  }
  String message=null;
  if (refMethod.isOnlyCallsSuper()) {
    RefMethod refSuper=findSuperWithBody(refMethod);
    if (refSuper == null || RefUtil.compareAccess(refMethod.getAccessModifier(),refSuper.getAccessModifier()) <= 0) {
      message="Method only calls its super.";
    }
  }
 else   if (refMethod.hasBody() && hasEmptySuperImplementation(refMethod)) {
    message="Empty method overrides empty method.";
  }
 else   if (areAllImplementationsEmpty(refMethod)) {
    if (refMethod.hasBody()) {
      if (refMethod.getDerivedMethods().size() == 0) {
        if (refMethod.getSuperMethods().size() == 0) {
          message="The method is empty.";
        }
      }
 else {
        message="The method and all it's deriveables are empty.";
      }
    }
 else {
      if (refMethod.getDerivedMethods().size() > 0) {
        message="All implementations of this method are empty.";
      }
    }
  }
  if (message != null) {
    return new ProblemDescriptor[]{getManager().createProblemDescriptor(refMethod.getElement(),message,getFix(),ProblemHighlightType.GENERIC_ERROR_OR_WARNING)};
  }
  return null;
}
