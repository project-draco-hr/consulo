{
  final MyList fProduction=myProduction;
  StartMarker rootMarker=(StartMarker)fProduction.get(0);
  for (int i=1; i < fProduction.size() - 1; i++) {
    ProductionMarker item=fProduction.get(i);
    if (item instanceof StartMarker) {
      while (item.myLexemIndex < myLexems.size() && myWhitespaces.contains(myLexems.get(item.myLexemIndex).getTokenType())) {
        item.myLexemIndex++;
      }
    }
 else     if (item instanceof DoneMarker || item instanceof ErrorItem) {
      int prevProductionLexIndex=fProduction.get(i - 1).myLexemIndex;
      while (item.myLexemIndex > prevProductionLexIndex && item.myLexemIndex < myLexems.size() && myWhitespaces.contains(myLexems.get(item.myLexemIndex - 1).getTokenType())) {
        item.myLexemIndex--;
      }
    }
  }
  StartMarker curNode=rootMarker;
  int curToken=0;
  int lastErrorIndex=-1;
  Stack<StartMarker> nodes=new Stack<StartMarker>();
  nodes.push(rootMarker);
  for (int i=1; i < fProduction.size(); i++) {
    ProductionMarker item=fProduction.get(i);
    if (curNode == null)     LOG.error("Unexpected end of the production");
    int lexIndex=item.myLexemIndex;
    if (item instanceof StartMarker) {
      StartMarker marker=(StartMarker)item;
      curToken=insertLeafs(curToken,lexIndex,curNode);
      curNode.addChild(item);
      nodes.push(curNode);
      curNode=marker;
    }
 else     if (item instanceof DoneMarker) {
      curToken=insertLeafs(curToken,lexIndex,curNode);
      curNode=nodes.pop();
    }
 else     if (item instanceof ErrorItem) {
      curToken=insertLeafs(curToken,lexIndex,curNode);
      if (curToken == lastErrorIndex)       continue;
      lastErrorIndex=curToken;
      curNode.addChild(item);
    }
  }
  final boolean allTokensInserted=curToken == myLexems.size();
  if (!allTokensInserted) {
    LOG.assertTrue(false,"Not all of the tokens inserted to the tree, parsed text:\n" + myText);
  }
  myLexems.add(new Token());
  LOG.assertTrue(curNode == rootMarker,"Unbalanced tree");
  return rootMarker;
}
