{
  ProjectDescriptor pd;
  final Project project=loadProject(projectPath);
  final BuildFSState fsState=new BuildFSState(false);
  ProjectTimestamps timestamps=null;
  BuildDataManager dataManager=null;
  final File dataStorageRoot=Utils.getDataStorageRoot(project);
  try {
    timestamps=new ProjectTimestamps(dataStorageRoot);
    dataManager=new BuildDataManager(dataStorageRoot,true);
  }
 catch (  Exception e) {
    e.printStackTrace(System.err);
    if (timestamps != null) {
      timestamps.close();
    }
    if (dataManager != null) {
      dataManager.close();
    }
    buildType=BuildType.PROJECT_REBUILD;
    FileUtil.delete(dataStorageRoot);
    timestamps=new ProjectTimestamps(dataStorageRoot);
    dataManager=new BuildDataManager(dataStorageRoot,true);
    msgHandler.processMessage(new CompilerMessage("compile-server",BuildMessage.Kind.INFO,"Project rebuild forced: " + e.getMessage()));
  }
  pd=new ProjectDescriptor(project,fsState,timestamps,dataManager,BuildLoggingManager.DEFAULT);
  try {
    final CompileScope compileScope=createCompilationScope(buildType,pd,modules,artifacts,paths);
    final IncProjectBuilder builder=new IncProjectBuilder(pd,BuilderRegistry.getInstance(),builderParams,cs);
    if (msgHandler != null) {
      builder.addMessageHandler(msgHandler);
    }
switch (buildType) {
case PROJECT_REBUILD:
      builder.build(compileScope,false,true);
    break;
case FORCED_COMPILATION:
  builder.build(compileScope,false,false);
break;
case MAKE:
builder.build(compileScope,true,false);
break;
case CLEAN:
break;
}
}
  finally {
pd.release();
}
}
