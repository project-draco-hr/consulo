{
  int result=0;
  if (brace == null) {
    throw new BadPsiElementException("adjustSpacing: illegal syntax (mismatched braces); PsiElement for brace is null");
  }
  int offset=brace.getTextRange().getStartOffset() + bias;
  int direction=before ? -1 : +1;
  int count=0;
{
    char braceChar=myBuffer.charAt(offset);
    if (braceChar != '{' && braceChar != '}') {
      int L=offset - 50;
      int R=offset + 50;
      if (L < 0) {
        L=0;
      }
      if (R > myBuffer.length()) {
        R=myBuffer.length();
      }
      String context=myBuffer.toString().substring(L,R);
      throw new RuntimeException("adjustSpacing: char at offset " + offset + " is not a brace, ='"+ braceChar+ "'"+ "; context is "+ context);
    }
  }
  PsiElement whiteSpace=brace;
  do {
    whiteSpace=getNextElement(whiteSpace,before);
    if (whiteSpace == matchingBrace) {
      return result;
    }
  }
 while (whiteSpace != null && (!(whiteSpace instanceof PsiWhiteSpace) || whiteSpace.getText().indexOf('\n') < 0));
  VirtualElement virtualWhiteSpace=null;
  if (whiteSpace != null) {
    virtualWhiteSpace=(virtualElements.get(whiteSpace));
    if (virtualWhiteSpace == null) {
      virtualWhiteSpace=new VirtualElement((PsiWhiteSpace)whiteSpace,bias);
    }
 else {
      LOG.debug("reusing virtualWhiteSpace, offset=" + virtualWhiteSpace.textOffset);
    }
    String s=virtualWhiteSpace.getText();
    for (int i=0; i < s.length(); i++) {
      if (s.charAt(i) == '\n') {
        count++;
      }
    }
  }
  if (offset + direction >= myBuffer.length()) {
    LOG.debug("at EOF, don't append any extra blank lines");
    nBlankLines=0;
  }
  int desiredNewlineChars=nBlankLines + 1;
  if (desiredNewlineChars == 1 && count == 0 && before) {
    desiredNewlineChars=0;
  }
{
    PsiElement element=brace.getParent();
    if (element instanceof PsiCodeBlock && element.getParent() instanceof PsiMethod) {
      element=element.getParent();
    }
    LOG.debug("adjustSpacing: " + (before ? "before " : "after ") + element.toString()+ " "+ brace.getText()+ ", desire "+ desiredNewlineChars+ " newlines, have "+ count);
  }
  if (desiredNewlineChars == count) {
    return 0;
  }
  int endIndex;
  if (virtualWhiteSpace != null) {
    String s=virtualWhiteSpace.getText();
    for (endIndex=s.length() - 1; endIndex >= 0; endIndex--) {
      if (s.charAt(endIndex) != ' ' && s.charAt(endIndex) != '\t') {
        break;
      }
    }
    offset=virtualWhiteSpace.getTextOffset();
    endIndex+=offset + 1;
  }
 else {
    offset=endIndex=myBuffer.length();
  }
  try {
    myChangesMade=true;
    LOG.debug("sb.replace(" + offset + ","+ endIndex+ ") with "+ desiredNewlineChars+ " newline characters");
    myBuffer.replace(offset,endIndex,new String(myNewlineChars,0,desiredNewlineChars));
    result=desiredNewlineChars - (endIndex - offset);
    if (virtualWhiteSpace != null) {
      offset-=virtualWhiteSpace.getTextOffset();
      endIndex-=virtualWhiteSpace.getTextOffset();
      StringBuffer vsb=new StringBuffer(virtualWhiteSpace.getText());
      vsb.replace(offset,endIndex,new String(myNewlineChars,0,desiredNewlineChars));
      virtualWhiteSpace.setTextValue(vsb.toString());
    }
  }
 catch (  StringIndexOutOfBoundsException si) {
    throw new RuntimeException("sb.length()=" + myBuffer.length() + ", offset="+ offset+ ", before="+ before+ ", count="+ count+ ", desiredNewlineChars="+ desiredNewlineChars+ ", charAt offset="+ (offset < myBuffer.length() ? "" + myBuffer.charAt(offset) : "OOB"),si);
  }
  return result;
}
