{
  long count=PsiManager.getInstance(getProject()).getModificationTracker().getModificationCount();
  if (myCachedChildren != null && storedModificationCount == count || !isValid() || myTreeBuilder.splitByLeafExpressions) {
    return myCachedChildren == null ? Collections.<AbstractTreeNode>emptyList() : myCachedChildren;
  }
  myCachedChildren=Collections.synchronizedList(new ArrayList<AbstractTreeNode>());
  storedModificationCount=count;
  final SliceManager manager=SliceManager.getInstance(getProject());
  manager.runInterruptibly(new Runnable(){
    public void run(){
      getValue().processChildren(new Processor<SliceUsage>(){
        public boolean process(        SliceUsage sliceUsage){
          manager.checkCanceled();
          SliceNode node=new SliceNode(myProject,sliceUsage,targetEqualUsages,myTreeBuilder,getLeafExpressions());
          myCachedChildren.add(node);
          return true;
        }
      }
);
    }
  }
,new Runnable(){
    public void run(){
      myCachedChildren=null;
      storedModificationCount=-1;
      changed=true;
      SwingUtilities.invokeLater(new Runnable(){
        public void run(){
          DefaultMutableTreeNode node=myTreeBuilder.getNodeForElement(getValue());
          if (node == null)           node=myTreeBuilder.getRootNode();
          myTreeBuilder.addSubtreeToUpdate(node);
        }
      }
);
    }
  }
,progress);
  return myCachedChildren;
}
