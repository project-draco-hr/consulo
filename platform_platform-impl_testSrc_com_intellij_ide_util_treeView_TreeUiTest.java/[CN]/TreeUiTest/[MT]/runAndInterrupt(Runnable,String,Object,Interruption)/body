{
  myElementUpdate.clear();
  Log.print("runAndInterrupt action=" + interruptAction + " element="+ interruptElement+ " cancelRequest="+ myCancelRequest+ " interruption="+ interruption+ " builder="+ getBuilder());
  final Ref<Thread> thread=new Ref<Thread>();
  final boolean[] wasInterrupted=new boolean[]{false};
  myElementUpdateHook=new ElementUpdateHook(){
    public void onElementAction(    String action,    Object element){
      if (thread.get() == null) {
        thread.set(Thread.currentThread());
      }
      if (thread.get() != Thread.currentThread()) {
        Log.print("FFFFFFFFFFUUUUUUUUUUUUUCCCCCCCCCCCCKKKKKKKKK!!!!!!!!!!!!!!!!!!!!!!!!!!!");
      }
      boolean toInterrupt=element.equals(interruptElement) && action.equals(interruptAction);
      Log.print("-- onElementAction action=" + action + " element="+ element+ " wasInterrupted="+ wasInterrupted[0]+ " toInterrupt="+ toInterrupt+ " cancelProcessed"+ getBuilder().getUi().isCancelProcessed());
      if (wasInterrupted[0]) {
        if (myCancelRequest == null) {
          String status=getBuilder().getUi().getStatus();
          Log.print("!!!! status=" + status);
          myCancelRequest=new AssertionError("Not supposed to be update after interruption request: action=" + action + " element="+ element+ " interruptAction="+ interruptAction+ " interruptElement="+ interruptElement);
        }
      }
 else {
        if (toInterrupt) {
          Log.print("-- send interruption ready=" + getBuilder().getUi().isReady());
          wasInterrupted[0]=true;
switch (interruption) {
case throwProcessCancelled:
            throw new ProcessCanceledException();
case invokeCancel:
          getBuilder().cancelUpdate();
        break;
    }
  }
}
}
}
;
action.run();
myCancelRequest=null;
}
