{
  final Collection<String> trackingBranches=findTrackingBranches(branchName);
  String currentBranch=getCurrentBranchOrRev();
  boolean currentBranchTracksBranchToDelete=false;
  if (trackingBranches.contains(currentBranch)) {
    currentBranchTracksBranchToDelete=true;
    trackingBranches.remove(currentBranch);
  }
  final DeleteRemoteBranchDecision decision=confirmBranchDeletion(branchName,trackingBranches,currentBranchTracksBranchToDelete);
  if (decision.delete()) {
    new CommonBackgroundTask(myProject,"Deleting " + branchName,myCallInAwtAfterExecution){
      @Override public void execute(      @NotNull ProgressIndicator indicator){
        boolean deletedSuccessfully=doDeleteRemote(branchName);
        if (deletedSuccessfully) {
          final Collection<String> successfullyDeletedLocalBranches=new ArrayList<String>(1);
          if (decision.deleteTracking()) {
            for (            final String branch : trackingBranches) {
              indicator.setText("Deleting " + branch);
              new GitDeleteBranchOperation(myProject,myGit,myRepositories,branch,getCurrentBranchOrRev(),indicator){
                @Override protected void notifySuccess(                @NotNull String message){
                  successfullyDeletedLocalBranches.add(branch);
                }
              }
.execute();
            }
          }
          notifySuccessfulDeletion(branchName,successfullyDeletedLocalBranches);
        }
      }
    }
.runInBackground();
  }
}
