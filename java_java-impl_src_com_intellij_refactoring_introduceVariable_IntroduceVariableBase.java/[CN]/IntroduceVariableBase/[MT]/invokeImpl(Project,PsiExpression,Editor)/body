{
  if (expr != null) {
    final String errorMessage=getErrorMessage(expr);
    if (errorMessage != null) {
      showErrorMessage(project,editor,RefactoringBundle.getCannotRefactorMessage(errorMessage));
      return false;
    }
  }
  if (expr != null && expr.getParent() instanceof PsiExpressionStatement) {
    FeatureUsageTracker.getInstance().triggerFeatureUsed("refactoring.introduceVariable.incompleteStatement");
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug("expression:" + expr);
  }
  if (expr == null || !expr.isPhysical()) {
    if (ReassignVariableUtil.reassign(editor))     return false;
    if (expr == null) {
      String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.block.should.represent.an.expression"));
      showErrorMessage(project,editor,message);
      return false;
    }
  }
  final PsiType originalType=RefactoringUtil.getTypeByExpressionWithExpectedType(expr);
  if (originalType == null) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("unknown.expression.type"));
    showErrorMessage(project,editor,message);
    return false;
  }
  if (PsiType.VOID.equals(originalType)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("selected.expression.has.void.type"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiElement physicalElement=expr.getUserData(ElementToWorkOn.PARENT);
  final PsiElement anchorStatement=RefactoringUtil.getParentStatement(physicalElement != null ? physicalElement : expr,false);
  if (anchorStatement == null) {
    return parentStatementNotFound(project,editor);
  }
  if (checkAnchorBeforeThisOrSuper(project,editor,anchorStatement,REFACTORING_NAME,HelpID.INTRODUCE_VARIABLE))   return false;
  final PsiElement tempContainer=anchorStatement.getParent();
  if (!(tempContainer instanceof PsiCodeBlock) && !isLoopOrIf(tempContainer)) {
    String message=RefactoringBundle.message("refactoring.is.not.supported.in.the.current.context",REFACTORING_NAME);
    showErrorMessage(project,editor,message);
    return false;
  }
  if (!NotInSuperCallOccurrenceFilter.INSTANCE.isOK(expr)) {
    String message=RefactoringBundle.getCannotRefactorMessage(RefactoringBundle.message("cannot.introduce.variable.in.super.constructor.call"));
    showErrorMessage(project,editor,message);
    return false;
  }
  final PsiFile file=anchorStatement.getContainingFile();
  LOG.assertTrue(file != null,"expr.getContainingFile() == null");
  if (!CommonRefactoringUtil.checkReadOnlyStatus(project,file))   return false;
  PsiElement containerParent=tempContainer;
  PsiElement lastScope=tempContainer;
  while (true) {
    if (containerParent instanceof PsiFile)     break;
    if (containerParent instanceof PsiMethod)     break;
    containerParent=containerParent.getParent();
    if (containerParent instanceof PsiCodeBlock) {
      lastScope=containerParent;
    }
  }
  final ExpressionOccurrenceManager occurenceManager=new ExpressionOccurrenceManager(expr,lastScope,NotInSuperCallOccurrenceFilter.INSTANCE);
  final PsiExpression[] occurrences=occurenceManager.getOccurrences();
  final PsiElement anchorStatementIfAll=occurenceManager.getAnchorStatementForAll();
  final LinkedHashMap<OccurrencesChooser.ReplaceChoice,List<PsiExpression>> occurrencesMap=Maps.newLinkedHashMap();
  final boolean hasWriteAccess=fillChoices(expr,occurrences,occurrencesMap);
  final PsiElement nameSuggestionContext=editor != null ? file.findElementAt(editor.getCaretModel().getOffset()) : null;
  final RefactoringSupportProvider supportProvider=LanguageRefactoringSupport.INSTANCE.forLanguage(expr.getLanguage());
  final boolean isInplaceAvailableOnDataContext=supportProvider != null && editor.getSettings().isVariableInplaceRenameEnabled() && supportProvider.isInplaceIntroduceAvailable(expr,nameSuggestionContext) && !ApplicationManager.getApplication().isUnitTestMode() && !isInJspHolderMethod(expr);
  final boolean inFinalContext=occurenceManager.isInFinalContext();
  final InputValidator validator=new InputValidator(this,project,anchorStatementIfAll,anchorStatement,occurenceManager);
  final TypeSelectorManagerImpl typeSelectorManager=new TypeSelectorManagerImpl(project,originalType,expr,occurrences);
  final boolean[] wasSucceed=new boolean[]{true};
  final Pass<OccurrencesChooser.ReplaceChoice> callback=new Pass<OccurrencesChooser.ReplaceChoice>(){
    @Override public void pass(    final OccurrencesChooser.ReplaceChoice choice){
      final boolean allOccurences=choice != OccurrencesChooser.ReplaceChoice.NO;
      final PsiElement chosenAnchor=allOccurences ? anchorStatementIfAll : anchorStatement;
      final Ref<SmartPsiElementPointer<PsiVariable>> variable=new Ref<SmartPsiElementPointer<PsiVariable>>();
      final IntroduceVariableSettings settings=getSettings(project,editor,expr,occurrences,typeSelectorManager,inFinalContext,hasWriteAccess,validator,chosenAnchor,choice);
      if (!settings.isOK()) {
        wasSucceed[0]=false;
        return;
      }
      typeSelectorManager.setAllOccurrences(allOccurences);
      final TypeExpression expression=new TypeExpression(project,allOccurences ? typeSelectorManager.getTypesForAll() : typeSelectorManager.getTypesForOne());
      final RangeMarker exprMarker=editor.getDocument().createRangeMarker(expr.getTextRange());
      final SuggestedNameInfo suggestedName=getSuggestedName(settings.getSelectedType(),expr,chosenAnchor);
      final List<RangeMarker> occurrenceMarkers=new ArrayList<RangeMarker>();
      final boolean noWrite=choice == OccurrencesChooser.ReplaceChoice.NO_WRITE;
      for (      PsiExpression occurrence : occurrences) {
        if (allOccurences || (noWrite && !PsiUtil.isAccessedForWriting(occurrence))) {
          occurrenceMarkers.add(editor.getDocument().createRangeMarker(occurrence.getTextRange()));
        }
      }
      final String expressionText=expr.getText();
      final Runnable runnable=introduce(project,expr,editor,anchorStatement,tempContainer,occurrences,anchorStatementIfAll,settings,variable);
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        public void run(){
          ApplicationManager.getApplication().runWriteAction(runnable);
          if (isInplaceAvailableOnDataContext) {
            final PsiVariable elementToRename=variable.get().getElement();
            if (elementToRename != null) {
              editor.getCaretModel().moveToOffset(elementToRename.getTextOffset());
              final boolean cantChangeFinalModifier=(hasWriteAccess || inFinalContext) && choice == OccurrencesChooser.ReplaceChoice.ALL;
              final JavaVariableInplaceIntroducer renamer=new JavaVariableInplaceIntroducer(project,expression,editor,elementToRename,cantChangeFinalModifier,typeSelectorManager.getTypesForAll().length > 1,exprMarker,occurrenceMarkers,IntroduceVariableBase.REFACTORING_NAME);
              renamer.initInitialText(expressionText);
              PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(editor.getDocument());
              renamer.performInplaceRefactoring(new LinkedHashSet<String>(Arrays.asList(suggestedName.names)));
            }
          }
        }
      }
,REFACTORING_NAME,null);
    }
  }
;
  if (!isInplaceAvailableOnDataContext) {
    callback.pass(null);
  }
 else {
    OccurrencesChooser.<PsiExpression>simpleChooser(editor).showChooser(callback,occurrencesMap);
  }
  return wasSucceed[0];
}
