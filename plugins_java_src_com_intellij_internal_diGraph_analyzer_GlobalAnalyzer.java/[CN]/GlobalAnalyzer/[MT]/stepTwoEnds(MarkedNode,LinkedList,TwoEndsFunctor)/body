{
  boolean result=false;
  for (Iterator i=currNode.outIterator(); i.hasNext(); ) {
    final MarkedEdge currEdge=(MarkedEdge)i.next();
    final MarkedNode nextNode=(MarkedNode)currEdge.end();
    final Pair<Mark,Mark> markPair=functor.compute(currNode.getMark(),currEdge.getMark(),nextNode.getMark());
    final Mark leftMark=markPair.getFirst();
    final Mark rightMark=markPair.getSecond();
    if (!leftMark.coincidesWith(currNode.getMark())) {
      result=true;
      currNode.setMark(leftMark);
      worklist.addFirst(currNode);
    }
    if (!rightMark.coincidesWith(nextNode.getMark())) {
      result=true;
      nextNode.setMark(rightMark);
      worklist.addFirst(nextNode);
    }
  }
  return result;
}
