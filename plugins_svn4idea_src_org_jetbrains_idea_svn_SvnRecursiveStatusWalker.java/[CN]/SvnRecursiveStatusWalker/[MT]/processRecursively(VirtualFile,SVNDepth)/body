{
  if (SVNDepth.EMPTY.equals(prevDepth))   return;
  if (myPartner.isIgnoredIdeaLevel(vFile)) {
    myReceiver.processIgnored(vFile);
    return;
  }
  final SVNDepth newDepth=SVNDepth.INFINITY.equals(prevDepth) ? SVNDepth.INFINITY : SVNDepth.EMPTY;
  final File ioFile=new File(vFile.getPath());
  final Processor<File> processor;
  final Processor<File> directoryFilter;
  if (SVNDepth.EMPTY.equals(newDepth)) {
    directoryFilter=Processor.TRUE;
    processor=new Processor<File>(){
      @Override public boolean process(      File file){
        if (!FileUtil.filesEqual(ioFile,file))         return true;
        if (!FileUtil.filesEqual(ioFile,file.getParentFile()))         return false;
        if (file.isDirectory() && new File(file,SVNFileUtil.getAdminDirectoryName()).exists()) {
          final MyItem childItem=new MyItem(myProject,new FilePathImpl(file,true),newDepth,myPartner.createStatusClient(),true);
          myQueue.add(childItem);
        }
        return true;
      }
    }
;
  }
 else {
    directoryFilter=new Processor<File>(){
      @Override public boolean process(      File file){
        return myQueue.isEmpty() || !FileUtil.filesEqual(myQueue.getLast().getPath().getIOFile(),file);
      }
    }
;
    processor=new Processor<File>(){
      @Override public boolean process(      File file){
        if (file.isDirectory() && new File(file,SVNFileUtil.getAdminDirectoryName()).exists()) {
          final FilePathImpl path=new FilePathImpl(file,true);
          path.hardRefresh();
          final MyItem childItem=new MyItem(myProject,path,newDepth,myPartner.createStatusClient(),true);
          myQueue.add(childItem);
        }
        return true;
      }
    }
;
  }
  FileUtil.processFilesRecursively(ioFile,processor,directoryFilter);
}
