{
  myPartner.checkCanceled();
  final File ioFile=status.getFile();
  checkIfCopyRootWasReported();
  final boolean[] excluded=new boolean[1];
  final VirtualFile[] vfRef=new VirtualFile[1];
  ApplicationManager.getApplication().runReadAction(new Runnable(){
    @Override public void run(){
      if (myProject.isDisposed())       return;
      vfRef[0]=getVirtualFile(ioFile);
      excluded[0]=vfRef[0] != null && myPartner.isExcluded(vfRef[0]);
    }
  }
);
  if (myProject.isDisposed())   throw new ProcessCanceledException();
  final VirtualFile vFile=vfRef[0];
  if (excluded[0])   return;
  if ((vFile != null) && (SvnVcs.svnStatusIsUnversioned(status))) {
    if (vFile.isDirectory()) {
      if (FileUtil.filesEqual(myCurrentItem.getPath().getIOFile(),ioFile)) {
        myReceiver.processUnversioned(vFile);
        processRecursively(vFile,myCurrentItem.getDepth());
      }
 else {
        final MyItem childItem=new MyItem(myProject,new FilePathImpl(vFile),SVNDepth.INFINITY,myPartner.createStatusClient(),true);
        myQueue.add(childItem);
      }
    }
 else {
      myReceiver.processUnversioned(vFile);
    }
  }
 else {
    final FilePath path=VcsUtil.getFilePath(ioFile,status.getKind().equals(SVNNodeKind.DIR));
    myReceiver.process(path,status);
  }
}
