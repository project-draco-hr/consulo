{
  LinkedHashSet<PsiMethod> validOverriding=new LinkedHashSet<PsiMethod>(overridingMethods);
  boolean anyNewBadRefs;
  do {
    anyNewBadRefs=false;
    for (Iterator<PsiMethod> iterator=overridingMethods.iterator(); iterator.hasNext(); ) {
      PsiMethod overridingMethod=iterator.next();
      if (validOverriding.contains(overridingMethod)) {
        final PsiReference[] overridingReferences=methodToReferences.get(overridingMethod);
        boolean anyOverridingRefs=false;
        for (int j=0; j < overridingReferences.length && !anyOverridingRefs; j++) {
          final PsiElement element=overridingReferences[j].getElement();
          if (!isInside(element,myElements) && !isInside(element,validOverriding)) {
            anyOverridingRefs=true;
          }
        }
        if (anyOverridingRefs) {
          validOverriding.remove(overridingMethod);
          anyNewBadRefs=true;
          for (int j=0; j < originalReferences.length; j++) {
            PsiReference reference=originalReferences[j];
            final PsiElement element=reference.getElement();
            if (!isInside(element,myElements) && !isInside(element,overridingMethods)) {
              usages.add(new SafeDeleteReferenceSimpleDeleteUsageInfo(element,originalMethod,false));
              validOverriding.clear();
            }
          }
        }
      }
    }
  }
 while (anyNewBadRefs && !validOverriding.isEmpty());
  for (Iterator<PsiMethod> iterator=validOverriding.iterator(); iterator.hasNext(); ) {
    PsiMethod method=iterator.next();
    if (method != originalMethod) {
      usages.add(new SafeDeleteOverridingMethodUsageInfo(method,originalMethod));
    }
  }
  for (Iterator<PsiMethod> iterator=overridingMethods.iterator(); iterator.hasNext(); ) {
    PsiMethod method=iterator.next();
    if (!validOverriding.contains(method)) {
      final boolean methodCanBePrivate=canBePrivate(method,methodToReferences.get(method),validOverriding);
      if (methodCanBePrivate) {
        usages.add(new SafeDeletePrivatizeMethod(method,originalMethod));
      }
    }
  }
  return validOverriding;
}
