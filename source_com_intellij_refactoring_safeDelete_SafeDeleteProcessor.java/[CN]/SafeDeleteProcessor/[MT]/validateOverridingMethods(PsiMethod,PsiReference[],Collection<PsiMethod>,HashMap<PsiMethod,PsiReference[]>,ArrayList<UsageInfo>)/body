{
  LinkedHashSet<PsiMethod> validOverriding=new LinkedHashSet<PsiMethod>(overridingMethods);
  boolean anyNewBadRefs;
  do {
    anyNewBadRefs=false;
    for (    PsiMethod overridingMethod : overridingMethods) {
      if (validOverriding.contains(overridingMethod)) {
        final PsiReference[] overridingReferences=methodToReferences.get(overridingMethod);
        boolean anyOverridingRefs=false;
        for (int j=0; j < overridingReferences.length && !anyOverridingRefs; j++) {
          final PsiElement element=overridingReferences[j].getElement();
          if (!isInside(element,myElements) && !isInside(element,validOverriding)) {
            anyOverridingRefs=true;
          }
        }
        if (anyOverridingRefs) {
          validOverriding.remove(overridingMethod);
          anyNewBadRefs=true;
          for (          PsiReference reference : originalReferences) {
            final PsiElement element=reference.getElement();
            if (!isInside(element,myElements) && !isInside(element,overridingMethods)) {
              usages.add(new SafeDeleteReferenceSimpleDeleteUsageInfo(element,originalMethod,false));
              validOverriding.clear();
            }
          }
        }
      }
    }
  }
 while (anyNewBadRefs && !validOverriding.isEmpty());
  for (  PsiMethod method : validOverriding) {
    if (method != originalMethod) {
      usages.add(new SafeDeleteOverridingMethodUsageInfo(method,originalMethod));
    }
  }
  for (  PsiMethod method : overridingMethods) {
    if (!validOverriding.contains(method)) {
      final boolean methodCanBePrivate=canBePrivate(method,methodToReferences.get(method),validOverriding);
      if (methodCanBePrivate) {
        usages.add(new SafeDeletePrivatizeMethod(method,originalMethod));
      }
    }
  }
  return validOverriding;
}
