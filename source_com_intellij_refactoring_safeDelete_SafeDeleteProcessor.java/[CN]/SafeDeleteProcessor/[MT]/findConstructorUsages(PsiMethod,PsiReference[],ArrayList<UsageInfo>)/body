{
  final PsiSearchHelper searchHelper=constructor.getManager().getSearchHelper();
  HashMap<PsiMethod,PsiReference[]> constructorsToRefs=new HashMap<PsiMethod,PsiReference[]>();
  HashSet<PsiMethod> newConstructors=new HashSet<PsiMethod>();
  newConstructors.add(constructor);
  constructorsToRefs.put(constructor,originalReferences);
  HashSet<PsiMethod> passConstructors=new HashSet<PsiMethod>();
  do {
    passConstructors.clear();
    for (    PsiMethod method : newConstructors) {
      final PsiReference[] references=constructorsToRefs.get(method);
      for (      PsiReference reference : references) {
        PsiMethod overridingConstructor=getOverridingConstructorOfSuperCall(reference.getElement());
        if (overridingConstructor != null && !constructorsToRefs.containsKey(overridingConstructor)) {
          PsiReference[] overridingConstructorReferences=searchHelper.findReferences(overridingConstructor,GlobalSearchScope.projectScope(myProject),false);
          constructorsToRefs.put(overridingConstructor,overridingConstructorReferences);
          passConstructors.add(overridingConstructor);
        }
      }
    }
    newConstructors.clear();
    newConstructors.addAll(passConstructors);
  }
 while (!newConstructors.isEmpty());
  final HashSet<PsiMethod> validOverriding=validateOverridingMethods(constructor,originalReferences,constructorsToRefs.keySet(),constructorsToRefs,usages);
  addNonCodeUsages(constructor,usages,new UsageInsideDeleted(){
    public boolean isInsideDeleted(    PsiElement usage){
      if (usage instanceof PsiFile)       return false;
      return isInside(usage,myElements) || isInside(usage,validOverriding);
    }
  }
);
}
