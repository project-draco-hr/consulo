{
  if (HintManager.getInstance().hasShownHintsThatWillHideByOtherHint())   return false;
  if (isCaretNearRef(editor,ref))   return false;
  PsiManager manager=ref.getManager();
  if (manager == null)   return false;
  ApplicationManager.getApplication().assertReadAccessAllowed();
  PsiShortNamesCache cache=manager.getShortNamesCache();
  PsiElement refname=ref.getReferenceNameElement();
  if (!(refname instanceof PsiIdentifier)) {
    return false;
  }
  PsiElement refElement=ref.resolve();
  if (refElement != null) {
    return false;
  }
  String name=ref.getQualifiedName();
  if (manager.getResolveHelper().resolveReferencedClass(name,ref) != null)   return false;
  GlobalSearchScope scope=ref.getResolveScope();
  PsiClass[] classes=cache.getClassesByName(name,scope);
  if (classes.length == 0)   return false;
  try {
    Pattern pattern=Pattern.compile(DaemonCodeAnalyzerSettings.getInstance().NO_AUTO_IMPORT_PATTERN);
    Matcher matcher=pattern.matcher(name);
    if (matcher.matches())     return false;
  }
 catch (  PatternSyntaxException e) {
  }
  List<PsiClass> availableClasses=new ArrayList<PsiClass>();
  boolean isAnnotationReference=ref.getParent() instanceof PsiAnnotation;
  for (int j=0; j < classes.length; j++) {
    PsiClass aClass=classes[j];
    if (aClass.getParent() instanceof PsiDeclarationStatement)     continue;
    PsiFile file=aClass.getContainingFile();
    if (!(file instanceof PsiJavaFile) || ((PsiJavaFile)file).getPackageName().length() == 0)     continue;
    if (isAnnotationReference && !aClass.isAnnotationType())     continue;
    if (!aClass.hasModifierProperty(PsiModifier.PUBLIC))     continue;
    availableClasses.add(aClass);
  }
  if (availableClasses.size() == 0)   return false;
  int refTypeArgsLength=ref.getParameterList().getTypeArguments().length;
  if (availableClasses.size() > 0 && refTypeArgsLength != 0) {
    List<PsiClass> typeArgMatched=new ArrayList<PsiClass>(availableClasses);
    for (int i=typeArgMatched.size() - 1; i >= 0; i--) {
      final PsiClass aClass=typeArgMatched.get(i);
      PsiTypeParameter[] typeParameters=aClass.getTypeParameters();
      if (refTypeArgsLength != typeParameters.length) {
        typeArgMatched.remove(i);
      }
    }
    if (typeArgMatched.size() != 0) {
      availableClasses=typeArgMatched;
    }
  }
  classes=availableClasses.toArray(new PsiClass[availableClasses.size()]);
  CodeInsightUtil.sortIdenticalShortNameClasses(classes);
  String hintText=classes[0].getQualifiedName() + "? ";
  if (classes.length > 1) {
    hintText+="(multiple choices...) ";
  }
  hintText+=KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(IdeActions.ACTION_SHOW_INTENTION_ACTIONS));
  int offset1=ref.getTextOffset();
  int offset2=ref.getTextRange().getEndOffset();
  QuestionAction action=new AddImportAction(manager.getProject(),ref,classes,editor);
  if (classes.length == 1 && CodeInsightSettings.getInstance().ADD_UNAMBIGIOUS_IMPORTS_ON_THE_FLY) {
    action.execute();
    return false;
  }
  HintManager hintManager=HintManager.getInstance();
  hintManager.showQuestionHint(editor,hintText,offset1,offset2,action);
  return true;
}
