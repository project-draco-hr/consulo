{
  String error=null;
  boolean wasCheckedNode=false;
  boolean reorderMerges=false;
  for (int i=0; i < myTreeRoot.getChildCount(); i++) {
    CheckedTreeNode node=(CheckedTreeNode)myTreeRoot.getChildAt(i);
    boolean seenCheckedNode=false;
    boolean reorderNeeded=false;
    boolean seenMerges=false;
    boolean seenUnchecked=false;
    for (int j=0; j < node.getChildCount(); j++) {
      if (node.getChildAt(j) instanceof CheckedTreeNode) {
        CheckedTreeNode commitNode=(CheckedTreeNode)node.getChildAt(j);
        Commit commit=(Commit)commitNode.getUserObject();
        seenMerges|=commit.isMerge;
        if (commitNode.isChecked()) {
          seenCheckedNode=true;
        }
 else {
          seenUnchecked=true;
          if (seenCheckedNode) {
            reorderNeeded=true;
          }
        }
      }
    }
    if (!seenCheckedNode) {
      continue;
    }
    Root r=(Root)node.getUserObject();
    if (seenMerges && seenUnchecked) {
      error=GitBundle.getString("push.active.error.merges.unchecked");
    }
    if (seenMerges && reorderNeeded) {
      reorderMerges=true;
      error=GitBundle.getString("push.active.error.reorder.merges");
    }
    if (reorderNeeded) {
      if (error == null) {
        error=GitBundle.getString("push.active.error.reorder.needed");
      }
    }
    if (r.branch == null) {
      if (error == null) {
        error=GitBundle.getString("push.active.error.no.branch");
      }
      break;
    }
    wasCheckedNode|=r.remoteBranch != null;
    if (r.remoteCommits != 0 && r.commits.size() != 0) {
      if (error == null) {
        error=GitBundle.getString("push.active.error.behind");
      }
      break;
    }
  }
  boolean rebaseNeeded=isRebaseNeeded();
  setOKActionEnabled(wasCheckedNode && error == null && !rebaseNeeded);
  setErrorText(error);
  myRebaseButton.setEnabled(rebaseNeeded && !reorderMerges);
}
