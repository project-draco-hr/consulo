{
  if (rebaseInfo.reorderedCommits.isEmpty()) {
    return true;
  }
  ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
  if (progressIndicator == null) {
    progressIndicator=new EmptyProgressIndicator();
  }
  String stashMessage="Uncommitted changes before rebase operation at " + DateFormatUtil.formatDateTime(Clock.getTime());
  final GitChangesSaver saver=rebaseInfo.policy == GitVcsSettings.UpdateChangesPolicy.SHELVE ? new GitShelveChangesSaver(myProject,progressIndicator,stashMessage) : new GitStashChangesSaver(myProject,progressIndicator,stashMessage);
  final Boolean[] result=new Boolean[1];
  result[0]=false;
  final ProgressIndicator finalProgressIndicator=progressIndicator;
  new GitUpdateLikeProcess(myProject){
    @Override protected void runImpl(    ContinuationContext context){
      try {
        final Set<VirtualFile> rootsToReorder=rebaseInfo.reorderedCommits.keySet();
        saver.saveLocalChanges(rootsToReorder);
        try {
          GitRebaser rebaser=new GitRebaser(myProject,finalProgressIndicator);
          for (          Map.Entry<VirtualFile,List<String>> rootToCommits : rebaseInfo.reorderedCommits.entrySet()) {
            final VirtualFile root=rootToCommits.getKey();
            GitBranch b=GitBranch.current(myProject,root);
            if (b == null) {
              LOG.info("executeRebase: current branch is null");
              continue;
            }
            GitBranch t=b.tracked(myProject,root);
            if (t == null) {
              LOG.info("executeRebase: tracked branch is null");
              continue;
            }
            final GitRevisionNumber mergeBase=b.getMergeBase(myProject,root,t);
            if (mergeBase == null) {
              LOG.info("executeRebase: merge base is null for " + b + " and "+ t);
              continue;
            }
            String parentCommit=mergeBase.getRev();
            result[0]=rebaser.reoderCommitsIfNeeded(root,parentCommit,rootToCommits.getValue());
          }
        }
 catch (        VcsException e) {
          notifyMessage(myProject,"Commits weren't pushed","Failed to reorder commits",NotificationType.WARNING,true,Collections.singleton(e));
        }
 finally {
          saver.restoreLocalChanges(context);
        }
      }
 catch (      VcsException e) {
        LOG.info("Couldn't save local changes",e);
        notifyError(myProject,"Couldn't save local changes","Tried to save uncommitted changes in " + saver.getSaverName() + " before update, but failed with an error.<br/>"+ "Update was cancelled.",true,e);
      }
    }
  }
.execute();
  return result[0];
}
