{
  if (rebaseInfo.reorderedCommits.isEmpty()) {
    return true;
  }
  ProgressIndicator progressIndicator=ProgressManager.getInstance().getProgressIndicator();
  if (progressIndicator == null) {
    progressIndicator=new EmptyProgressIndicator();
  }
  String stashMessage="Uncommitted changes before rebase operation at " + DateFormatUtil.formatDateTime(Clock.getTime());
  GitChangesSaver saver=rebaseInfo.policy == GitVcsSettings.UpdateChangesPolicy.SHELVE ? new GitShelveChangesSaver(myProject,progressIndicator,stashMessage) : new GitStashChangesSaver(myProject,progressIndicator,stashMessage);
  final boolean saveOnFrameDeactivation=myGeneralSettings.isSaveOnFrameDeactivation();
  final boolean syncOnFrameDeactivation=myGeneralSettings.isSyncOnFrameActivation();
  myProjectManager.blockReloadingProjectOnExternalChanges();
  UIUtil.invokeAndWaitIfNeeded(new Runnable(){
    @Override public void run(){
      ApplicationManager.getApplication().runWriteAction(new Runnable(){
        @Override public void run(){
          FileDocumentManager.getInstance().saveAllDocuments();
          myGeneralSettings.setSaveOnFrameDeactivation(false);
          myGeneralSettings.setSyncOnFrameActivation(false);
        }
      }
);
    }
  }
);
  try {
    final Set<VirtualFile> rootsToReorder=rebaseInfo.reorderedCommits.keySet();
    saver.saveLocalChanges(rootsToReorder);
    try {
      GitRebaser rebaser=new GitRebaser(myProject);
      for (      Map.Entry<VirtualFile,List<String>> rootToCommits : rebaseInfo.reorderedCommits.entrySet()) {
        final VirtualFile root=rootToCommits.getKey();
        GitBranch b=GitBranch.current(myProject,root);
        if (b == null) {
          LOG.info("executeRebase: current branch is null");
          continue;
        }
        GitBranch t=b.tracked(myProject,root);
        if (t == null) {
          LOG.info("executeRebase: tracked branch is null");
          continue;
        }
        final GitRevisionNumber mergeBase=b.getMergeBase(myProject,root,t);
        if (mergeBase == null) {
          LOG.info("executeRebase: merge base is null for " + b + " and "+ t);
          continue;
        }
        String parentCommit=mergeBase.getRev();
        return rebaser.reoderCommitsIfNeeded(root,parentCommit,rootToCommits.getValue());
      }
    }
 catch (    VcsException e) {
      notifyMessage(myProject,"Commits weren't pushed","Failed to reorder commits",NotificationType.WARNING,true,Collections.singleton(e));
    }
 finally {
      try {
        saver.restoreLocalChanges();
      }
 catch (      VcsException e) {
        LOG.info("Couldn't restore local changes after reordering commits",e);
        notifyImportantError(myProject,"Couldn't restore local changes after update","Restoring changes saved before update failed with an error.<br/>" + e.getLocalizedMessage());
      }
    }
  }
 catch (  VcsException e) {
    LOG.info("Couldn't save local changes",e);
    notifyError(myProject,"Couldn't save local changes","Tried to save uncommitted changes in " + saver.getSaverName() + " before update, but failed with an error.<br/>"+ "Update was cancelled.",true,e);
  }
 finally {
    myProjectManager.unblockReloadingProjectOnExternalChanges();
    myGeneralSettings.setSaveOnFrameDeactivation(saveOnFrameDeactivation);
    myGeneralSettings.setSyncOnFrameActivation(syncOnFrameDeactivation);
  }
  return false;
}
