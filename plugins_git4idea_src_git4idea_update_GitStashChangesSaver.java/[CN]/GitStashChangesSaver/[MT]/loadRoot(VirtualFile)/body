{
  LOG.info("loadRoot " + root);
  myProgressIndicator.setText(GitHandlerUtil.formatOperationName("Unstashing changes to",root));
  final GitLineHandler handler=new GitLineHandler(myProject,root,GitCommand.STASH);
  handler.setNoSSH(true);
  handler.addParameters("pop");
  final AtomicBoolean conflict=new AtomicBoolean();
  handler.addLineListener(new GitLineHandlerAdapter(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (line.contains("Merge conflict")) {
        conflict.set(true);
      }
    }
  }
);
  final GitTask task=new GitTask(myProject,handler,"git stash pop");
  task.setExecuteResultInAwt(false);
  task.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
    }
    @Override protected void onCancel(){
      Notifications.Bus.notify(new Notification(GitVcs.NOTIFICATION_GROUP_ID,"Unstash cancelled","You may view the stashed changes <a href='saver'>here</a>",NotificationType.WARNING,new ShowSavedChangesNotificationListener()),myProject);
    }
    @Override protected void onFailure(){
      if (conflict.get()) {
        new GitMergeConflictResolver(myProject,true,"Uncommitted changes that were stashed before update have conflicts with updated files.","Can't update","").merge(Collections.singleton(root));
      }
 else {
        LOG.info("unstash failed " + handler.errors());
        GitUIUtil.notifyImportantError(myProject,"Couldn't unstash","<br/>" + GitUIUtil.stringifyErrors(handler.errors()));
      }
    }
  }
);
}
