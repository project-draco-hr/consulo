{
  LOG.info("loadRoot " + root);
  myProgressIndicator.setText(GitHandlerUtil.formatOperationName("Unstashing changes to",root));
  final GitLineHandler handler=new GitLineHandler(myProject,root,GitCommand.STASH);
  handler.setNoSSH(true);
  handler.addParameters("pop");
  final AtomicBoolean conflict=new AtomicBoolean();
  handler.addLineListener(new GitLineHandlerAdapter(){
    @Override public void onLineAvailable(    String line,    Key outputType){
      if (line.contains("Merge conflict")) {
        conflict.set(true);
      }
    }
  }
);
  final GitTask task=new GitTask(myProject,handler,"git stash pop");
  task.setExecuteResultInAwt(false);
  final AtomicBoolean failure=new AtomicBoolean();
  task.executeInBackground(true,new GitTaskResultHandlerAdapter(){
    @Override protected void onSuccess(){
    }
    @Override protected void onCancel(){
      Notifications.Bus.notify(new Notification(GitVcs.NOTIFICATION_GROUP_ID,"Unstash cancelled","You may view the stashed changes <a href='saver'>here</a>",WARNING,new ShowSavedChangesNotificationListener()),myProject);
    }
    @Override protected void onFailure(){
      failure.set(true);
    }
  }
);
  if (failure.get()) {
    if (conflict.get()) {
      boolean conflictsResolved=new UnstashConflictResolver().merge(Collections.singleton(root));
      if (conflictsResolved) {
        LOG.info("loadRoot " + root + " conflicts resolved, dropping stash");
        dropStash(root);
      }
    }
 else {
      LOG.info("unstash failed " + handler.errors());
      GitUIUtil.notifyImportantError(myProject,"Couldn't unstash","<br/>" + GitUIUtil.stringifyErrors(handler.errors()));
    }
  }
}
