{
  String title="Delete Remote Branch";
  String message="Delete remote branch " + branchName;
  boolean delete;
  final boolean deleteTracking;
  if (trackingBranches.isEmpty()) {
    delete=Messages.showYesNoDialog(myProject,message,title,"Delete","Cancel",Messages.getQuestionIcon()) == Messages.OK;
    deleteTracking=false;
  }
 else {
    if (currentBranchTracksBranchToDelete) {
      message+="\n\nCurrent branch " + GitBranchUtil.getCurrentBranchOrRev(repositories) + " tracks "+ branchName+ " but won't be deleted.";
    }
    final String checkboxMessage;
    if (trackingBranches.size() == 1) {
      checkboxMessage="Delete tracking local branch " + trackingBranches.iterator().next() + " as well";
    }
 else {
      checkboxMessage="Delete tracking local branches " + StringUtil.join(trackingBranches,", ");
    }
    final AtomicBoolean deleteChoice=new AtomicBoolean();
    delete=Messages.OK == Messages.showYesNoDialog(message,title,"Delete","Cancel",Messages.getQuestionIcon(),new DialogWrapper.DoNotAskOption(){
      @Override public boolean isToBeShown(){
        return true;
      }
      @Override public void setToBeShown(      boolean value,      int exitCode){
        deleteChoice.set(!value);
      }
      @Override public boolean canBeHidden(){
        return true;
      }
      @Override public boolean shouldSaveOptionsOnCancel(){
        return false;
      }
      @Override public String getDoNotShowMessage(){
        return checkboxMessage;
      }
    }
);
    deleteTracking=deleteChoice.get();
  }
  return new DeleteRemoteBranchDecision(delete,deleteTracking);
}
