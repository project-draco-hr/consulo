{
  final WhiteSpace whiteSpace=myCurrentBlock.getWhiteSpace();
  final WrapImpl[] wraps=myCurrentBlock.getWraps();
  boolean wrapWasPresent=whiteSpace.containsLineFeeds();
  if (wrapWasPresent) {
    myFirstWrappedBlockOnLine=null;
  }
  if (whiteSpace.containsLineFeeds() && !whiteSpace.containsLineFeedsInitially()) {
    whiteSpace.removeLineFeeds(spacing,this);
  }
  boolean wrapIsPresent=whiteSpace.containsLineFeeds();
  for (  WrapImpl wrap : wraps) {
    wrap.processNextEntry(myCurrentBlock.getStartOffset());
  }
  WrapImpl wrap=getWrapToBeUsed(wraps);
  if (wrap != null || wrapIsPresent) {
    if (!wrapIsPresent && !canReplaceWrapCandidate(wrap)) {
      myCurrentBlock=myWrapCandidate;
      return true;
    }
 else {
      if (wrap != null && wrap.getFirstEntry() != null) {
        myCurrentBlock=wrap.getFirstEntry();
        wrap.markAsUsed();
        return true;
      }
 else {
        if (wrap != null && wrapCanBeUsedInTheFuture(wrap)) {
          wrap.markAsUsed();
        }
      }
    }
    if (!whiteSpace.containsLineFeeds()) {
      whiteSpace.ensureLineFeed();
      if (!wrapWasPresent && wrap != null) {
        if (myFirstWrappedBlockOnLine != null && wrap.isChildOf(myFirstWrappedBlockOnLine.getWrap())) {
          wrap.ignoreParentWrap(myFirstWrappedBlockOnLine.getWrap());
          myCurrentBlock=myFirstWrappedBlockOnLine;
          return true;
        }
 else {
          myFirstWrappedBlockOnLine=myCurrentBlock;
        }
      }
    }
    myWrapCandidate=null;
  }
 else {
    for (    WrapImpl wrap1 : wraps) {
      if (isCandidateToBeWrapped(wrap1) && canReplaceWrapCandidate(wrap1)) {
        myWrapCandidate=myCurrentBlock;
      }
      if (wrapCanBeUsedInTheFuture(wrap1)) {
        wrap1.saveFirstEntry(myCurrentBlock);
      }
    }
  }
  if (!whiteSpace.containsLineFeeds() && lineOver() && myWrapCandidate != null && !whiteSpace.isReadOnly()) {
    myCurrentBlock=myWrapCandidate;
    return true;
  }
  return false;
}
