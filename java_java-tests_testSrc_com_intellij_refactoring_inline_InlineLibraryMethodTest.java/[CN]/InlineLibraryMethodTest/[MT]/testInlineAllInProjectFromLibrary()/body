{
  configureByText(JavaFileType.INSTANCE,"package mycompany;\n" + "public class File {\n" + " public static File createTempFile(String pr, String postfix){return createTempFile(pr, postfix, null);}\n"+ " public static File createTempFile(String pr, String postfix, String base){return new File();}\n"+ "}");
  @NonNls String fileName="/refactoring/inlineMethod/" + getTestName(false) + ".java";
  configureByFile(fileName);
  PsiClass fileClass=JavaPsiFacade.getInstance(getProject()).findClass("mycompany.File");
  assertTrue(fileClass != null);
  PsiFile file=fileClass.getContainingFile();
  ((VirtualFileSystemEntry)file.getVirtualFile()).setWritable(false);
  PsiElement element=null;
  PsiMethod[] createTempFiles=fileClass.findMethodsByName("createTempFile",false);
  for (  PsiMethod createTempFile : createTempFiles) {
    if (createTempFile.getParameterList().getParametersCount() == 2) {
      element=createTempFile;
      break;
    }
  }
  assertTrue(element != null);
  PsiMethod method=(PsiMethod)element;
  final boolean condition=InlineMethodProcessor.checkBadReturns(method) && !InlineUtil.allUsagesAreTailCalls(method);
  assertFalse("Bad returns found",condition);
  final InlineMethodProcessor processor=new InlineMethodProcessor(getProject(),method,null,myEditor,false);
  processor.run();
  checkResultByFile(fileName + ".after");
}
