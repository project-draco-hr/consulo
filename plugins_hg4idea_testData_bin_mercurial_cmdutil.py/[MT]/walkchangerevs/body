def walkchangerevs(repo, match, opts, prepare):
    'Iterate over files and the revs in which they changed.\n\n    Callers most commonly need to iterate backwards over the history\n    in which they are interested. Doing so has awful (quadratic-looking)\n    performance, so we use iterators in a "windowed" way.\n\n    We walk a window of revisions in the desired order.  Within the\n    window, we first walk forwards to gather data, then in the desired\n    order (usually backwards) to display it.\n\n    This function returns an iterator yielding contexts. Before\n    yielding each context, the iterator will first call the prepare\n    function on each context in the window in forward order.'

    def increasing_windows(start, end, windowsize=8, sizelimit=512):
        if (start < end):
            while (start < end):
                yield (start, min(windowsize, (end - start)))
                start += windowsize
                if (windowsize < sizelimit):
                    windowsize *= 2
        else:
            while (start > end):
                yield (start, min(windowsize, ((start - end) - 1)))
                start -= windowsize
                if (windowsize < sizelimit):
                    windowsize *= 2
    follow = (opts.get('follow') or opts.get('follow_first'))
    if (not len(repo)):
        return []
    if follow:
        defrange = ('%s:0' % repo['.'].rev())
    else:
        defrange = '-1:0'
    revs = revrange(repo, (opts['rev'] or [defrange]))
    wanted = set()
    slowpath = (match.anypats() or (match.files() and opts.get('removed')))
    fncache = {}
    change = util.cachefunc(repo.changectx)
    if ((not slowpath) and (not match.files())):
        wanted = set(revs)
    copies = []
    if (not slowpath):

        def filerevgen(filelog, node):
            cl_count = len(repo)
            if (node is None):
                last = (len(filelog) - 1)
            else:
                last = filelog.rev(node)
            for (i, window) in increasing_windows(last, nullrev):
                revs = []
                for j in xrange((i - window), (i + 1)):
                    n = filelog.node(j)
                    revs.append((filelog.linkrev(j), (follow and filelog.renamed(n))))
                for rev in reversed(revs):
                    if (rev[0] < cl_count):
                        yield rev

        def iterfiles():
            for filename in match.files():
                yield (filename, None)
            for filename_node in copies:
                yield filename_node
        (minrev, maxrev) = (min(revs), max(revs))
        for (file_, node) in iterfiles():
            filelog = repo.file(file_)
            if (not len(filelog)):
                if (node is None):
                    if follow:
                        raise util.Abort((_('cannot follow nonexistent file: "%s"') % file_))
                    slowpath = True
                    break
                else:
                    continue
            for (rev, copied) in filerevgen(filelog, node):
                if (rev <= maxrev):
                    if (rev < minrev):
                        break
                    fncache.setdefault(rev, [])
                    fncache[rev].append(file_)
                    wanted.add(rev)
                    if (follow and copied):
                        copies.append(copied)
    if slowpath:
        if follow:
            raise util.Abort(_('can only follow copies/renames for explicit filenames'))

        def changerevgen():
            for (i, window) in increasing_windows((len(repo) - 1), nullrev):
                for j in xrange((i - window), (i + 1)):
                    yield change(j)
        for ctx in changerevgen():
            matches = filter(match, ctx.files())
            if matches:
                fncache[ctx.rev()] = matches
                wanted.add(ctx.rev())


    class followfilter(object):

        def __init__(self, onlyfirst=False):
            self.startrev = nullrev
            self.roots = set()
            self.onlyfirst = onlyfirst

        def match(self, rev):

            def realparents(rev):
                if self.onlyfirst:
                    return repo.changelog.parentrevs(rev)[0:1]
                else:
                    return filter((lambda x: (x != nullrev)), repo.changelog.parentrevs(rev))
            if (self.startrev == nullrev):
                self.startrev = rev
                return True
            if (rev > self.startrev):
                if (not self.roots):
                    self.roots.add(self.startrev)
                for parent in realparents(rev):
                    if (parent in self.roots):
                        self.roots.add(rev)
                        return True
            else:
                if (not self.roots):
                    self.roots.update(realparents(self.startrev))
                if (rev in self.roots):
                    self.roots.remove(rev)
                    self.roots.update(realparents(rev))
                    return True
            return False
    for rev in opts.get('prune', ()):
        rev = repo.changelog.rev(repo.lookup(rev))
        ff = followfilter()
        stop = min(revs[0], revs[(-1)])
        for x in xrange(rev, (stop - 1), (-1)):
            if ff.match(x):
                wanted.discard(x)

    def iterate():
        if (follow and (not match.files())):
            ff = followfilter(onlyfirst=opts.get('follow_first'))

            def want(rev):
                return (ff.match(rev) and (rev in wanted))
        else:

            def want(rev):
                return (rev in wanted)
        for (i, window) in increasing_windows(0, len(revs)):
            change = util.cachefunc(repo.changectx)
            nrevs = [rev for rev in revs[i:(i + window)] if want(rev)]
            for rev in sorted(nrevs):
                fns = fncache.get(rev)
                ctx = change(rev)
                if (not fns):

                    def fns_generator():
                        for f in ctx.files():
                            if match(f):
                                yield f
                    fns = fns_generator()
                prepare(ctx, fns)
            for rev in nrevs:
                yield change(rev)
    return iterate()
