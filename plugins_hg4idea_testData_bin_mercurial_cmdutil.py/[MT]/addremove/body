def addremove(repo, pats=[], opts={}, dry_run=None, similarity=None):
    if (dry_run is None):
        dry_run = opts.get('dry_run')
    if (similarity is None):
        similarity = float((opts.get('similarity') or 0))
    (added, unknown, deleted, removed) = ([], [], [], [])
    audit_path = util.path_auditor(repo.root)
    m = match(repo, pats, opts)
    for abs in repo.walk(m):
        target = repo.wjoin(abs)
        good = True
        try:
            audit_path(abs)
        except:
            good = False
        rel = m.rel(abs)
        exact = m.exact(abs)
        if (good and (abs not in repo.dirstate)):
            unknown.append(abs)
            if (repo.ui.verbose or (not exact)):
                repo.ui.status((_('adding %s\n') % ((pats and rel) or abs)))
        elif ((repo.dirstate[abs] != 'r') and ((not good) or (not util.lexists(target)) or (os.path.isdir(target) and (not os.path.islink(target))))):
            deleted.append(abs)
            if (repo.ui.verbose or (not exact)):
                repo.ui.status((_('removing %s\n') % ((pats and rel) or abs)))
        elif (repo.dirstate[abs] == 'r'):
            removed.append(abs)
        elif (repo.dirstate[abs] == 'a'):
            added.append(abs)
    if (not dry_run):
        repo.remove(deleted)
        repo.add(unknown)
    if (similarity > 0):
        for (old, new, score) in findrenames(repo, (added + unknown), (removed + deleted), similarity):
            if (repo.ui.verbose or (not m.exact(old)) or (not m.exact(new))):
                repo.ui.status((_('recording removal of %s as rename to %s (%d%% similar)\n') % (m.rel(old), m.rel(new), (score * 100))))
            if (not dry_run):
                repo.copy(old, new)
