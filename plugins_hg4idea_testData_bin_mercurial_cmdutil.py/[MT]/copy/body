def copy(ui, repo, pats, opts, rename=False):
    cwd = repo.getcwd()
    targets = {}
    after = opts.get('after')
    dryrun = opts.get('dry_run')

    def walkpat(pat):
        srcs = []
        m = match(repo, [pat], opts, globbed=True)
        for abs in repo.walk(m):
            state = repo.dirstate[abs]
            rel = m.rel(abs)
            exact = m.exact(abs)
            if (state in '?r'):
                if (exact and (state == '?')):
                    ui.warn((_('%s: not copying - file is not managed\n') % rel))
                if (exact and (state == 'r')):
                    ui.warn((_('%s: not copying - file has been marked for remove\n') % rel))
                continue
            srcs.append((abs, rel, exact))
        return srcs

    def copyfile(abssrc, relsrc, otarget, exact):
        abstarget = util.canonpath(repo.root, cwd, otarget)
        reltarget = repo.pathto(abstarget, cwd)
        target = repo.wjoin(abstarget)
        src = repo.wjoin(abssrc)
        state = repo.dirstate[abstarget]
        prevsrc = targets.get(abstarget)
        if (prevsrc is not None):
            ui.warn((_('%s: not overwriting - %s collides with %s\n') % (reltarget, repo.pathto(abssrc, cwd), repo.pathto(prevsrc, cwd))))
            return
        exists = os.path.exists(target)
        if (((not after) and exists) or (after and (state in 'mn'))):
            if (not opts['force']):
                ui.warn((_('%s: not overwriting - file exists\n') % reltarget))
                return
        if after:
            if (not exists):
                return
        elif (not dryrun):
            try:
                if exists:
                    os.unlink(target)
                targetdir = (os.path.dirname(target) or '.')
                if (not os.path.isdir(targetdir)):
                    os.makedirs(targetdir)
                util.copyfile(src, target)
            except IOError as inst:
                if (inst.errno == errno.ENOENT):
                    ui.warn((_('%s: deleted in working copy\n') % relsrc))
                else:
                    ui.warn((_('%s: cannot copy - %s\n') % (relsrc, inst.strerror)))
                    return True
        if (ui.verbose or (not exact)):
            if rename:
                ui.status((_('moving %s to %s\n') % (relsrc, reltarget)))
            else:
                ui.status((_('copying %s to %s\n') % (relsrc, reltarget)))
        targets[abstarget] = abssrc
        origsrc = (repo.dirstate.copied(abssrc) or abssrc)
        if (abstarget == origsrc):
            if ((state not in 'mn') and (not dryrun)):
                repo.dirstate.normallookup(abstarget)
        elif ((repo.dirstate[origsrc] == 'a') and (origsrc == abssrc)):
            if (not ui.quiet):
                ui.warn((_('%s has not been committed yet, so no copy data will be stored for %s.\n') % (repo.pathto(origsrc, cwd), reltarget)))
            if ((repo.dirstate[abstarget] in '?r') and (not dryrun)):
                repo.add([abstarget])
        elif (not dryrun):
            repo.copy(origsrc, abstarget)
        if (rename and (not dryrun)):
            repo.remove([abssrc], (not after))

    def targetpathfn(pat, dest, srcs):
        if os.path.isdir(pat):
            abspfx = util.canonpath(repo.root, cwd, pat)
            abspfx = util.localpath(abspfx)
            if destdirexists:
                striplen = len(os.path.split(abspfx)[0])
            else:
                striplen = len(abspfx)
            if striplen:
                striplen += len(os.sep)
            res = (lambda p: os.path.join(dest, util.localpath(p)[striplen:]))
        elif destdirexists:
            res = (lambda p: os.path.join(dest, os.path.basename(util.localpath(p))))
        else:
            res = (lambda p: dest)
        return res

    def targetpathafterfn(pat, dest, srcs):
        if _match.patkind(pat):
            res = (lambda p: os.path.join(dest, os.path.basename(util.localpath(p))))
        else:
            abspfx = util.canonpath(repo.root, cwd, pat)
            if (len(abspfx) < len(srcs[0][0])):

                def evalpath(striplen):
                    score = 0
                    for s in srcs:
                        t = os.path.join(dest, util.localpath(s[0])[striplen:])
                        if os.path.exists(t):
                            score += 1
                    return score
                abspfx = util.localpath(abspfx)
                striplen = len(abspfx)
                if striplen:
                    striplen += len(os.sep)
                if os.path.isdir(os.path.join(dest, os.path.split(abspfx)[1])):
                    score = evalpath(striplen)
                    striplen1 = len(os.path.split(abspfx)[0])
                    if striplen1:
                        striplen1 += len(os.sep)
                    if (evalpath(striplen1) > score):
                        striplen = striplen1
                res = (lambda p: os.path.join(dest, util.localpath(p)[striplen:]))
            elif destdirexists:
                res = (lambda p: os.path.join(dest, os.path.basename(util.localpath(p))))
            else:
                res = (lambda p: dest)
        return res
    pats = expandpats(pats)
    if (not pats):
        raise util.Abort(_('no source or destination specified'))
    if (len(pats) == 1):
        raise util.Abort(_('no destination specified'))
    dest = pats.pop()
    destdirexists = (os.path.isdir(dest) and (not os.path.islink(dest)))
    if (not destdirexists):
        if ((len(pats) > 1) or _match.patkind(pats[0])):
            raise util.Abort(_('with multiple sources, destination must be an existing directory'))
        if util.endswithsep(dest):
            raise util.Abort((_('destination %s is not a directory') % dest))
    tfn = targetpathfn
    if after:
        tfn = targetpathafterfn
    copylist = []
    for pat in pats:
        srcs = walkpat(pat)
        if (not srcs):
            continue
        copylist.append((tfn(pat, dest, srcs), srcs))
    if (not copylist):
        raise util.Abort(_('no files to copy'))
    errors = 0
    for (targetpath, srcs) in copylist:
        for (abssrc, relsrc, exact) in srcs:
            if copyfile(abssrc, relsrc, targetpath(abssrc), exact):
                errors += 1
    if errors:
        ui.warn(_('(consider using --after)\n'))
    return errors
