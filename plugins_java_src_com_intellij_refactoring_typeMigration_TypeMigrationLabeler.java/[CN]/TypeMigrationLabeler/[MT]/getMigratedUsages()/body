{
  final LinkedList<Pair<TypeMigrationUsageInfo,PsiType>> declarations=getTypeEvaluator().getMigratedDeclarations();
  final TypeMigrationUsageInfo[] usages=new TypeMigrationUsageInfo[declarations.size() + myConversions.size() + myNewExpressionTypeChange.size()+ myClassTypeArgumentsChange.size()];
  int j=0;
  List<PsiElement> conversionExprs=new ArrayList<PsiElement>(myConversions.keySet());
  Collections.sort(conversionExprs,new Comparator<PsiElement>(){
    public int compare(    final PsiElement e1,    final PsiElement e2){
      return e2.getTextRange().getStartOffset() - e1.getTextRange().getStartOffset();
    }
  }
);
  for (  final PsiElement element : conversionExprs) {
    final Object conv=myConversions.get(element);
    usages[j++]=new TypeMigrationUsageInfo(element){
      public String getTooltipText(){
        if (conv instanceof String) {
          final String conversion=(String)conv;
          return "Replaced with " + conversion.replaceAll("\\$",element.getText());
        }
 else {
          return "Replaced with " + conv.toString();
        }
      }
      @Override public boolean isExcluded(){
        if (conv instanceof TypeConversionDescriptorBase)         return ((TypeConversionDescriptorBase)conv).getRoot().isExcluded();
        return super.isExcluded();
      }
    }
;
  }
  for (  final Pair<TypeMigrationUsageInfo,PsiType> p : declarations) {
    final TypeMigrationUsageInfo element=p.getFirst();
    usages[j++]=element;
  }
  for (  TypeMigrationUsageInfo info : myClassTypeArgumentsChange.keySet()) {
    usages[j++]=info;
  }
  for (  final TypeMigrationUsageInfo expr : myNewExpressionTypeChange.keySet()) {
    usages[j++]=expr;
  }
  return usages;
}
