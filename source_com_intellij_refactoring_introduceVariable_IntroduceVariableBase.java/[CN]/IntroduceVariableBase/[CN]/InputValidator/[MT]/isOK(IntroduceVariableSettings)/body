{
  String name=settings.getEnteredName();
  final PsiElement anchor;
  final boolean replaceAllOccurrences=settings.isReplaceAllOccurrences();
  if (replaceAllOccurrences) {
    anchor=myAnchorStatementIfAll;
  }
 else {
    anchor=myAnchorStatement;
  }
  final PsiElement scope=anchor.getParent();
  if (scope == null)   return true;
  final ArrayList<String> conflicts=new ArrayList<String>();
  final HashSet<PsiVariable> reportedVariables=new HashSet<PsiVariable>();
  RenameUtil.CollidingVariableVisitor visitor=new RenameUtil.CollidingVariableVisitor(){
    public void visitCollidingElement(    PsiVariable collidingVariable){
      if (collidingVariable instanceof PsiField)       return;
      if (!reportedVariables.contains(collidingVariable)) {
        reportedVariables.add(collidingVariable);
        String message="Introduced variable will conflict with " + ConflictsUtil.getDescription(collidingVariable,true);
        conflicts.add(message);
      }
    }
  }
;
  RenameUtil.visitLocalsCollisions(anchor,name,scope,anchor,visitor);
  if (replaceAllOccurrences) {
    final PsiExpression[] occurences=myOccurenceManager.getOccurences();
    for (int i=0; i < occurences.length; i++) {
      PsiExpression occurence=occurences[i];
      checkInLoopCondition(occurence,conflicts);
    }
  }
 else {
    checkInLoopCondition(myOccurenceManager.getMainOccurence(),conflicts);
  }
  if (conflicts.size() > 0) {
    return reportConflicts(conflicts,myProject);
  }
 else {
    return true;
  }
}
