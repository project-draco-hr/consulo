{
  final PsiReference invocationReference=editor != null ? TargetElementUtilBase.findReference(editor) : null;
  final InlineHandler.Settings settings=languageSpecific.prepareInlineElement(element,editor,invocationReference != null);
  if (settings == null || settings == InlineHandler.Settings.CANNOT_INLINE_SETTINGS) {
    return settings != null;
  }
  final Collection<PsiReference> allReferences;
  if (settings.isOnlyOneReferenceToInline()) {
    allReferences=Collections.singleton(invocationReference);
  }
 else {
    final Ref<Collection<PsiReference>> usagesRef=new Ref<Collection<PsiReference>>();
    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable(){
      @Override public void run(){
        final ReferencesToInlineSearcher searcher=ReferencesToInlineSearchers.getSearcher(element.getLanguage());
        if (searcher != null) {
          usagesRef.set(searcher.findReferences(element));
        }
 else {
          usagesRef.set(ReferencesSearch.search(element).findAll());
        }
      }
    }
,"Find Usages",false,element.getProject());
    allReferences=usagesRef.get();
  }
  final Map<Language,InlineHandler.Inliner> inliners=new HashMap<Language,InlineHandler.Inliner>();
  final MultiMap<PsiElement,String> conflicts=new MultiMap<PsiElement,String>();
  for (  PsiReference ref : allReferences) {
    final Language language=ref.getElement().getLanguage();
    if (inliners.containsKey(language))     continue;
    InlineHandler.Inliner inliner=null;
    final List<InlineHandler> handlers=InlineHandlers.getInlineHandlers(language);
    for (    InlineHandler handler : handlers) {
      inliner=handler.createInliner(element,settings);
      if (inliner != null) {
        inliners.put(language,inliner);
        break;
      }
    }
    if (inliner == null) {
      conflicts.putValue(null,"Cannot inline reference from " + language.getID());
    }
  }
  for (  PsiReference reference : allReferences) {
    collectConflicts(reference,element,inliners,conflicts);
  }
  final Project project=element.getProject();
  if (!conflicts.isEmpty()) {
    if (ApplicationManager.getApplication().isUnitTestMode()) {
      throw new BaseRefactoringProcessor.ConflictsInTestsException(conflicts.values());
    }
 else {
      final ConflictsDialog conflictsDialog=new ConflictsDialog(project,conflicts);
      conflictsDialog.show();
      if (!conflictsDialog.isOK()) {
        return true;
      }
    }
  }
  HashSet<PsiElement> elements=new HashSet<PsiElement>();
  for (  PsiReference reference : allReferences) {
    PsiElement refElement=reference.getElement();
    if (refElement != null) {
      elements.add(refElement);
    }
  }
  if (!settings.isOnlyOneReferenceToInline()) {
    elements.add(element);
  }
  if (!CommonRefactoringUtil.checkReadOnlyStatusRecursively(project,elements,true)) {
    return true;
  }
  ApplicationManager.getApplication().runWriteAction(new Runnable(){
    public void run(){
      final String subj=element instanceof PsiNamedElement ? ((PsiNamedElement)element).getName() : "element";
      CommandProcessor.getInstance().executeCommand(project,new Runnable(){
        public void run(){
          final PsiReference[] references=sortDepthFirstRightLeftOrder(allReferences);
          final UsageInfo[] usages=new UsageInfo[references.length];
          for (int i=0; i < references.length; i++) {
            usages[i]=new UsageInfo(references[i]);
          }
          for (          UsageInfo usage : usages) {
            inlineReference(usage,element,inliners);
          }
          if (!settings.isOnlyOneReferenceToInline()) {
            languageSpecific.removeDefinition(element,settings);
          }
        }
      }
,RefactoringBundle.message("inline.command",subj),null);
    }
  }
);
  return true;
}
