{
  Object value=originalExpression.getValue();
  if (!(value instanceof String))   return;
  Project project=holder.getProject();
  if (!shouldCheck(project,originalExpression))   return;
  final String stringToFind=(String)value;
  if (stringToFind.length() == 0)   return;
  final GlobalSearchScope scope=GlobalSearchScope.projectScope(originalExpression.getProject());
  final PsiSearchHelper searchHelper=PsiSearchHelper.SERVICE.getInstance(holder.getFile().getProject());
  final List<String> words=StringUtil.getWordsIn(stringToFind);
  if (words.isEmpty())   return;
  Collections.sort(words,new Comparator<String>(){
    @Override public int compare(    final String o1,    final String o2){
      return o2.length() - o1.length();
    }
  }
);
  ProgressIndicator progress=ProgressManager.getInstance().getProgressIndicator();
  Set<PsiFile> resultFiles=null;
  for (  String word : words) {
    if (word.length() < MIN_STRING_LENGTH) {
      continue;
    }
    progress.checkCanceled();
    final Set<PsiFile> files=new THashSet<PsiFile>();
    searchHelper.processAllFilesWithWordInLiterals(word,scope,new CommonProcessors.CollectProcessor<PsiFile>(files));
    if (resultFiles == null) {
      resultFiles=files;
    }
 else {
      resultFiles.retainAll(files);
    }
    if (resultFiles.isEmpty())     return;
  }
  if (resultFiles == null || resultFiles.isEmpty())   return;
  final List<PsiExpression> foundExpr=new ArrayList<PsiExpression>();
  for (  PsiFile file : resultFiles) {
    progress.checkCanceled();
    CharSequence text=file.getViewProvider().getContents();
    final char[] textArray=CharArrayUtil.fromSequenceWithoutCopying(text);
    StringSearcher searcher=new StringSearcher(stringToFind,true,true);
    for (int offset=LowLevelSearchUtil.searchWord(text,textArray,0,text.length(),searcher,progress); offset >= 0; offset=LowLevelSearchUtil.searchWord(text,textArray,offset + searcher.getPattern().length(),text.length(),searcher,progress)) {
      progress.checkCanceled();
      PsiElement element=file.findElementAt(offset);
      if (element == null || !(element.getParent() instanceof PsiLiteralExpression))       continue;
      PsiLiteralExpression expression=(PsiLiteralExpression)element.getParent();
      if (expression != originalExpression && Comparing.equal(stringToFind,expression.getValue()) && shouldCheck(project,expression)) {
        foundExpr.add(expression);
      }
    }
  }
  if (foundExpr.isEmpty())   return;
  Set<PsiClass> classes=new THashSet<PsiClass>();
  for (  PsiElement aClass : foundExpr) {
    progress.checkCanceled();
    do {
      aClass=PsiTreeUtil.getParentOfType(aClass,PsiClass.class);
    }
 while (aClass != null && ((PsiClass)aClass).getQualifiedName() == null);
    if (aClass != null) {
      classes.add((PsiClass)aClass);
    }
  }
  if (classes.isEmpty())   return;
  List<PsiClass> tenClassesMost=Arrays.asList(classes.toArray(new PsiClass[classes.size()]));
  if (tenClassesMost.size() > 10) {
    tenClassesMost=tenClassesMost.subList(0,10);
  }
  String classList;
  if (isOnTheFly) {
    classList=StringUtil.join(tenClassesMost,new Function<PsiClass,String>(){
      @Override public String fun(      final PsiClass aClass){
        final boolean thisFile=aClass.getContainingFile() == originalExpression.getContainingFile();
        return "&nbsp;&nbsp;&nbsp;'<b>" + aClass.getQualifiedName() + "</b>'"+ (thisFile ? " " + InspectionsBundle.message("inspection.duplicates.message.in.this.file") : "");
      }
    }
,", " + BR);
  }
 else {
    classList=StringUtil.join(tenClassesMost,new Function<PsiClass,String>(){
      @Override public String fun(      final PsiClass aClass){
        return "'" + aClass.getQualifiedName() + "'";
      }
    }
,", ");
  }
  if (classes.size() > tenClassesMost.size()) {
    classList+=BR + InspectionsBundle.message("inspection.duplicates.message.more",classes.size() - 10);
  }
  String msg=InspectionsBundle.message("inspection.duplicates.message",classList);
  Collection<LocalQuickFix> fixes=new SmartList<LocalQuickFix>();
  final LocalQuickFix introduceConstFix=createIntroduceConstFix(foundExpr,originalExpression);
  fixes.add(introduceConstFix);
  createReplaceFixes(foundExpr,originalExpression,fixes);
  LocalQuickFix[] array=fixes.toArray(new LocalQuickFix[fixes.size()]);
  holder.registerProblem(originalExpression,msg,ProblemHighlightType.GENERIC_ERROR_OR_WARNING,array);
}
