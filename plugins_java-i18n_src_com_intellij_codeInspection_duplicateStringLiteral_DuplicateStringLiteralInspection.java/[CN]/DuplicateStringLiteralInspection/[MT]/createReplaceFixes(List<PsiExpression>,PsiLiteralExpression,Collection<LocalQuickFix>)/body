{
  Set<PsiField> constants=new THashSet<PsiField>();
  for (Iterator<PsiExpression> iterator=foundExpr.iterator(); iterator.hasNext(); ) {
    PsiExpression expression1=iterator.next();
    if (expression1.getParent() instanceof PsiField) {
      final PsiField field=(PsiField)expression1.getParent();
      if (field.getInitializer() == expression1 && field.hasModifierProperty(PsiModifier.FINAL) && field.hasModifierProperty(PsiModifier.STATIC)) {
        constants.add(field);
        iterator.remove();
      }
    }
  }
  for (  final PsiField constant : constants) {
    final PsiClass containingClass=constant.getContainingClass();
    if (containingClass == null)     continue;
    boolean isAccessible=JavaPsiFacade.getInstance(constant.getProject()).getResolveHelper().isAccessible(constant,originalExpression,containingClass);
    if (!isAccessible && containingClass.getQualifiedName() == null) {
      continue;
    }
    final LocalQuickFix replaceQuickFix=new LocalQuickFix(){
      @NotNull public String getName(){
        return InspectionsBundle.message("inspection.duplicates.replace.quickfix",PsiFormatUtil.formatVariable(constant,PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_FQ_NAME | PsiFormatUtil.SHOW_NAME,PsiSubstitutor.EMPTY));
      }
      public void applyFix(      @NotNull final Project project,      @NotNull ProblemDescriptor descriptor){
        if (!CodeInsightUtilBase.prepareFileForWrite(originalExpression.getContainingFile()))         return;
        try {
          final PsiReferenceExpression reference=createReferenceTo(constant,originalExpression);
          if (reference != null) {
            originalExpression.replace(reference);
          }
        }
 catch (        IncorrectOperationException e) {
          LOG.error(e);
        }
      }
      @NotNull public String getFamilyName(){
        return InspectionsBundle.message("inspection.duplicates.replace.family.quickfix");
      }
    }
;
    fixes.add(replaceQuickFix);
  }
}
