{
  myChangesCacheFile.myLocation.onBeforeBatch();
  final Collection<FilePath> incomingFiles=myChangesCacheFile.myChangesProvider.getIncomingFiles(myChangesCacheFile.myLocation);
  myAnyChanges=false;
  myChangesCacheFile.openStreams();
  myChangesCacheFile.loadHeader();
  try {
    IncomingChangeState.header(myChangesCacheFile.myLocation.toPresentableString());
    final List<IncomingChangeListData> list=myChangesCacheFile.loadIncomingChangeListData();
    boolean shouldChangeHeader;
    if (incomingFiles != null && incomingFiles.isEmpty()) {
      shouldChangeHeader=!list.isEmpty();
      for (      IncomingChangeListData data : list) {
        myChangesCacheFile.saveIncoming(data,true);
      }
    }
 else {
      shouldChangeHeader=refreshIncomingInFile(incomingFiles,list);
    }
    IncomingChangeState.footer();
    if (shouldChangeHeader) {
      myChangesCacheFile.writeHeader();
    }
  }
  finally {
    myChangesCacheFile.myLocation.onAfterBatch();
    myChangesCacheFile.closeStreams();
  }
  return myAnyChanges;
}
