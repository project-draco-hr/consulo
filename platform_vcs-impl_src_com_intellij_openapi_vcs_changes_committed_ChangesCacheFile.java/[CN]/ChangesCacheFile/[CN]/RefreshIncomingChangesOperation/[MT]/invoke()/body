{
  if (myProject.isDisposed()) {
    return false;
  }
  myClManager=ChangeListManagerImpl.getInstanceImpl(myProject);
  final DiffProvider diffProvider=myVcs.getDiffProvider();
  if (diffProvider == null)   return false;
  final Collection<FilePath> incomingFiles=myChangesProvider.getIncomingFiles(myLocation);
  boolean anyChanges=false;
  openStreams();
  loadHeader();
  myCurrentRevisions=new FactoryMap<VirtualFile,VcsRevisionNumber>(){
    protected VcsRevisionNumber create(    final VirtualFile key){
      return diffProvider.getCurrentRevision(key);
    }
  }
;
  try {
    final List<IncomingChangeListData> list=loadIncomingChangeListData();
    myDeletedFiles=new HashSet<FilePath>();
    myCreatedFiles=new HashSet<FilePath>();
    myReplacedFiles=new HashSet<FilePath>();
    IncomingChangeState.header(myLocation.toPresentableString());
    for (    IncomingChangeListData data : list) {
      debug("Checking incoming changelist " + data.changeList.getNumber());
      boolean updated=false;
      for (      Change change : data.changeList.getChanges()) {
        if (data.accountedChanges.contains(change))         continue;
        final ContentRevision revision=(change.getAfterRevision() == null) ? change.getBeforeRevision() : change.getAfterRevision();
        final IncomingChangeState state=new IncomingChangeState(change,revision.getRevisionNumber().asString());
        final boolean changeFound=processIncomingChange(change,data,incomingFiles,state);
        state.logSelf();
        if (changeFound) {
          data.accountedChanges.add(change);
        }
        updated|=changeFound;
      }
      if (updated) {
        anyChanges=true;
        saveIncoming(data);
      }
    }
    IncomingChangeState.footer();
    if (anyChanges) {
      writeHeader();
    }
  }
  finally {
    closeStreams();
  }
  return anyChanges;
}
