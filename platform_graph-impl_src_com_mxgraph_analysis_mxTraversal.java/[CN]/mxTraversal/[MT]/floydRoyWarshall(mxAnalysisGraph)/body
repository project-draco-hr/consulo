{
  Object[] vertices=aGraph.getChildVertices(aGraph.getGraph().getDefaultParent());
  Double[][] dist=new Double[vertices.length][vertices.length];
  Object[][] paths=new Object[vertices.length][vertices.length];
  Map<Object,Integer> indexMap=new HashMap<Object,Integer>();
  for (int i=0; i < vertices.length; i++) {
    indexMap.put(vertices[i],i);
  }
  Object[] edges=aGraph.getChildEdges(aGraph.getGraph().getDefaultParent());
  dist=initializeWeight(aGraph,vertices,edges,indexMap);
  for (int k=0; k < vertices.length; k++) {
    for (int i=0; i < vertices.length; i++) {
      for (int j=0; j < vertices.length; j++) {
        if (dist[i][j] > dist[i][k] + dist[k][j]) {
          paths[i][j]=mxGraphStructure.getVertexWithValue(aGraph,k);
          dist[i][j]=dist[i][k] + dist[k][j];
        }
      }
    }
  }
  for (int i=0; i < dist[0].length; i++) {
    if ((Double)dist[i][i] < 0) {
      throw new StructuralException("The graph has negative cycles");
    }
  }
  ArrayList<Object[][]> result=new ArrayList<Object[][]>();
  result.add(dist);
  result.add(paths);
  return result;
}
