{
  mxGraph graph=aGraph.getGraph();
  Object[] vertices=aGraph.getChildVertices(graph.getDefaultParent());
  Object[] edges=aGraph.getChildEdges(graph.getDefaultParent());
  int vertexNum=vertices.length;
  int edgeNum=edges.length;
  Map<Object,Object> distanceMap=new HashMap<Object,Object>();
  Map<Object,Object> parentMap=new HashMap<Object,Object>();
  mxCostFunction costFunction=aGraph.getGenerator().getCostFunction();
  mxGraphView view=graph.getView();
  for (int i=0; i < vertexNum; i++) {
    Object currVertex=vertices[i];
    distanceMap.put(currVertex,Double.MAX_VALUE);
  }
  distanceMap.put(startVertex,0.0);
  parentMap.put(startVertex,startVertex);
  for (int i=0; i < vertexNum; i++) {
    for (int j=0; j < edgeNum; j++) {
      Object currEdge=edges[j];
      Object source=aGraph.getTerminal(currEdge,true);
      Object target=aGraph.getTerminal(currEdge,false);
      double dist=(Double)distanceMap.get(source) + costFunction.getCost(new mxCellState(view,currEdge,null));
      if (dist < (Double)distanceMap.get(target)) {
        distanceMap.put(target,dist);
        parentMap.put(target,source);
      }
      if (!mxGraphProperties.isDirected(aGraph.getProperties(),mxGraphProperties.DEFAULT_DIRECTED)) {
        dist=(Double)distanceMap.get(target) + costFunction.getCost(new mxCellState(view,currEdge,null));
        if (dist < (Double)distanceMap.get(source)) {
          distanceMap.put(source,dist);
          parentMap.put(source,target);
        }
      }
    }
  }
  for (int i=0; i < edgeNum; i++) {
    Object currEdge=edges[i];
    Object source=aGraph.getTerminal(currEdge,true);
    Object target=aGraph.getTerminal(currEdge,false);
    double dist=(Double)distanceMap.get(source) + costFunction.getCost(new mxCellState(view,currEdge,null));
    if (dist < (Double)distanceMap.get(target)) {
      throw new StructuralException("The graph contains a negative cycle, so Bellman-Ford can't be completed.");
    }
  }
  List<Map<Object,Object>> result=new ArrayList<Map<Object,Object>>();
  result.add(distanceMap);
  result.add(parentMap);
  return result;
}
