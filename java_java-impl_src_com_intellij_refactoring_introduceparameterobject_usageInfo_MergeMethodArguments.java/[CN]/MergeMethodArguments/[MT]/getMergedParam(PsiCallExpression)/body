{
  final PsiExpression[] args=call.getArgumentList().getExpressions();
  StringBuffer newExpression=new StringBuffer();
  final String qualifiedName;
  if (myContainingClass != null) {
    final String containingClassQName=myContainingClass.getQualifiedName();
    if (containingClassQName != null) {
      qualifiedName=containingClassQName + "." + className;
    }
 else {
      qualifiedName=className;
    }
  }
 else {
    qualifiedName=StringUtil.getQualifiedName(packageName,className);
  }
  newExpression.append("new ").append(qualifiedName);
  if (!typeParams.isEmpty()) {
    final JavaResolveResult resolvant=call.resolveMethodGenerics();
    final PsiSubstitutor substitutor=resolvant.getSubstitutor();
    newExpression.append('<');
    final Map<PsiTypeParameter,PsiType> substitutionMap=substitutor.getSubstitutionMap();
    newExpression.append(StringUtil.join(typeParams,new Function<PsiTypeParameter,String>(){
      public String fun(      final PsiTypeParameter typeParameter){
        final PsiType boundType=substitutionMap.get(typeParameter);
        if (boundType != null) {
          return boundType.getCanonicalText();
        }
 else {
          return typeParameter.getName();
        }
      }
    }
,", "));
    newExpression.append('>');
  }
  newExpression.append('(');
  boolean isFirst=true;
  for (  int index : paramsToMerge) {
    if (!isFirst) {
      newExpression.append(", ");
    }
    isFirst=false;
    newExpression.append(getArgument(args,index));
  }
  if (lastParamIsVararg) {
    final int lastArg=paramsToMerge[paramsToMerge.length - 1];
    for (int i=lastArg + 1; i < args.length; i++) {
      newExpression.append(',');
      newExpression.append(getArgument(args,i));
    }
  }
  newExpression.append(')');
  return newExpression.toString();
}
