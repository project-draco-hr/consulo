{
  try {
    final List<File> toCompile=collectChangedFiles(context,chunk);
    LOG.info((myForStubs ? "stubs" : "groovyc") + ", toCompile=" + toCompile);
    if (toCompile.isEmpty()) {
      return ExitCode.NOTHING_DONE;
    }
    Map<Module,String> finalOutputs=getCanonicalModuleOutputs(context,chunk);
    Map<Module,String> generationOutputs=getGenerationOutputs(chunk,finalOutputs);
    final Set<String> toCompilePaths=new LinkedHashSet<String>();
    for (    File file : toCompile) {
      toCompilePaths.add(FileUtil.toSystemIndependentName(file.getPath()));
    }
    Map<String,String> class2Src=buildClassToSourceMap(chunk,context,toCompilePaths,finalOutputs);
    final String encoding=context.getProjectDescriptor().getEncodingConfiguration().getPreferredModuleChunkEncoding(chunk);
    List<String> patchers=Collections.emptyList();
    String compilerOutput=generationOutputs.get(chunk.representativeModule());
    final File tempFile=GroovycOSProcessHandler.fillFileWithGroovycParameters(compilerOutput,toCompilePaths,FileUtil.toSystemDependentName(finalOutputs.get(chunk.representativeModule())),class2Src,encoding,patchers);
    final List<String> cmd=ExternalProcessUtil.buildJavaCommandLine(getJavaExecutable(chunk),"org.jetbrains.groovy.compiler.rt.GroovycRunner",Collections.<String>emptyList(),new ArrayList<String>(generateClasspath(context,chunk)),Arrays.asList("-Xmx384m","-Dfile.encoding=" + CharsetToolkit.getDefaultSystemCharset().name()),Arrays.<String>asList(myForStubs ? "stubs" : "groovyc",tempFile.getPath()));
    final Process process=Runtime.getRuntime().exec(ArrayUtil.toStringArray(cmd));
    GroovycOSProcessHandler handler=GroovycOSProcessHandler.runGroovyc(process,new Consumer<String>(){
      public void consume(      String s){
        context.processMessage(new ProgressMessage(s));
      }
    }
);
    if (!context.isProjectRebuild() && handler.shouldRetry()) {
      if (CHUNK_REBUILD_ORDERED.get(context) != null) {
        CHUNK_REBUILD_ORDERED.set(context,null);
      }
 else {
        CHUNK_REBUILD_ORDERED.set(context,Boolean.TRUE);
        LOG.info("Order chunk rebuild");
        return ExitCode.CHUNK_REBUILD_REQUIRED;
      }
    }
    if (myForStubs) {
      for (      Module module : generationOutputs.keySet()) {
        File root=new File(generationOutputs.get(module));
        context.getRootsIndex().associateRoot(root,module,context.isCompilingTests(),true,true);
      }
    }
    for (    CompilerMessage message : handler.getCompilerMessages()) {
      LOG.info(message.toString());
      context.processMessage(message);
    }
    List<GroovycOSProcessHandler.OutputItem> compiled=new ArrayList<GroovycOSProcessHandler.OutputItem>();
    for (    GroovycOSProcessHandler.OutputItem item : handler.getSuccessfullyCompiled()) {
      LOG.info("Compiled " + item);
      compiled.add(ensureCorrectOutput(context,chunk,item,generationOutputs,compilerOutput));
    }
    if (!myForStubs && updateDependencies(context,chunk,toCompile,generationOutputs,compiled)) {
      return ExitCode.ADDITIONAL_PASS_REQUIRED;
    }
    return ExitCode.OK;
  }
 catch (  Exception e) {
    throw new ProjectBuildException(e);
  }
}
