{
  final GitBranchesSearcher searcher=new GitBranchesSearcher(myProject,vcsRoot,true);
  if (searcher.getLocal() == null || searcher.getRemote() == null) {
    return new ArrayList<Change>(localChanges);
  }
  final GitRevisionNumber base;
  try {
    base=searcher.getLocal().getMergeBase(myProject,vcsRoot,searcher.getRemote());
  }
 catch (  VcsException e) {
    return new ArrayList<Change>(localChanges);
  }
  if (base == null) {
    return new ArrayList<Change>(localChanges);
  }
  final List<Pair<SHAHash,Date>> hashes=GitHistoryUtils.onlyHashesHistory(myProject,new FilePathImpl(vcsRoot),vcsRoot,(base.asString() + "..HEAD"));
  if (hashes.isEmpty())   return Collections.emptyList();
  final String first=hashes.get(0).getFirst().getValue();
  final Set<String> localHashes=new HashSet<String>();
  for (  Pair<SHAHash,Date> hash : hashes) {
    localHashes.add(hash.getFirst().getValue());
  }
  final Collection<Change> result=new ArrayList<Change>();
  for (  Change change : localChanges) {
    if (change.getBeforeRevision() != null) {
      final String changeBeforeRevision=change.getBeforeRevision().getRevisionNumber().asString().trim();
      if (first.equals(changeBeforeRevision) || localHashes.contains(changeBeforeRevision)) {
        result.add(change);
      }
    }
  }
  return result;
}
