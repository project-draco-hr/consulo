def findcommonincoming(self, remote, base=None, heads=None, force=False):
    'Return a tuple (common, missing roots, heads) used to identify\n        missing nodes from remote.\n\n        If base dict is specified, assume that these nodes and their parents\n        exist on the remote side and that no child of a node of base exists\n        in both remote and self.\n        Furthermore base will be updated to include the nodes that exists\n        in self and remote but no children exists in self and remote.\n        If a list of heads is specified, return only nodes which are heads\n        or ancestors of these heads.\n\n        All the ancestors of base are in self and in remote.\n        '
    m = self.changelog.nodemap
    search = []
    fetch = set()
    seen = set()
    seenbranch = set()
    if (base is None):
        base = {}
    if (not heads):
        heads = remote.heads()
    if (self.changelog.tip() == nullid):
        base[nullid] = 1
        if (heads != [nullid]):
            return ([nullid], [nullid], list(heads))
        return ([nullid], [], [])
    self.ui.status(_('searching for changes\n'))
    unknown = []
    for h in heads:
        if (h not in m):
            unknown.append(h)
        else:
            base[h] = 1
    heads = unknown
    if (not unknown):
        return (base.keys(), [], [])
    req = set(unknown)
    reqcnt = 0
    unknown = remote.branches(unknown)
    while unknown:
        r = []
        while unknown:
            n = unknown.pop(0)
            if (n[0] in seen):
                continue
            self.ui.debug(('examining %s:%s\n' % (short(n[0]), short(n[1]))))
            if (n[0] == nullid):
                pass
            elif (n in seenbranch):
                self.ui.debug('branch already found\n')
                continue
            elif (n[1] and (n[1] in m)):
                self.ui.debug(('found incomplete branch %s:%s\n' % (short(n[0]), short(n[1]))))
                search.append(n[0:2])
                seenbranch.add(n)
            else:
                if ((n[1] not in seen) and (n[1] not in fetch)):
                    if ((n[2] in m) and (n[3] in m)):
                        self.ui.debug(('found new changeset %s\n' % short(n[1])))
                        fetch.add(n[1])
                    for p in n[2:4]:
                        if (p in m):
                            base[p] = 1
                for p in n[2:4]:
                    if ((p not in req) and (p not in m)):
                        r.append(p)
                        req.add(p)
            seen.add(n[0])
        if r:
            reqcnt += 1
            self.ui.progress(_('searching'), reqcnt, unit=_('queries'))
            self.ui.debug(('request %d: %s\n' % (reqcnt, ' '.join(map(short, r)))))
            for p in xrange(0, len(r), 10):
                for b in remote.branches(r[p:(p + 10)]):
                    self.ui.debug(('received %s:%s\n' % (short(b[0]), short(b[1]))))
                    unknown.append(b)
    while search:
        newsearch = []
        reqcnt += 1
        self.ui.progress(_('searching'), reqcnt, unit=_('queries'))
        for (n, l) in zip(search, remote.between(search)):
            l.append(n[1])
            p = n[0]
            f = 1
            for i in l:
                self.ui.debug(('narrowing %d:%d %s\n' % (f, len(l), short(i))))
                if (i in m):
                    if (f <= 2):
                        self.ui.debug(('found new branch changeset %s\n' % short(p)))
                        fetch.add(p)
                        base[i] = 1
                    else:
                        self.ui.debug(('narrowed branch search to %s:%s\n' % (short(p), short(i))))
                        newsearch.append((p, i))
                    break
                (p, f) = (i, (f * 2))
            search = newsearch
    for f in fetch:
        if (f in m):
            raise error.RepoError((_('already have changeset ') + short(f[:4])))
    if (base.keys() == [nullid]):
        if force:
            self.ui.warn(_('warning: repository is unrelated\n'))
        else:
            raise util.Abort(_('repository is unrelated'))
    self.ui.debug((('found new changesets starting at ' + ' '.join([short(f) for f in fetch])) + '\n'))
    self.ui.progress(_('searching'), None, unit=_('queries'))
    self.ui.debug(('%d total queries\n' % reqcnt))
    return (base.keys(), list(fetch), heads)
