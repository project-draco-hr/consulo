def prepush(self, remote, force, revs):
    'Analyze the local and remote repositories and determine which\n        changesets need to be pushed to the remote.  Return a tuple\n        (changegroup, remoteheads).  changegroup is a readable file-like\n        object whose read() returns successive changegroup chunks ready to\n        be sent over the wire.  remoteheads is the list of remote heads.\n        '
    common = {}
    remote_heads = remote.heads()
    inc = self.findincoming(remote, common, remote_heads, force=force)
    cl = self.changelog
    (update, updated_heads) = self.findoutgoing(remote, common, remote_heads)
    (outg, bases, heads) = cl.nodesbetween(update, revs)
    if (not bases):
        self.ui.status(_('no changes found\n'))
        return (None, 1)
    if ((not force) and (remote_heads != [nullid])):

        def fail_multiple_heads(unsynced, branch=None):
            if branch:
                msg = (_("abort: push creates new remote heads on branch '%s'!\n") % branch)
            else:
                msg = _('abort: push creates new remote heads!\n')
            self.ui.warn(msg)
            if unsynced:
                self.ui.status(_('(you should pull and merge or use push -f to force)\n'))
            else:
                self.ui.status(_('(did you forget to merge? use push -f to force)\n'))
            return (None, 0)
        if remote.capable('branchmap'):
            branches = set((self[n].branch() for n in outg))
            remotemap = remote.branchmap()
            newbranches = (branches - set(remotemap))
            if newbranches:
                branchnames = ', '.join((('%s' % b) for b in newbranches))
                self.ui.warn((_('abort: push creates new remote branches: %s!\n') % branchnames))
                self.ui.status(_("(use 'hg push -f' to force)\n"))
                return (None, 0)
            oldmap = {}
            newmap = {}
            unsynced = set()
            for branch in branches:
                remoteheads = remotemap[branch]
                prunedheads = [h for h in remoteheads if (h in cl.nodemap)]
                oldmap[branch] = prunedheads
                newmap[branch] = list(prunedheads)
                if (len(remoteheads) > len(prunedheads)):
                    unsynced.add(branch)
            ctxgen = (self[n] for n in outg)
            self._updatebranchcache(newmap, ctxgen)
            for branch in branches:
                if (len(newmap[branch]) > len(oldmap[branch])):
                    return fail_multiple_heads((branch in unsynced), branch)
            if unsynced:
                self.ui.warn(_('note: unsynced remote changes!\n'))
        else:
            newheads = set((h for h in remote_heads if (h in cl.nodemap)))
            oldheadcnt = len(newheads)
            newheads.update(outg)
            if (len(newheads) > 1):
                for latest in reversed(outg):
                    if (latest not in newheads):
                        continue
                    minhrev = min((cl.rev(h) for h in newheads))
                    reachable = cl.reachable(latest, cl.node(minhrev))
                    reachable.remove(latest)
                    newheads.difference_update(reachable)
            if (len(newheads) > oldheadcnt):
                return fail_multiple_heads(inc)
            if inc:
                self.ui.warn(_('note: unsynced remote changes!\n'))
    if (revs is None):
        nodes = self.changelog.findmissing(common.keys())
        cg = self._changegroup(nodes, 'push')
    else:
        cg = self.changegroupsubset(update, revs, 'push')
    return (cg, remote_heads)
