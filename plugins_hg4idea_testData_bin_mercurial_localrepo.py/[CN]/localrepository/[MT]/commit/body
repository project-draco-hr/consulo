def commit(self, text='', user=None, date=None, match=None, force=False, editor=False, extra={}):
    'Add a new revision to current repository.\n\n        Revision information is gathered from the working directory,\n        match can be used to filter the committed files. If editor is\n        supplied, it is called to get a commit message.\n        '

    def fail(f, msg):
        raise util.Abort(('%s: %s' % (f, msg)))
    if (not match):
        match = match_.always(self.root, '')
    if (not force):
        vdirs = []
        match.dir = vdirs.append
        match.bad = fail
    wlock = self.wlock()
    try:
        (p1, p2) = self.dirstate.parents()
        wctx = self[None]
        if ((not force) and (p2 != nullid) and match and (match.files() or match.anypats())):
            raise util.Abort(_('cannot partially commit a merge (do not specify files or patterns)'))
        changes = self.status(match=match, clean=force)
        if force:
            changes[0].extend(changes[6])
        subs = []
        removedsubs = set()
        for p in wctx.parents():
            removedsubs.update((s for s in p.substate if match(s)))
        for s in wctx.substate:
            removedsubs.discard(s)
            if (match(s) and wctx.sub(s).dirty()):
                subs.append(s)
        if ((subs or removedsubs) and ('.hgsubstate' not in changes[0])):
            changes[0].insert(0, '.hgsubstate')
        if ((not force) and match.files()):
            matched = set(((changes[0] + changes[1]) + changes[2]))
            for f in match.files():
                if ((f == '.') or (f in matched) or (f in wctx.substate)):
                    continue
                if (f in changes[3]):
                    fail(f, _('file not found!'))
                if (f in vdirs):
                    d = (f + '/')
                    for mf in matched:
                        if mf.startswith(d):
                            break
                    else:
                        fail(f, _('no match under directory!'))
                elif (f not in self.dirstate):
                    fail(f, _('file not tracked!'))
        if ((not force) and (not extra.get('close')) and (p2 == nullid) and (not (changes[0] or changes[1] or changes[2])) and (self[None].branch() == self['.'].branch())):
            return None
        ms = merge_.mergestate(self)
        for f in changes[0]:
            if ((f in ms) and (ms[f] == 'u')):
                raise util.Abort(_('unresolved merge conflicts (see hg resolve)'))
        cctx = context.workingctx(self, (p1, p2), text, user, date, extra, changes)
        if editor:
            cctx._text = editor(self, cctx, subs)
        edited = (text != cctx._text)
        if (subs or removedsubs):
            state = wctx.substate.copy()
            for s in subs:
                self.ui.status((_('committing subrepository %s\n') % s))
                sr = wctx.sub(s).commit(cctx._text, user, date)
                state[s] = (state[s][0], sr)
            subrepo.writestate(self, state)
        msgfile = self.opener('last-message.txt', 'wb')
        msgfile.write(cctx._text)
        msgfile.close()
        try:
            (hookp1, hookp2) = (hex(p1), (((p2 != nullid) and hex(p2)) or ''))
            self.hook('precommit', throw=True, parent1=hookp1, parent2=hookp2)
            ret = self.commitctx(cctx, True)
        except:
            if edited:
                msgfn = self.pathto(msgfile.name[(len(self.root) + 1):])
                self.ui.write((_('note: commit message saved in %s\n') % msgfn))
            raise
        for f in (changes[0] + changes[1]):
            self.dirstate.normal(f)
        for f in changes[2]:
            self.dirstate.forget(f)
        self.dirstate.setparents(ret)
        ms.reset()
    finally:
        wlock.release()
    self.hook('commit', node=hex(ret), parent1=hookp1, parent2=hookp2)
    return ret
