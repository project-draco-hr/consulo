def _changegroup(self, nodes, source):
    "Compute the changegroup of all nodes that we have that a recipient\n        doesn't.  Return a chunkbuffer object whose read() method will return\n        successive changegroup chunks.\n\n        This is much easier than the previous function as we can assume that\n        the recipient has any changenode we aren't sending them.\n\n        nodes is the set of nodes to send"
    self.hook('preoutgoing', throw=True, source=source)
    cl = self.changelog
    revset = set([cl.rev(n) for n in nodes])
    self.changegroupinfo(nodes, source)

    def identity(x):
        return x

    def gennodelst(log):
        for r in log:
            if (log.linkrev(r) in revset):
                yield log.node(r)

    def lookuprevlink_func(revlog):

        def lookuprevlink(n):
            return cl.node(revlog.linkrev(revlog.rev(n)))
        return lookuprevlink

    def gengroup():
        'yield a sequence of changegroup chunks (strings)'
        changedfiles = {}
        mmfs = {}
        collect = changegroup.collector(cl, mmfs, changedfiles)
        cnt = 0
        for chnk in cl.group(nodes, identity, collect):
            self.ui.progress(_('bundling changes'), cnt, unit=_('chunks'))
            cnt += 1
            yield chnk
        self.ui.progress(_('bundling changes'), None, unit=_('chunks'))
        mnfst = self.manifest
        nodeiter = gennodelst(mnfst)
        cnt = 0
        for chnk in mnfst.group(nodeiter, lookuprevlink_func(mnfst)):
            self.ui.progress(_('bundling manifests'), cnt, unit=_('chunks'))
            cnt += 1
            yield chnk
        self.ui.progress(_('bundling manifests'), None, unit=_('chunks'))
        cnt = 0
        for fname in sorted(changedfiles):
            filerevlog = self.file(fname)
            if (not len(filerevlog)):
                raise util.Abort((_('empty or missing revlog for %s') % fname))
            nodeiter = gennodelst(filerevlog)
            nodeiter = list(nodeiter)
            if nodeiter:
                yield changegroup.chunkheader(len(fname))
                yield fname
                lookup = lookuprevlink_func(filerevlog)
                for chnk in filerevlog.group(nodeiter, lookup):
                    self.ui.progress(_('bundling files'), cnt, item=fname, unit=_('chunks'))
                    cnt += 1
                    yield chnk
        self.ui.progress(_('bundling files'), None, unit=_('chunks'))
        yield changegroup.closechunk()
        if nodes:
            self.hook('outgoing', node=hex(nodes[0]), source=source)
    return util.chunkbuffer(gengroup())
