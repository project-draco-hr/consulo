def findoutgoing(self, remote, base=None, heads=None, force=False):
    'Return list of nodes that are roots of subsets not in remote\n\n        If base dict is specified, assume that these nodes and their parents\n        exist on the remote side.\n        If a list of heads is specified, return only nodes which are heads\n        or ancestors of these heads, and return a second element which\n        contains all remote heads which get new children.\n        '
    if (base is None):
        base = {}
        self.findincoming(remote, base, heads, force=force)
    self.ui.debug((('common changesets up to ' + ' '.join(map(short, base.keys()))) + '\n'))
    remain = set(self.changelog.nodemap)
    remain.remove(nullid)
    remove = base.keys()
    while remove:
        n = remove.pop(0)
        if (n in remain):
            remain.remove(n)
            for p in self.changelog.parents(n):
                remove.append(p)
    subset = []
    updated_heads = set()
    for n in remain:
        (p1, p2) = self.changelog.parents(n)
        if ((p1 not in remain) and (p2 not in remain)):
            subset.append(n)
        if heads:
            if (p1 in heads):
                updated_heads.add(p1)
            if (p2 in heads):
                updated_heads.add(p2)
    if heads:
        return (subset, list(updated_heads))
    else:
        return subset
