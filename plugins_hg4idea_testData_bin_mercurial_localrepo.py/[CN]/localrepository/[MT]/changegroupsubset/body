def changegroupsubset(self, bases, heads, source, extranodes=None):
    'Compute a changegroup consisting of all the nodes that are\n        descendents of any of the bases and ancestors of any of the heads.\n        Return a chunkbuffer object whose read() method will return\n        successive changegroup chunks.\n\n        It is fairly complex as determining which filenodes and which\n        manifest nodes need to be included for the changeset to be complete\n        is non-trivial.\n\n        Another wrinkle is doing the reverse, figuring out which changeset in\n        the changegroup a particular filenode or manifestnode belongs to.\n\n        The caller can specify some nodes that must be included in the\n        changegroup using the extranodes argument.  It should be a dict\n        where the keys are the filenames (or 1 for the manifest), and the\n        values are lists of (node, linknode) tuples, where node is a wanted\n        node and linknode is the changelog node that should be transmitted as\n        the linkrev.\n        '
    cl = self.changelog
    if (not bases):
        bases = [nullid]
    (msng_cl_lst, bases, heads) = cl.nodesbetween(bases, heads)
    if (extranodes is None):
        heads.sort()
        allheads = self.heads()
        allheads.sort()
        if (heads == allheads):
            return self._changegroup(msng_cl_lst, source)
    self.hook('preoutgoing', throw=True, source=source)
    self.changegroupinfo(msng_cl_lst, source)
    knownheads = set()
    for n in bases:
        knownheads.update(cl.parents(n))
    knownheads.discard(nullid)
    knownheads = list(knownheads)
    if knownheads:
        (has_cl_set, junk, junk) = cl.nodesbetween(None, knownheads)
        junk = None
        has_cl_set = set(has_cl_set)
    else:
        has_cl_set = set()
    mnfst = self.manifest
    msng_mnfst_set = {}
    msng_filenode_set = {}
    junk = mnfst.index[(len(mnfst) - 1)]
    junk = None

    def identity(x):
        return x

    def prune_parents(revlog, hasset, msngset):
        for r in revlog.ancestors(*[revlog.rev(n) for n in hasset]):
            msngset.pop(revlog.node(r), None)

    def lookup_manifest_link(mnfstnode):
        return msng_mnfst_set[mnfstnode]

    def filenode_collector(changedfiles):

        def collect_msng_filenodes(mnfstnode):
            r = mnfst.rev(mnfstnode)
            if ((r - 1) in mnfst.parentrevs(r)):
                deltamf = mnfst.readdelta(mnfstnode)
                for (f, fnode) in deltamf.iteritems():
                    f = changedfiles.get(f, None)
                    if (f is not None):
                        clnode = msng_mnfst_set[mnfstnode]
                        ndset = msng_filenode_set.setdefault(f, {})
                        ndset.setdefault(fnode, clnode)
            else:
                m = mnfst.read(mnfstnode)
                for f in changedfiles:
                    fnode = m.get(f, None)
                    if (fnode is not None):
                        clnode = msng_mnfst_set[mnfstnode]
                        ndset = msng_filenode_set.setdefault(f, {})
                        ndset.setdefault(fnode, clnode)
        return collect_msng_filenodes

    def prune_filenodes(f, filerevlog):
        msngset = msng_filenode_set[f]
        hasset = set()
        for n in msngset:
            clnode = cl.node(filerevlog.linkrev(filerevlog.rev(n)))
            if (clnode in has_cl_set):
                hasset.add(n)
        prune_parents(filerevlog, hasset, msngset)

    def lookup_filenode_link_func(fname):
        msngset = msng_filenode_set[fname]

        def lookup_filenode_link(fnode):
            return msngset[fnode]
        return lookup_filenode_link

    def add_extra_nodes(name, nodes):
        if ((not extranodes) or (name not in extranodes)):
            return
        for (node, linknode) in extranodes[name]:
            if (node not in nodes):
                nodes[node] = linknode

    def gengroup():
        changedfiles = {}
        collect = changegroup.collector(cl, msng_mnfst_set, changedfiles)
        group = cl.group(msng_cl_lst, identity, collect)
        cnt = 0
        for chnk in group:
            yield chnk
            self.ui.progress(_('bundling changes'), cnt, unit=_('chunks'))
            cnt += 1
        self.ui.progress(_('bundling changes'), None, unit=_('chunks'))
        has_mnfst_set = set()
        for n in msng_mnfst_set:
            linknode = cl.node(mnfst.linkrev(mnfst.rev(n)))
            if (linknode in has_cl_set):
                has_mnfst_set.add(n)
        prune_parents(mnfst, has_mnfst_set, msng_mnfst_set)
        add_extra_nodes(1, msng_mnfst_set)
        msng_mnfst_lst = msng_mnfst_set.keys()
        msng_mnfst_lst.sort(key=mnfst.rev)
        group = mnfst.group(msng_mnfst_lst, lookup_manifest_link, filenode_collector(changedfiles))
        cnt = 0
        for chnk in group:
            yield chnk
            self.ui.progress(_('bundling manifests'), cnt, unit=_('chunks'))
            cnt += 1
        self.ui.progress(_('bundling manifests'), None, unit=_('chunks'))
        msng_mnfst_lst = None
        msng_mnfst_set.clear()
        if extranodes:
            for fname in extranodes:
                if isinstance(fname, int):
                    continue
                msng_filenode_set.setdefault(fname, {})
                changedfiles[fname] = 1
        cnt = 0
        for fname in sorted(changedfiles):
            filerevlog = self.file(fname)
            if (not len(filerevlog)):
                raise util.Abort((_('empty or missing revlog for %s') % fname))
            if (fname in msng_filenode_set):
                prune_filenodes(fname, filerevlog)
                add_extra_nodes(fname, msng_filenode_set[fname])
                msng_filenode_lst = msng_filenode_set[fname].keys()
            else:
                msng_filenode_lst = []
            if (len(msng_filenode_lst) > 0):
                yield changegroup.chunkheader(len(fname))
                yield fname
                msng_filenode_lst.sort(key=filerevlog.rev)
                group = filerevlog.group(msng_filenode_lst, lookup_filenode_link_func(fname))
                for chnk in group:
                    self.ui.progress(_('bundling files'), cnt, item=fname, unit=_('chunks'))
                    cnt += 1
                    yield chnk
            if (fname in msng_filenode_set):
                del msng_filenode_set[fname]
        yield changegroup.closechunk()
        self.ui.progress(_('bundling files'), None, unit=_('chunks'))
        if msng_cl_lst:
            self.hook('outgoing', node=hex(msng_cl_lst[0]), source=source)
    return util.chunkbuffer(gengroup())
