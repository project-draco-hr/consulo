def status(self, node1='.', node2=None, match=None, ignored=False, clean=False, unknown=False):
    'return status of files between two nodes or node and working directory\n\n        If node1 is None, use the first dirstate parent instead.\n        If node2 is None, compare node1 with working directory.\n        '

    def mfmatches(ctx):
        mf = ctx.manifest().copy()
        for fn in mf.keys():
            if (not match(fn)):
                del mf[fn]
        return mf
    if isinstance(node1, context.changectx):
        ctx1 = node1
    else:
        ctx1 = self[node1]
    if isinstance(node2, context.changectx):
        ctx2 = node2
    else:
        ctx2 = self[node2]
    working = (ctx2.rev() is None)
    parentworking = (working and (ctx1 == self['.']))
    match = (match or match_.always(self.root, self.getcwd()))
    (listignored, listclean, listunknown) = (ignored, clean, unknown)
    if ((not working) and (ctx2.rev() < ctx1.rev())):
        ctx2.manifest()
    if (not parentworking):

        def bad(f, msg):
            if (f not in ctx1):
                self.ui.warn(('%s: %s\n' % (self.dirstate.pathto(f), msg)))
        match.bad = bad
    if working:
        subrepos = ctx1.substate.keys()
        s = self.dirstate.status(match, subrepos, listignored, listclean, listunknown)
        (cmp, modified, added, removed, deleted, unknown, ignored, clean) = s
        if (parentworking and cmp):
            fixup = []
            for f in sorted(cmp):
                if ((f not in ctx1) or (ctx2.flags(f) != ctx1.flags(f)) or ctx1[f].cmp(ctx2[f].data())):
                    modified.append(f)
                else:
                    fixup.append(f)
            if listclean:
                clean += fixup
            if fixup:
                try:
                    wlock = self.wlock(False)
                    try:
                        for f in fixup:
                            self.dirstate.normal(f)
                    finally:
                        wlock.release()
                except error.LockError:
                    pass
    if (not parentworking):
        mf1 = mfmatches(ctx1)
        if working:
            mf2 = mfmatches(self['.'])
            for f in ((cmp + modified) + added):
                mf2[f] = None
                mf2.set(f, ctx2.flags(f))
            for f in removed:
                if (f in mf2):
                    del mf2[f]
        else:
            (deleted, unknown, ignored) = ([], [], [])
            mf2 = mfmatches(ctx2)
        (modified, added, clean) = ([], [], [])
        for fn in mf2:
            if (fn in mf1):
                if ((mf1.flags(fn) != mf2.flags(fn)) or ((mf1[fn] != mf2[fn]) and (mf2[fn] or ctx1[fn].cmp(ctx2[fn].data())))):
                    modified.append(fn)
                elif listclean:
                    clean.append(fn)
                del mf1[fn]
            else:
                added.append(fn)
        removed = mf1.keys()
    r = (modified, added, removed, deleted, unknown, ignored, clean)
    [l.sort() for l in r]
    return r
