def __init__(self, baseui, path=None, create=0):
    repo.repository.__init__(self)
    self.root = os.path.realpath(util.expandpath(path))
    self.path = os.path.join(self.root, '.hg')
    self.origroot = path
    self.opener = util.opener(self.path)
    self.wopener = util.opener(self.root)
    self.baseui = baseui
    self.ui = baseui.copy()
    try:
        self.ui.readconfig(self.join('hgrc'), self.root)
        extensions.loadall(self.ui)
    except IOError:
        pass
    if (not os.path.isdir(self.path)):
        if create:
            if (not os.path.exists(path)):
                os.mkdir(path)
            os.mkdir(self.path)
            requirements = ['revlogv1']
            if self.ui.configbool('format', 'usestore', True):
                os.mkdir(os.path.join(self.path, 'store'))
                requirements.append('store')
                if self.ui.configbool('format', 'usefncache', True):
                    requirements.append('fncache')
                self.opener('00changelog.i', 'a').write('\x00\x00\x00\x02 dummy changelog to prevent using the old repo layout')
            reqfile = self.opener('requires', 'w')
            for r in requirements:
                reqfile.write(('%s\n' % r))
            reqfile.close()
        else:
            raise error.RepoError((_('repository %s not found') % path))
    elif create:
        raise error.RepoError((_('repository %s already exists') % path))
    else:
        requirements = set()
        try:
            requirements = set(self.opener('requires').read().splitlines())
        except IOError as inst:
            if (inst.errno != errno.ENOENT):
                raise
        for r in (requirements - self.supported):
            raise error.RepoError((_("requirement '%s' not supported") % r))
    self.sharedpath = self.path
    try:
        s = os.path.realpath(self.opener('sharedpath').read())
        if (not os.path.exists(s)):
            raise error.RepoError((_('.hg/sharedpath points to nonexistent directory %s') % s))
        self.sharedpath = s
    except IOError as inst:
        if (inst.errno != errno.ENOENT):
            raise
    self.store = store.store(requirements, self.sharedpath, util.opener)
    self.spath = self.store.path
    self.sopener = self.store.opener
    self.sjoin = self.store.join
    self.opener.createmode = self.store.createmode
    self.sopener.options = {}
    self._tags = None
    self._tagtypes = None
    self._branchcache = None
    self._branchcachetip = None
    self.nodetagscache = None
    self.filterpats = {}
    self._datafilters = {}
    self._transref = self._lockref = self._wlockref = None
