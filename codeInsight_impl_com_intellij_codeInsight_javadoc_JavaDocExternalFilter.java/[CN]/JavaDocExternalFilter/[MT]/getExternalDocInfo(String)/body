{
  if (surl == null) {
    return null;
  }
  final String root=ourAnchorsuffix.matcher(surl).replaceAll("");
  final StringBuffer data=new StringBuffer();
  final Runnable process=new Runnable(){
    public void run(){
      final Reader stream=getReaderByUrl(surl);
      if (stream == null) {
        return;
      }
      Matcher anchorMatcher=ourAnchorsuffix.matcher(surl);
      @NonNls String startSection="<!-- ======== START OF CLASS DATA ======== -->";
      @NonNls String endSection="SUMMARY ======== -->";
      boolean isClassDoc=true;
      if (anchorMatcher.find()) {
        isClassDoc=false;
        startSection="<A NAME=\"" + anchorMatcher.group(1).toUpperCase() + "\"";
        endSection="<A NAME=";
      }
      final BufferedReader buf=new BufferedReader(stream);
      data.append(HTML + "\n");
      try {
        String read;
        do {
          ProgressManager.getInstance().checkCanceled();
          read=buf.readLine();
        }
 while (read != null && read.toUpperCase().indexOf(startSection) == -1);
        if (read == null) {
          data.delete(0,data.length());
          return;
        }
        data.append(read);
        if (isClassDoc) {
          boolean skip=false;
          while (((read=buf.readLine()) != null) && !read.toUpperCase().equals(DL)) {
            ProgressManager.getInstance().checkCanceled();
            if (read.toUpperCase().indexOf(H2) != -1) {
              data.append(H2 + "\n");
              skip=true;
            }
 else             if (!skip)             data.append(read);
          }
          data.append(DL + "\n");
          StringBuffer classDetails=new StringBuffer();
          while (((read=buf.readLine()) != null) && !read.toUpperCase().equals(HR)) {
            ProgressManager.getInstance().checkCanceled();
            classDetails.append(read);
            classDetails.append("\n");
          }
          while (((read=buf.readLine()) != null) && !read.toUpperCase().equals(P)) {
            ProgressManager.getInstance().checkCanceled();
            data.append(read);
            data.append("\n");
          }
          data.append(classDetails);
          data.append(P + "\n");
        }
        while (((read=buf.readLine()) != null) && read.indexOf(endSection) == -1) {
          ProgressManager.getInstance().checkCanceled();
          if (read.toUpperCase().indexOf(HR) == -1) {
            data.append(read);
            data.append("\n");
          }
        }
        data.append(HTML_CLOSE + "\n");
      }
 catch (      final IOException e) {
        showErrorMessage(e);
      }
 finally {
        if (buf != null) {
          try {
            buf.close();
          }
 catch (          IOException e) {
            showErrorMessage(e);
          }
        }
      }
    }
  }
;
  final boolean ok=ProgressManager.getInstance().runProcessWithProgressSynchronously(process,"Fetch external javadoc",true,myProject);
  if (ok) {
    final String docText=correctRefs(root,data.toString());
    if (LOG.isDebugEnabled()) {
      LOG.debug("Filtered JavaDoc: " + docText + "\n");
    }
    return JavaDocUtil.fixupText(docText);
  }
  return null;
}
